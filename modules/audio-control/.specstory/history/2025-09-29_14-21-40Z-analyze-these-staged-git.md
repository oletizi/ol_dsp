<!-- Generated by SpecStory -->

# AI Agents Collaborate on Multi-Phase Project Strategy (2025-09-29 14:21:40Z)

<!-- Claude Code Session fa35e912-bf3b-4b63-8911-c51643c2937c (2025-09-29_14-21-40Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/package-lock.json b/modules/audio-control/modules/launch-control-xl3/package-lock.json
index 5765d96..1cb98da 100644
--- a/modules/audio-control/modules/launch-control-xl3/package-lock.json
+++ b/modules/audio-control/modules/launch-control-xl3/package-lock.json
@@ -1,12 +1,12 @@
 {
   "name": "@oletizi/launch-control-xl3",
-  "version": "1.1.0",
+  "version": "1.8.0",
   "lockfileVersion": 3,
   "requires": true,
   "packages": {
     "": {
       "name": "@oletizi/launch-control-xl3",
-      "version": "1.1.0",
+      "version": "1.8.0",
       "license": "Apache-2.0",
       "dependencies": {
         "@types/js-yaml": "^4.0.9",
@@ -23,11 +23,13 @@
       },
       "devDependencies": {
         "@oletizi/mulder-specs": "^0.6.0",
+        "@playwright/test": "^1.55.1",
         "@types/node": "^20.11.0",
         "@vitest/coverage-v8": "^1.2.0",
         "easymidi": "^3.1.0",
         "jazz-midi-headless": "^1.1.5",
         "jzz": "^1.9.6",
+        "playwright": "^1.55.1",
         "tsx": "^4.7.0",
         "typescript": "^5.3.3",
         "vite": "^5.0.0",
@@ -498,6 +500,22 @@
         "node": ">=18"
       }
     },
+    "node_modules/@playwright/test": {
+      "version": "1.55.1",
+      "resolved": "https://registry.npmjs.org/@playwright/test/-/test-1.55.1.tgz",
+      "integrity": "sha512-IVAh/nOJaw6W9g+RJVlIQJ6gSiER+ae6mKQ5CX1bERzQgbC1VSeBlwdvczT7pxb0GWiyrxH4TGKbMfDb4Sq/ig==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "playwright": "1.55.1"
+      },
+      "bin": {
+        "playwright": "cli.js"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
     "node_modules/@types/js-yaml": {
       "version": "4.0.9",
       "resolved": "https://registry.npmjs.org/@types/js-yaml/-/js-yaml-4.0.9.tgz",
@@ -783,6 +801,21 @@
       "integrity": "sha512-GWkBvjiSZK87ELrYOSESUYeVIc9mvLLf/nXalMOS5dYrgZq9o5OVkbZAVM06CVxYsCwH9BDZFPlQTlPA1j4ahA==",
       "license": "MIT"
     },
+    "node_modules/fsevents": {
+      "version": "2.3.2",
+      "resolved": "https://registry.npmjs.org/fsevents/-/fsevents-2.3.2.tgz",
+      "integrity": "sha512-xiqMQR4xAeHTuB9uWm+fFRcIOgKBMiOBP+eXiyT7jsgVCq1bkVygt00oASowB7EdtpOHaaPgKt812P9ab+DDKA==",
+      "dev": true,
+      "hasInstallScript": true,
+      "license": "MIT",
+      "optional": true,
+      "os": [
+        "darwin"
+      ],
+      "engines": {
+        "node": "^8.16.0 || ^10.6.0 || >=11.0.0"
+      }
+    },
     "node_modules/get-caller-file": {
       "version": "2.0.5",
       "resolved": "https://registry.npmjs.org/get-caller-file/-/get-caller-file-2.0.5.tgz",
@@ -1228,6 +1261,38 @@
         "node": ">= 14.15.0"
       }
     },
+    "node_modules/playwright": {
+      "version": "1.55.1",
+      "resolved": "https://registry.npmjs.org/playwright/-/playwright-1.55.1.tgz",
+      "integrity": "sha512-cJW4Xd/G3v5ovXtJJ52MAOclqeac9S/aGGgRzLabuF8TnIb6xHvMzKIa6JmrRzUkeXJgfL1MhukP0NK6l39h3A==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "dependencies": {
+        "playwright-core": "1.55.1"
+      },
+      "bin": {
+        "playwright": "cli.js"
+      },
+      "engines": {
+        "node": ">=18"
+      },
+      "optionalDependencies": {
+        "fsevents": "2.3.2"
+      }
+    },
+    "node_modules/playwright-core": {
+      "version": "1.55.1",
+      "resolved": "https://registry.npmjs.org/playwright-core/-/playwright-core-1.55.1.tgz",
+      "integrity": "sha512-Z6Mh9mkwX+zxSlHqdr5AOcJnfp+xUWLCt9uKV18fhzA8eyxUd8NUWzAjxUh55RZKSYwDGX0cfaySdhZJGMoJ+w==",
+      "dev": true,
+      "license": "Apache-2.0",
+      "bin": {
+        "playwright-core": "cli.js"
+      },
+      "engines": {
+        "node": ">=18"
+      }
+    },
     "node_modules/readable-stream": {
       "version": "3.6.2",
       "resolved": "https://registry.npmjs.org/readable-stream/-/readable-stream-3.6.2.tgz",
diff --git a/modules/audio-control/modules/launch-control-xl3/package.json b/modules/audio-control/modules/launch-control-xl3/package.json
index a324966..dd51326 100644
--- a/modules/audio-control/modules/launch-control-xl3/package.json
+++ b/modules/audio-control/modules/launch-control-xl3/package.json
@@ -83,11 +83,13 @@
   },
   "devDependencies": {
     "@oletizi/mulder-specs": "^0.6.0",
+    "@playwright/test": "^1.55.1",
     "@types/node": "^20.11.0",
     "@vitest/coverage-v8": "^1.2.0",
     "easymidi": "^3.1.0",
     "jazz-midi-headless": "^1.1.5",
     "jzz": "^1.9.6",
+    "playwright": "^1.55.1",
     "tsx": "^4.7.0",
     "typescript": "^5.3.3",
     "vite": "^5.0.0",
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/playwright-test-actions.ts b/modules/audio-control/modules/launch-control-xl3/utils/playwright-test-actions.ts
new file mode 100644
index 0000000..2f9d21a
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/playwright-test-actions.ts
@@ -0,0 +1,416 @@
+#!/usr/bin/env tsx
+
+/**
+ * Playwright Test Actions - Phase 2 Systematic Web Editor Actions
+ *
+ * This module defines systematic test actions for the Novation web editor
+ * to capture corresponding MIDI messages for protocol reverse engineering.
+ *
+ * Each action is designed to trigger specific MIDI communication patterns
+ * that can be analyzed to understand the true SysEx protocol.
+ */
+
+import { Page } from 'playwright';
+import { CapturedMessage } from './midi-monitor.js';
+
+// Test action interface
+export interface TestAction {
+  readonly name: string;
+  readonly description: string;
+  readonly category: 'mode-management' | 'control-config' | 'visual-config' | 'device-interaction';
+  readonly expectedMidiMessages: number;
+  readonly estimatedDuration: number; // milliseconds
+  execute: (page: Page) => Promise<void>;
+  verify?: (capturedMessages: CapturedMessage[]) => ValidationResult;
+  cleanup?: (page: Page) => Promise<void>;
+}
+
+// Validation result for test actions
+export interface ValidationResult {
+  readonly isValid: boolean;
+  readonly expectedMessages: number;
+  readonly actualMessages: number;
+  readonly missingMessages?: string[];
+  readonly unexpectedMessages?: string[];
+  readonly notes?: string;
+}
+
+// Test action execution result
+export interface ActionExecutionResult {
+  readonly action: TestAction;
+  readonly startTime: number;
+  readonly endTime: number;
+  readonly duration: number;
+  readonly success: boolean;
+  readonly capturedMessages: readonly CapturedMessage[];
+  readonly validation?: ValidationResult;
+  readonly error?: string;
+  readonly screenshots?: readonly string[];
+}
+
+/**
+ * Mode Management Actions
+ * These actions test custom mode creation, saving, and loading
+ */
+export const MODE_MANAGEMENT_ACTIONS: TestAction[] = [
+  {
+    name: 'create_simple_mode',
+    description: 'Create a new custom mode with basic settings',
+    category: 'mode-management',
+    expectedMidiMessages: 1,
+    estimatedDuration: 5000,
+    execute: async (page: Page) => {
+      // Take screenshot before action
+      await page.screenshot({ path: 'action-create-simple-mode-before.png' });
+
+      // Look for and click new mode button (selectors to be refined based on actual UI)
+      await page.click('[data-testid="new-mode"], .new-mode-button, button:has-text("New Mode")',
+        { timeout: 5000 }).catch(() => {
+        // Fallback selectors
+        return page.click('button[contains(@class, "mode")], .mode-create, #new-mode');
+      });
+
+      await page.waitForTimeout(1000);
+
+      // Set mode name if input is available
+      const nameInput = await page.locator('input[placeholder*="mode"], input[name*="name"], .mode-name-input').first();
+      if (await nameInput.isVisible({ timeout: 2000 }).catch(() => false)) {
+        await nameInput.fill('SPY_TEST_MODE_1');
+        await page.waitForTimeout(500);
+      }
+
+      // Save the mode
+      await page.click('[data-testid="save-mode"], .save-button, button:has-text("Save")')
+        .catch(() => {
+          return page.keyboard.press('Enter'); // Fallback to Enter key
+        });
+
+      await page.waitForTimeout(2000);
+    },
+    verify: (messages: CapturedMessage[]) => {
+      const sysexMessages = messages.filter(msg => msg.messageType === 'sysex');
+      return {
+        isValid: sysexMessages.length >= 1,
+        expectedMessages: 1,
+        actualMessages: sysexMessages.length,
+        notes: `Expected at least 1 SysEx message for mode creation, got ${sysexMessages.length}`,
+      };
+    },
+  },
+
+  {
+    name: 'save_mode_to_slot',
+    description: 'Save current mode to device slot 1',
+    category: 'mode-management',
+    expectedMidiMessages: 1,
+    estimatedDuration: 3000,
+    execute: async (page: Page) => {
+      // Look for save/send to device buttons
+      await page.click('[data-testid="save-to-device"], .send-to-device, button:has-text("Send to Device")')
+        .catch(async () => {
+          // Alternative selectors
+          await page.click('[data-testid="save-slot"], .save-slot, button:has-text("Save Slot")');
+        });
+
+      await page.waitForTimeout(1000);
+
+      // Select slot 1 if slot selection is available
+      const slot1Button = page.locator('[data-slot="1"], .slot-1, button:has-text("Slot 1")').first();
+      if (await slot1Button.isVisible({ timeout: 2000 }).catch(() => false)) {
+        await slot1Button.click();
+        await page.waitForTimeout(500);
+      }
+
+      // Confirm save action
+      await page.click('[data-testid="confirm-save"], .confirm-button, button:has-text("Confirm")')
+        .catch(() => {
+          return page.keyboard.press('Enter');
+        });
+
+      await page.waitForTimeout(2000);
+    },
+  },
+
+  {
+    name: 'load_mode_from_slot',
+    description: 'Load mode from device slot 1',
+    category: 'mode-management',
+    expectedMidiMessages: 2, // Usually read request + response
+    estimatedDuration: 3000,
+    execute: async (page: Page) => {
+      // Look for load from device buttons
+      await page.click('[data-testid="load-from-device"], .load-from-device, button:has-text("Load from Device")')
+        .catch(async () => {
+          await page.click('[data-testid="load-slot"], .load-slot, button:has-text("Load Slot")');
+        });
+
+      await page.waitForTimeout(1000);
+
+      // Select slot 1
+      const slot1Button = page.locator('[data-slot="1"], .slot-1, button:has-text("Slot 1")').first();
+      if (await slot1Button.isVisible({ timeout: 2000 }).catch(() => false)) {
+        await slot1Button.click();
+        await page.waitForTimeout(2000); // Wait for load to complete
+      }
+    },
+  },
+];
+
+/**
+ * Control Configuration Actions
+ * These actions test control naming, CC assignment, and behavior configuration
+ */
+export const CONTROL_CONFIG_ACTIONS: TestAction[] = [
+  {
+    name: 'set_fader_name',
+    description: 'Set name for first fader control',
+    category: 'control-config',
+    expectedMidiMessages: 1,
+    estimatedDuration: 4000,
+    execute: async (page: Page) => {
+      // Find and click on first fader or its label
+      await page.click('[data-control="fader-1"], .fader-1, .control-fader:first-of-type')
+        .catch(async () => {
+          // Try clicking on fader area or label
+          await page.click('.fader-container:first-of-type, .control-item:first-of-type');
+        });
+
+      await page.waitForTimeout(1000);
+
+      // Look for name input field
+      const nameInput = page.locator('input[placeholder*="name"], input[name*="label"], .control-name-input').first();
+      if (await nameInput.isVisible({ timeout: 3000 }).catch(() => false)) {
+        await nameInput.clear();
+        await nameInput.fill('SPY_VOLUME_1');
+        await nameInput.press('Enter');
+        await page.waitForTimeout(1500);
+      }
+    },
+  },
+
+  {
+    name: 'set_encoder_cc',
+    description: 'Set MIDI CC number for first encoder',
+    category: 'control-config',
+    expectedMidiMessages: 1,
+    estimatedDuration: 4000,
+    execute: async (page: Page) => {
+      // Find and click on first encoder
+      await page.click('[data-control="encoder-1"], .encoder-1, .control-encoder:first-of-type')
+        .catch(async () => {
+          await page.click('.encoder-container:first-of-type');
+        });
+
+      await page.waitForTimeout(1000);
+
+      // Look for CC input field
+      const ccInput = page.locator('input[placeholder*="CC"], input[name*="cc"], input[type="number"]').first();
+      if (await ccInput.isVisible({ timeout: 3000 }).catch(() => false)) {
+        await ccInput.clear();
+        await ccInput.fill('21'); // Use CC 21 as test value
+        await ccInput.press('Enter');
+        await page.waitForTimeout(1500);
+      }
+    },
+  },
+
+  {
+    name: 'configure_button_behavior',
+    description: 'Configure behavior for first button pad',
+    category: 'control-config',
+    expectedMidiMessages: 1,
+    estimatedDuration: 5000,
+    execute: async (page: Page) => {
+      // Find and click on first button pad
+      await page.click('[data-control="button-1"], .button-1, .pad-1, .control-button:first-of-type')
+        .catch(async () => {
+          await page.click('.button-container:first-of-type, .pad-container:first-of-type');
+        });
+
+      await page.waitForTimeout(1000);
+
+      // Look for behavior selection dropdown
+      const behaviorSelect = page.locator('select[name*="behavior"], .behavior-select, .control-type-select').first();
+      if (await behaviorSelect.isVisible({ timeout: 3000 }).catch(() => false)) {
+        await behaviorSelect.selectOption('toggle'); // or 'momentary', 'trigger', etc.
+        await page.waitForTimeout(1500);
+      }
+    },
+  },
+];
+
+/**
+ * Visual Configuration Actions
+ * These actions test LED colors and visual feedback settings
+ */
+export const VISUAL_CONFIG_ACTIONS: TestAction[] = [
+  {
+    name: 'set_button_color',
+    description: 'Set LED color for first button pad',
+    category: 'visual-config',
+    expectedMidiMessages: 1,
+    estimatedDuration: 3000,
+    execute: async (page: Page) => {
+      // Find and click on first button pad
+      await page.click('[data-control="button-1"], .button-1, .pad-1');
+      await page.waitForTimeout(1000);
+
+      // Look for color picker or color options
+      const colorPicker = page.locator('.color-picker, [type="color"], .led-color-select').first();
+      if (await colorPicker.isVisible({ timeout: 3000 }).catch(() => false)) {
+        await colorPicker.click();
+        await page.waitForTimeout(500);
+
+        // Select a specific color (red)
+        await page.click('[data-color="red"], .color-red, [style*="rgb(255, 0, 0)"]')
+          .catch(async () => {
+            // Fallback: use color input
+            await colorPicker.fill('#FF0000');
+          });
+
+        await page.waitForTimeout(1500);
+      }
+    },
+  },
+
+  {
+    name: 'set_fader_led_behavior',
+    description: 'Configure LED behavior for fader',
+    category: 'visual-config',
+    expectedMidiMessages: 1,
+    estimatedDuration: 4000,
+    execute: async (page: Page) => {
+      // Find and click on first fader
+      await page.click('[data-control="fader-1"], .fader-1');
+      await page.waitForTimeout(1000);
+
+      // Look for LED behavior settings
+      const ledSettings = page.locator('.led-settings, .visual-feedback, .led-behavior').first();
+      if (await ledSettings.isVisible({ timeout: 3000 }).catch(() => false)) {
+        await ledSettings.click();
+        await page.waitForTimeout(1500);
+      }
+    },
+  },
+];
+
+/**
+ * Device Interaction Actions
+ * These actions test direct device communication and status queries
+ */
+export const DEVICE_INTERACTION_ACTIONS: TestAction[] = [
+  {
+    name: 'device_handshake',
+    description: 'Perform device handshake/ping',
+    category: 'device-interaction',
+    expectedMidiMessages: 2, // Request + response
+    estimatedDuration: 2000,
+    execute: async (page: Page) => {
+      // Look for device status or connection check buttons
+      await page.click('[data-testid="device-status"], .device-ping, button:has-text("Check Device")')
+        .catch(async () => {
+          // Trigger via JavaScript if no UI button available
+          await page.evaluate(() => {
+            // This would trigger a device ping through Web MIDI
+            const output = (window as any).__lcxl3_midi_output;
+            if (output) {
+              // Send a simple identity request (standard MIDI SysEx)
+              output.send([0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7]);
+            }
+          });
+        });
+
+      await page.waitForTimeout(2000);
+    },
+  },
+
+  {
+    name: 'request_device_info',
+    description: 'Request device firmware and status information',
+    category: 'device-interaction',
+    expectedMidiMessages: 2,
+    estimatedDuration: 3000,
+    execute: async (page: Page) => {
+      // Look for device info buttons
+      await page.click('[data-testid="device-info"], .device-info, button:has-text("Device Info")')
+        .catch(async () => {
+          // Fallback to programmatic request
+          await page.evaluate(() => {
+            const output = (window as any).__lcxl3_midi_output;
+            if (output) {
+              // Request device information (manufacturer-specific)
+              output.send([0xF0, 0x00, 0x20, 0x29, 0x02, 0x0C, 0x00, 0xF7]);
+            }
+          });
+        });
+
+      await page.waitForTimeout(3000);
+    },
+  },
+];
+
+/**
+ * Combined test action collections
+ */
+export const ALL_TEST_ACTIONS: TestAction[] = [
+  ...MODE_MANAGEMENT_ACTIONS,
+  ...CONTROL_CONFIG_ACTIONS,
+  ...VISUAL_CONFIG_ACTIONS,
+  ...DEVICE_INTERACTION_ACTIONS,
+];
+
+/**
+ * Test action categories for organized execution
+ */
+export const TEST_ACTION_CATEGORIES = {
+  'mode-management': MODE_MANAGEMENT_ACTIONS,
+  'control-config': CONTROL_CONFIG_ACTIONS,
+  'visual-config': VISUAL_CONFIG_ACTIONS,
+  'device-interaction': DEVICE_INTERACTION_ACTIONS,
+} as const;
+
+/**
+ * Get actions by category
+ */
+export function getActionsByCategory(category: keyof typeof TEST_ACTION_CATEGORIES): TestAction[] {
+  return TEST_ACTION_CATEGORIES[category] || [];
+}
+
+/**
+ * Get action by name
+ */
+export function getActionByName(name: string): TestAction | undefined {
+  return ALL_TEST_ACTIONS.find(action => action.name === name);
+}
+
+/**
+ * Estimate total execution time for a set of actions
+ */
+export function estimateExecutionTime(actions: TestAction[]): number {
+  return actions.reduce((total, action) => total + action.estimatedDuration, 0);
+}
+
+/**
+ * Validate action execution results
+ */
+export function validateActionResults(results: ActionExecutionResult[]): {
+  totalActions: number;
+  successfulActions: number;
+  failedActions: number;
+  totalMessages: number;
+  averageMessagesPerAction: number;
+} {
+  const totalActions = results.length;
+  const successfulActions = results.filter(r => r.success).length;
+  const failedActions = totalActions - successfulActions;
+  const totalMessages = results.reduce((sum, r) => sum + r.capturedMessages.length, 0);
+  const averageMessagesPerAction = totalActions > 0 ? totalMessages / totalActions : 0;
+
+  return {
+    totalActions,
+    successfulActions,
+    failedActions,
+    totalMessages,
+    averageMessagesPerAction,
+  };
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/protocol-reverse-engineer.ts b/modules/audio-control/modules/launch-control-xl3/utils/protocol-reverse-engineer.ts
new file mode 100644
index 0000000..f9f583a
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/protocol-reverse-engineer.ts
@@ -0,0 +1,574 @@
+#!/usr/bin/env tsx
+
+/**
+ * Protocol Reverse Engineer - Phase 2 Systematic Protocol Analysis
+ *
+ * This class coordinates web editor automation with MIDI monitoring to systematically
+ * reverse engineer the true Launch Control XL 3 MIDI protocol.
+ *
+ * Features:
+ * - Systematic test action execution
+ * - MIDI message correlation with web actions
+ * - Pattern analysis and comparison
+ * - Protocol specification generation
+ * - Integration with existing monitoring infrastructure
+ */
+
+import { WebEditorAutomation, WebEditorConfig } from './web-editor-automation.js';
+import { TestAction, ActionExecutionResult, ALL_TEST_ACTIONS, getActionsByCategory, validateActionResults } from './playwright-test-actions.js';
+import { MidiMonitor, MonitorSession } from './midi-monitor.js';
+import { writeFileSync, existsSync, mkdirSync } from 'fs';
+import { join } from 'path';
+
+// Protocol analysis session configuration
+export interface ReverseEngineerConfig {
+  readonly outputDir?: string;
+  readonly sessionName?: string;
+  readonly webEditorConfig?: WebEditorConfig;
+  readonly includedActions?: string[]; // Action names to include
+  readonly excludedActions?: string[]; // Action names to exclude
+  readonly actionCategories?: Array<'mode-management' | 'control-config' | 'visual-config' | 'device-interaction'>;
+  readonly delayBetweenActions?: number; // ms delay between actions
+  readonly captureScreenshots?: boolean;
+  readonly validateResults?: boolean;
+  readonly maxRetries?: number;
+}
+
+// Analysis results for a complete reverse engineering session
+export interface ReverseEngineeringResults {
+  readonly sessionId: string;
+  readonly startTime: number;
+  readonly endTime: number;
+  readonly config: ReverseEngineerConfig;
+  readonly actionResults: readonly ActionExecutionResult[];
+  readonly midiSession?: MonitorSession;
+  readonly analysis: ProtocolAnalysis;
+  readonly recommendations: readonly ProtocolRecommendation[];
+  readonly summary: SessionSummary;
+}
+
+// Protocol analysis findings
+export interface ProtocolAnalysis {
+  readonly totalMessages: number;
+  readonly sysexMessages: number;
+  readonly messagePatterns: readonly MessagePattern[];
+  readonly actionMessageMapping: readonly ActionMessageMapping[];
+  readonly comparisonWithCurrentImplementation: readonly ProtocolComparison[];
+  readonly discoveredProtocolElements: readonly ProtocolElement[];
+}
+
+// Message pattern analysis
+export interface MessagePattern {
+  readonly patternId: string;
+  readonly description: string;
+  readonly hexPattern: string;
+  readonly occurrences: number;
+  readonly associatedActions: readonly string[];
+  readonly messageType: 'sysex-write' | 'sysex-read' | 'sysex-response' | 'cc' | 'other';
+  readonly confidence: number; // 0-1
+}
+
+// Action to message mapping
+export interface ActionMessageMapping {
+  readonly actionName: string;
+  readonly triggerTimestamp: number;
+  readonly capturedMessages: readonly {
+    timestamp: number;
+    messageType: string;
+    rawData: readonly number[];
+    hexData: string;
+    timingOffset: number; // ms from action trigger
+  }[];
+  readonly expectedMessages: number;
+  readonly actualMessages: number;
+  readonly isValid: boolean;
+}
+
+// Protocol comparison with current implementation
+export interface ProtocolComparison {
+  readonly actionContext: string;
+  readonly capturedMessage: {
+    hexData: string;
+    rawData: readonly number[];
+  };
+  readonly ourImplementation: {
+    hexData: string;
+    rawData: readonly number[];
+  };
+  readonly differences: readonly {
+    byteIndex: number;
+    expected: number;
+    actual: number;
+    significance: 'critical' | 'important' | 'minor';
+  }[];
+  readonly similarity: number; // 0-1
+  readonly recommendation: string;
+}
+
+// Discovered protocol elements
+export interface ProtocolElement {
+  readonly elementType: 'header' | 'command' | 'data' | 'checksum' | 'footer';
+  readonly byteRange: { start: number; end: number };
+  readonly hexValue: string;
+  readonly description: string;
+  readonly variability: 'fixed' | 'variable' | 'calculated';
+  readonly examples: readonly string[];
+}
+
+// Protocol improvement recommendations
+export interface ProtocolRecommendation {
+  readonly priority: 'critical' | 'high' | 'medium' | 'low';
+  readonly category: 'message-format' | 'timing' | 'error-handling' | 'implementation';
+  readonly description: string;
+  readonly affectedActions: readonly string[];
+  readonly suggestedFix: string;
+  readonly codeExample?: string;
+}
+
+// Session execution summary
+export interface SessionSummary {
+  readonly totalActions: number;
+  readonly successfulActions: number;
+  readonly failedActions: number;
+  readonly totalExecutionTime: number;
+  readonly averageActionTime: number;
+  readonly messagesPerAction: number;
+  readonly protocolConfidence: number; // 0-1 overall confidence in findings
+}
+
+/**
+ * Protocol Reverse Engineer Controller
+ *
+ * Coordinates systematic testing of web editor actions with MIDI message capture
+ * to reverse engineer the true Launch Control XL 3 protocol
+ */
+export class ProtocolReverseEngineer {
+  private readonly config: Required<ReverseEngineerConfig>;
+  private webAutomation: WebEditorAutomation | null = null;
+  private midiMonitor: MidiMonitor | null = null;
+  private sessionId: string;
+  private startTime: number = 0;
+  private actionResults: ActionExecutionResult[] = [];
+
+  constructor(config: ReverseEngineerConfig = {}) {
+    this.config = {
+      outputDir: './protocol-analysis',
+      sessionName: undefined,
+      webEditorConfig: {},
+      includedActions: [],
+      excludedActions: [],
+      actionCategories: ['mode-management', 'control-config', 'visual-config', 'device-interaction'],
+      delayBetweenActions: 3000,
+      captureScreenshots: true,
+      validateResults: true,
+      maxRetries: 2,
+      ...config,
+    };
+
+    this.sessionId = this.generateSessionId();
+    this.ensureOutputDirectory();
+  }
+
+  /**
+   * Run complete reverse engineering session
+   */
+  async runReverseEngineeringSession(): Promise<ReverseEngineeringResults> {
+    try {
+      console.log('🔬 Starting Protocol Reverse Engineering Session');
+      console.log('═'.repeat(60));
+      console.log(`📋 Session ID: ${this.sessionId}`);
+
+      this.startTime = Date.now();
+
+      // Step 1: Initialize web automation and device connection
+      await this.initializeWebAutomation();
+
+      // Step 2: Start MIDI monitoring
+      await this.startMidiMonitoring();
+
+      // Step 3: Select and execute test actions
+      const selectedActions = this.selectTestActions();
+      console.log(`🎯 Selected ${selectedActions.length} test actions for execution`);
+
+      // Step 4: Execute actions systematically
+      await this.executeActionSequence(selectedActions);
+
+      // Step 5: Stop monitoring and collect data
+      const midiSession = await this.stopMidiMonitoring();
+
+      // Step 6: Analyze captured data
+      const analysis = await this.analyzeProtocol();
+
+      // Step 7: Generate recommendations
+      const recommendations = this.generateRecommendations(analysis);
+
+      // Step 8: Create session summary
+      const summary = this.createSessionSummary();
+
+      // Step 9: Save results
+      const results: ReverseEngineeringResults = {
+        sessionId: this.sessionId,
+        startTime: this.startTime,
+        endTime: Date.now(),
+        config: this.config,
+        actionResults: [...this.actionResults],
+        midiSession,
+        analysis,
+        recommendations,
+        summary,
+      };
+
+      await this.saveResults(results);
+
+      console.log('✅ Reverse engineering session completed successfully');
+      console.log(`📊 Results saved to: ${this.config.outputDir}`);
+
+      return results;
+
+    } catch (error: any) {
+      console.error('❌ Reverse engineering session failed:', error.message);
+      throw error;
+    } finally {
+      await this.cleanup();
+    }
+  }
+
+  /**
+   * Run specific action sequence with custom configuration
+   */
+  async runActionSequence(actions: TestAction[]): Promise<ActionExecutionResult[]> {
+    if (!this.webAutomation) {
+      await this.initializeWebAutomation();
+    }
+
+    return await this.executeActionSequence(actions);
+  }
+
+  /**
+   * Initialize web automation and connect to device
+   */
+  private async initializeWebAutomation(): Promise<void> {
+    console.log('🚀 Initializing web automation...');
+
+    this.webAutomation = new WebEditorAutomation({
+      outputDir: join(this.config.outputDir, 'web-automation'),
+      captureScreenshots: this.config.captureScreenshots,
+      ...this.config.webEditorConfig,
+    });
+
+    // Launch web editor
+    await this.webAutomation.launchEditor();
+
+    // Connect to device
+    await this.webAutomation.connectToDevice('LCXL3');
+
+    // Wait for device ready
+    await this.webAutomation.waitForDeviceReady();
+
+    console.log('✅ Web automation initialized');
+  }
+
+  /**
+   * Start MIDI monitoring for the session
+   */
+  private async startMidiMonitoring(): Promise<void> {
+    console.log('🎵 Starting MIDI monitoring...');
+
+    this.midiMonitor = new MidiMonitor({
+      deviceFilter: 'LCXL3',
+      outputDir: join(this.config.outputDir, 'midi-captures'),
+      sessionName: `reverse-engineer-${this.sessionId}`,
+      verboseLogging: false, // Reduce noise during systematic testing
+      bufferMessages: true,
+    });
+
+    await this.midiMonitor.startMonitoring();
+    console.log('✅ MIDI monitoring started');
+  }
+
+  /**
+   * Stop MIDI monitoring and return session data
+   */
+  private async stopMidiMonitoring(): Promise<MonitorSession | undefined> {
+    if (this.midiMonitor) {
+      console.log('🛑 Stopping MIDI monitoring...');
+      const session = await this.midiMonitor.stopMonitoring();
+      console.log(`✅ MIDI monitoring stopped. Captured ${session.messages.length} messages`);
+      return session;
+    }
+    return undefined;
+  }
+
+  /**
+   * Select test actions based on configuration
+   */
+  private selectTestActions(): TestAction[] {
+    let actions: TestAction[] = [];
+
+    // Start with all actions or category-filtered actions
+    if (this.config.actionCategories.length > 0) {
+      for (const category of this.config.actionCategories) {
+        actions.push(...getActionsByCategory(category));
+      }
+    } else {
+      actions = [...ALL_TEST_ACTIONS];
+    }
+
+    // Apply include filter
+    if (this.config.includedActions.length > 0) {
+      actions = actions.filter(action => this.config.includedActions.includes(action.name));
+    }
+
+    // Apply exclude filter
+    if (this.config.excludedActions.length > 0) {
+      actions = actions.filter(action => !this.config.excludedActions.includes(action.name));
+    }
+
+    return actions;
+  }
+
+  /**
+   * Execute sequence of test actions with MIDI capture
+   */
+  private async executeActionSequence(actions: TestAction[]): Promise<ActionExecutionResult[]> {
+    const results: ActionExecutionResult[] = [];
+
+    console.log('🎬 Executing action sequence...');
+    console.log(`   Actions to execute: ${actions.length}`);
+    console.log(`   Delay between actions: ${this.config.delayBetweenActions}ms`);
+
+    for (let i = 0; i < actions.length; i++) {
+      const action = actions[i];
+      console.log(`\n📋 [${i + 1}/${actions.length}] Executing: ${action.name}`);
+
+      const result = await this.executeAction(action);
+      results.push(result);
+      this.actionResults.push(result);
+
+      if (!result.success && this.config.maxRetries > 0) {
+        console.log(`   ⚠️  Action failed, retrying...`);
+        // TODO: Implement retry logic
+      }
+
+      // Delay between actions to allow device/web editor to settle
+      if (i < actions.length - 1) {
+        console.log(`   ⏳ Waiting ${this.config.delayBetweenActions}ms before next action...`);
+        await this.sleep(this.config.delayBetweenActions);
+      }
+    }
+
+    const summary = validateActionResults(results);
+    console.log(`\n📊 Action sequence completed:`);
+    console.log(`   ✅ Successful: ${summary.successfulActions}/${summary.totalActions}`);
+    console.log(`   📨 Messages captured: ${summary.totalMessages} (avg: ${summary.averageMessagesPerAction.toFixed(1)}/action)`);
+
+    return results;
+  }
+
+  /**
+   * Execute a single test action with timing and message capture
+   */
+  private async executeAction(action: TestAction): Promise<ActionExecutionResult> {
+    const startTime = Date.now();
+    let success = false;
+    let error: string | undefined;
+    let screenshots: string[] = [];
+
+    try {
+      if (!this.webAutomation) {
+        throw new Error('Web automation not initialized');
+      }
+
+      // Take screenshot before action if enabled
+      if (this.config.captureScreenshots) {
+        const beforeScreenshot = await this.webAutomation.takeScreenshot(`${action.name}-before`);
+        screenshots.push(beforeScreenshot);
+      }
+
+      // Mark start time for message correlation
+      const actionStartTime = Date.now();
+
+      // Execute the action
+      await action.execute(this.webAutomation.getPage());
+
+      // Take screenshot after action if enabled
+      if (this.config.captureScreenshots) {
+        const afterScreenshot = await this.webAutomation.takeScreenshot(`${action.name}-after`);
+        screenshots.push(afterScreenshot);
+      }
+
+      success = true;
+
+      // Get messages captured during this action (approximate timing)
+      const capturedMessages = this.getCurrentMessages(actionStartTime);
+
+      console.log(`   ✅ Action completed in ${Date.now() - startTime}ms`);
+      console.log(`   📨 Captured ${capturedMessages.length} MIDI messages`);
+
+      const endTime = Date.now();
+
+      return {
+        action,
+        startTime,
+        endTime,
+        duration: endTime - startTime,
+        success,
+        capturedMessages,
+        screenshots,
+        validation: action.verify ? action.verify(capturedMessages) : undefined,
+      };
+
+    } catch (actionError: any) {
+      success = false;
+      error = actionError.message;
+
+      console.log(`   ❌ Action failed: ${error}`);
+
+      const endTime = Date.now();
+
+      return {
+        action,
+        startTime,
+        endTime,
+        duration: endTime - startTime,
+        success,
+        capturedMessages: [],
+        error,
+        screenshots,
+      };
+    }
+  }
+
+  /**
+   * Get MIDI messages captured since a specific timestamp
+   */
+  private getCurrentMessages(since: number): any[] {
+    // This is a simplified implementation - in practice, we'd need to
+    // coordinate with the MIDI monitor to get time-filtered messages
+    return [];
+  }
+
+  /**
+   * Analyze captured protocol data to identify patterns and differences
+   */
+  private async analyzeProtocol(): Promise<ProtocolAnalysis> {
+    console.log('🔍 Analyzing captured protocol data...');
+
+    // TODO: Implement comprehensive protocol analysis
+    // This would include:
+    // - Message pattern recognition
+    // - Action-message correlation
+    // - Comparison with current implementation
+    // - Protocol element identification
+
+    return {
+      totalMessages: 0,
+      sysexMessages: 0,
+      messagePatterns: [],
+      actionMessageMapping: [],
+      comparisonWithCurrentImplementation: [],
+      discoveredProtocolElements: [],
+    };
+  }
+
+  /**
+   * Generate improvement recommendations based on analysis
+   */
+  private generateRecommendations(analysis: ProtocolAnalysis): ProtocolRecommendation[] {
+    const recommendations: ProtocolRecommendation[] = [];
+
+    // TODO: Implement recommendation generation based on analysis findings
+
+    return recommendations;
+  }
+
+  /**
+   * Create session execution summary
+   */
+  private createSessionSummary(): SessionSummary {
+    const validation = validateActionResults(this.actionResults);
+    const totalTime = Date.now() - this.startTime;
+
+    return {
+      totalActions: validation.totalActions,
+      successfulActions: validation.successfulActions,
+      failedActions: validation.failedActions,
+      totalExecutionTime: totalTime,
+      averageActionTime: validation.totalActions > 0 ? totalTime / validation.totalActions : 0,
+      messagesPerAction: validation.averageMessagesPerAction,
+      protocolConfidence: 0.8, // TODO: Calculate based on analysis results
+    };
+  }
+
+  /**
+   * Save session results to files
+   */
+  private async saveResults(results: ReverseEngineeringResults): Promise<void> {
+    const resultsFile = join(this.config.outputDir, `reverse-engineering-${this.sessionId}.json`);
+    const summaryFile = join(this.config.outputDir, `summary-${this.sessionId}.json`);
+
+    // Save complete results
+    writeFileSync(resultsFile, JSON.stringify(results, null, 2));
+
+    // Save summary for quick review
+    writeFileSync(summaryFile, JSON.stringify({
+      sessionId: results.sessionId,
+      summary: results.summary,
+      topRecommendations: results.recommendations.slice(0, 5),
+      keyFindings: results.analysis.messagePatterns.slice(0, 10),
+    }, null, 2));
+
+    console.log(`💾 Results saved:`);
+    console.log(`   Complete: ${resultsFile}`);
+    console.log(`   Summary: ${summaryFile}`);
+  }
+
+  /**
+   * Clean up resources
+   */
+  private async cleanup(): Promise<void> {
+    try {
+      if (this.midiMonitor) {
+        await this.stopMidiMonitoring();
+      }
+
+      if (this.webAutomation) {
+        await this.webAutomation.close();
+      }
+    } catch (error: any) {
+      console.warn('⚠️  Cleanup warning:', error.message);
+    }
+  }
+
+  /**
+   * Utility: Sleep for specified milliseconds
+   */
+  private async sleep(ms: number): Promise<void> {
+    return new Promise(resolve => setTimeout(resolve, ms));
+  }
+
+  /**
+   * Generate unique session ID
+   */
+  private generateSessionId(): string {
+    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
+    const random = Math.random().toString(36).substring(2, 8);
+    return `reverse-engineer-${timestamp}-${random}`;
+  }
+
+  /**
+   * Ensure output directory exists
+   */
+  private ensureOutputDirectory(): void {
+    if (!existsSync(this.config.outputDir)) {
+      mkdirSync(this.config.outputDir, { recursive: true });
+    }
+  }
+}
+
+/**
+ * Factory function for creating ProtocolReverseEngineer instances
+ */
+export function createProtocolReverseEngineer(config?: ReverseEngineerConfig): ProtocolReverseEngineer {
+  return new ProtocolReverseEngineer(config);
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/web-editor-automation.ts b/modules/audio-control/modules/launch-control-xl3/utils/web-editor-automation.ts
new file mode 100644
index 0000000..5acdd33
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/web-editor-automation.ts
@@ -0,0 +1,453 @@
+#!/usr/bin/env tsx
+
+/**
+ * Web Editor Automation - Phase 2 Playwright Automation for Novation Web Editor
+ *
+ * This class provides automated interaction with the Novation Launch Control XL 3 web editor
+ * for systematic protocol reverse engineering.
+ *
+ * Features:
+ * - Browser automation using Playwright
+ * - Web MIDI API interaction
+ * - Device connection handling
+ * - Systematic action execution
+ * - Integration with MIDI monitoring infrastructure
+ *
+ * Target URL: https://components.novationmusic.com/launch-control-xl-3/custom-modes
+ */
+
+import { Browser, BrowserContext, Page, chromium } from 'playwright';
+import { MidiMonitor } from './midi-monitor.js';
+import { writeFileSync, existsSync, mkdirSync } from 'fs';
+import { join } from 'path';
+
+// Configuration for web editor automation
+export interface WebEditorConfig {
+  readonly headless?: boolean;
+  readonly timeout?: number;
+  readonly slowMo?: number;
+  readonly devtools?: boolean;
+  readonly recordVideo?: boolean;
+  readonly recordScreenshots?: boolean;
+  readonly outputDir?: string;
+}
+
+// Device connection state
+export interface DeviceConnectionState {
+  readonly isConnected: boolean;
+  readonly deviceName?: string;
+  readonly deviceId?: string;
+  readonly firmwareVersion?: string;
+  readonly lastConnectionTime?: number;
+}
+
+// Web editor session data
+export interface WebEditorSession {
+  readonly sessionId: string;
+  readonly startTime: number;
+  readonly endTime?: number;
+  readonly config: WebEditorConfig;
+  readonly connectionState: DeviceConnectionState;
+  readonly actionsExecuted: readonly string[];
+  readonly errors: readonly string[];
+}
+
+/**
+ * Web Editor Automation Controller
+ *
+ * Handles browser automation for the Novation web editor with integrated MIDI monitoring
+ */
+export class WebEditorAutomation {
+  private readonly config: WebEditorConfig;
+  private browser: Browser | null = null;
+  private context: BrowserContext | null = null;
+  private page: Page | null = null;
+  private midiMonitor: MidiMonitor | null = null;
+  private sessionId: string;
+  private startTime: number = 0;
+  private connectionState: DeviceConnectionState = { isConnected: false };
+  private actionsExecuted: string[] = [];
+  private errors: string[] = [];
+
+  // Web Editor Constants
+  private static readonly WEB_EDITOR_URL = 'https://components.novationmusic.com/launch-control-xl-3/custom-modes';
+  private static readonly DEVICE_CONNECTION_TIMEOUT = 30000; // 30 seconds
+  private static readonly PAGE_LOAD_TIMEOUT = 60000; // 60 seconds
+
+  constructor(config: WebEditorConfig = {}) {
+    this.config = {
+      headless: false, // Default to visible for debugging
+      timeout: 30000,
+      slowMo: 100, // Slow down actions for better observation
+      devtools: false,
+      recordVideo: false,
+      recordScreenshots: true,
+      outputDir: './playwright-sessions',
+      ...config,
+    };
+
+    this.sessionId = this.generateSessionId();
+    this.ensureOutputDirectory();
+  }
+
+  /**
+   * Launch the web editor in a browser
+   */
+  async launchEditor(): Promise<void> {
+    try {
+      console.log('🚀 Launching Web Editor Automation');
+      console.log('═'.repeat(60));
+
+      this.startTime = Date.now();
+
+      // Launch browser with Web MIDI API support
+      this.browser = await chromium.launch({
+        headless: this.config.headless,
+        slowMo: this.config.slowMo,
+        devtools: this.config.devtools,
+        args: [
+          '--enable-web-midi', // Enable Web MIDI API
+          '--disable-web-security', // Allow MIDI access
+          '--allow-running-insecure-content',
+          '--disable-features=VizDisplayCompositor',
+        ],
+      });
+
+      // Create browser context with permissions
+      this.context = await this.browser.newContext({
+        permissions: ['midi', 'midi-sysex'], // Grant MIDI permissions
+        recordVideo: this.config.recordVideo ? {
+          dir: join(this.config.outputDir!, 'videos'),
+          size: { width: 1280, height: 720 }
+        } : undefined,
+      });
+
+      // Create new page
+      this.page = await this.context.newPage();
+
+      // Set timeouts
+      this.page.setDefaultTimeout(this.config.timeout!);
+      this.page.setDefaultNavigationTimeout(WebEditorAutomation.PAGE_LOAD_TIMEOUT);
+
+      // Add console logging for debugging
+      this.page.on('console', (msg) => {
+        console.log(`🌐 Browser Console [${msg.type()}]: ${msg.text()}`);
+      });
+
+      // Handle dialog boxes
+      this.page.on('dialog', async (dialog) => {
+        console.log(`🗨️  Dialog: ${dialog.message()}`);
+        await dialog.accept();
+      });
+
+      // Navigate to web editor
+      console.log(`🌐 Navigating to: ${WebEditorAutomation.WEB_EDITOR_URL}`);
+      await this.page.goto(WebEditorAutomation.WEB_EDITOR_URL, {
+        waitUntil: 'networkidle',
+        timeout: WebEditorAutomation.PAGE_LOAD_TIMEOUT
+      });
+
+      // Wait for page to be fully loaded
+      await this.waitForEditorReady();
+
+      this.actionsExecuted.push('launch_editor');
+      console.log('✅ Web editor launched successfully');
+
+    } catch (error: any) {
+      const errorMsg = `Failed to launch web editor: ${error.message}`;
+      this.errors.push(errorMsg);
+      console.error('❌', errorMsg);
+      throw new Error(errorMsg);
+    }
+  }
+
+  /**
+   * Connect to the Launch Control XL 3 device through Web MIDI API
+   */
+  async connectToDevice(deviceName: string = 'LCXL3'): Promise<void> {
+    if (!this.page) {
+      throw new Error('Web editor not launched. Call launchEditor() first.');
+    }
+
+    try {
+      console.log(`🎛️  Attempting to connect to device: ${deviceName}`);
+
+      // Execute Web MIDI connection script in browser
+      const connectionResult = await this.page.evaluate(async (targetDeviceName) => {
+        try {
+          // Request MIDI access with SysEx support
+          const midiAccess = await (navigator as any).requestMIDIAccess({ sysex: true });
+
+          // Find the target device
+          let targetInput: any = null;
+          let targetOutput: any = null;
+
+          // Check inputs
+          for (const [id, input] of midiAccess.inputs) {
+            console.log(`Found MIDI input: ${input.name}`);
+            if (input.name?.includes(targetDeviceName)) {
+              targetInput = input;
+              break;
+            }
+          }
+
+          // Check outputs
+          for (const [id, output] of midiAccess.outputs) {
+            console.log(`Found MIDI output: ${output.name}`);
+            if (output.name?.includes(targetDeviceName)) {
+              targetOutput = output;
+              break;
+            }
+          }
+
+          if (!targetInput || !targetOutput) {
+            const availableDevices = {
+              inputs: Array.from(midiAccess.inputs.values()).map((input: any) => input.name),
+              outputs: Array.from(midiAccess.outputs.values()).map((output: any) => output.name),
+            };
+            return {
+              success: false,
+              error: `Device "${targetDeviceName}" not found`,
+              availableDevices,
+            };
+          }
+
+          // Store references globally for the web editor to use
+          (window as any).__lcxl3_midi_input = targetInput;
+          (window as any).__lcxl3_midi_output = targetOutput;
+
+          return {
+            success: true,
+            deviceName: targetInput.name,
+            deviceId: targetInput.id,
+          };
+
+        } catch (error: any) {
+          return {
+            success: false,
+            error: error.message,
+          };
+        }
+      }, deviceName);
+
+      if (!connectionResult.success) {
+        const errorMsg = `Device connection failed: ${connectionResult.error}`;
+        this.errors.push(errorMsg);
+
+        if (connectionResult.availableDevices) {
+          console.log('📱 Available MIDI devices:');
+          console.log('   Inputs:', connectionResult.availableDevices.inputs);
+          console.log('   Outputs:', connectionResult.availableDevices.outputs);
+        }
+
+        throw new Error(errorMsg);
+      }
+
+      // Update connection state
+      this.connectionState = {
+        isConnected: true,
+        deviceName: connectionResult.deviceName,
+        deviceId: connectionResult.deviceId,
+        lastConnectionTime: Date.now(),
+      };
+
+      this.actionsExecuted.push('connect_device');
+      console.log(`✅ Connected to device: ${connectionResult.deviceName}`);
+
+    } catch (error: any) {
+      const errorMsg = `Failed to connect to device: ${error.message}`;
+      this.errors.push(errorMsg);
+      console.error('❌', errorMsg);
+      throw new Error(errorMsg);
+    }
+  }
+
+  /**
+   * Start MIDI monitoring in parallel with web actions
+   */
+  async startMidiMonitoring(): Promise<void> {
+    try {
+      console.log('🎵 Starting integrated MIDI monitoring');
+
+      // Create MIDI monitor with session-specific configuration
+      this.midiMonitor = new MidiMonitor({
+        deviceFilter: 'LCXL3',
+        outputDir: this.config.outputDir,
+        sessionName: `web-automation-${this.sessionId}`,
+        verboseLogging: true,
+        bufferMessages: true,
+      });
+
+      await this.midiMonitor.startMonitoring();
+      console.log('✅ MIDI monitoring started');
+
+    } catch (error: any) {
+      const errorMsg = `Failed to start MIDI monitoring: ${error.message}`;
+      this.errors.push(errorMsg);
+      console.error('❌', errorMsg);
+      throw new Error(errorMsg);
+    }
+  }
+
+  /**
+   * Stop MIDI monitoring and save session data
+   */
+  async stopMidiMonitoring(): Promise<void> {
+    if (this.midiMonitor) {
+      try {
+        const session = await this.midiMonitor.stopMonitoring();
+        console.log(`✅ MIDI monitoring stopped. Captured ${session.messages.length} messages`);
+      } catch (error: any) {
+        console.error('❌ Error stopping MIDI monitoring:', error.message);
+      }
+    }
+  }
+
+  /**
+   * Wait for device to be ready and responsive
+   */
+  async waitForDeviceReady(): Promise<void> {
+    if (!this.connectionState.isConnected) {
+      throw new Error('Device not connected. Call connectToDevice() first.');
+    }
+
+    console.log('⏳ Waiting for device to be ready...');
+
+    // Add a reasonable delay for device initialization
+    await this.page!.waitForTimeout(2000);
+
+    // TODO: Add device ping/handshake if needed
+    console.log('✅ Device ready');
+  }
+
+  /**
+   * Take a screenshot of the current state
+   */
+  async takeScreenshot(name?: string): Promise<string> {
+    if (!this.page) {
+      throw new Error('Page not available');
+    }
+
+    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
+    const filename = `${name || 'screenshot'}-${timestamp}.png`;
+    const filepath = join(this.config.outputDir!, 'screenshots', filename);
+
+    // Ensure screenshots directory exists
+    const screenshotsDir = join(this.config.outputDir!, 'screenshots');
+    if (!existsSync(screenshotsDir)) {
+      mkdirSync(screenshotsDir, { recursive: true });
+    }
+
+    await this.page.screenshot({
+      path: filepath,
+      fullPage: true
+    });
+
+    console.log(`📸 Screenshot saved: ${filepath}`);
+    return filepath;
+  }
+
+  /**
+   * Get current page instance for external action execution
+   */
+  getPage(): Page {
+    if (!this.page) {
+      throw new Error('Web editor not launched. Call launchEditor() first.');
+    }
+    return this.page;
+  }
+
+  /**
+   * Get current connection state
+   */
+  getConnectionState(): DeviceConnectionState {
+    return { ...this.connectionState };
+  }
+
+  /**
+   * Clean up and close browser resources
+   */
+  async close(): Promise<WebEditorSession> {
+    try {
+      // Stop MIDI monitoring
+      await this.stopMidiMonitoring();
+
+      // Save session data
+      const session: WebEditorSession = {
+        sessionId: this.sessionId,
+        startTime: this.startTime,
+        endTime: Date.now(),
+        config: this.config,
+        connectionState: this.connectionState,
+        actionsExecuted: [...this.actionsExecuted],
+        errors: [...this.errors],
+      };
+
+      // Save session metadata
+      const sessionFile = join(this.config.outputDir!, `session-${this.sessionId}.json`);
+      writeFileSync(sessionFile, JSON.stringify(session, null, 2));
+
+      // Close browser
+      if (this.browser) {
+        await this.browser.close();
+        console.log('🔒 Browser closed');
+      }
+
+      console.log(`📊 Session completed: ${session.actionsExecuted.length} actions, ${session.errors.length} errors`);
+      console.log(`💾 Session data saved: ${sessionFile}`);
+
+      return session;
+
+    } catch (error: any) {
+      console.error('❌ Error during cleanup:', error.message);
+      throw error;
+    }
+  }
+
+  /**
+   * Wait for the web editor to be fully loaded and ready
+   */
+  private async waitForEditorReady(): Promise<void> {
+    if (!this.page) return;
+
+    try {
+      // Wait for common web editor elements to be present
+      // These selectors may need to be updated based on actual web editor structure
+      await Promise.race([
+        this.page.waitForSelector('body', { timeout: 10000 }),
+        this.page.waitForLoadState('networkidle', { timeout: 10000 }),
+      ]);
+
+      // Additional wait for potential JavaScript initialization
+      await this.page.waitForTimeout(2000);
+
+    } catch (error: any) {
+      console.warn('⚠️  Editor ready check timed out, proceeding anyway');
+    }
+  }
+
+  /**
+   * Generate unique session ID
+   */
+  private generateSessionId(): string {
+    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
+    const random = Math.random().toString(36).substring(2, 8);
+    return `web-automation-${timestamp}-${random}`;
+  }
+
+  /**
+   * Ensure output directory exists
+   */
+  private ensureOutputDirectory(): void {
+    if (!existsSync(this.config.outputDir!)) {
+      mkdirSync(this.config.outputDir!, { recursive: true });
+    }
+  }
+}
+
+/**
+ * Factory function for creating WebEditorAutomation instances
+ */
+export function createWebEditorAutomation(config?: WebEditorConfig): WebEditorAutomation {
+  return new WebEditorAutomation(config);
+}
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

feat(launch-control-xl3): add Playwright-based web editor automation for MIDI protocol reverse engineering

