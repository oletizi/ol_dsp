<!-- Generated by SpecStory -->

# MIDI Handshake Protocol Fix Workplan (2025-09-28 17:46:24Z)

<!-- Claude Code Session be70513c-2e11-4469-9e57-1dd037958d4c (2025-09-28_17-46-24Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/WORKPLAN-HANDSHAKE-FIX.md b/modules/audio-control/modules/launch-control-xl3/WORKPLAN-HANDSHAKE-FIX.md
new file mode 100644
index 0000000..23603d4
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/WORKPLAN-HANDSHAKE-FIX.md
@@ -0,0 +1,630 @@
+# Workplan: Fix Launch Control XL3 Handshake Implementation
+
+## Problem Statement
+
+The current handshake implementation in `LaunchControlXL3` does not follow the complete protocol documented in `MIDI-PROTOCOL.md`. Specifically:
+
+### Current Behavior
+- Only sends Universal Device Inquiry: `F0 7E 00 06 01 F7` (6 bytes)
+- Uses wrong device ID (`0x00` instead of `0x7F`)
+- Skips Novation-specific SYN/SYN-ACK exchange
+- Missing proper sequence coordination
+
+### Expected Behavior (per MIDI-PROTOCOL.md)
+The complete handshake should be a 4-message sequence:
+
+1. **SYN Request**: `F0 00 20 29 00 42 02 F7` (8 bytes)
+   - Novation-specific initialization message
+
+2. **SYN-ACK Response**: `F0 00 20 29 00 42 02 [SERIAL_NUMBER] F7` (22 bytes)
+   - Device responds with serial number
+
+3. **ACK Request**: `F0 7E 7F 06 01 F7` (6 bytes)
+   - Universal Device Inquiry with correct device ID (`0x7F` for broadcast)
+
+4. **Device Response**: `F0 7E 00 06 02 00 20 29 48 01 00 00 01 00 0A 54 F7` (17 bytes)
+   - Device identification information
+
+## Technical Analysis
+
+### Affected Files
+- `src/core/SysExParser.ts` - Contains `buildDeviceQuery()` at line 404
+- `src/device/DeviceManager.ts` - Handles connection and handshake coordination
+- `test/LaunchControlXL3.handshake.test.ts` - Unit tests need updates
+
+### Current Implementation Location
+```typescript
+// src/core/SysExParser.ts:404
+static buildDeviceQuery(): number[] {
+  return [
+    0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7  // ‚ùå Incomplete, wrong device ID
+  ];
+}
+```
+
+### Protocol Constants
+```typescript
+// Novation Manufacturer ID
+const NOVATION_MANUFACTURER_ID = [0x00, 0x20, 0x29];
+
+// Launch Control XL3 Device ID
+const LCXL3_DEVICE_ID = [0x48, 0x01];
+
+// Universal System Exclusive IDs
+const UNIVERSAL_NON_REALTIME = 0x7E;
+const DEVICE_INQUIRY_REQUEST = 0x06;
+const DEVICE_INQUIRY_REPLY = 0x02;
+```
+
+## Implementation Plan
+
+### Phase 1: Update SysExParser
+
+**Task 1.1: Add handshake message builders**
+
+Create new static methods in `SysExParser`:
+
+```typescript
+static buildNovationSyn(): number[] {
+  return [
+    0xF0,              // SysEx start
+    0x00, 0x20, 0x29,  // Novation manufacturer ID
+    0x00,              // Device model (Launch Control)
+    0x42,              // Command (handshake)
+    0x02,              // Sub-command (SYN)
+    0xF7               // SysEx end
+  ];
+}
+
+static buildUniversalDeviceInquiry(): number[] {
+  return [
+    0xF0,              // SysEx start
+    0x7E,              // Universal Non-Realtime
+    0x7F,              // Device ID (broadcast)
+    0x06,              // Sub-ID 1 (Device Inquiry)
+    0x01,              // Sub-ID 2 (Inquiry Request)
+    0xF7               // SysEx end
+  ];
+}
+
+static parseNovationSynAck(data: number[]): {
+  valid: boolean;
+  serialNumber?: string;
+} {
+  if (data.length !== 22) {
+    return { valid: false };
+  }
+
+  if (data[0] !== 0xF0 || data[data.length - 1] !== 0xF7) {
+    return { valid: false };
+  }
+
+  // Verify Novation manufacturer ID
+  if (data[1] !== 0x00 || data[2] !== 0x20 || data[3] !== 0x29) {
+    return { valid: false };
+  }
+
+  // Verify command bytes
+  if (data[4] !== 0x00 || data[5] !== 0x42 || data[6] !== 0x02) {
+    return { valid: false };
+  }
+
+  // Extract serial number (bytes 7-20)
+  const serialBytes = data.slice(7, 21);
+  const serialNumber = String.fromCharCode(...serialBytes);
+
+  return { valid: true, serialNumber };
+}
+```
+
+**Task 1.2: Update `buildDeviceQuery()` for backwards compatibility**
+
+Keep the existing method but add JSDoc warning:
+
+```typescript
+/**
+ * @deprecated Use the complete handshake sequence with buildNovationSyn()
+ * and buildUniversalDeviceInquiry() instead. This method only performs
+ * partial handshake and uses incorrect device ID.
+ */
+static buildDeviceQuery(): number[] {
+  return [
+    0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7
+  ];
+}
+```
+
+### Phase 2: Update DeviceManager
+
+**Task 2.1: Implement complete handshake sequence**
+
+Update `DeviceManager.ts` to implement the 4-message protocol:
+
+```typescript
+private async performHandshake(): Promise<DeviceInfo> {
+  const logger = this.logger;
+  const timeout = this.config.handshakeTimeout ?? 5000;
+
+  // Step 1: Send Novation SYN
+  logger.debug('Handshake Step 1: Sending Novation SYN...');
+  const synMessage = SysExParser.buildNovationSyn();
+  await this.midiInterface.sendMessage(synMessage);
+
+  // Step 2: Wait for SYN-ACK
+  logger.debug('Handshake Step 2: Waiting for SYN-ACK...');
+  const synAckData = await this.waitForMessage(
+    (data) => {
+      const parsed = SysExParser.parseNovationSynAck(data);
+      return parsed.valid;
+    },
+    timeout,
+    'SYN-ACK'
+  );
+
+  const synAck = SysExParser.parseNovationSynAck(synAckData);
+  logger.info(`Received SYN-ACK with serial: ${synAck.serialNumber}`);
+
+  // Step 3: Send Universal Device Inquiry (ACK)
+  logger.debug('Handshake Step 3: Sending Universal Device Inquiry...');
+  const inquiryMessage = SysExParser.buildUniversalDeviceInquiry();
+  await this.midiInterface.sendMessage(inquiryMessage);
+
+  // Step 4: Wait for Device Response
+  logger.debug('Handshake Step 4: Waiting for Device Response...');
+  const responseData = await this.waitForMessage(
+    (data) => SysExParser.isDeviceInquiryResponse(data),
+    timeout,
+    'Device Response'
+  );
+
+  const deviceInfo = SysExParser.parseDeviceInquiryResponse(responseData);
+  logger.info(`Handshake complete. Device: ${deviceInfo.manufacturerId}`);
+
+  return deviceInfo;
+}
+
+private async waitForMessage(
+  validator: (data: number[]) => boolean,
+  timeoutMs: number,
+  messageName: string
+): Promise<number[]> {
+  return new Promise<number[]>((resolve, reject) => {
+    const timeout = setTimeout(() => {
+      this.midiInterface.removeMessageListener(handler);
+      reject(new Error(`Handshake timeout waiting for ${messageName}`));
+    }, timeoutMs);
+
+    const handler = (message: MidiMessage) => {
+      if (validator(Array.from(message.data))) {
+        clearTimeout(timeout);
+        this.midiInterface.removeMessageListener(handler);
+        resolve(Array.from(message.data));
+      }
+    };
+
+    this.midiInterface.addMessageListener(handler);
+  });
+}
+```
+
+**Task 2.2: Add message listener management**
+
+Update `MidiInterface.ts` to support temporary message listeners:
+
+```typescript
+export interface MidiInterface {
+  // ... existing methods ...
+
+  addMessageListener(handler: (message: MidiMessage) => void): void;
+  removeMessageListener(handler: (message: MidiMessage) => void): void;
+}
+```
+
+### Phase 3: Update Tests
+
+**Task 3.1: Update handshake unit tests**
+
+Update `test/LaunchControlXL3.handshake.test.ts`:
+
+```typescript
+describe('Complete Handshake Sequence', () => {
+  it('should perform full 4-message handshake', async () => {
+    const sendSpy = vi.spyOn(mockBackend, 'sendMessage');
+
+    const connectionPromise = controller.connect();
+
+    // Wait for SYN
+    await vi.waitFor(() => {
+      const calls = sendSpy.mock.calls;
+      const synSent = calls.some(call => {
+        const message = Array.from(call[1].data);
+        return arraysEqual(message, [0xF0, 0x00, 0x20, 0x29, 0x00, 0x42, 0x02, 0xF7]);
+      });
+      expect(synSent).toBe(true);
+    });
+
+    // Simulate SYN-ACK
+    mockBackend.simulateNovationSynAck();
+
+    // Wait for ACK (Universal Inquiry)
+    await vi.waitFor(() => {
+      const calls = sendSpy.mock.calls;
+      const ackSent = calls.some(call => {
+        const message = Array.from(call[1].data);
+        return arraysEqual(message, [0xF0, 0x7E, 0x7F, 0x06, 0x01, 0xF7]);
+      });
+      expect(ackSent).toBe(true);
+    });
+
+    // Simulate Device Response
+    mockBackend.simulateDeviceInquiryResponse();
+
+    await connectionPromise;
+    expect(controller.isConnected()).toBe(true);
+  });
+
+  it('should timeout if SYN-ACK not received', async () => {
+    mockBackend.shouldRespondToSyn = false;
+
+    await expect(controller.connect()).rejects.toThrow(/timeout.*SYN-ACK/i);
+  });
+
+  it('should reject invalid SYN-ACK serial number format', async () => {
+    mockBackend.invalidSynAck = true;
+
+    await expect(controller.connect()).rejects.toThrow(/invalid.*SYN-ACK/i);
+  });
+
+  it('should extract serial number from SYN-ACK', async () => {
+    const deviceHandler = vi.fn();
+    controller.on('device:connected', deviceHandler);
+
+    await controller.connect();
+
+    expect(deviceHandler).toHaveBeenCalled();
+    expect(deviceHandler.mock.calls[0][0]).toMatchObject({
+      serialNumber: expect.stringMatching(/^LX2\d{11}$/),
+    });
+  });
+});
+```
+
+**Task 3.2: Add MockMidiBackend support**
+
+Update `MockMidiBackend` in test file:
+
+```typescript
+class MockMidiBackend implements MidiBackendInterface {
+  shouldRespondToSyn = true;
+  invalidSynAck = false;
+
+  simulateNovationSynAck(): void {
+    if (!this.shouldRespondToSyn) return;
+
+    const serialNumber = 'LX28093540046969';
+    const response: number[] = [
+      0xF0, 0x00, 0x20, 0x29, 0x00, 0x42, 0x02,
+      ...Array.from(serialNumber).map(c => c.charCodeAt(0)),
+      0xF7
+    ];
+
+    if (this.invalidSynAck) {
+      response[6] = 0xFF; // Corrupt command byte
+    }
+
+    this.simulateIncomingMessage({
+      timestamp: Date.now(),
+      data: response,
+      type: 'sysex',
+    });
+  }
+
+  simulateDeviceInquiryResponse(): void {
+    const response: number[] = [
+      0xF0, 0x7E, 0x00, 0x06, 0x02,
+      0x00, 0x20, 0x29,  // Novation
+      0x48, 0x01,         // Launch Control XL3
+      0x00, 0x00,         // Device family
+      0x01, 0x00, 0x0A, 0x54,  // Firmware version
+      0xF7
+    ];
+
+    this.simulateIncomingMessage({
+      timestamp: Date.now(),
+      data: response,
+      type: 'sysex',
+    });
+  }
+}
+```
+
+### Phase 4: Integration Testing
+
+**Task 4.1: Hardware test script**
+
+Create `utils/test-complete-handshake.ts`:
+
+```typescript
+import { LaunchControlXL3 } from '@/LaunchControlXL3.js';
+import { EasyMidiBackend } from '@/core/backends/EasyMidiBackend.js';
+import { ConsoleLogger } from '@/core/Logger.js';
+
+async function testCompleteHandshake() {
+  const logger = new ConsoleLogger({
+    prefix: 'HandshakeTest',
+    includeTimestamp: true
+  });
+
+  const backend = new EasyMidiBackend(logger);
+  const controller = new LaunchControlXL3({
+    midiBackend: backend,
+    logger,
+  });
+
+  try {
+    logger.info('Starting complete handshake test...');
+    await controller.connect();
+
+    logger.info('‚úÖ Handshake successful!');
+    logger.info(`Device: ${JSON.stringify(controller.getDeviceInfo(), null, 2)}`);
+
+    await controller.disconnect();
+    logger.info('‚úÖ Disconnected cleanly');
+  } catch (error) {
+    logger.error('‚ùå Handshake failed:', (error as Error).message);
+    process.exit(1);
+  }
+}
+
+testCompleteHandshake();
+```
+
+**Task 4.2: Add to test suite**
+
+Update `package.json` with new test script:
+
+```json
+{
+  "scripts": {
+    "test:handshake:node": "tsx utils/test-complete-handshake.ts",
+    "test:handshake:unit": "vitest run test/LaunchControlXL3.handshake.test.ts"
+  }
+}
+```
+
+## Backwards Compatibility
+
+### Automatic Fallback Strategy
+
+If the complete handshake fails, fall back to simple Universal Device Inquiry:
+
+```typescript
+private async performHandshake(): Promise<DeviceInfo> {
+  try {
+    return await this.performCompleteHandshake();
+  } catch (error) {
+    this.logger.warn('Complete handshake failed, trying fallback:', (error as Error).message);
+    return await this.performSimpleHandshake();
+  }
+}
+
+private async performCompleteHandshake(): Promise<DeviceInfo> {
+  // 4-message sequence as documented above
+}
+
+private async performSimpleHandshake(): Promise<DeviceInfo> {
+  // Original implementation (Universal Inquiry only)
+  this.logger.debug('Using simple handshake (Universal Inquiry only)');
+  const inquiryMessage = SysExParser.buildDeviceQuery();
+  await this.midiInterface.sendMessage(inquiryMessage);
+
+  const responseData = await this.waitForMessage(
+    (data) => SysExParser.isDeviceInquiryResponse(data),
+    this.config.handshakeTimeout ?? 5000,
+    'Device Response'
+  );
+
+  return SysExParser.parseDeviceInquiryResponse(responseData);
+}
+```
+
+### Configuration Option
+
+Add opt-in flag to `LaunchControlXL3Options`:
+
+```typescript
+export interface LaunchControlXL3Options {
+  // ... existing options ...
+
+  /**
+   * Use complete Novation handshake sequence (SYN/SYN-ACK/ACK/Response).
+   * If false or if complete handshake fails, falls back to simple Universal
+   * Device Inquiry.
+   *
+   * @default true
+   */
+  useCompleteHandshake?: boolean;
+}
+```
+
+## Documentation Updates
+
+### Task 5.1: Update MIDI-PROTOCOL.md
+
+Add implementation status section:
+
+```markdown
+## Implementation Status
+
+### ‚úÖ Complete Handshake (v2.0.0+)
+
+The controller now implements the full 4-message handshake sequence:
+
+1. **SYN**: Novation-specific initialization
+2. **SYN-ACK**: Device responds with serial number
+3. **ACK**: Universal Device Inquiry
+4. **Response**: Device identification
+
+### Fallback Support
+
+If the complete handshake fails, the controller automatically falls back to
+the simple Universal Device Inquiry for compatibility with older devices or
+non-standard implementations.
+```
+
+### Task 5.2: Update README.md
+
+Add handshake details to README:
+
+```markdown
+## Device Handshake
+
+The controller performs a complete 4-message handshake on connection:
+
+1. Sends Novation-specific SYN
+2. Receives SYN-ACK with device serial number
+3. Sends Universal Device Inquiry (ACK)
+4. Receives device identification
+
+If the complete handshake fails, it automatically falls back to a simple
+Universal Device Inquiry for compatibility.
+
+### Configuration
+
+```typescript
+const controller = new LaunchControlXL3({
+  useCompleteHandshake: true,  // default
+  handshakeTimeout: 5000,      // milliseconds
+});
+```
+```
+
+### Task 5.3: Update JSDoc
+
+Add detailed JSDoc to `performHandshake()`:
+
+```typescript
+/**
+ * Performs device handshake according to Launch Control XL3 protocol.
+ *
+ * Implements the complete 4-message sequence:
+ * 1. SYN: Novation initialization (8 bytes)
+ * 2. SYN-ACK: Device serial number response (22 bytes)
+ * 3. ACK: Universal Device Inquiry (6 bytes)
+ * 4. Response: Device identification (17 bytes)
+ *
+ * If `useCompleteHandshake` is false or the complete sequence fails,
+ * falls back to simple Universal Device Inquiry.
+ *
+ * @throws {Error} If handshake times out or receives invalid response
+ * @returns {Promise<DeviceInfo>} Device identification information
+ *
+ * @see MIDI-PROTOCOL.md for complete protocol specification
+ */
+private async performHandshake(): Promise<DeviceInfo>
+```
+
+## Testing Strategy
+
+### Unit Tests
+- ‚úÖ Test each message builder function
+- ‚úÖ Test SYN-ACK parser with valid/invalid data
+- ‚úÖ Test complete 4-message sequence
+- ‚úÖ Test timeout scenarios at each step
+- ‚úÖ Test fallback to simple handshake
+- ‚úÖ Test serial number extraction
+
+### Integration Tests
+- ‚úÖ Test with real hardware (Launch Control XL3)
+- ‚úÖ Test with MIDI loopback (software simulation)
+- ‚úÖ Test with modified timeout values
+- ‚úÖ Verify logging output at each step
+
+### Performance Tests
+- ‚úÖ Measure handshake completion time
+- ‚úÖ Verify timeout behavior under load
+- ‚úÖ Test concurrent connection attempts
+
+## Risk Assessment
+
+### Low Risk
+- Adding new message builders (no breaking changes)
+- Adding SYN-ACK parser (new functionality)
+- Logging improvements (visibility only)
+
+### Medium Risk
+- Changing handshake sequence (mitigated by fallback)
+- Timeout handling (need careful testing)
+- Message listener management (ensure proper cleanup)
+
+### High Risk
+- None (fallback ensures backwards compatibility)
+
+## Success Criteria
+
+### Functional Requirements
+- ‚úÖ Controller sends all 4 messages in correct order
+- ‚úÖ Controller validates SYN-ACK response
+- ‚úÖ Controller extracts serial number correctly
+- ‚úÖ Controller uses correct device ID (0x7F)
+- ‚úÖ Fallback works when complete handshake unavailable
+
+### Performance Requirements
+- ‚úÖ Handshake completes within 2 seconds (typical)
+- ‚úÖ Timeout occurs within configured duration
+- ‚úÖ No memory leaks in message listeners
+
+### Quality Requirements
+- ‚úÖ All unit tests pass
+- ‚úÖ Integration test passes with real hardware
+- ‚úÖ Code coverage ‚â• 80%
+- ‚úÖ TypeScript compilation succeeds with strict mode
+- ‚úÖ Documentation updated and accurate
+
+## Timeline
+
+### Phase 1: SysExParser Updates
+- Estimated: 2-3 hours
+- Priority: High
+- Blocking: Yes (required for subsequent phases)
+
+### Phase 2: DeviceManager Updates
+- Estimated: 3-4 hours
+- Priority: High
+- Blocking: Yes (core functionality)
+
+### Phase 3: Test Updates
+- Estimated: 2-3 hours
+- Priority: High
+- Blocking: No (can parallel with Phase 4)
+
+### Phase 4: Integration Testing
+- Estimated: 2-3 hours
+- Priority: Medium
+- Blocking: No (validation only)
+
+### Phase 5: Documentation
+- Estimated: 1-2 hours
+- Priority: Low
+- Blocking: No (can be done last)
+
+**Total Estimated Time**: 10-15 hours
+
+## Implementation Order
+
+1. Update `SysExParser.ts` with new message builders
+2. Update `SysExParser.ts` with SYN-ACK parser
+3. Update `DeviceManager.ts` with complete handshake
+4. Add message listener support to `MidiInterface.ts`
+5. Update unit tests
+6. Test with real hardware
+7. Update documentation
+8. Final review and PR
+
+## Notes
+
+- The complete handshake is optional with automatic fallback
+- No breaking changes to public API
+- Maintains compatibility with older devices
+- Improves protocol correctness and logging
+- Enables serial number extraction for device tracking
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/LaunchControlXL3.handshake.test.ts b/modules/audio-control/modules/launch-control-xl3/test/LaunchControlXL3.handshake.test.ts
new file mode 100644
index 0000000..9b8a838
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/LaunchControlXL3.handshake.test.ts
@@ -0,0 +1,267 @@
+/**
+ * LaunchControlXL3 Handshake Unit Tests
+ *
+ * Tests that the controller properly facilitates the device handshake
+ * according to the MIDI-PROTOCOL.md specification.
+ */
+
+import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
+import { LaunchControlXL3 } from '@/LaunchControlXL3.js';
+import type { MidiBackendInterface, MidiMessage, MidiPortInfo, MidiInputPort, MidiOutputPort } from '@/core/MidiInterface.js';
+import { NoOpLogger } from '@/core/Logger.js';
+
+describe('LaunchControlXL3 - Device Handshake', () => {
+  let controller: LaunchControlXL3;
+  let mockBackend: MockMidiBackend;
+
+  beforeEach(() => {
+    mockBackend = new MockMidiBackend();
+    controller = new LaunchControlXL3({
+      midiBackend: mockBackend,
+      logger: new NoOpLogger(),
+    });
+  });
+
+  afterEach(async () => {
+    await controller.cleanup();
+    vi.clearAllMocks();
+  });
+
+  describe('Device Inquiry Handshake', () => {
+    it('should send device inquiry message when connecting', async () => {
+      const sendSpy = vi.spyOn(mockBackend, 'sendMessage');
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(sendSpy).toHaveBeenCalled();
+      });
+
+      const deviceInquiryMessage = [0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7];
+      const calls = sendSpy.mock.calls;
+      const inquirySent = calls.some(call => {
+        const message = call[1];
+        return arraysEqual(Array.from(message.data), deviceInquiryMessage);
+      });
+
+      expect(inquirySent).toBe(true);
+
+      mockBackend.simulateDeviceResponse();
+      await connectionPromise;
+    });
+
+    it('should accept valid device inquiry response', async () => {
+      const validResponse: number[] = [
+        0xF0, 0x7E, 0x00, 0x06, 0x02,
+        0x00, 0x20, 0x29,
+        0x48, 0x01,
+        0x00, 0x00,
+        0x01, 0x00, 0x0A, 0x54,
+        0xF7
+      ];
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(mockBackend.inputPort).toBeDefined();
+      });
+
+      mockBackend.simulateIncomingMessage({
+        timestamp: Date.now(),
+        data: validResponse,
+        type: 'sysex',
+      });
+
+      await expect(connectionPromise).resolves.not.toThrow();
+      expect(controller.isConnected()).toBe(true);
+    });
+
+    it('should validate manufacturer ID in response', async () => {
+      const invalidResponse: number[] = [
+        0xF0, 0x7E, 0x00, 0x06, 0x02,
+        0xFF, 0xFF, 0xFF,
+        0x48, 0x01,
+        0x00, 0x00,
+        0x01, 0x00, 0x0A, 0x54,
+        0xF7
+      ];
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(mockBackend.inputPort).toBeDefined();
+      });
+
+      mockBackend.simulateIncomingMessage({
+        timestamp: Date.now(),
+        data: invalidResponse,
+        type: 'sysex',
+      });
+
+      await expect(connectionPromise).rejects.toThrow();
+    });
+
+    it('should timeout if no response received', async () => {
+      controller = new LaunchControlXL3({
+        midiBackend: mockBackend,
+        logger: new NoOpLogger(),
+      });
+
+      mockBackend.shouldRespondToInquiry = false;
+
+      const connectionPromise = controller.connect();
+
+      await expect(connectionPromise).rejects.toThrow(/timeout/i);
+    }, 10000);
+
+    it('should emit device:connected event after successful handshake', async () => {
+      const connectedHandler = vi.fn();
+      controller.on('device:connected', connectedHandler);
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(mockBackend.inputPort).toBeDefined();
+      });
+
+      mockBackend.simulateDeviceResponse();
+      await connectionPromise;
+
+      expect(connectedHandler).toHaveBeenCalled();
+      expect(connectedHandler.mock.calls[0][0]).toMatchObject({
+        manufacturerId: expect.any(String),
+        deviceFamily: expect.any(Number),
+        modelNumber: expect.any(Number),
+        firmwareVersion: expect.any(String),
+      });
+    });
+
+    it('should emit device:error event if handshake fails', async () => {
+      const errorHandler = vi.fn();
+      controller.on('device:error', errorHandler);
+
+      mockBackend.shouldRespondToInquiry = false;
+
+      const connectionPromise = controller.connect();
+
+      await expect(connectionPromise).rejects.toThrow();
+      expect(errorHandler).toHaveBeenCalled();
+      expect(errorHandler.mock.calls[0][0]).toBeInstanceOf(Error);
+    });
+
+    it('should not proceed with connection if handshake fails', async () => {
+      mockBackend.shouldRespondToInquiry = false;
+
+      await expect(controller.connect()).rejects.toThrow();
+      expect(controller.isConnected()).toBe(false);
+    });
+  });
+});
+
+function arraysEqual(a: number[], b: number[]): boolean {
+  if (a.length !== b.length) return false;
+  return a.every((val, idx) => val === b[idx]);
+}
+
+class MockMidiBackend implements MidiBackendInterface {
+  inputPort?: MidiInputPort;
+  outputPort?: MidiOutputPort;
+  shouldRespondToInquiry = true;
+  private initCount = 0;
+
+  async initialize(): Promise<void> {
+    this.initCount++;
+  }
+
+  async getInputPorts(): Promise<MidiPortInfo[]> {
+    return [
+      { id: 'test-input', name: 'Launch Control XL' },
+    ];
+  }
+
+  async getOutputPorts(): Promise<MidiPortInfo[]> {
+    return [
+      { id: 'test-output', name: 'Launch Control XL' },
+    ];
+  }
+
+  async openInput(portId: string): Promise<MidiInputPort> {
+    this.inputPort = {
+      id: portId,
+      name: 'Launch Control XL',
+      type: 'input',
+      onMessage: undefined,
+      close: async () => {
+        this.inputPort = undefined;
+      },
+    };
+    return this.inputPort;
+  }
+
+  async openOutput(portId: string): Promise<MidiOutputPort> {
+    this.outputPort = {
+      id: portId,
+      name: 'Launch Control XL',
+      type: 'output',
+      close: async () => {
+        this.outputPort = undefined;
+      },
+    };
+    return this.outputPort;
+  }
+
+  async sendMessage(_port: MidiOutputPort, message: MidiMessage): Promise<void> {
+    const data = Array.from(message.data);
+
+    if (this.shouldRespondToInquiry && this.isDeviceInquiry(data)) {
+      setTimeout(() => {
+        this.simulateDeviceResponse();
+      }, 10);
+    }
+  }
+
+  private isDeviceInquiry(data: number[]): boolean {
+    const inquiryPattern = [0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7];
+    return arraysEqual(data, inquiryPattern);
+  }
+
+  simulateDeviceResponse(): void {
+    if (!this.inputPort || !this.inputPort.onMessage) {
+      return;
+    }
+
+    const response: number[] = [
+      0xF0, 0x7E, 0x00, 0x06, 0x02,
+      0x00, 0x20, 0x29,
+      0x48, 0x01,
+      0x00, 0x00,
+      0x01, 0x00, 0x0A, 0x54,
+      0xF7
+    ];
+
+    this.inputPort.onMessage({
+      timestamp: Date.now(),
+      data: response,
+      type: 'sysex',
+    });
+  }
+
+  simulateIncomingMessage(message: MidiMessage): void {
+    if (this.inputPort && this.inputPort.onMessage) {
+      this.inputPort.onMessage(message);
+    }
+  }
+
+  async closePort(port: { close: () => Promise<void> }): Promise<void> {
+    await port.close();
+  }
+
+  async cleanup(): Promise<void> {
+    if (this.inputPort) {
+      await this.inputPort.close();
+    }
+    if (this.outputPort) {
+      await this.outputPort.close();
+    }
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/core/Midimunge.test.ts b/modules/audio-control/modules/launch-control-xl3/test/core/Midimunge.test.ts
deleted file mode 100644
index 3179066..0000000
--- a/modules/audio-control/modules/launch-control-xl3/test/core/Midimunge.test.ts
+++ /dev/null
@@ -1,340 +0,0 @@
-import { describe, it, expect } from 'vitest';
-import { Midimunge, MidimungeBitField } from '@/core/Midimunge';
-
-describe('Midimunge', () => {
-  describe('encode', () => {
-    it('should encode single chunk of 7 bytes', () => {
-      const input = [0x81, 0x02, 0x83, 0x04, 0x85, 0x06, 0x87];
-      const expected = [
-        0x55, // Header: 0b01010101 (bits 0,2,4,6 set for bytes with MSB)
-        0x01, // 0x81 & 0x7F
-        0x02, // 0x02 & 0x7F
-        0x03, // 0x83 & 0x7F
-        0x04, // 0x04 & 0x7F
-        0x05, // 0x85 & 0x7F
-        0x06, // 0x06 & 0x7F
-        0x07, // 0x87 & 0x7F
-      ];
-
-      const result = Midimunge.encode(input);
-      expect(result).toEqual(expected);
-    });
-
-    it('should encode partial chunk', () => {
-      const input = [0x81, 0x02, 0x83];
-      const expected = [
-        0x05, // Header: 0b00000101 (bits 0,2 set)
-        0x01, // 0x81 & 0x7F
-        0x02, // 0x02 & 0x7F
-        0x03, // 0x83 & 0x7F
-      ];
-
-      const result = Midimunge.encode(input);
-      expect(result).toEqual(expected);
-    });
-
-    it('should encode multiple chunks', () => {
-      const input = [
-        0x81, 0x02, 0x83, 0x04, 0x85, 0x06, 0x87, // First chunk
-        0x88, 0x09, // Second chunk (partial)
-      ];
-
-      const result = Midimunge.encode(input);
-
-      // First chunk: header + 7 bytes
-      expect(result.slice(0, 8)).toEqual([
-        0x55, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
-      ]);
-
-      // Second chunk: header + 2 bytes
-      expect(result.slice(8)).toEqual([
-        0x01, // Header: bit 0 set for 0x88
-        0x08, // 0x88 & 0x7F
-        0x09, // 0x09 & 0x7F
-      ]);
-    });
-
-    it('should encode all 7-bit values unchanged', () => {
-      const input = [0x00, 0x7F, 0x40, 0x20, 0x10, 0x08, 0x04];
-      const expected = [
-        0x00, // No MSBs set
-        0x00, 0x7F, 0x40, 0x20, 0x10, 0x08, 0x04
-      ];
-
-      const result = Midimunge.encode(input);
-      expect(result).toEqual(expected);
-    });
-
-    it('should handle empty input', () => {
-      const result = Midimunge.encode([]);
-      expect(result).toEqual([]);
-    });
-
-    it('should throw error for invalid values', () => {
-      expect(() => Midimunge.encode([256])).toThrow('Invalid data value');
-      expect(() => Midimunge.encode([-1])).toThrow('Invalid data value');
-      expect(() => Midimunge.encode([0, 300, 0])).toThrow('Invalid data value');
-    });
-  });
-
-  describe('decode', () => {
-    it('should decode single chunk', () => {
-      const input = [
-        0x55, // Header
-        0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07
-      ];
-      const expected = [0x81, 0x02, 0x83, 0x04, 0x85, 0x06, 0x87];
-
-      const result = Midimunge.decode(input);
-      expect(result).toEqual(expected);
-    });
-
-    it('should decode partial chunk', () => {
-      const input = [0x05, 0x01, 0x02, 0x03];
-      const expected = [0x81, 0x02, 0x83];
-
-      const result = Midimunge.decode(input);
-      expect(result).toEqual(expected);
-    });
-
-    it('should decode multiple chunks', () => {
-      const input = [
-        0x55, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, // First chunk
-        0x01, 0x08, 0x09, // Second chunk
-      ];
-      const expected = [
-        0x81, 0x02, 0x83, 0x04, 0x85, 0x06, 0x87,
-        0x88, 0x09
-      ];
-
-      const result = Midimunge.decode(input);
-      expect(result).toEqual(expected);
-    });
-
-    it('should handle empty input', () => {
-      const result = Midimunge.decode([]);
-      expect(result).toEqual([]);
-    });
-
-    it('should throw error for invalid 7-bit values', () => {
-      expect(() => Midimunge.decode([128])).toThrow('Invalid 7-bit value');
-      expect(() => Midimunge.decode([0, 200, 0])).toThrow('Invalid 7-bit value');
-      expect(() => Midimunge.decode([-1])).toThrow('Invalid 7-bit value');
-    });
-
-    it('should decode header-only chunk as empty', () => {
-      const input = [0x00]; // Just a header with no data bytes
-      const result = Midimunge.decode(input);
-      expect(result).toEqual([]);
-    });
-  });
-
-  describe('round-trip encoding/decoding', () => {
-    it('should preserve data through encode/decode cycle', () => {
-      const testCases = [
-        [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06],
-        [0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86],
-        [0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9],
-        Array.from({ length: 100 }, (_, i) => i),
-        Array.from({ length: 256 }, (_, i) => i % 256),
-      ];
-
-      for (const original of testCases) {
-        const encoded = Midimunge.encode(original);
-        const decoded = Midimunge.decode(encoded);
-        expect(decoded).toEqual(original);
-      }
-    });
-  });
-
-  describe('getEncodedSize', () => {
-    it('should calculate correct encoded size', () => {
-      expect(Midimunge.getEncodedSize(0)).toBe(0);
-      expect(Midimunge.getEncodedSize(1)).toBe(2); // 1 header + 1 data
-      expect(Midimunge.getEncodedSize(7)).toBe(8); // 1 header + 7 data
-      expect(Midimunge.getEncodedSize(8)).toBe(10); // (1+7) + (1+1)
-      expect(Midimunge.getEncodedSize(14)).toBe(16); // 2 full chunks
-      expect(Midimunge.getEncodedSize(15)).toBe(18); // 2 full + partial
-    });
-  });
-
-  describe('getMaxDecodedSize', () => {
-    it('should calculate correct max decoded size', () => {
-      expect(Midimunge.getMaxDecodedSize(0)).toBe(0);
-      expect(Midimunge.getMaxDecodedSize(2)).toBe(1); // 1 header + 1 data
-      expect(Midimunge.getMaxDecodedSize(8)).toBe(7); // Full chunk
-      expect(Midimunge.getMaxDecodedSize(16)).toBe(14); // 2 full chunks
-      expect(Midimunge.getMaxDecodedSize(10)).toBe(8); // 1 full + partial
-    });
-  });
-
-  describe('encodeString / decodeString', () => {
-    it('should encode and decode ASCII strings', () => {
-      const testStrings = [
-        'Hello, World!',
-        'Launch Control XL',
-        '1234567890',
-        'MIDI SysEx Test',
-        '', // Empty string
-      ];
-
-      for (const original of testStrings) {
-        const encoded = Midimunge.encodeString(original);
-        const decoded = Midimunge.decodeString(encoded);
-        expect(decoded).toBe(original);
-      }
-    });
-
-    it('should throw error for non-ASCII characters', () => {
-      expect(() => Midimunge.encodeString('üéπ')).toThrow('not ASCII');
-      expect(() => Midimunge.encodeString('‚Ç¨')).toThrow('not ASCII');
-    });
-  });
-
-  describe('isValidEncoding', () => {
-    it('should validate correct encodings', () => {
-      const validEncodings = [
-        [],
-        [0x00],
-        [0x00, 0x01, 0x02],
-        [0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F],
-        Midimunge.encode([0x80, 0x81, 0x82]),
-      ];
-
-      for (const data of validEncodings) {
-        expect(Midimunge.isValidEncoding(data)).toBe(true);
-      }
-    });
-
-    it('should reject invalid encodings', () => {
-      const invalidEncodings = [
-        [128], // 8-bit value
-        [0, 255, 0], // Contains 8-bit value
-        [-1], // Negative value
-      ];
-
-      for (const data of invalidEncodings) {
-        expect(Midimunge.isValidEncoding(data)).toBe(false);
-      }
-    });
-  });
-
-  describe('toHexString', () => {
-    it('should format encoded data as hex string', () => {
-      const data = [0x55, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x01, 0x08];
-      const result = Midimunge.toHexString(data);
-      expect(result).toBe('55 01 02 03 04 05 06 07 | 01 08');
-    });
-
-    it('should handle empty data', () => {
-      expect(Midimunge.toHexString([])).toBe('');
-    });
-  });
-});
-
-describe('MidimungeBitField', () => {
-  describe('bit operations', () => {
-    it('should set and get individual bits', () => {
-      const field = new MidimungeBitField(16);
-
-      field.setBit(0, true);
-      field.setBit(7, true);
-      field.setBit(8, true);
-      field.setBit(15, true);
-
-      expect(field.getBit(0)).toBe(true);
-      expect(field.getBit(1)).toBe(false);
-      expect(field.getBit(7)).toBe(true);
-      expect(field.getBit(8)).toBe(true);
-      expect(field.getBit(15)).toBe(true);
-    });
-
-    it('should clear bits', () => {
-      const field = new MidimungeBitField(8);
-      field.setBit(3, true);
-      expect(field.getBit(3)).toBe(true);
-
-      field.setBit(3, false);
-      expect(field.getBit(3)).toBe(false);
-    });
-
-    it('should throw error for out-of-range access', () => {
-      const field = new MidimungeBitField(8);
-      expect(() => field.setBit(8, true)).toThrow('out of range');
-      expect(() => field.getBit(8)).toThrow('out of range');
-    });
-  });
-
-  describe('multi-bit operations', () => {
-    it('should set and get bit ranges', () => {
-      const field = new MidimungeBitField(16);
-
-      // Set 4 bits starting at index 2 to value 0b1010 (10)
-      field.setBits(2, 4, 0b1010);
-
-      expect(field.getBit(2)).toBe(false); // bit 0 of 0b1010
-      expect(field.getBit(3)).toBe(true);  // bit 1 of 0b1010
-      expect(field.getBit(4)).toBe(false); // bit 2 of 0b1010
-      expect(field.getBit(5)).toBe(true);  // bit 3 of 0b1010
-
-      expect(field.getBits(2, 4)).toBe(0b1010);
-    });
-
-    it('should handle byte-aligned values', () => {
-      const field = new MidimungeBitField(16);
-
-      field.setBits(0, 8, 0xFF);
-      expect(field.getBits(0, 8)).toBe(0xFF);
-
-      field.setBits(8, 8, 0xAA);
-      expect(field.getBits(8, 8)).toBe(0xAA);
-
-      const bytes = field.toBytes();
-      expect(bytes).toEqual([0xFF, 0xAA]);
-    });
-  });
-
-  describe('byte conversion', () => {
-    it('should convert to and from bytes', () => {
-      const original = [0x55, 0xAA, 0xFF, 0x00];
-      const field = MidimungeBitField.fromBytes(original);
-      const result = field.toBytes();
-
-      expect(result).toEqual(original);
-    });
-
-    it('should create correct size from bit count', () => {
-      const field1 = new MidimungeBitField(1);
-      expect(field1.toBytes()).toEqual([0]);
-
-      const field8 = new MidimungeBitField(8);
-      expect(field8.toBytes()).toEqual([0]);
-
-      const field9 = new MidimungeBitField(9);
-      expect(field9.toBytes()).toEqual([0, 0]);
-    });
-  });
-
-  describe('Midimunge encoding/decoding', () => {
-    it('should encode and decode bit field', () => {
-      const field = new MidimungeBitField(16);
-      field.setBits(0, 8, 0x81);
-      field.setBits(8, 8, 0xFE);
-
-      const encoded = field.encode();
-      const decoded = MidimungeBitField.decode(encoded);
-
-      expect(decoded.toBytes()).toEqual(field.toBytes());
-      expect(decoded.getBits(0, 8)).toBe(0x81);
-      expect(decoded.getBits(8, 8)).toBe(0xFE);
-    });
-
-    it('should handle empty bit field', () => {
-      const field = new MidimungeBitField(0);
-      const encoded = field.encode();
-      const decoded = MidimungeBitField.decode(encoded);
-
-      expect(decoded.toBytes()).toEqual([]);
-    });
-  });
-});
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

test(launch-control-xl3): add handshake tests, workplan doc, remove Midimunge tests

