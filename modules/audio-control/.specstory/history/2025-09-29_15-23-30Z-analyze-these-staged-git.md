<!-- Generated by SpecStory -->

# Web MIDI Automation for Launch Control XL 3 (2025-09-29 15:23:30Z)

<!-- Claude Code Session 92ca5141-7da0-4799-b4de-a23c23d4a4c8 (2025-09-29_15-23-30Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/CORRECTED-PROTOCOL.md b/modules/audio-control/modules/launch-control-xl3/docs/CORRECTED-PROTOCOL.md
new file mode 100644
index 0000000..2595675
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/docs/CORRECTED-PROTOCOL.md
@@ -0,0 +1,83 @@
+# Launch Control XL3 CORRECTED SysEx Protocol
+
+## Critical Correction
+
+The web editor DOES send full SysEx data messages! The confusion arose from monitoring the wrong MIDI port.
+
+## Correct Protocol
+
+### Write Operation (0x45)
+**TO Device (LCXL3 1 MIDI In):**
+```
+F0 00 20 29 02 15 05 00 45 [slot] [full custom mode data] F7
+```
+- Byte 8: 0x45 - Write command with data
+- Byte 9: Slot number (0x00-0x0E)
+- Bytes 10+: Complete custom mode data (300+ bytes)
+
+**FROM Device (LCXL3 1 MIDI Out):**
+```
+F0 00 20 29 02 15 05 00 15 [slot] 07 F7
+```
+- Byte 8: 0x15 - Write acknowledgment
+- Byte 9: Slot number
+- Byte 10: 0x07 - Success status (was seeing 0x06 in some cases)
+
+### Read Operation (0x40)
+**TO Device:**
+```
+F0 00 20 29 02 15 05 00 40 [slot] 00 F7
+```
+
+**FROM Device:**
+```
+F0 00 20 29 02 15 05 00 10 [slot] [data] F7
+```
+
+## Key Findings
+
+1. **Our SysExParser was using the correct 0x45 byte!**
+2. **The issue was monitoring the wrong port** - we were only watching output FROM device
+3. **The 12-byte messages are acknowledgments, not commands**
+4. **Both read and write use different command/response bytes:**
+   - Write: 0x45 (command) → 0x15 (ack)
+   - Read: 0x40 (command) → 0x10 (response)
+
+## Data Structure Differences
+
+Looking at the actual captured data, there are subtle differences from our implementation:
+
+### Web Editor Format
+```
+49 10 02 05 00 01 40 00 0D 7F 00  (control definition)
+^^                ^^
+0x49 not 0x48     0x40 not 0x48
+```
+
+### Our Format
+```
+48 10 02 05 00 01 48 00 0D 7F     (no trailing 0x00)
+^^                ^^
+0x48              0x48
+```
+
+## The Real Problem
+
+The issue isn't the 0x45 byte - it's the data structure! The web editor uses:
+- 0x49 markers for controls (not 0x48)
+- 0x40/0x50 for certain fields
+- Extra 0x00 padding bytes
+- Different structure for the data payload
+
+## Next Steps
+
+1. Update SysExParser to use correct data format:
+   - Use 0x49 for control markers during write
+   - Add proper padding bytes
+   - Fix the internal data structure
+
+2. Monitor the correct MIDI port (MIDI In for messages TO device)
+
+3. Test with corrected data format
+
+This explains why our writes weren't working - we had the right protocol (0x45) but wrong data format!
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/REVERSE-ENGINEERED-PROTOCOL.md b/modules/audio-control/modules/launch-control-xl3/docs/REVERSE-ENGINEERED-PROTOCOL.md
new file mode 100644
index 0000000..8e92a2e
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/docs/REVERSE-ENGINEERED-PROTOCOL.md
@@ -0,0 +1,149 @@
+# Launch Control XL3 Reverse-Engineered SysEx Protocol
+
+## Executive Summary
+
+Through extensive reverse engineering using Web MIDI monitoring, browser automation, and protocol analysis, we have discovered critical discrepancies between the official documentation and actual device behavior. Most importantly, **the web editor appears to be pre-staging data on the device through an undocumented mechanism** before sending simple activation commands.
+
+## Key Discoveries
+
+### 1. The 12-Byte Mystery Command
+
+The web editor sends only a 12-byte SysEx message when writing custom modes:
+```
+0xF0 0x00 0x20 0x29 0x02 0x15 0x05 0x00 0x15 [slot] 0x06 0xF7
+```
+
+This command does NOT contain any custom mode data, yet after sending it:
+- The device successfully stores the custom mode
+- Reading the slot returns the complete custom mode data including our test names
+
+### 2. Evidence of Hidden Data Transfer
+
+**Proof that data IS written:**
+- Created control with name "SPY_TEST_1" in web editor
+- Sent only the 12-byte command
+- Read slot 0 back and found: `0x6a 0x10 0x53 0x50 0x59 0x5f 0x54 0x45 0x53 0x54 0x5f 0x31` (label for "SPY_TEST_1")
+
+**The paradox:**
+- No MIDI messages containing this data were captured
+- The 12-byte command contains no payload
+- Yet the data appears on the device
+
+### 3. Protocol Byte Positions
+
+#### Read Response Format (0x10)
+```
+Byte 0-7:  0xF0 0x00 0x20 0x29 0x02 0x15 0x05 0x00
+Byte 8:    0x10 - Read response indicator
+Byte 9:    [slot] - Slot number
+Byte 10+:  Custom mode data
+```
+
+#### Write Command Format (0x15)
+```
+Byte 0-7:  0xF0 0x00 0x20 0x29 0x02 0x15 0x05 0x00
+Byte 8:    0x15 - Write/activate command
+Byte 9:    [slot] - Slot number
+Byte 10:   0x06 - Unknown marker (always 0x06)
+Byte 11:   0xF7 - SysEx end
+```
+
+### 4. Our Incorrect Implementation (0x45)
+
+Our SysExParser incorrectly used 0x45 at byte 8 for writes, sending full data payloads. This doesn't work because:
+- The device expects 0x15 for write commands
+- The 0x15 command is only 12 bytes and contains no data
+- Full data must be pre-staged through another mechanism
+
+## Hypotheses for Hidden Data Transfer
+
+### Theory 1: Browser-Side State Management
+The web editor may be:
+1. Building the complete mode in browser memory
+2. Using undocumented MIDI commands to incrementally update device RAM
+3. Sending the 12-byte 0x15 command to commit/activate the changes
+
+### Theory 2: Multiple Virtual MIDI Ports
+The device presents multiple MIDI ports:
+- "LCXL3 1 MIDI In/Out" - Standard MIDI
+- "LCXL3 1 DAW In/Out" - DAW integration
+- Possibly hidden ports for configuration
+
+### Theory 3: Non-MIDI Data Channel
+The web editor could be using:
+- WebUSB API for direct USB communication
+- Hidden WebSocket/HTTP endpoints
+- Browser storage that the device firmware reads
+
+## Test Results
+
+### Successful Operations
+- ✅ Reading custom modes (0x40 command → 0x10 response)
+- ✅ Detecting device presence and handshake
+- ✅ Capturing web editor's 12-byte commands
+- ✅ Confirming data IS written to device
+
+### Failed Operations
+- ❌ Writing with 0x45 + full payload (our incorrect assumption)
+- ❌ Writing with 0x10 + full payload (mimicking read response format)
+- ❌ Writing with just 0x15 12-byte command (no data to write)
+- ❌ Capturing the actual data transfer messages
+
+## Implementation Recommendations
+
+### Immediate Fix Options
+
+1. **Continue Investigation**
+   - Monitor ALL MIDI ports simultaneously
+   - Use USB protocol analyzer
+   - Decompile web editor JavaScript
+
+2. **Workaround Using Factory Modes**
+   - Use only the 8 factory template modes
+   - These work with simple 12-byte activation commands
+   - Limited but functional
+
+3. **Hybrid Approach**
+   - Use our current read implementation (working)
+   - Document write as "unsupported pending further research"
+   - Focus on LED control and other working features
+
+## Technical Details
+
+### Custom Mode Data Structure
+```
+Mode Name: Null-terminated string with 0x2a prefix
+Controls:  0x48 [id] [params...] repeated for each control
+Labels:    0x6a/0x6b [id] [ASCII text] for named controls
+Colors:    0x60 [id] [color] for LED colors
+Footer:    0x06 0x00 0x04 0x40 0xF7
+```
+
+### Observed Message Flow
+```
+1. Web Editor → Device: [UNKNOWN DATA TRANSFER METHOD]
+2. Web Editor → Device: 0xF0...0x15 [slot] 0x06 0xF7 (12 bytes)
+3. Device → Host: (No immediate response)
+4. Host → Device: 0xF0...0x40 [slot] 0x00 0xF7 (read request)
+5. Device → Host: 0xF0...0x10 [slot] [FULL DATA] 0xF7
+```
+
+## Conclusion
+
+The Launch Control XL3 uses an undocumented two-phase write protocol where:
+1. Custom mode data is pre-staged on the device through an unknown mechanism
+2. A simple 12-byte command activates/commits the staged data
+
+Without discovering the data staging mechanism, full write support cannot be implemented. The device IS receiving and storing the data, but not through the documented SysEx protocol.
+
+## Next Steps
+
+1. **Deep JavaScript Analysis**: Reverse engineer the minified web editor code
+2. **USB Protocol Analysis**: Use Wireshark with USBPcap to capture raw USB traffic
+3. **Firmware Analysis**: Extract and analyze device firmware for hidden commands
+4. **Contact Novation**: Request official protocol documentation
+
+---
+
+*Document generated from reverse engineering sessions conducted 2024*
+*Test hardware: Launch Control XL3 with firmware v1.0.10.84*
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
index 365df88..7ed465c 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
@@ -367,6 +367,10 @@ export class SysExParser {
           if (ccNumber !== undefined && controlIndex < expectedControls.length) {
             const controlId = expectedControls[controlIndex];
 
+            if (controlId === undefined) {
+              continue;
+            }
+
             controls.push({
               controlId,
               channel: 0, // Default channel
@@ -836,9 +840,9 @@ export class SysExParser {
     // Encode the custom mode data
     const encodedData = this.encodeCustomModeData(modeData);
 
-    // CORRECTED PROTOCOL: Based on actual device communication analysis
-    // Format: F0 00 20 29 02 15 05 00 10 [SLOT] [encoded data] F7
-    // Note: 0x10 indicates data transfer (matches read response format)
+    // VERIFIED PROTOCOL: Based on actual web editor traffic capture
+    // Format: F0 00 20 29 02 15 05 00 45 [SLOT] [encoded data] F7
+    // The web editor DOES use 0x45 for write operations with full data payload
     return [
       0xF0,             // SysEx start
       0x00, 0x20, 0x29, // Manufacturer ID (Novation)
@@ -846,7 +850,7 @@ export class SysExParser {
       0x15,             // Command (Custom mode)
       0x05,             // Sub-command
       0x00,             // Reserved
-      0x10,             // Data transfer operation (was incorrectly 0x45)
+      0x45,             // Write operation with data (confirmed from web editor)
       slot,             // Slot number (0-14 for slots 1-15)
       ...encodedData,   // Encoded custom mode data
       0xF7              // SysEx end
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/capture-web-editor-write.ts b/modules/audio-control/modules/launch-control-xl3/utils/capture-web-editor-write.ts
new file mode 100644
index 0000000..45a99e1
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/capture-web-editor-write.ts
@@ -0,0 +1,122 @@
+#!/usr/bin/env tsx
+/**
+ * Use Playwright to perform a write operation in the web editor
+ * while capturing all MIDI traffic
+ */
+
+import { chromium } from 'playwright';
+
+async function captureWebEditorWrite() {
+  console.log('Web Editor Write Capture');
+  console.log('========================\n');
+  console.log('This will automate the web editor to write a custom mode');
+  console.log('Run midi-monitor.ts in another terminal to capture traffic\n');
+
+  const browser = await chromium.launch({
+    headless: false,
+    args: ['--enable-features=WebMIDI']
+  });
+
+  const context = await browser.newContext({
+    permissions: ['midi', 'midi-sysex']
+  });
+
+  const page = await context.newPage();
+
+  try {
+    console.log('→ Navigating to Novation web editor...');
+    await page.goto('https://components.novationmusic.com/launch-control-xl-3/custom-modes');
+
+    // Wait for page to load
+    await page.waitForLoadState('networkidle');
+    console.log('✓ Page loaded\n');
+
+    // Look for and handle any permission prompts
+    page.on('dialog', async dialog => {
+      console.log(`Dialog: ${dialog.message()}`);
+      await dialog.accept();
+    });
+
+    // Check if we need to grant MIDI permissions
+    console.log('→ Checking for MIDI permission button...');
+    const connectButton = await page.locator('button:has-text("Connect")').first();
+    if (await connectButton.isVisible()) {
+      console.log('→ Clicking Connect button...');
+      await connectButton.click();
+      await page.waitForTimeout(2000);
+    }
+
+    // Wait for device connection
+    console.log('→ Waiting for device to be detected...');
+    await page.waitForTimeout(3000);
+
+    // Click on Custom Mode 1 (slot 0)
+    console.log('\n→ Selecting Custom Mode 1...');
+    const customMode1 = await page.locator('text=Custom Mode 1').first();
+    if (await customMode1.isVisible()) {
+      await customMode1.click();
+      await page.waitForTimeout(1000);
+    }
+
+    // Find the first encoder control
+    console.log('→ Locating first encoder control...');
+    const firstEncoder = await page.locator('[data-control-type="encoder"]').first();
+    if (await firstEncoder.isVisible()) {
+      await firstEncoder.click();
+      await page.waitForTimeout(500);
+    }
+
+    // Look for name input field
+    console.log('→ Setting control name...');
+    const nameInput = await page.locator('input[placeholder*="name" i]').first();
+    if (await nameInput.isVisible()) {
+      await nameInput.fill('');
+      await nameInput.type('REV_ENG_1');
+      await page.waitForTimeout(500);
+    }
+
+    console.log('\n🔴 CRITICAL MONITORING POINT - WATCH MIDI MONITOR NOW! 🔴');
+    console.log('→ Clicking "Send to Device" button...\n');
+
+    // Find and click the send button
+    const sendButton = await page.locator('button:has-text("Send")').first();
+    if (await sendButton.isVisible()) {
+      console.log('✓ Found Send button, clicking...');
+      await sendButton.click();
+
+      console.log('⏳ Waiting 5 seconds to capture all traffic...');
+      await page.waitForTimeout(5000);
+
+      console.log('✓ Write operation completed\n');
+    } else {
+      console.log('✗ Send button not found');
+    }
+
+    // Now try to read it back
+    console.log('→ Attempting to trigger a read...');
+    const refreshButton = await page.locator('button:has-text("Refresh")').first();
+    if (await refreshButton.isVisible()) {
+      await refreshButton.click();
+      await page.waitForTimeout(2000);
+    }
+
+    console.log('\n✓ Capture complete!');
+    console.log('\nCheck the MIDI monitor for:');
+    console.log('1. Any messages BEFORE the Send button click');
+    console.log('2. Messages sent WHEN Send was clicked');
+    console.log('3. Any follow-up messages');
+
+    // Keep browser open for manual inspection
+    console.log('\nBrowser will stay open for 30 seconds for inspection...');
+    await page.waitForTimeout(30000);
+
+  } catch (error) {
+    console.error('Error:', error);
+  } finally {
+    await browser.close();
+    console.log('\n✓ Browser closed');
+  }
+}
+
+// Run the capture
+captureWebEditorWrite().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-web-editor-protocol.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-web-editor-protocol.ts
new file mode 100644
index 0000000..7dfc35a
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-web-editor-protocol.ts
@@ -0,0 +1,121 @@
+#!/usr/bin/env tsx
+/**
+ * Test the exact protocol captured from the web editor
+ */
+
+import { LaunchControlXL3 } from '../src/index.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+
+async function testWebEditorProtocol() {
+  console.log('Testing Web Editor Protocol');
+  console.log('============================\n');
+
+  let device: LaunchControlXL3 | null = null;
+
+  try {
+    // Initialize backend
+    const backend = new EasyMidiBackend();
+    await backend.initialize();
+
+    // Create device
+    device = new LaunchControlXL3({
+      midiBackend: backend,
+      enableLedControl: false,
+      enableCustomModes: false
+    });
+
+    console.log('→ Connecting to device...');
+    await device.connect();
+    console.log('✓ Connected\n');
+
+    console.log('Key Discovery from Web Editor Analysis:');
+    console.log('========================================');
+    console.log('The web editor sends ONLY a 12-byte command:');
+    console.log('0xf0 0x00 0x20 0x29 0x02 0x15 0x05 0x00 0x15 [slot] 0x06 0xf7\n');
+
+    console.log('This suggests the web editor either:');
+    console.log('1. Pre-loads data via a different channel (HTTP/WebSocket)');
+    console.log('2. Uses a two-phase protocol we haven\'t captured yet');
+    console.log('3. Relies on browser-side state management\n');
+
+    // Test sending the exact web editor command for different slots
+    const testSlots = [0, 1, 2, 3];
+
+    for (const slot of testSlots) {
+      console.log(`\n→ Sending web editor command for slot ${slot}...`);
+      const webEditorCommand = [
+        0xF0,             // SysEx start
+        0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+        0x02,             // Device ID
+        0x15,             // Command
+        0x05,             // Sub-command
+        0x00,             // Reserved
+        0x15,             // Web editor write operation
+        slot,             // Slot number
+        0x06,             // Unknown marker
+        0xF7              // SysEx end
+      ];
+
+      console.log(`Command: ${webEditorCommand.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
+
+      try {
+        await device.sendSysEx(webEditorCommand);
+        console.log('✓ Sent successfully');
+
+        // Wait a bit for any response
+        await new Promise(resolve => setTimeout(resolve, 500));
+
+      } catch (error) {
+        console.log(`✗ Send failed: ${error}`);
+      }
+    }
+
+    // Now try reading the slots to see if anything changed
+    console.log('\n\n→ Reading all slots to check state...');
+    for (const slot of testSlots) {
+      console.log(`\nSlot ${slot}:`);
+      try {
+        const mode = await device.readCustomMode(slot);
+        if (mode) {
+          console.log(`  Name: ${mode.name}`);
+          console.log(`  Controls: ${mode.controls?.length || 0}`);
+
+          // Check for our test name
+          const namedControls = mode.controls?.filter(c => c.name) || [];
+          if (namedControls.length > 0) {
+            console.log(`  Named controls: ${namedControls.length}`);
+            const spyTest = namedControls.find(c => c.name?.includes('SPY_TEST'));
+            if (spyTest) {
+              console.log(`  🎯 Found our test control: ${spyTest.name}`);
+            }
+          }
+        } else {
+          console.log('  Empty');
+        }
+      } catch (error) {
+        console.log(`  Read failed: ${error}`);
+      }
+    }
+
+    console.log('\n\nConclusion:');
+    console.log('===========');
+    console.log('The 12-byte command alone is NOT sufficient for writing data.');
+    console.log('The web editor must be using additional mechanisms we haven\'t captured yet.');
+    console.log('\nNext steps:');
+    console.log('1. Monitor ALL MIDI ports (including virtual ones)');
+    console.log('2. Check browser network traffic for HTTP/WebSocket data');
+    console.log('3. Analyze browser console for Web MIDI API calls');
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (device) {
+      console.log('\n→ Disconnecting...');
+      await device.disconnect();
+      console.log('✓ Disconnected');
+    }
+  }
+}
+
+// Run the test
+testWebEditorProtocol().catch(console.error);
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

feat(launch-control-xl3): add web editor protocol analysis tools and documentation

