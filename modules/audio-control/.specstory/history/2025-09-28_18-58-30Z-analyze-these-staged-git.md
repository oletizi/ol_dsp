<!-- Generated by SpecStory -->

# Consolidating Tests in Launch Control XL3 Module (2025-09-28 18:58:30Z)

<!-- Claude Code Session cb56c6f6-1d03-43c8-968e-fa1944428792 (2025-09-28_18-58-30Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/test/e2e/custom-mode.test.ts b/modules/audio-control/modules/launch-control-xl3/test/e2e/custom-mode.test.ts
new file mode 100644
index 0000000..872978a
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/e2e/custom-mode.test.ts
@@ -0,0 +1,154 @@
+#!/usr/bin/env tsx
+
+/**
+ * Test complete custom mode functionality with the corrected SysEx implementation
+ */
+
+import { SysExParser } from '@/core/SysExParser';
+import { NodeMidiBackend } from '@/core/backends/NodeMidiBackend';
+import type { MidiInputPort, MidiOutputPort } from '@/core/MidiInterface';
+
+console.log('🎛️ Launch Control XL 3 - Complete Custom Mode Test\n');
+
+async function testCustomModeReadWrite() {
+  const backend = new NodeMidiBackend();
+  await backend.initialize();
+
+  // Find Launch Control XL 3 ports
+  const inputPorts = await backend.getInputPorts();
+  const outputPorts = await backend.getOutputPorts();
+
+  const lcxl3Input = inputPorts.find(p => p.name === 'LCXL3 1 MIDI Out');
+  const lcxl3Output = outputPorts.find(p => p.name === 'LCXL3 1 MIDI In');
+
+  if (!lcxl3Input || !lcxl3Output) {
+    console.log('❌ Launch Control XL 3 not found');
+    console.log('Available input ports:', inputPorts.map(p => p.name));
+    console.log('Available output ports:', outputPorts.map(p => p.name));
+    return;
+  }
+
+  console.log(`✅ Found LCXL3 ports:`)
+  console.log(`   Input: ${lcxl3Input.name}`)
+  console.log(`   Output: ${lcxl3Output.name}\n`)
+
+  // Open ports
+  let inputPort: MidiInputPort;
+  let outputPort: MidiOutputPort;
+
+  try {
+    inputPort = await backend.openInput(lcxl3Input.id);
+    outputPort = await backend.openOutput(lcxl3Output.id);
+    console.log('🔗 Ports opened successfully\n');
+  } catch (error: any) {
+    console.error('❌ Failed to open ports:', error.message);
+    return;
+  }
+
+  // Set up response handler
+  let responseReceived = false;
+  let responseData: any = null;
+
+  inputPort.onMessage = (message) => {
+    console.log(`📨 Received MIDI: ${message.data.length} bytes`);
+
+    if (message.data[0] === 0xF0) {
+      console.log(`🎯 SysEx message received!`);
+      console.log(`   Length: ${message.data.length} bytes`);
+      console.log(`   First 15 bytes: ${message.data.slice(0, 15).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
+
+      try {
+        const parsed = SysExParser.parse(Array.from(message.data));
+        console.log(`✅ Parsed SysEx message successfully:`);
+        console.log(`   Type: ${parsed.type}`);
+
+        if (parsed.type === 'custom_mode_response') {
+          const customMode = parsed as any;
+          console.log(`   📛 Mode Name: "${customMode.name || 'Unknown'}"`);
+          console.log(`   🎛️  Controls: ${customMode.controls?.length || 0}`);
+          console.log(`   🌈 Colors: ${customMode.colors?.length || 0}`);
+          console.log(`   📍 Slot: ${customMode.slot}`);
+
+          // Show first few controls
+          if (customMode.controls && customMode.controls.length > 0) {
+            console.log(`   🎚️  First few controls:`);
+            customMode.controls.slice(0, 5).forEach((ctrl: any, i: number) => {
+              console.log(`      ${i + 1}. ID=0x${ctrl.controlId.toString(16)} Ch=${ctrl.channel + 1} CC=${ctrl.ccNumber} Max=${ctrl.maxValue}`);
+            });
+            if (customMode.controls.length > 5) {
+              console.log(`      ... and ${customMode.controls.length - 5} more`);
+            }
+          }
+
+          responseData = customMode;
+        }
+
+        responseReceived = true;
+      } catch (error: any) {
+        console.error(`❌ Failed to parse SysEx:`, error.message);
+      }
+    }
+  };
+
+  console.log('📡 Testing custom mode read operation...\n');
+
+  // Test reading from slot 0
+  const slot = 0;
+  const readRequest = SysExParser.buildCustomModeReadRequest(slot);
+
+  console.log(`🔍 Reading custom mode from slot ${slot}:`);
+  console.log(`   Request: ${readRequest.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
+
+  try {
+    await backend.sendMessage(outputPort, {
+      timestamp: Date.now(),
+      data: readRequest
+    });
+
+    console.log('✅ Read request sent, waiting for response...');
+
+    // Wait for response
+    const timeout = 5000;
+    const startTime = Date.now();
+    while (!responseReceived && (Date.now() - startTime) < timeout) {
+      await new Promise(resolve => setTimeout(resolve, 100));
+    }
+
+    if (responseReceived && responseData) {
+      console.log(`\n🎉 SUCCESS! Custom mode read operation working!`);
+      console.log(`📋 Retrieved custom mode "${responseData.name}" with ${responseData.controls.length} controls\n`);
+
+      // Test if we can build write request (don't actually send it)
+      console.log('🔧 Testing write request generation...');
+      try {
+        const writeRequest = SysExParser.buildCustomModeWriteRequest(slot + 1, responseData);
+        console.log(`✅ Write request generated successfully: ${writeRequest.length} bytes`);
+        console.log(`   Format: ${writeRequest.slice(0, 12).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')} ... 0xF7`);
+      } catch (error: any) {
+        console.error(`❌ Failed to generate write request:`, error.message);
+      }
+
+    } else {
+      console.log(`\n❌ No response received within ${timeout}ms`);
+      console.log('This could indicate:');
+      console.log('- Device is not in a custom mode');
+      console.log('- SysEx filtering still active');
+      console.log('- Incorrect protocol format');
+    }
+
+  } catch (error: any) {
+    console.error('❌ Failed to send read request:', error.message);
+  }
+
+  // Cleanup
+  try {
+    await inputPort.close();
+    await outputPort.close();
+    await backend.cleanup();
+    console.log('\n✅ Cleanup completed');
+  } catch (error: any) {
+    console.error('❌ Cleanup failed:', error.message);
+  }
+}
+
+testCustomModeReadWrite().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-operations.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-operations.test.ts
new file mode 100644
index 0000000..232545f
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-operations.test.ts
@@ -0,0 +1,470 @@
+/**
+ * Integration tests for complete custom mode operations
+ * Tests reading, writing, and acknowledgment handling for Launch Control XL 3
+ */
+
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { SysExParser, type CustomModeMessage } from '@/core/SysExParser';
+import { MockMidiBackend } from '@/core/backends/MockMidiBackend';
+import type { MidiInputPort, MidiOutputPort } from '@/core/MidiInterface';
+
+describe('Custom Mode Operations Integration Tests', () => {
+  let mockBackend: MockMidiBackend;
+  let inputPort: MidiInputPort;
+  let outputPort: MidiOutputPort;
+
+  beforeEach(async () => {
+    mockBackend = new MockMidiBackend();
+    await mockBackend.initialize();
+
+    const inputPorts = await mockBackend.getInputPorts();
+    const outputPorts = await mockBackend.getOutputPorts();
+
+    inputPort = await mockBackend.openInput(inputPorts[0].id);
+    outputPort = await mockBackend.openOutput(outputPorts[0].id);
+  });
+
+  afterEach(async () => {
+    await mockBackend.cleanup();
+  });
+
+  describe('Reading Factory Custom Modes', () => {
+    it('should read multiple slots successfully', async () => {
+      const mockResponses = [
+        // Response for slot 0
+        [
+          0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00,
+          0x06, 0x20, 0x08,
+          0x53, 0x4C, 0x4F, 0x54, 0x30, 0x00, 0x00, 0x00, // "SLOT0"
+          0x21, 0x00,
+          0x48, 0x10, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F, // Top encoder 1
+          0xF7
+        ],
+        // Response for slot 1
+        [
+          0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x01,
+          0x06, 0x20, 0x08,
+          0x53, 0x4C, 0x4F, 0x54, 0x31, 0x00, 0x00, 0x00, // "SLOT1"
+          0x21, 0x00,
+          0x48, 0x11, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0E, 0x7F, // Top encoder 2
+          0xF7
+        ]
+      ];
+
+      const responses: any[] = [];
+      let responseCount = 0;
+
+      inputPort.onMessage = (message) => {
+        if (message.data[0] === 0xF0) {
+          const parsed = SysExParser.parse(Array.from(message.data));
+          responses.push(parsed);
+          responseCount++;
+        }
+      };
+
+      // Read from slot 0
+      const readRequest0 = SysExParser.buildCustomModeReadRequest(0);
+      await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: readRequest0 });
+
+      // Simulate response for slot 0
+      if (inputPort.onMessage) {
+        inputPort.onMessage({ timestamp: Date.now(), data: mockResponses[0] });
+      }
+
+      // Read from slot 1
+      const readRequest1 = SysExParser.buildCustomModeReadRequest(1);
+      await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: readRequest1 });
+
+      // Simulate response for slot 1
+      if (inputPort.onMessage) {
+        inputPort.onMessage({ timestamp: Date.now(), data: mockResponses[1] });
+      }
+
+      expect(responseCount).toBe(2);
+      expect(responses[0].name).toBe('SLOT0');
+      expect(responses[0].slot).toBe(0);
+      expect(responses[1].name).toBe('SLOT1');
+      expect(responses[1].slot).toBe(1);
+    });
+
+    it('should handle corrupted response data gracefully', async () => {
+      const corruptedResponse = [
+        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00,
+        0x06, 0x20, 0x08,
+        0xFF, 0xFF, 0xFF, 0xFF, // Corrupted data
+        0x21, 0x00,
+        0x48, 0x10, 0xFF, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F, // Invalid control
+        0xF7
+      ];
+
+      let parseError: Error | null = null;
+      let parsedResponse: any = null;
+
+      inputPort.onMessage = (message) => {
+        if (message.data[0] === 0xF0) {
+          try {
+            parsedResponse = SysExParser.parse(Array.from(message.data));
+          } catch (error) {
+            parseError = error as Error;
+          }
+        }
+      };
+
+      // Send read request
+      const readRequest = SysExParser.buildCustomModeReadRequest(0);
+      await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: readRequest });
+
+      // Simulate corrupted response
+      if (inputPort.onMessage) {
+        inputPort.onMessage({ timestamp: Date.now(), data: corruptedResponse });
+      }
+
+      // Should parse without throwing but with graceful handling
+      expect(parseError).toBeNull();
+      expect(parsedResponse).toBeDefined();
+      expect(parsedResponse.type).toBe('custom_mode_response');
+      // Controls with invalid structure should be filtered out
+      expect(parsedResponse.controls.length).toBe(0);
+    });
+  });
+
+  describe('Writing Simple Custom Mode', () => {
+    it('should create and send a simple custom mode successfully', async () => {
+      const simpleMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'SIMPLE',
+        controls: [
+          {
+            controlId: 0x00, // Fader 1
+            channel: 0,
+            ccNumber: 20,
+            minValue: 0,
+            maxValue: 127,
+            behaviour: 'absolute' as const
+          }
+        ],
+        colors: [
+          {
+            controlId: 0x00,
+            color: 0x3F,
+            behaviour: 'static' as const
+          }
+        ],
+        data: []
+      };
+
+      let acknowledgmentReceived = false;
+
+      inputPort.onMessage = (message) => {
+        // Check for acknowledgment: F0 00 20 29 02 15 05 00 15 [SLOT] 06 F7
+        if (message.data.length === 12 &&
+            message.data[0] === 0xF0 &&
+            message.data[8] === 0x15 && // Write ACK operation
+            message.data[10] === 0x06) { // Success code
+          acknowledgmentReceived = true;
+        }
+      };
+
+      // Build and send write request
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, simpleMode);
+      await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: writeRequest });
+
+      // Verify write request structure
+      expect(writeRequest[0]).toBe(0xF0); // SysEx start
+      expect(writeRequest.slice(1, 4)).toEqual([0x00, 0x20, 0x29]); // Manufacturer ID
+      expect(writeRequest[8]).toBe(0x45); // Write operation
+      expect(writeRequest[9]).toBe(0); // Slot 0
+      expect(writeRequest[writeRequest.length - 1]).toBe(0xF7); // SysEx end
+
+      // Simulate device acknowledgment
+      const mockAck = [0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x15, 0x00, 0x06, 0xF7];
+      if (inputPort.onMessage) {
+        inputPort.onMessage({ timestamp: Date.now(), data: mockAck });
+      }
+
+      expect(acknowledgmentReceived).toBe(true);
+      expect(mockBackend.sentMessages).toHaveLength(1);
+    });
+
+    it('should validate custom mode data before sending', () => {
+      const invalidMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'INVALID',
+        controls: [
+          {
+            controlId: 0x00,
+            channel: 16, // Invalid channel (should be 0-15)
+            ccNumber: 128, // Invalid CC (should be 0-127)
+            minValue: 0,
+            maxValue: 127,
+            behaviour: 'absolute' as const
+          }
+        ],
+        colors: [],
+        data: []
+      };
+
+      expect(() => {
+        SysExParser.buildCustomModeWriteRequest(0, invalidMode);
+      }).toThrow();
+    });
+
+    it('should handle missing required sections', () => {
+      const incompleteMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'INCOMPLETE',
+        controls: [], // Empty controls
+        colors: [], // Empty colors
+        data: []
+      };
+
+      expect(() => {
+        SysExParser.buildCustomModeWriteRequest(0, incompleteMode);
+      }).toThrow('Custom mode must have controls array');
+    });
+  });
+
+  describe('Writing Complex Multi-Control Mode', () => {
+    it('should create and send a complex custom mode with all control types', async () => {
+      const complexMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 1,
+        name: 'COMPLEX',
+        controls: [
+          // Faders
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          { controlId: 0x01, channel: 0, ccNumber: 11, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          // Top encoders
+          { controlId: 0x10, channel: 0, ccNumber: 20, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          { controlId: 0x11, channel: 0, ccNumber: 21, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          // Middle encoders
+          { controlId: 0x18, channel: 0, ccNumber: 30, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          { controlId: 0x19, channel: 0, ccNumber: 31, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          // Bottom encoders
+          { controlId: 0x20, channel: 0, ccNumber: 40, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          { controlId: 0x21, channel: 0, ccNumber: 41, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x0F, behaviour: 'static' as const }, // Red faders
+          { controlId: 0x01, color: 0x0F, behaviour: 'static' as const },
+          { controlId: 0x10, color: 0x60, behaviour: 'static' as const }, // Blue top encoders
+          { controlId: 0x11, color: 0x60, behaviour: 'static' as const },
+          { controlId: 0x18, color: 0x48, behaviour: 'static' as const }, // Yellow middle encoders
+          { controlId: 0x19, color: 0x48, behaviour: 'static' as const },
+          { controlId: 0x20, color: 0x3C, behaviour: 'static' as const }, // Green bottom encoders
+          { controlId: 0x21, color: 0x3C, behaviour: 'static' as const },
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(1, complexMode);
+      await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: writeRequest });
+
+      // Verify the message structure
+      expect(writeRequest[0]).toBe(0xF0); // SysEx start
+      expect(writeRequest[9]).toBe(1); // Slot 1
+      expect(writeRequest[writeRequest.length - 1]).toBe(0xF7); // SysEx end
+
+      // Message should be significantly larger due to all the controls and labels
+      expect(writeRequest.length).toBeGreaterThan(200);
+
+      // Verify we have the expected data header
+      const dataStart = 10; // After header
+      expect(writeRequest.slice(dataStart, dataStart + 3)).toEqual([0x00, 0x20, 0x08]);
+
+      // Verify mode name "COMPLEX" is present
+      const nameBytes = writeRequest.slice(dataStart + 3, dataStart + 3 + 7);
+      const nameString = String.fromCharCode(...nameBytes);
+      expect(nameString).toBe('COMPLEX');
+    });
+
+    it('should maintain correct control ID offset (+0x28) for all control types', async () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'OFFSET',
+        controls: [
+          { controlId: 0x10, channel: 0, ccNumber: 13, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }, // Should become 0x38
+        ],
+        colors: [
+          { controlId: 0x10, color: 0x60, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Find the control definition in the message
+      let controlFoundAt = -1;
+      for (let i = 0; i < writeRequest.length - 10; i++) {
+        if (writeRequest[i] === 0x49) { // Write control marker
+          controlFoundAt = i;
+          break;
+        }
+      }
+
+      expect(controlFoundAt).toBeGreaterThan(-1);
+      expect(writeRequest[controlFoundAt + 1]).toBe(0x10 + 0x28); // Control ID with offset
+    });
+  });
+
+  describe('Acknowledgment Handling', () => {
+    it('should properly handle successful write acknowledgments', async () => {
+      const mode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 2,
+        name: 'ACKTEST',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 50, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      let ackSlot = -1;
+      let ackStatus = -1;
+
+      inputPort.onMessage = (message) => {
+        const data = Array.from(message.data);
+        // Check for acknowledgment format: F0 00 20 29 02 15 05 00 15 [SLOT] [STATUS] F7
+        if (data.length === 12 &&
+            data[0] === 0xF0 &&
+            data[1] === 0x00 && data[2] === 0x20 && data[3] === 0x29 &&
+            data[8] === 0x15) { // Write ACK operation
+          ackSlot = data[9];
+          ackStatus = data[10];
+        }
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(2, mode);
+      await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: writeRequest });
+
+      // Simulate successful acknowledgment
+      const successAck = [0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x15, 0x02, 0x06, 0xF7];
+      if (inputPort.onMessage) {
+        inputPort.onMessage({ timestamp: Date.now(), data: successAck });
+      }
+
+      expect(ackSlot).toBe(2);
+      expect(ackStatus).toBe(0x06); // Success status
+    });
+
+    it('should handle error acknowledgments', async () => {
+      const mode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'ERROR',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 60, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      let ackStatus = -1;
+
+      inputPort.onMessage = (message) => {
+        const data = Array.from(message.data);
+        if (data.length === 12 && data[8] === 0x15) {
+          ackStatus = data[10];
+        }
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, mode);
+      await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: writeRequest });
+
+      // Simulate error acknowledgment (status != 0x06)
+      const errorAck = [0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x15, 0x00, 0x01, 0xF7];
+      if (inputPort.onMessage) {
+        inputPort.onMessage({ timestamp: Date.now(), data: errorAck });
+      }
+
+      expect(ackStatus).toBe(0x01); // Error status
+    });
+  });
+
+  describe('Error Cases', () => {
+    it('should handle invalid slot numbers gracefully', () => {
+      const mode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      expect(() => SysExParser.buildCustomModeWriteRequest(-1, mode)).toThrow('Custom mode slot must be 0-15');
+      expect(() => SysExParser.buildCustomModeWriteRequest(16, mode)).toThrow('Custom mode slot must be 0-15');
+    });
+
+    it('should handle malformed SysEx messages', async () => {
+      const malformedMessages = [
+        [0xF0], // Missing end byte
+        [0x80, 0x40, 0x7F], // Not a SysEx message
+        [0xF0, 0xF7], // Too short
+        [0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, 0xFF], // Missing F7
+      ];
+
+      let parseErrors = 0;
+
+      inputPort.onMessage = (message) => {
+        try {
+          SysExParser.parse(Array.from(message.data));
+        } catch (error) {
+          parseErrors++;
+        }
+      };
+
+      for (const malformed of malformedMessages) {
+        if (inputPort.onMessage) {
+          inputPort.onMessage({ timestamp: Date.now(), data: malformed });
+        }
+      }
+
+      expect(parseErrors).toBe(4); // All malformed messages should cause parse errors
+    });
+
+    it('should handle device communication timeouts', async () => {
+      let messagesSent = 0;
+      let responsesReceived = 0;
+
+      inputPort.onMessage = () => {
+        responsesReceived++;
+      };
+
+      // Send multiple read requests without responses
+      for (let slot = 0; slot < 3; slot++) {
+        const readRequest = SysExParser.buildCustomModeReadRequest(slot);
+        await mockBackend.sendMessage(outputPort, { timestamp: Date.now(), data: readRequest });
+        messagesSent++;
+      }
+
+      // Wait briefly - no responses should be received from mock
+      await new Promise(resolve => setTimeout(resolve, 50));
+
+      expect(messagesSent).toBe(3);
+      expect(responsesReceived).toBe(0); // Mock backend doesn't auto-respond to custom mode reads
+      expect(mockBackend.sentMessages).toHaveLength(3);
+    });
+  });
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-read.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-read.test.ts
new file mode 100644
index 0000000..22da684
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-read.test.ts
@@ -0,0 +1,217 @@
+/**
+ * Integration test for reading custom modes from Launch Control XL 3
+ * Tests reading and parsing the CHANNEV custom mode from the device
+ */
+
+import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
+import { SysExParser } from '@/core/SysExParser';
+import { MockMidiBackend } from '@/core/backends/MockMidiBackend';
+import type { MidiInputPort, MidiOutputPort } from '@/core/MidiInterface';
+
+describe('Custom Mode Read Integration Tests', () => {
+  let mockBackend: MockMidiBackend;
+  let inputPort: MidiInputPort;
+  let outputPort: MidiOutputPort;
+
+  beforeEach(async () => {
+    mockBackend = new MockMidiBackend();
+    await mockBackend.initialize();
+
+    const inputPorts = await mockBackend.getInputPorts();
+    const outputPorts = await mockBackend.getOutputPorts();
+
+    inputPort = await mockBackend.openInput(inputPorts[0].id);
+    outputPort = await mockBackend.openOutput(outputPorts[0].id);
+  });
+
+  afterEach(async () => {
+    await mockBackend.cleanup();
+  });
+
+  describe('Reading Factory Custom Mode', () => {
+    it('should build correct read request for slot 0', () => {
+      const readRequest = SysExParser.buildCustomModeReadRequest(0);
+
+      expect(readRequest).toEqual([
+        0xF0,             // SysEx start
+        0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+        0x02,             // Device ID (Launch Control XL 3)
+        0x15,             // Command (Custom mode)
+        0x05,             // Sub-command
+        0x00,             // Reserved
+        0x40,             // Read operation
+        0,                // Slot number (0 for slot 1)
+        0x00,             // Parameter
+        0xF7              // SysEx end
+      ]);
+    });
+
+    it('should validate slot range for read requests', () => {
+      expect(() => SysExParser.buildCustomModeReadRequest(-1)).toThrow('Custom mode slot must be 0-15');
+      expect(() => SysExParser.buildCustomModeReadRequest(16)).toThrow('Custom mode slot must be 0-15');
+    });
+
+    it('should handle successful device response', async () => {
+      // Simulate a successful custom mode read response (based on actual CHANNEV response)
+      const mockResponse = [
+        0xF0, // SysEx start
+        0x00, 0x20, 0x29, // Manufacturer ID
+        0x02, 0x15, 0x05, 0x00, // Device header
+        0x10, // Response operation
+        0x00, // Slot
+        // Custom mode data starts here
+        0x06, 0x20, 0x08, // Data header
+        // Mode name "CHANNEV"
+        0x43, 0x48, 0x41, 0x4E, 0x4E, 0x45, 0x56, 0x00,
+        0x21, 0x00, // Name terminator
+        // Control definitions (using 0x48 markers for READ response)
+        0x48, 0x10, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F, // Top encoder 1, CC 13
+        0x48, 0x11, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0E, 0x7F, // Top encoder 2, CC 14
+        0x48, 0x12, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0F, 0x7F, // Top encoder 3, CC 15
+        0x48, 0x00, 0x02, 0x00, 0x00, 0x01, 0x48, 0x00, 0x0A, 0x7F, // Fader 1, CC 10
+        0x48, 0x01, 0x02, 0x00, 0x00, 0x01, 0x48, 0x00, 0x0B, 0x7F, // Fader 2, CC 11
+        0xF7 // SysEx end
+      ];
+
+      let responseReceived = false;
+      let parsedResponse: any = null;
+      let parseError: Error | null = null;
+
+      inputPort.onMessage = (message) => {
+        if (message.data[0] === 0xF0) {
+          responseReceived = true;
+          try {
+            parsedResponse = SysExParser.parse(Array.from(message.data));
+          } catch (error) {
+            parseError = error as Error;
+          }
+        }
+      };
+
+      // Send read request
+      const readRequest = SysExParser.buildCustomModeReadRequest(0);
+      await mockBackend.sendMessage(outputPort, {
+        timestamp: Date.now(),
+        data: readRequest
+      });
+
+      // Simulate device response
+      if (inputPort.onMessage) {
+        inputPort.onMessage({
+          timestamp: Date.now(),
+          data: mockResponse
+        });
+      }
+
+      expect(responseReceived).toBe(true);
+      expect(parseError).toBeNull();
+      expect(parsedResponse).toBeDefined();
+      expect(parsedResponse.type).toBe('custom_mode_response');
+      expect(parsedResponse.slot).toBe(0);
+      expect(parsedResponse.name).toBe('CHANNEV');
+      expect(parsedResponse.controls).toHaveLength(5);
+
+      // Verify specific control mappings
+      const controls = parsedResponse.controls;
+      expect(controls.find((c: any) => c.controlId === 0x10 && c.ccNumber === 13)).toBeDefined(); // Top encoder 1
+      expect(controls.find((c: any) => c.controlId === 0x11 && c.ccNumber === 14)).toBeDefined(); // Top encoder 2
+      expect(controls.find((c: any) => c.controlId === 0x12 && c.ccNumber === 15)).toBeDefined(); // Top encoder 3
+      expect(controls.find((c: any) => c.controlId === 0x00 && c.ccNumber === 10)).toBeDefined(); // Fader 1
+      expect(controls.find((c: any) => c.controlId === 0x01 && c.ccNumber === 11)).toBeDefined(); // Fader 2
+    });
+
+    it('should handle timeout when device does not respond', async () => {
+      let responseReceived = false;
+
+      inputPort.onMessage = () => {
+        responseReceived = true;
+      };
+
+      // Send read request
+      const readRequest = SysExParser.buildCustomModeReadRequest(0);
+      await mockBackend.sendMessage(outputPort, {
+        timestamp: Date.now(),
+        data: readRequest
+      });
+
+      // Wait a short time to verify no response
+      await new Promise(resolve => setTimeout(resolve, 100));
+
+      expect(responseReceived).toBe(false);
+      expect(mockBackend.sentMessages).toHaveLength(1);
+      expect(mockBackend.sentMessages[0].data).toEqual(readRequest);
+    });
+  });
+
+  describe('Control Structure Validation', () => {
+    it('should correctly identify control markers in read response', () => {
+      const testData = [
+        0x48, 0x10, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F, // Valid control
+        0x48, 0x11, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0E, 0x7F, // Valid control
+        0x00, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // Invalid (not at start)
+      ];
+
+      // Test our parsing logic can distinguish valid control markers
+      const { controls } = (SysExParser as any).parseCustomModeData(testData);
+
+      expect(controls).toHaveLength(2);
+      expect(controls[0].controlId).toBe(0x10);
+      expect(controls[0].ccNumber).toBe(13);
+      expect(controls[1].controlId).toBe(0x11);
+      expect(controls[1].ccNumber).toBe(14);
+    });
+
+    it('should validate control structure format', () => {
+      // Control with invalid definition type (should be 0x02)
+      const invalidDefType = [
+        0x48, 0x10, 0xFF, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F
+      ];
+
+      const { controls: invalidControls } = (SysExParser as any).parseCustomModeData(invalidDefType);
+      expect(invalidControls).toHaveLength(0); // Should reject invalid structure
+
+      // Control with valid structure
+      const validControl = [
+        0x48, 0x10, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F
+      ];
+
+      const { controls: validControls } = (SysExParser as any).parseCustomModeData(validControl);
+      expect(validControls).toHaveLength(1);
+    });
+  });
+
+  describe('Mode Name Parsing', () => {
+    it('should extract mode name from response data', () => {
+      const testData = [
+        0x06, 0x20, 0x08, // Header
+        0x43, 0x48, 0x41, 0x4E, 0x4E, 0x45, 0x56, // "CHANNEV"
+        0x21, 0x00, // Terminator
+        // Rest of data...
+      ];
+
+      const { name } = (SysExParser as any).parseCustomModeData(testData);
+      expect(name).toBe('CHANNEV');
+    });
+
+    it('should handle mode name without explicit terminator', () => {
+      const testData = [
+        0x06, 0x20, 0x08, // Header
+        0x54, 0x45, 0x53, 0x54, // "TEST"
+        0x48, 0x10, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F, // Control follows
+      ];
+
+      const { name } = (SysExParser as any).parseCustomModeData(testData);
+      expect(name).toBe('TEST');
+    });
+
+    it('should handle empty or missing mode name', () => {
+      const testData = [
+        0x06, 0x20, 0x08, // Header
+        0x48, 0x10, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F, // Control immediately
+      ];
+
+      const { name } = (SysExParser as any).parseCustomModeData(testData);
+      expect(name).toBeUndefined();
+    });
+  });
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/led-control.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/led-control.test.ts
new file mode 100644
index 0000000..fe2ba3a
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/led-control.test.ts
@@ -0,0 +1,135 @@
+#!/usr/bin/env tsx
+
+/**
+ * Test LED control based on web editor analysis
+ * Uses the actual working protocol discovered from web editor MIDI traffic
+ */
+
+import { createRequire } from 'module';
+
+const require = createRequire(import.meta.url);
+const midi = require('midi');
+
+console.log('Testing Launch Control XL 3 LED Control (Web Editor Protocol)...\n');
+
+// Color mapping based on web editor analysis
+const colors = {
+  off: 0x0C,
+  red: 0x0F,
+  green: 0x3C,
+  amber: 0x60,
+  yellow: 0x3F,
+  blue: 0x3D,
+};
+
+// LED ID mapping based on captured traffic
+const ledIds = {
+  // Encoders (from captured traffic)
+  encoder1: 0x41,
+  encoder2: 0x42,
+  encoder3: 0x43,
+  encoder4: 0x44,
+  encoder5: 0x45,
+  encoder6: 0x46,
+  encoder7: 0x47,
+  encoder8: 0x48,
+
+  // These are estimates based on pattern - need verification
+  // Faders (likely different range)
+  fader1: 0x29,
+  fader2: 0x2A,
+  fader3: 0x2B,
+  fader4: 0x2C,
+
+  // Buttons (likely another range)
+  button1: 0x51,
+  button2: 0x52,
+};
+
+function createLedControlMessage(ledId: number, colorCode: number): number[] {
+  return [
+    0xF0,             // SysEx start
+    0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+    0x11,             // Device ID (Launch Control XL 3) - from captured traffic
+    0x78,             // LED control command - from captured traffic
+    ledId,            // LED identifier
+    colorCode,        // Color code
+    0xF7              // SysEx end
+  ];
+}
+
+// Create output
+const output = new midi.Output();
+const outputCount = output.getPortCount();
+let outputIndex = -1;
+
+// Find MIDI port (not DAW port)
+console.log('Finding MIDI output port...');
+for (let i = 0; i < outputCount; i++) {
+  const name = output.getPortName(i);
+  if (name === 'LCXL3 1 MIDI In') {
+    outputIndex = i;
+    console.log(`Found LCXL3 1 MIDI In at port ${i}`);
+    break;
+  }
+}
+
+if (outputIndex >= 0) {
+  output.openPort(outputIndex);
+  console.log('✓ MIDI port opened');
+
+  console.log('\n🎨 Testing LED control sequence...');
+
+  let step = 0;
+  const testSequence = [
+    { led: ledIds.encoder1, color: colors.red, name: 'Encoder 1 Red' },
+    { led: ledIds.encoder2, color: colors.green, name: 'Encoder 2 Green' },
+    { led: ledIds.encoder3, color: colors.amber, name: 'Encoder 3 Amber' },
+    { led: ledIds.encoder4, color: colors.yellow, name: 'Encoder 4 Yellow' },
+    { led: ledIds.encoder1, color: colors.off, name: 'Encoder 1 Off' },
+    { led: ledIds.encoder2, color: colors.off, name: 'Encoder 2 Off' },
+    { led: ledIds.encoder3, color: colors.off, name: 'Encoder 3 Off' },
+    { led: ledIds.encoder4, color: colors.off, name: 'Encoder 4 Off' },
+  ];
+
+  const runTest = () => {
+    if (step >= testSequence.length) {
+      console.log('\n✅ LED control test completed!');
+      console.log('If you saw LEDs change color, the protocol is working correctly.');
+
+      // Clean up
+      setTimeout(() => {
+        output.closePort();
+        console.log('✓ MIDI port closed');
+      }, 500);
+      return;
+    }
+
+    const test = testSequence[step];
+    const message = createLedControlMessage(test.led, test.color);
+
+    console.log(`${step + 1}. ${test.name}`);
+    console.log(`   Message: ${message.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
+
+    try {
+      output.sendMessage(message);
+      console.log('   ✓ Sent successfully');
+    } catch (error) {
+      console.error(`   ❌ Failed: ${error}`);
+    }
+
+    step++;
+    setTimeout(runTest, 1500); // 1.5 second delay between steps
+  };
+
+  runTest();
+
+} else {
+  console.error('❌ LCXL3 1 MIDI In port not found');
+  console.error('Make sure the Launch Control XL 3 is connected via USB.');
+
+  console.log('\nAvailable MIDI ports:');
+  for (let i = 0; i < outputCount; i++) {
+    console.log(`  ${i}: ${output.getPortName(i)}`);
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/midi-discovery.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/midi-discovery.test.ts
new file mode 100644
index 0000000..a1e3cd6
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/midi-discovery.test.ts
@@ -0,0 +1,38 @@
+import { describe, test } from 'vitest';
+import easymidi from 'easymidi';
+
+describe('MIDI Device Discovery', () => {
+  test('should print all available MIDI inputs and outputs', () => {
+    console.log('\n=== MIDI DEVICE DISCOVERY ===\n');
+
+    // Get all available MIDI inputs
+    const inputs = easymidi.getInputs();
+    console.log('📥 MIDI INPUTS:');
+    if (inputs.length === 0) {
+      console.log('  (No MIDI input devices found)');
+    } else {
+      inputs.forEach((input, index) => {
+        console.log(`  ${index + 1}. ${input}`);
+      });
+    }
+
+    console.log(''); // Empty line for readability
+
+    // Get all available MIDI outputs
+    const outputs = easymidi.getOutputs();
+    console.log('📤 MIDI OUTPUTS:');
+    if (outputs.length === 0) {
+      console.log('  (No MIDI output devices found)');
+    } else {
+      outputs.forEach((output, index) => {
+        console.log(`  ${index + 1}. ${output}`);
+      });
+    }
+
+    console.log('\n=== END DISCOVERY ===\n');
+
+    // Optional: Log the counts
+    console.log(`Total inputs: ${inputs.length}`);
+    console.log(`Total outputs: ${outputs.length}`);
+  });
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/midi-loopback.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/midi-loopback.test.ts
new file mode 100644
index 0000000..c23b050
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/midi-loopback.test.ts
@@ -0,0 +1,153 @@
+import { describe, test, expect, beforeAll, afterAll } from 'vitest';
+//import { EasyMidiBackend } from '@/core/backends/EasyMidiBackend.js'
+//import { EasyMidiBackend } from '@/core/backends/EasyMidiBackend';
+import { Input, Output } from 'easymidi';
+
+describe('MIDI Loopback Test', () => {
+  let myInput: Input;
+  let myOutput: Output;
+  const MIDI_PORT_NAME = 'TestPort_' + Date.now();
+
+  beforeAll(async () => {
+    // Create virtual MIDI ports
+    myInput = new Input(MIDI_PORT_NAME, true); // true = virtual port
+    myOutput = new Output(MIDI_PORT_NAME, true);
+
+    // Small delay to ensure ports are ready
+    await new Promise((resolve) => setTimeout(resolve, 1000));
+  });
+
+  afterAll(() => {
+    // Clean up MIDI ports
+    if (myInput) {
+      myInput.close();
+    }
+    if (myOutput) {
+      myOutput.close();
+    }
+  });
+
+  test('should send and receive a note on message', async () => {
+    const testMessage = {
+      channel: 0,
+      note: 60, // Middle C
+      velocity: 127,
+    };
+
+    // Promise to capture the received message
+    const messageReceived = new Promise<Message>((resolve) => {
+      myInput.on('noteon', (msg) => {
+        resolve(msg);
+      });
+    });
+
+    // Send the MIDI message
+    myOutput.send('noteon', testMessage);
+
+    // Wait for and verify the received message
+    const receivedMessage = await messageReceived;
+
+    expect(receivedMessage.channel).toBe(testMessage.channel);
+    expect(receivedMessage.note).toBe(testMessage.note);
+    expect(receivedMessage.velocity).toBe(testMessage.velocity);
+  });
+
+  test('should send and receive a control change message', async () => {
+    const testMessage = {
+      channel: 1,
+      controller: 7, // Volume controller
+      value: 100,
+    };
+
+    const messageReceived = new Promise<Message>((resolve) => {
+      myInput.on('cc', (msg) => {
+        resolve(msg);
+      });
+    });
+
+    myOutput.send('cc', testMessage);
+
+    const receivedMessage = await messageReceived;
+
+    expect(receivedMessage.channel).toBe(testMessage.channel);
+    expect(receivedMessage.controller).toBe(testMessage.controller);
+    expect(receivedMessage.value).toBe(testMessage.value);
+  });
+
+  test('should send and receive a program change message', async () => {
+    const testMessage = {
+      channel: 2,
+      number: 42, // Program number
+    };
+
+    const messageReceived = new Promise<Message>((resolve) => {
+      myInput.on('program', (msg) => {
+        resolve(msg);
+      });
+    });
+
+    myOutput.send('program', testMessage);
+
+    const receivedMessage = await messageReceived;
+
+    expect(receivedMessage.channel).toBe(testMessage.channel);
+    expect(receivedMessage.number).toBe(testMessage.number);
+  });
+
+  test('should handle multiple messages in sequence', async () => {
+    const messages = [
+      { type: 'noteon', data: { channel: 0, note: 60, velocity: 127 } },
+      { type: 'noteon', data: { channel: 0, note: 64, velocity: 100 } },
+      { type: 'noteoff', data: { channel: 0, note: 60, velocity: 0 } },
+      { type: 'noteoff', data: { channel: 0, note: 64, velocity: 0 } },
+    ];
+
+    const receivedMessages: Message[] = [];
+
+    // Set up listeners for different message types
+    myInput.on('noteon', (msg) => receivedMessages.push({ ...msg, _type: 'noteon' }));
+    myInput.on('noteoff', (msg) => receivedMessages.push({ ...msg, _type: 'noteoff' }));
+
+    // Send all messages
+    for (const message of messages) {
+      myOutput.send(message.type as any, message.data);
+      // Small delay between messages
+      await new Promise((resolve) => setTimeout(resolve, 10));
+    }
+
+    // Wait for all messages to be received
+    await new Promise((resolve) => setTimeout(resolve, 100));
+
+    expect(receivedMessages).toHaveLength(messages.length);
+
+    // Verify each message
+    for (let i = 0; i < messages.length; i++) {
+      const sent = messages[i];
+      const received = receivedMessages[i];
+
+      expect(received._type).toBe(sent.type);
+      expect(received.channel).toBe(sent.data.channel);
+      expect(received.note).toBe(sent.data.note);
+
+      if (sent.type === 'noteon') {
+        expect(received.velocity).toBe(sent.data.velocity);
+      }
+    }
+  });
+
+  test('should handle sysex messages', async () => {
+    const sysexData = [0xf0, 0x43, 0x12, 0x00, 0x43, 0x12, 0x00, 0xf7]; // Example sysex
+
+    const messageReceived = new Promise<Message>((resolve) => {
+      myInput.on('sysex', (msg) => {
+        resolve(msg);
+      });
+    });
+
+    myOutput.send('sysex', { bytes: sysexData });
+
+    const receivedMessage = await messageReceived;
+
+    expect(receivedMessage.bytes).toEqual(sysexData);
+  });
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/midi-send.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/midi-send.test.ts
new file mode 100644
index 0000000..93cc443
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/midi-send.test.ts
@@ -0,0 +1,67 @@
+import { describe, test, expect } from 'vitest';
+import easymidi from 'easymidi';
+
+describe('MIDI Real Device Output Test', () => {
+  test('should send a MIDI message to a real device', () => {
+    // First, discover available MIDI inputs (devices that can receive messages)
+    const availableInputs = easymidi.getInputs();
+
+    console.log('\n=== AVAILABLE MIDI INPUTS (devices that can receive) ===');
+    if (availableInputs.length === 0) {
+      console.log('❌ No MIDI input devices found!');
+      console.log('Make sure you have a MIDI device connected or virtual MIDI software running.');
+      return; // Skip the test if no devices
+    }
+
+    availableInputs.forEach((input, index) => {
+      console.log(`  ${index + 1}. ${input}`);
+    });
+
+    // Use the first available MIDI input device
+    const targetDevice = availableInputs[0];
+    console.log(`\n🎯 Sending MIDI message to: "${targetDevice}"`);
+
+    try {
+      // Create output connection to the target device
+      const output = new easymidi.Output(targetDevice, false); // false = connect to existing device
+
+      // Define the MIDI message to send
+      const midiMessage = {
+        channel: 0,    // MIDI channel 1 (0-indexed)
+        note: 60,      // Middle C
+        velocity: 100  // Medium velocity
+      };
+
+      console.log('📤 Sending Note On message:');
+      console.log(`   Channel: ${midiMessage.channel + 1}`);
+      console.log(`   Note: ${midiMessage.note} (Middle C)`);
+      console.log(`   Velocity: ${midiMessage.velocity}`);
+
+      // Send the MIDI message
+      output.send('noteon', midiMessage);
+
+      console.log('✅ MIDI message sent successfully!');
+
+      // Wait a moment, then send note off
+      setTimeout(() => {
+        output.send('noteoff', {
+          channel: midiMessage.channel,
+          note: midiMessage.note,
+          velocity: 0
+        });
+        console.log('📤 Note Off sent');
+
+        // Clean up
+        output.close();
+        console.log('🔌 Connection closed');
+      }, 1000); // 1 second note duration
+
+      // Test passes if we got this far without errors
+      expect(true).toBe(true);
+
+    } catch (error) {
+      console.error('❌ Error sending MIDI message:', error);
+      throw error;
+    }
+  }, 5000); // 5 second timeout for this test
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/protocol-verification.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/protocol-verification.test.ts
new file mode 100644
index 0000000..7824eac
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/protocol-verification.test.ts
@@ -0,0 +1,229 @@
+#!/usr/bin/env tsx
+
+/**
+ * WORKING Launch Control XL 3 Custom Mode Protocol Implementation
+ * With the correct ignoreTypes configuration
+ */
+
+import { createRequire } from 'module';
+
+const require = createRequire(import.meta.url);
+const midi = require('midi');
+
+console.log('🎛️ Launch Control XL 3 - WORKING Protocol Implementation\n');
+
+// Create input and output
+const input = new midi.Input();
+const output = new midi.Output();
+
+// CRITICAL: Disable message filtering to receive SysEx
+input.ignoreTypes(false, false, false); // Don't ignore SysEx, timing, active sensing
+
+// Find ports
+let inputIndex = -1;
+let outputIndex = -1;
+
+const inputCount = input.getPortCount();
+const outputCount = output.getPortCount();
+
+for (let i = 0; i < inputCount; i++) {
+  const name = input.getPortName(i);
+  if (name === 'LCXL3 1 MIDI Out') {
+    inputIndex = i;
+    console.log(`Found input: ${name} at index ${i}`);
+    break;
+  }
+}
+
+for (let i = 0; i < outputCount; i++) {
+  const name = output.getPortName(i);
+  if (name === 'LCXL3 1 MIDI In') {
+    outputIndex = i;
+    console.log(`Found output: ${name} at index ${i}`);
+    break;
+  }
+}
+
+if (inputIndex >= 0 && outputIndex >= 0) {
+  console.log('\nOpening MIDI ports...');
+
+  let responseCount = 0;
+  const responses: any[] = [];
+
+  // Set up comprehensive message handler
+  input.on('message', (deltaTime: number, message: number[]) => {
+    responseCount++;
+    const timestamp = new Date().toISOString().split('T')[1].substring(0, 12);
+
+    console.log(`\n[${timestamp}] === RESPONSE ${responseCount} ===`);
+    console.log(`Length: ${message.length} bytes`);
+
+    if (message[0] === 0xF0) {
+      console.log('🎯 SysEx Response Received!');
+      console.log(`First 20 bytes: ${message.slice(0, 20).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
+      console.log(`Last 10 bytes: ${message.slice(-10).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
+
+      // Parse Novation custom mode response
+      if (message.length >= 10 &&
+          message[1] === 0x00 &&
+          message[2] === 0x20 &&
+          message[3] === 0x29 &&
+          message[4] === 0x02 &&
+          message[5] === 0x15 &&
+          message[6] === 0x05 &&
+          message[7] === 0x00) {
+
+        const operation = message[8];
+        const slot = message[9];
+
+        console.log(`✅ Novation Custom Mode Response!`);
+        console.log(`   Operation: 0x${operation.toString(16).padStart(2, '0')} (${operation === 0x10 ? 'READ' : operation === 0x15 ? 'ACK' : 'OTHER'})`);
+        console.log(`   Slot: ${slot}`);
+
+        if (operation === 0x10) {
+          console.log(`   🎼 Custom Mode Data Retrieved!`);
+
+          // Parse mode name (after 06 20 0E pattern)
+          let nameStart = -1;
+          for (let i = 10; i < message.length - 3; i++) {
+            if (message[i] === 0x06 && message[i + 1] === 0x20 && message[i + 2] === 0x0E) {
+              nameStart = i + 3;
+              break;
+            }
+          }
+
+          if (nameStart > 0) {
+            const nameBytes = [];
+            for (let i = nameStart; i < message.length - 1; i++) {
+              if (message[i] === 0x00 || message[i] === 0x48 || message[i] === 0xF7) break;
+              if (message[i] >= 32 && message[i] <= 126) {
+                nameBytes.push(message[i]);
+              }
+            }
+
+            if (nameBytes.length > 0) {
+              const modeName = String.fromCharCode(...nameBytes);
+              console.log(`   📛 Mode Name: "${modeName}"`);
+            }
+          }
+
+          // Count and parse first few control definitions
+          let controlCount = 0;
+          const controls: any[] = [];
+
+          for (let i = 10; i < message.length - 10; i++) {
+            if (message[i] === 0x48) { // Control marker
+              controlCount++;
+
+              if (controlCount <= 5) { // Show first 5 controls
+                const controlId = message[i + 1];
+                const defType = message[i + 2];
+                const controlType = message[i + 3];
+                const channel = message[i + 4];
+                const param1 = message[i + 5];
+                const param2 = message[i + 6];
+                const ccNumber = message[i + 7];
+                const maxValue = message[i + 8];
+
+                let controlTypeName = 'Unknown';
+                if (controlType === 0x21 || controlType === 0x2D) controlTypeName = 'Encoder';
+                else if (controlType === 0x0D) controlTypeName = 'Fader';
+                else if (controlType === 0x1A) controlTypeName = 'Button';
+
+                console.log(`   🎛️  Control ${controlCount}: ${controlTypeName} (ID=0x${controlId.toString(16)}, Ch=${channel + 1}, CC=${ccNumber})`);
+
+                controls.push({
+                  id: controlId,
+                  type: controlTypeName,
+                  channel: channel + 1,
+                  cc: ccNumber
+                });
+              }
+            }
+          }
+
+          console.log(`   📊 Total Controls: ${controlCount}`);
+
+          // Store response for analysis
+          responses.push({
+            slot,
+            modeName: nameBytes.length > 0 ? String.fromCharCode(...nameBytes) : 'Unknown',
+            controlCount,
+            controls,
+            rawData: [...message]
+          });
+        }
+      }
+    } else {
+      console.log(`📨 MIDI Message: ${message.map(b => '0x' + b.toString(16)).join(' ')}`);
+    }
+  });
+
+  input.openPort(inputIndex);
+  output.openPort(outputIndex);
+
+  console.log('✅ Ports opened with SysEx enabled');
+  console.log('📡 Monitoring for responses...\n');
+
+  async function testReadOperations() {
+    const slotsToTest = [0, 1, 2, 3]; // Test first 4 slots
+
+    for (const slot of slotsToTest) {
+      console.log(`\n🔍 Reading from slot ${slot}...`);
+
+      // Correct read request format (from MIDI capture)
+      const readRequest = [0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x40, slot, 0x00, 0xF7];
+
+      console.log(`Request: ${readRequest.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')}`);
+
+      try {
+        output.sendMessage(readRequest);
+        console.log('✅ Read request sent');
+
+        // Wait for response
+        await new Promise(resolve => setTimeout(resolve, 1500));
+
+      } catch (error) {
+        console.error('❌ Failed to send read request:', error);
+      }
+    }
+
+    // Summary
+    console.log(`\n📋 FINAL RESULTS:`);
+    console.log(`   Total responses: ${responseCount}`);
+    console.log(`   Slots with data: ${responses.length}`);
+
+    if (responses.length > 0) {
+      console.log(`\n📊 Custom Modes Found:`);
+      responses.forEach((resp, i) => {
+        console.log(`   ${i + 1}. Slot ${resp.slot}: "${resp.modeName}" (${resp.controlCount} controls)`);
+        resp.controls.forEach((ctrl: any, j: number) => {
+          if (j < 3) { // Show first 3 controls
+            console.log(`      - ${ctrl.type}: CC${ctrl.cc} on Ch${ctrl.channel}`);
+          }
+        });
+        if (resp.controls.length > 3) {
+          console.log(`      - ... and ${resp.controls.length - 3} more`);
+        }
+      });
+
+      console.log(`\n🎉 SUCCESS! Launch Control XL 3 protocol is now working!`);
+      console.log(`The key was: input.ignoreTypes(false, false, false)`);
+
+    } else {
+      console.log(`\n⚠️  No custom mode data found in tested slots`);
+    }
+
+    // Cleanup
+    input.closePort();
+    output.closePort();
+    console.log('\n✅ Ports closed');
+  }
+
+  testReadOperations().catch(console.error);
+
+} else {
+  console.log('❌ Required ports not found:');
+  if (inputIndex < 0) console.log('  - LCXL3 1 MIDI Out (input)');
+  if (outputIndex < 0) console.log('  - LCXL3 1 MIDI In (output)');
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/sysex-protocol.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/sysex-protocol.test.ts
new file mode 100644
index 0000000..61cf2fc
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/sysex-protocol.test.ts
@@ -0,0 +1,520 @@
+/**
+ * Integration tests for SysEx protocol implementation
+ * Tests the correct implementation of Launch Control XL 3 SysEx protocol
+ * Based on PROTOCOL-CORRECTED.md specifications
+ */
+
+import { describe, it, expect, beforeEach, afterEach } from 'vitest';
+import { SysExParser, type CustomModeMessage } from '@/core/SysExParser';
+import { MockMidiBackend } from '@/core/backends/MockMidiBackend';
+import type { MidiInputPort, MidiOutputPort } from '@/core/MidiInterface';
+
+describe('SysEx Protocol Implementation Tests', () => {
+  let mockBackend: MockMidiBackend;
+  let inputPort: MidiInputPort;
+  let outputPort: MidiOutputPort;
+
+  beforeEach(async () => {
+    mockBackend = new MockMidiBackend();
+    await mockBackend.initialize();
+
+    const inputPorts = await mockBackend.getInputPorts();
+    const outputPorts = await mockBackend.getOutputPorts();
+
+    inputPort = await mockBackend.openInput(inputPorts[0].id);
+    outputPort = await mockBackend.openOutput(outputPorts[0].id);
+  });
+
+  afterEach(async () => {
+    await mockBackend.cleanup();
+  });
+
+  describe('Command Byte Usage', () => {
+    it('should use 0x40 for read operations', () => {
+      const readRequest = SysExParser.buildCustomModeReadRequest(0);
+
+      // Expected format: F0 00 20 29 02 15 05 00 40 [SLOT] 00 F7
+      expect(readRequest[8]).toBe(0x40); // Read operation command byte
+    });
+
+    it('should use 0x45 for write operations', () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Expected format: F0 00 20 29 02 15 05 00 45 [SLOT] [DATA...] F7
+      expect(writeRequest[8]).toBe(0x45); // Write operation command byte
+    });
+
+    it('should handle different slot numbers correctly', () => {
+      for (let slot = 0; slot < 8; slot++) {
+        const readRequest = SysExParser.buildCustomModeReadRequest(slot);
+        expect(readRequest[9]).toBe(slot); // Slot byte should match
+      }
+    });
+  });
+
+  describe('Control ID Offset for Writing', () => {
+    it('should add 0x28 offset to control IDs when writing', () => {
+      const testCases = [
+        { originalId: 0x00, expectedOffset: 0x28 }, // Fader 1
+        { originalId: 0x07, expectedOffset: 0x2F }, // Fader 8
+        { originalId: 0x10, expectedOffset: 0x38 }, // Top encoder 1
+        { originalId: 0x17, expectedOffset: 0x3F }, // Top encoder 8
+        { originalId: 0x18, expectedOffset: 0x40 }, // Middle encoder 1
+        { originalId: 0x1F, expectedOffset: 0x47 }, // Middle encoder 8
+        { originalId: 0x20, expectedOffset: 0x48 }, // Bottom encoder 1
+        { originalId: 0x27, expectedOffset: 0x4F }, // Bottom encoder 8
+      ];
+
+      for (const testCase of testCases) {
+        const testMode: CustomModeMessage = {
+          type: 'custom_mode_write',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'OFFSET',
+          controls: [
+            {
+              controlId: testCase.originalId,
+              channel: 0,
+              ccNumber: 20,
+              minValue: 0,
+              maxValue: 127,
+              behaviour: 'absolute' as const
+            }
+          ],
+          colors: [
+            { controlId: testCase.originalId, color: 0x3F, behaviour: 'static' as const }
+          ],
+          data: []
+        };
+
+        const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+        // Find the control definition (0x49 marker)
+        let controlMarkerIndex = -1;
+        for (let i = 0; i < writeRequest.length - 1; i++) {
+          if (writeRequest[i] === 0x49) {
+            controlMarkerIndex = i;
+            break;
+          }
+        }
+
+        expect(controlMarkerIndex).toBeGreaterThan(-1);
+        expect(writeRequest[controlMarkerIndex + 1]).toBe(testCase.expectedOffset);
+      }
+    });
+
+    it('should add 0x28 offset to label and color markers', () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'LABEL',
+        controls: [
+          { controlId: 0x10, channel: 0, ccNumber: 13, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x10, color: 0x60, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Find label marker (0x69)
+      let labelMarkerIndex = -1;
+      for (let i = 0; i < writeRequest.length - 1; i++) {
+        if (writeRequest[i] === 0x69) {
+          labelMarkerIndex = i;
+          break;
+        }
+      }
+
+      // Find color marker (0x60)
+      let colorMarkerIndex = -1;
+      for (let i = 0; i < writeRequest.length - 1; i++) {
+        if (writeRequest[i] === 0x60 && i !== labelMarkerIndex) {
+          colorMarkerIndex = i;
+          break;
+        }
+      }
+
+      expect(labelMarkerIndex).toBeGreaterThan(-1);
+      expect(colorMarkerIndex).toBeGreaterThan(-1);
+      expect(writeRequest[labelMarkerIndex + 1]).toBe(0x10 + 0x28); // Label ID with offset
+      expect(writeRequest[colorMarkerIndex + 1]).toBe(0x10 + 0x28); // Color ID with offset
+    });
+  });
+
+  describe('Control Marker Differences', () => {
+    it('should use 0x49 markers in write requests', () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'WRITE',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          { controlId: 0x10, channel: 0, ccNumber: 13, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x0F, behaviour: 'static' as const },
+          { controlId: 0x10, color: 0x60, behaviour: 'static' as const },
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Count 0x49 markers (should be 2, one for each control)
+      let writeMarkerCount = 0;
+      for (let i = 0; i < writeRequest.length; i++) {
+        if (writeRequest[i] === 0x49) {
+          writeMarkerCount++;
+        }
+      }
+
+      expect(writeMarkerCount).toBe(2);
+
+      // Ensure no 0x48 markers are present in write requests
+      let readMarkerCount = 0;
+      for (let i = 0; i < writeRequest.length; i++) {
+        if (writeRequest[i] === 0x48) {
+          readMarkerCount++;
+        }
+      }
+
+      expect(readMarkerCount).toBe(0); // Should not have read markers in write request
+    });
+
+    it('should expect 0x48 markers in read responses', () => {
+      // Simulate a read response with 0x48 markers
+      const mockReadResponse = [
+        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, // Header
+        0x06, 0x20, 0x08, // Data header
+        0x54, 0x45, 0x53, 0x54, 0x00, 0x00, 0x00, 0x00, // "TEST" name
+        0x21, 0x00, // Name terminator
+        // Control definitions with 0x48 markers (READ response format)
+        0x48, 0x00, 0x02, 0x00, 0x00, 0x01, 0x48, 0x00, 0x0A, 0x7F, // Fader 1, CC 10
+        0x48, 0x10, 0x02, 0x05, 0x00, 0x01, 0x48, 0x00, 0x0D, 0x7F, // Top encoder 1, CC 13
+        0xF7 // End
+      ];
+
+      let parsedResponse: any = null;
+
+      inputPort.onMessage = (message) => {
+        if (message.data[0] === 0xF0) {
+          parsedResponse = SysExParser.parse(Array.from(message.data));
+        }
+      };
+
+      // Simulate device response
+      if (inputPort.onMessage) {
+        inputPort.onMessage({ timestamp: Date.now(), data: mockReadResponse });
+      }
+
+      expect(parsedResponse).toBeDefined();
+      expect(parsedResponse.type).toBe('custom_mode_response');
+      expect(parsedResponse.controls).toHaveLength(2);
+      expect(parsedResponse.controls[0].controlId).toBe(0x00);
+      expect(parsedResponse.controls[0].ccNumber).toBe(10);
+      expect(parsedResponse.controls[1].controlId).toBe(0x10);
+      expect(parsedResponse.controls[1].ccNumber).toBe(13);
+    });
+
+    it('should not parse controls with wrong markers', () => {
+      // Test data with mixed markers (should only parse 0x48 in read context)
+      const mixedMarkerData = [
+        0x06, 0x20, 0x08, // Header
+        0x48, 0x00, 0x02, 0x00, 0x00, 0x01, 0x48, 0x00, 0x0A, 0x7F, // Valid 0x48 marker
+        0x49, 0x01, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x0B, 0x7F, 0x00, // 0x49 marker (write format)
+        0x48, 0x02, 0x02, 0x00, 0x00, 0x01, 0x48, 0x00, 0x0C, 0x7F, // Another valid 0x48 marker
+      ];
+
+      const { controls } = (SysExParser as any).parseCustomModeData(mixedMarkerData);
+
+      // Should parse both 0x48 and 0x49 markers in mixed data
+      expect(controls.length).toBeGreaterThanOrEqual(2);
+
+      // Find the controls by ID
+      const control0 = controls.find((c: any) => c.controlId === 0x00);
+      const control1 = controls.find((c: any) => c.controlId === 0x01);
+      const control2 = controls.find((c: any) => c.controlId === 0x02);
+
+      expect(control0).toBeDefined();
+      expect(control2).toBeDefined();
+      // control1 may or may not be parsed depending on validation logic
+    });
+  });
+
+  describe('Label and Color Data Encoding', () => {
+    it('should encode labels with 0x69 marker', () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'LABELS',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          { controlId: 0x10, channel: 0, ccNumber: 20, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x0F, behaviour: 'static' as const },
+          { controlId: 0x10, color: 0x60, behaviour: 'static' as const },
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Find all label markers (0x69)
+      const labelMarkers: number[] = [];
+      for (let i = 0; i < writeRequest.length; i++) {
+        if (writeRequest[i] === 0x69) {
+          labelMarkers.push(i);
+        }
+      }
+
+      expect(labelMarkers.length).toBe(2); // One for each control
+
+      // Verify label structure: 0x69 [ID+0x28] [ASCII_TEXT...]
+      for (const markerIndex of labelMarkers) {
+        expect(writeRequest[markerIndex]).toBe(0x69);
+        const controlIdWithOffset = writeRequest[markerIndex + 1];
+        expect(controlIdWithOffset).toBeGreaterThanOrEqual(0x28);
+
+        // Extract and verify ASCII text follows
+        let asciiStart = markerIndex + 2;
+        let hasAsciiText = false;
+        while (asciiStart < writeRequest.length && writeRequest[asciiStart] >= 32 && writeRequest[asciiStart] <= 126) {
+          hasAsciiText = true;
+          asciiStart++;
+        }
+        expect(hasAsciiText).toBe(true);
+      }
+    });
+
+    it('should encode colors with 0x60 marker', () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'COLORS',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+          { controlId: 0x18, channel: 0, ccNumber: 30, minValue: 0, maxValue: 127, behaviour: 'absolute' as const },
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x0F, behaviour: 'static' as const },
+          { controlId: 0x18, color: 0x48, behaviour: 'static' as const },
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Find all color markers (0x60) - need to distinguish from color values
+      const colorMarkers: number[] = [];
+      for (let i = 0; i < writeRequest.length - 1; i++) {
+        if (writeRequest[i] === 0x60 && writeRequest[i + 1] >= 0x28) {
+          colorMarkers.push(i);
+        }
+      }
+
+      expect(colorMarkers.length).toBe(2); // One for each control
+
+      // Verify color structure: 0x60 [ID+0x28]
+      for (const markerIndex of colorMarkers) {
+        expect(writeRequest[markerIndex]).toBe(0x60);
+        const controlIdWithOffset = writeRequest[markerIndex + 1];
+        expect(controlIdWithOffset).toBeGreaterThanOrEqual(0x28);
+      }
+    });
+
+    it('should maintain proper section order: controls, labels, colors', () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'ORDER',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Find positions of different markers
+      let controlMarkerPos = -1;
+      let labelMarkerPos = -1;
+      let colorMarkerPos = -1;
+
+      for (let i = 0; i < writeRequest.length; i++) {
+        if (writeRequest[i] === 0x49 && controlMarkerPos === -1) {
+          controlMarkerPos = i;
+        } else if (writeRequest[i] === 0x69 && labelMarkerPos === -1) {
+          labelMarkerPos = i;
+        } else if (writeRequest[i] === 0x60 && writeRequest[i + 1] >= 0x28 && colorMarkerPos === -1) {
+          colorMarkerPos = i;
+        }
+      }
+
+      // Verify order: controls < labels < colors
+      expect(controlMarkerPos).toBeGreaterThan(-1);
+      expect(labelMarkerPos).toBeGreaterThan(-1);
+      expect(colorMarkerPos).toBeGreaterThan(-1);
+      expect(controlMarkerPos).toBeLessThan(labelMarkerPos);
+      expect(labelMarkerPos).toBeLessThan(colorMarkerPos);
+    });
+  });
+
+  describe('Data Header Format', () => {
+    it('should start with 00 20 08 header', () => {
+      const testMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'HEADER',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+      // Data should start after the SysEx header at position 10
+      const dataStart = 10;
+      expect(writeRequest[dataStart]).toBe(0x00);
+      expect(writeRequest[dataStart + 1]).toBe(0x20);
+      expect(writeRequest[dataStart + 2]).toBe(0x08);
+    });
+
+    it('should include mode name after header (max 8 chars)', () => {
+      const testCases = [
+        { name: 'SHORT', expectedLength: 5 },
+        { name: 'EXACTLY8', expectedLength: 8 },
+        { name: 'TOOLONGNAME', expectedLength: 8 }, // Should be truncated
+        { name: '', expectedLength: 0 },
+      ];
+
+      for (const testCase of testCases) {
+        const testMode: CustomModeMessage = {
+          type: 'custom_mode_write',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: testCase.name,
+          controls: [
+            { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+          ],
+          colors: [
+            { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+          ],
+          data: []
+        };
+
+        const writeRequest = SysExParser.buildCustomModeWriteRequest(0, testMode);
+
+        // Extract name bytes after header
+        const nameStart = 13; // After 00 20 08 header
+        const nameBytes: number[] = [];
+
+        for (let i = nameStart; i < writeRequest.length && nameBytes.length < 16; i++) {
+          // Stop at first control marker (0x49)
+          if (writeRequest[i] === 0x49) {
+            break;
+          }
+          // Stop at non-ASCII bytes (likely control data)
+          if (writeRequest[i] < 32 || writeRequest[i] > 126) {
+            break;
+          }
+          nameBytes.push(writeRequest[i]);
+        }
+
+        if (testCase.expectedLength > 0) {
+          expect(nameBytes.length).toBeGreaterThanOrEqual(Math.min(testCase.expectedLength, 8));
+          const extractedName = String.fromCharCode(...nameBytes);
+          const expectedName = testCase.name.substring(0, 8);
+          expect(extractedName).toContain(expectedName.substring(0, Math.min(expectedName.length, extractedName.length)));
+        }
+      }
+    });
+  });
+
+  describe('Message Size Validation', () => {
+    it('should generate messages of appropriate size for different complexities', () => {
+      // Simple mode (1 control)
+      const simpleMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'SIMPLE',
+        controls: [
+          { controlId: 0x00, channel: 0, ccNumber: 10, minValue: 0, maxValue: 127, behaviour: 'absolute' as const }
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x3F, behaviour: 'static' as const }
+        ],
+        data: []
+      };
+
+      // Complex mode (8 controls)
+      const complexMode: CustomModeMessage = {
+        type: 'custom_mode_write',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'COMPLEX',
+        controls: Array.from({ length: 8 }, (_, i) => ({
+          controlId: i,
+          channel: 0,
+          ccNumber: 10 + i,
+          minValue: 0,
+          maxValue: 127,
+          behaviour: 'absolute' as const
+        })),
+        colors: Array.from({ length: 8 }, (_, i) => ({
+          controlId: i,
+          color: 0x3F,
+          behaviour: 'static' as const
+        })),
+        data: []
+      };
+
+      const simpleRequest = SysExParser.buildCustomModeWriteRequest(0, simpleMode);
+      const complexRequest = SysExParser.buildCustomModeWriteRequest(0, complexMode);
+
+      // Simple mode should be smaller
+      expect(simpleRequest.length).toBeLessThan(complexRequest.length);
+
+      // Both should be reasonable sizes (based on protocol analysis)
+      expect(simpleRequest.length).toBeGreaterThan(50); // Minimum viable message
+      expect(simpleRequest.length).toBeLessThan(200); // Not too large for simple
+
+      expect(complexRequest.length).toBeGreaterThan(200); // More substantial
+      expect(complexRequest.length).toBeLessThan(600); // But not excessive
+
+      // Complex mode should have significantly more data
+      expect(complexRequest.length - simpleRequest.length).toBeGreaterThan(100);
+    });
+  });
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/unit/CustomModeBuilder.test.ts b/modules/audio-control/modules/launch-control-xl3/test/unit/CustomModeBuilder.test.ts
new file mode 100644
index 0000000..56c6b4c
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/unit/CustomModeBuilder.test.ts
@@ -0,0 +1,157 @@
+import { describe, it, expect } from 'vitest';
+import { CustomModeBuilder, Color } from '@/builders/CustomModeBuilder';
+
+describe('CustomModeBuilder', () => {
+  describe('Basic builder functionality', () => {
+    it('should create a simple custom mode', () => {
+      const mode = new CustomModeBuilder()
+        .name('TEST')
+        .addFader(1, { cc: 10, channel: 1 })
+        .addEncoder(1, 1, { cc: 20, channel: 1 })
+        .build();
+
+      expect(mode.name).toBe('TEST');
+      expect(mode.controls).toHaveLength(2);
+      expect(mode.controls[0]).toMatchObject({
+        controlId: 0,
+        controlType: 0x00,
+        midiChannel: 0,
+        ccNumber: 10
+      });
+      expect(mode.controls[1]).toMatchObject({
+        controlId: 0x10,
+        controlType: 0x05,
+        midiChannel: 0,
+        ccNumber: 20
+      });
+    });
+
+    it('should add labels to controls', () => {
+      const mode = new CustomModeBuilder()
+        .name('LABELED')
+        .addFader(1, { cc: 10 })
+        .addFaderLabel(1, 'Volume')
+        .addEncoder(1, 1, { cc: 20 })
+        .addEncoderLabel(1, 1, 'Pan')
+        .build();
+
+      expect(mode.labels?.get(0)).toBe('Volume');
+      expect(mode.labels?.get(0x10)).toBe('Pan');
+    });
+
+    it('should add colors to buttons', () => {
+      const mode = new CustomModeBuilder()
+        .name('COLORED')
+        .addSideButton(1, { cc: 60 })
+        .addSideButtonColor(1, Color.RED_FULL)
+        .addBottomButton(1, { cc: 70 })
+        .addBottomButtonColor(1, Color.GREEN_FULL)
+        .build();
+
+      expect(mode.colors?.get(0x28)).toBe(Color.RED_FULL);
+      expect(mode.colors?.get(0x30)).toBe(Color.GREEN_FULL);
+    });
+
+    it('should sort controls by ID', () => {
+      const mode = new CustomModeBuilder()
+        .name('SORTED')
+        .addEncoder(3, 1, { cc: 30 }) // ID 0x20
+        .addEncoder(1, 1, { cc: 10 }) // ID 0x10
+        .addFader(1, { cc: 5 })       // ID 0x00
+        .build();
+
+      expect(mode.controls[0].controlId).toBe(0x00);
+      expect(mode.controls[1].controlId).toBe(0x10);
+      expect(mode.controls[2].controlId).toBe(0x20);
+    });
+  });
+
+  describe('Validation', () => {
+    it('should throw error for invalid fader number', () => {
+      const builder = new CustomModeBuilder();
+      expect(() => builder.addFader(0, { cc: 10 })).toThrow('Fader number must be 1-8');
+      expect(() => builder.addFader(9, { cc: 10 })).toThrow('Fader number must be 1-8');
+    });
+
+    it('should throw error for invalid encoder number', () => {
+      const builder = new CustomModeBuilder();
+      expect(() => builder.addEncoder(1, 0, { cc: 10 })).toThrow('Encoder number must be 1-8');
+      expect(() => builder.addEncoder(1, 9, { cc: 10 })).toThrow('Encoder number must be 1-8');
+    });
+
+    it('should throw error for invalid CC number', () => {
+      const builder = new CustomModeBuilder().name('TEST');
+      expect(() => builder.addFader(1, { cc: -1 })).toThrow('CC number must be 0-127');
+      expect(() => builder.addFader(1, { cc: 128 })).toThrow('CC number must be 0-127');
+    });
+
+    it('should throw error for duplicate control', () => {
+      const builder = new CustomModeBuilder()
+        .name('DUP')
+        .addFader(1, { cc: 10 });
+
+      expect(() => builder.addFader(1, { cc: 20 })).toThrow('Control 0 already defined');
+    });
+
+    it('should throw error for mode name too long', () => {
+      const builder = new CustomModeBuilder();
+      expect(() => builder.name('TOOLONGNAME')).toThrow('Mode name must be 8 characters or less');
+    });
+
+    it('should throw error when building without name', () => {
+      const builder = new CustomModeBuilder()
+        .addFader(1, { cc: 10 });
+
+      expect(() => builder.build()).toThrow('Mode name is required');
+    });
+
+    it('should throw error when building without controls', () => {
+      const builder = new CustomModeBuilder()
+        .name('EMPTY');
+
+      expect(() => builder.build()).toThrow('At least one control mapping is required');
+    });
+  });
+
+  describe('Pre-configured modes', () => {
+    it('should create test mode', () => {
+      const mode = CustomModeBuilder.createTestMode().build();
+
+      expect(mode.name).toBe('TEST');
+      expect(mode.controls).toHaveLength(2);
+      expect(mode.labels?.size).toBe(2);
+    });
+
+    it('should create CHANNEV mode', () => {
+      const mode = CustomModeBuilder.createChannevMode().build();
+
+      expect(mode.name).toBe('CHANNEV');
+      expect(mode.controls).toHaveLength(24); // 3 rows of 8 encoders
+      expect(mode.labels?.size).toBeGreaterThan(0);
+    });
+  });
+
+  describe('Encoder rows', () => {
+    it('should assign correct control types for each row', () => {
+      const mode = new CustomModeBuilder()
+        .name('ROWS')
+        .addEncoder(1, 1, { cc: 10 }) // Top row
+        .addEncoder(2, 1, { cc: 20 }) // Middle row
+        .addEncoder(3, 1, { cc: 30 }) // Bottom row
+        .build();
+
+      expect(mode.controls[0]).toMatchObject({
+        controlId: 0x10,
+        controlType: 0x05
+      });
+      expect(mode.controls[1]).toMatchObject({
+        controlId: 0x18,
+        controlType: 0x09
+      });
+      expect(mode.controls[2]).toMatchObject({
+        controlId: 0x20,
+        controlType: 0x0D
+      });
+    });
+  });
+});
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

test(launch-control-xl3): add comprehensive custom mode, protocol, and MIDI integration tests

