<!-- Generated by SpecStory -->

# Incomplete Code Review Interrupted Mid-Verification (2025-09-29 06:17:03Z)

<!-- Claude Code Session 1a3cd150-3cd4-444f-b8cf-ca4590f2515b (2025-09-29_06-17-03Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-SPY-HARNESS.md b/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-SPY-HARNESS.md
index 7e877a7..a108edd 100644
--- a/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-SPY-HARNESS.md
+++ b/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-SPY-HARNESS.md
@@ -556,7 +556,36 @@ npm install --save midi jzz-midi-gear
 
 ---
 
-**Document Version**: 1.0
-**Last Updated**: 2024-01-15
+## Progress Update - Session 1
+
+### Completed Tasks
+- ✅ **Workplan Updated**: Changed from man-in-the-middle interception to passive monitoring approach
+- ✅ **Phase 1 Implementation Started**: Created passive MIDI monitoring infrastructure
+  - Created `utils/midi-monitor.ts` - Node.js passive monitor implementation
+  - Created `utils/midi-monitor-web.html` - Web MIDI API monitor
+  - Created `utils/test-midi-monitor.ts` - Test script for verification
+  - Created `utils/monitor-session-analyzer.ts` - Session analysis tool
+
+### Key Discoveries
+- Web editor URL confirmed: `https://components.novationmusic.com/launch-control-xl-3/custom-modes`
+- Passive monitoring approach is simpler and more reliable than interception
+- Core MIDI's hub architecture allows multiple simultaneous listeners
+
+### Next Session Tasks
+1. **Test the monitoring tools** with actual device
+2. **Capture baseline messages** from our library's current implementation
+3. **Begin Phase 2**: Set up Playwright automation for web editor
+4. **Capture web editor messages** for comparison
+
+### Technical Notes
+- Monitor captures all MIDI traffic without interference
+- Supports filtering by device name (e.g., "LCXL3")
+- Logs messages in JSON format with timestamps and hex representation
+- Analyzer tool provides detailed comparison and pattern recognition
+
+---
+
+**Document Version**: 1.1
+**Last Updated**: 2024-01-15 (End of Session 1)
 **Author**: Claude AI Assistant
-**Status**: Draft - Awaiting Approval
\ No newline at end of file
+**Status**: In Progress - Phase 1 Implementation Complete
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/midi-monitor-web.html b/modules/audio-control/modules/launch-control-xl3/utils/midi-monitor-web.html
new file mode 100644
index 0000000..354078c
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/midi-monitor-web.html
@@ -0,0 +1,682 @@
+<!DOCTYPE html>
+<html lang="en">
+<head>
+    <meta charset="UTF-8">
+    <meta name="viewport" content="width=device-width, initial-scale=1.0">
+    <title>MIDI Monitor - Web MIDI API</title>
+    <style>
+        body {
+            font-family: 'Monaco', 'Consolas', monospace;
+            background: #1a1a1a;
+            color: #e0e0e0;
+            margin: 0;
+            padding: 20px;
+            line-height: 1.4;
+        }
+
+        .container {
+            max-width: 1200px;
+            margin: 0 auto;
+        }
+
+        .header {
+            text-align: center;
+            margin-bottom: 30px;
+            border-bottom: 2px solid #333;
+            padding-bottom: 20px;
+        }
+
+        .header h1 {
+            color: #ff6b35;
+            margin: 0;
+            font-size: 2.5em;
+        }
+
+        .header p {
+            color: #888;
+            margin: 10px 0 0 0;
+            font-size: 1.1em;
+        }
+
+        .controls {
+            display: grid;
+            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
+            gap: 20px;
+            margin-bottom: 30px;
+        }
+
+        .control-panel {
+            background: #2a2a2a;
+            border: 1px solid #444;
+            border-radius: 8px;
+            padding: 20px;
+        }
+
+        .control-panel h3 {
+            margin-top: 0;
+            color: #ff6b35;
+            border-bottom: 1px solid #444;
+            padding-bottom: 10px;
+        }
+
+        .btn {
+            background: #ff6b35;
+            color: white;
+            border: none;
+            padding: 10px 20px;
+            border-radius: 5px;
+            cursor: pointer;
+            font-size: 14px;
+            margin: 5px;
+            transition: background 0.3s;
+        }
+
+        .btn:hover {
+            background: #e55a2b;
+        }
+
+        .btn:disabled {
+            background: #666;
+            cursor: not-allowed;
+        }
+
+        .btn.stop {
+            background: #dc3545;
+        }
+
+        .btn.stop:hover {
+            background: #c82333;
+        }
+
+        .btn.clear {
+            background: #6c757d;
+        }
+
+        .btn.clear:hover {
+            background: #5a6268;
+        }
+
+        .status {
+            display: flex;
+            align-items: center;
+            gap: 10px;
+            margin: 10px 0;
+        }
+
+        .status-indicator {
+            width: 12px;
+            height: 12px;
+            border-radius: 50%;
+            background: #dc3545;
+            transition: background 0.3s;
+        }
+
+        .status-indicator.active {
+            background: #28a745;
+            animation: pulse 2s infinite;
+        }
+
+        @keyframes pulse {
+            0% { opacity: 1; }
+            50% { opacity: 0.5; }
+            100% { opacity: 1; }
+        }
+
+        .filter-controls {
+            display: flex;
+            gap: 10px;
+            align-items: center;
+            flex-wrap: wrap;
+        }
+
+        .filter-controls input {
+            background: #333;
+            border: 1px solid #555;
+            color: #e0e0e0;
+            padding: 8px;
+            border-radius: 4px;
+            font-family: inherit;
+        }
+
+        .stats {
+            display: grid;
+            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
+            gap: 10px;
+        }
+
+        .stat-item {
+            background: #333;
+            padding: 10px;
+            border-radius: 4px;
+            text-align: center;
+        }
+
+        .stat-value {
+            font-size: 1.5em;
+            font-weight: bold;
+            color: #ff6b35;
+        }
+
+        .stat-label {
+            font-size: 0.9em;
+            color: #888;
+        }
+
+        .output {
+            background: #000;
+            border: 1px solid #333;
+            border-radius: 8px;
+            padding: 20px;
+            height: 500px;
+            overflow-y: auto;
+            font-family: 'Monaco', 'Consolas', monospace;
+            font-size: 13px;
+            line-height: 1.3;
+        }
+
+        .message {
+            margin: 2px 0;
+            padding: 2px 0;
+        }
+
+        .message.sysex {
+            color: #ff6b35;
+            font-weight: bold;
+        }
+
+        .message.cc {
+            color: #4dabf7;
+        }
+
+        .message.note {
+            color: #51cf66;
+        }
+
+        .message.other {
+            color: #ffd43b;
+        }
+
+        .timestamp {
+            color: #666;
+            margin-right: 10px;
+        }
+
+        .port-name {
+            color: #ff8cc8;
+            margin-right: 10px;
+            display: inline-block;
+            min-width: 200px;
+        }
+
+        .message-type {
+            color: #74c0fc;
+            margin-right: 10px;
+            display: inline-block;
+            min-width: 80px;
+        }
+
+        .hex-data {
+            color: #e0e0e0;
+        }
+
+        .sysex-analysis {
+            color: #888;
+            margin-left: 20px;
+            font-size: 11px;
+        }
+
+        .error {
+            color: #ff4757;
+            background: #2d1b1b;
+            padding: 10px;
+            border-radius: 4px;
+            margin: 10px 0;
+        }
+
+        .ports-list {
+            background: #333;
+            border-radius: 4px;
+            padding: 10px;
+            max-height: 150px;
+            overflow-y: auto;
+        }
+
+        .port-item {
+            padding: 5px;
+            margin: 2px 0;
+            background: #444;
+            border-radius: 3px;
+            font-size: 12px;
+        }
+
+        .port-item.monitoring {
+            background: #1a4c96;
+        }
+    </style>
+</head>
+<body>
+    <div class="container">
+        <div class="header">
+            <h1>🎵 MIDI Monitor</h1>
+            <p>Web MIDI API - Launch Control XL 3 Protocol Analysis</p>
+        </div>
+
+        <div class="controls">
+            <div class="control-panel">
+                <h3>Monitor Control</h3>
+                <div class="status">
+                    <div class="status-indicator" id="statusIndicator"></div>
+                    <span id="statusText">Not Connected</span>
+                </div>
+                <button class="btn" id="startBtn" onclick="startMonitoring()">Start Monitoring</button>
+                <button class="btn stop" id="stopBtn" onclick="stopMonitoring()" disabled>Stop Monitoring</button>
+                <button class="btn clear" onclick="clearOutput()">Clear Output</button>
+            </div>
+
+            <div class="control-panel">
+                <h3>Filter Settings</h3>
+                <div class="filter-controls">
+                    <label>Device Filter:</label>
+                    <input type="text" id="deviceFilter" placeholder="e.g., LCXL3" value="LCXL3">
+                    <button class="btn" onclick="applyFilter()">Apply</button>
+                </div>
+                <label>
+                    <input type="checkbox" id="captureAll" checked> Monitor All Ports
+                </label>
+            </div>
+
+            <div class="control-panel">
+                <h3>Statistics</h3>
+                <div class="stats">
+                    <div class="stat-item">
+                        <div class="stat-value" id="totalMessages">0</div>
+                        <div class="stat-label">Total</div>
+                    </div>
+                    <div class="stat-item">
+                        <div class="stat-value" id="sysexMessages">0</div>
+                        <div class="stat-label">SysEx</div>
+                    </div>
+                    <div class="stat-item">
+                        <div class="stat-value" id="ccMessages">0</div>
+                        <div class="stat-label">CC</div>
+                    </div>
+                    <div class="stat-item">
+                        <div class="stat-value" id="noteMessages">0</div>
+                        <div class="stat-label">Notes</div>
+                    </div>
+                </div>
+            </div>
+
+            <div class="control-panel">
+                <h3>Available Ports</h3>
+                <div class="ports-list" id="portsList">
+                    <div class="error">Web MIDI API not initialized</div>
+                </div>
+            </div>
+        </div>
+
+        <div class="control-panel">
+            <h3>MIDI Messages</h3>
+            <div class="output" id="output">
+                <div style="color: #666; text-align: center; margin-top: 200px;">
+                    🔍 Waiting for MIDI messages...<br>
+                    💡 Use the Novation web editor to generate traffic<br>
+                    📡 https://components.novationmusic.com/launch-control-xl-3/custom-modes
+                </div>
+            </div>
+        </div>
+
+        <div class="control-panel">
+            <h3>Session Management</h3>
+            <button class="btn" onclick="downloadSession()">Download Session JSON</button>
+            <button class="btn clear" onclick="clearSession()">Clear Session</button>
+            <div style="margin-top: 10px; color: #888; font-size: 12px;">
+                Session ID: <span id="sessionId">-</span>
+            </div>
+        </div>
+    </div>
+
+    <script>
+        class WebMidiMonitor {
+            constructor() {
+                this.midiAccess = null;
+                this.monitoredPorts = new Map();
+                this.capturedMessages = [];
+                this.isMonitoring = false;
+                this.sessionId = this.generateSessionId();
+                this.startTime = null;
+                this.deviceFilter = 'LCXL3';
+                this.stats = {
+                    total: 0,
+                    sysex: 0,
+                    cc: 0,
+                    notes: 0,
+                    other: 0
+                };
+
+                document.getElementById('sessionId').textContent = this.sessionId;
+                this.initWebMidiAPI();
+            }
+
+            async initWebMidiAPI() {
+                try {
+                    if (!navigator.requestMIDIAccess) {
+                        throw new Error('Web MIDI API not supported in this browser');
+                    }
+
+                    this.midiAccess = await navigator.requestMIDIAccess({ sysex: true });
+                    this.updatePortsList();
+                    this.log('✅ Web MIDI API initialized successfully');
+
+                    // Listen for port changes
+                    this.midiAccess.onstatechange = () => {
+                        this.updatePortsList();
+                    };
+
+                } catch (error) {
+                    this.logError(`❌ Failed to initialize Web MIDI API: ${error.message}`);
+                }
+            }
+
+            updatePortsList() {
+                const portsList = document.getElementById('portsList');
+                const inputs = Array.from(this.midiAccess.inputs.values());
+
+                if (inputs.length === 0) {
+                    portsList.innerHTML = '<div class="error">No MIDI input ports available</div>';
+                    return;
+                }
+
+                portsList.innerHTML = '';
+                inputs.forEach(port => {
+                    const div = document.createElement('div');
+                    div.className = 'port-item';
+                    if (this.monitoredPorts.has(port.id)) {
+                        div.className += ' monitoring';
+                    }
+
+                    div.innerHTML = `
+                        <strong>${port.name}</strong><br>
+                        <small>ID: ${port.id} | State: ${port.state}</small>
+                    `;
+                    portsList.appendChild(div);
+                });
+            }
+
+            async startMonitoring() {
+                if (this.isMonitoring) return;
+
+                try {
+                    if (!this.midiAccess) {
+                        throw new Error('Web MIDI API not initialized');
+                    }
+
+                    const inputs = Array.from(this.midiAccess.inputs.values());
+                    const captureAll = document.getElementById('captureAll').checked;
+                    const filter = document.getElementById('deviceFilter').value.trim();
+
+                    let portsToMonitor = inputs;
+                    if (!captureAll && filter) {
+                        portsToMonitor = inputs.filter(port =>
+                            port.name.toLowerCase().includes(filter.toLowerCase())
+                        );
+                    }
+
+                    if (portsToMonitor.length === 0) {
+                        throw new Error(`No ports found${filter ? ` matching filter "${filter}"` : ''}`);
+                    }
+
+                    this.isMonitoring = true;
+                    this.startTime = Date.now();
+                    this.deviceFilter = filter;
+
+                    // Start monitoring each port
+                    for (const port of portsToMonitor) {
+                        await this.monitorPort(port);
+                    }
+
+                    this.updateUI();
+                    this.log(`🎯 Monitoring ${portsToMonitor.length} port(s)`);
+                    this.log('🔍 Passive monitoring active...');
+
+                } catch (error) {
+                    this.logError(`❌ Failed to start monitoring: ${error.message}`);
+                    this.isMonitoring = false;
+                }
+            }
+
+            async monitorPort(port) {
+                try {
+                    await port.open();
+                    this.monitoredPorts.set(port.id, port);
+
+                    port.onmidimessage = (event) => {
+                        this.handleMidiMessage(port.name, event);
+                    };
+
+                    this.log(`✅ Started monitoring: ${port.name}`);
+                } catch (error) {
+                    this.logError(`❌ Failed to monitor port ${port.name}: ${error.message}`);
+                }
+            }
+
+            handleMidiMessage(portName, event) {
+                const timestamp = event.timeStamp || Date.now();
+                const data = Array.from(event.data);
+                const messageType = this.identifyMessageType(data);
+
+                const message = {
+                    timestamp,
+                    portName,
+                    messageType,
+                    rawData: data,
+                    hexData: data.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ')
+                };
+
+                this.capturedMessages.push(message);
+                this.updateStats(messageType);
+                this.displayMessage(message);
+            }
+
+            identifyMessageType(data) {
+                if (data.length === 0) return 'empty';
+
+                const statusByte = data[0];
+
+                if (statusByte === 0xF0) return 'sysex';
+
+                const messageType = statusByte & 0xF0;
+                switch (messageType) {
+                    case 0xB0: return 'cc';
+                    case 0x90: return 'noteon';
+                    case 0x80: return 'noteoff';
+                    case 0xE0: return 'pitch';
+                    case 0xC0: return 'program';
+                    case 0xA0: return 'poly_aftertouch';
+                    case 0xD0: return 'channel_aftertouch';
+                    default: return 'other';
+                }
+            }
+
+            updateStats(messageType) {
+                this.stats.total++;
+
+                if (messageType === 'sysex') this.stats.sysex++;
+                else if (messageType === 'cc') this.stats.cc++;
+                else if (messageType === 'noteon' || messageType === 'noteoff') this.stats.notes++;
+                else this.stats.other++;
+
+                document.getElementById('totalMessages').textContent = this.stats.total;
+                document.getElementById('sysexMessages').textContent = this.stats.sysex;
+                document.getElementById('ccMessages').textContent = this.stats.cc;
+                document.getElementById('noteMessages').textContent = this.stats.notes;
+            }
+
+            displayMessage(message) {
+                const output = document.getElementById('output');
+                const timeStr = new Date(message.timestamp).toISOString().split('T')[1]?.split('.')[0] || '';
+
+                const messageDiv = document.createElement('div');
+                messageDiv.className = `message ${message.messageType}`;
+
+                let content = `<span class="timestamp">${timeStr}</span>`;
+                content += `<span class="port-name">[${message.portName}]</span>`;
+                content += `<span class="message-type">${message.messageType}</span>`;
+                content += `<span class="hex-data">${message.hexData}</span>`;
+
+                // Special handling for SysEx messages
+                if (message.messageType === 'sysex' && message.rawData.length >= 3) {
+                    const manufacturerId = message.rawData.slice(1, 3);
+                    const manIdHex = manufacturerId.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
+                    content += `<br><span class="sysex-analysis">└─ Manufacturer ID: ${manIdHex} | Length: ${message.rawData.length} bytes</span>`;
+                }
+
+                messageDiv.innerHTML = content;
+                output.appendChild(messageDiv);
+
+                // Auto-scroll to bottom
+                output.scrollTop = output.scrollHeight;
+
+                // Limit output to prevent memory issues
+                if (output.children.length > 1000) {
+                    output.removeChild(output.firstChild);
+                }
+            }
+
+            async stopMonitoring() {
+                if (!this.isMonitoring) return;
+
+                this.log('⏹️ Stopping MIDI monitor...');
+
+                for (const [portId, port] of this.monitoredPorts) {
+                    try {
+                        port.onmidimessage = null;
+                        await port.close();
+                    } catch (error) {
+                        this.logError(`❌ Error closing port: ${error.message}`);
+                    }
+                }
+
+                this.monitoredPorts.clear();
+                this.isMonitoring = false;
+                this.updateUI();
+                this.updatePortsList();
+
+                this.log(`💾 Session complete: ${this.capturedMessages.length} messages captured`);
+            }
+
+            updateUI() {
+                const statusIndicator = document.getElementById('statusIndicator');
+                const statusText = document.getElementById('statusText');
+                const startBtn = document.getElementById('startBtn');
+                const stopBtn = document.getElementById('stopBtn');
+
+                if (this.isMonitoring) {
+                    statusIndicator.classList.add('active');
+                    statusText.textContent = `Monitoring ${this.monitoredPorts.size} port(s)`;
+                    startBtn.disabled = true;
+                    stopBtn.disabled = false;
+                } else {
+                    statusIndicator.classList.remove('active');
+                    statusText.textContent = 'Not Monitoring';
+                    startBtn.disabled = false;
+                    stopBtn.disabled = true;
+                }
+            }
+
+            clearOutput() {
+                document.getElementById('output').innerHTML = '<div style="color: #666; text-align: center; margin-top: 200px;">🔍 Output cleared - waiting for MIDI messages...</div>';
+            }
+
+            clearSession() {
+                this.capturedMessages = [];
+                this.stats = { total: 0, sysex: 0, cc: 0, notes: 0, other: 0 };
+                this.sessionId = this.generateSessionId();
+                document.getElementById('sessionId').textContent = this.sessionId;
+                this.updateStats('');
+                this.clearOutput();
+                this.log('🗑️ Session cleared');
+            }
+
+            downloadSession() {
+                const session = {
+                    sessionId: this.sessionId,
+                    startTime: this.startTime,
+                    endTime: Date.now(),
+                    deviceFilter: this.deviceFilter,
+                    messages: this.capturedMessages,
+                    statistics: this.stats,
+                    platform: 'web-midi-api'
+                };
+
+                const blob = new Blob([JSON.stringify(session, null, 2)], { type: 'application/json' });
+                const url = URL.createObjectURL(blob);
+                const a = document.createElement('a');
+                a.href = url;
+                a.download = `midi-session-${this.sessionId}.json`;
+                document.body.appendChild(a);
+                a.click();
+                document.body.removeChild(a);
+                URL.revokeObjectURL(url);
+
+                this.log(`📁 Session downloaded: midi-session-${this.sessionId}.json`);
+            }
+
+            log(message) {
+                console.log(message);
+                // Optionally display in UI
+            }
+
+            logError(message) {
+                console.error(message);
+                const output = document.getElementById('output');
+                const errorDiv = document.createElement('div');
+                errorDiv.className = 'error';
+                errorDiv.textContent = message;
+                output.appendChild(errorDiv);
+                output.scrollTop = output.scrollHeight;
+            }
+
+            generateSessionId() {
+                const timestamp = Date.now().toString(36);
+                const random = Math.random().toString(36).substring(2, 8);
+                return `${timestamp}-${random}`;
+            }
+        }
+
+        // Global instance
+        let monitor;
+
+        // Initialize when page loads
+        document.addEventListener('DOMContentLoaded', () => {
+            monitor = new WebMidiMonitor();
+        });
+
+        // Global functions for UI
+        function startMonitoring() {
+            monitor.startMonitoring();
+        }
+
+        function stopMonitoring() {
+            monitor.stopMonitoring();
+        }
+
+        function clearOutput() {
+            monitor.clearOutput();
+        }
+
+        function clearSession() {
+            monitor.clearSession();
+        }
+
+        function downloadSession() {
+            monitor.downloadSession();
+        }
+
+        function applyFilter() {
+            // Filter will be applied on next start
+            console.log('Filter will be applied when monitoring starts');
+        }
+    </script>
+</body>
+</html>
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/midi-monitor.ts b/modules/audio-control/modules/launch-control-xl3/utils/midi-monitor.ts
new file mode 100755
index 0000000..d9d38ad
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/midi-monitor.ts
@@ -0,0 +1,426 @@
+#!/usr/bin/env tsx
+
+/**
+ * MIDI Monitor - Phase 1 Passive MIDI Monitoring Tool
+ *
+ * This tool implements passive MIDI monitoring to capture all MIDI traffic
+ * for reverse-engineering the Launch Control XL 3 protocol.
+ *
+ * Features:
+ * - Monitors all available MIDI input ports simultaneously
+ * - Focuses on SysEx messages but captures all MIDI data
+ * - Supports device filtering (e.g., "LCXL3")
+ * - Saves captured sessions to JSON for analysis
+ * - Real-time console output with hex formatting
+ * - Non-intrusive passive monitoring
+ */
+
+import * as easymidi from 'easymidi';
+import { writeFileSync, existsSync, mkdirSync } from 'fs';
+import { join } from 'path';
+// Using local type definitions to avoid import issues
+
+// Configuration interface
+interface MonitorConfig {
+  readonly deviceFilter?: string;
+  readonly outputDir?: string;
+  readonly sessionName?: string;
+  readonly captureAllPorts?: boolean;
+  readonly verboseLogging?: boolean;
+  readonly bufferMessages?: boolean;
+}
+
+// Captured message with metadata
+interface CapturedMessage {
+  readonly timestamp: number;
+  readonly portName: string;
+  readonly messageType: string;
+  readonly rawData: readonly number[];
+  readonly hexData: string;
+  readonly parsedData?: any;
+}
+
+// Monitor session data
+interface MonitorSession {
+  readonly sessionId: string;
+  readonly startTime: number;
+  readonly endTime?: number;
+  readonly config: MonitorConfig;
+  readonly messages: readonly CapturedMessage[];
+  readonly portsCaptured: readonly string[];
+  readonly statistics: {
+    readonly totalMessages: number;
+    readonly sysexMessages: number;
+    readonly ccMessages: number;
+    readonly noteMessages: number;
+    readonly otherMessages: number;
+  };
+}
+
+export class MidiMonitor {
+  private readonly config: MonitorConfig;
+  private readonly inputs: Map<string, easymidi.Input> = new Map();
+  private readonly capturedMessages: CapturedMessage[] = [];
+  private sessionId: string;
+  private startTime: number = 0;
+  private isRunning = false;
+
+  constructor(config: MonitorConfig = {}) {
+    this.config = {
+      deviceFilter: undefined,
+      outputDir: './midi-captures',
+      sessionName: undefined,
+      captureAllPorts: true,
+      verboseLogging: false,
+      bufferMessages: true,
+      ...config,
+    };
+
+    this.sessionId = this.generateSessionId();
+  }
+
+  /**
+   * Start passive monitoring of MIDI ports
+   */
+  async startMonitoring(): Promise<void> {
+    if (this.isRunning) {
+      throw new Error('Monitor is already running');
+    }
+
+    console.log('🎵 Starting MIDI Monitor - Phase 1 Passive Monitoring');
+    console.log('═'.repeat(60));
+
+    // Get available input ports
+    const availablePorts = easymidi.getInputs();
+    console.log(`📡 Available MIDI input ports: ${availablePorts.length}`);
+
+    if (availablePorts.length === 0) {
+      throw new Error('No MIDI input ports available');
+    }
+
+    // Filter ports if device filter is specified
+    const portsToMonitor = this.config.deviceFilter
+      ? availablePorts.filter(port =>
+          port.toLowerCase().includes(this.config.deviceFilter!.toLowerCase())
+        )
+      : availablePorts;
+
+    if (portsToMonitor.length === 0) {
+      const filterMsg = this.config.deviceFilter
+        ? ` matching filter "${this.config.deviceFilter}"`
+        : '';
+      throw new Error(`No MIDI input ports found${filterMsg}`);
+    }
+
+    console.log(`🎯 Monitoring ${portsToMonitor.length} port(s):`);
+    portsToMonitor.forEach((port, i) => {
+      console.log(`   ${i + 1}. ${port}`);
+    });
+
+    // Start monitoring each port
+    this.startTime = Date.now();
+    this.isRunning = true;
+
+    for (const portName of portsToMonitor) {
+      await this.monitorPort(portName);
+    }
+
+    console.log('\n🔍 Passive monitoring active...');
+    console.log('💡 Use Novation web editor to generate traffic');
+    console.log('⏹️  Press Ctrl+C to stop and save session');
+    console.log('─'.repeat(60));
+
+    // Set up graceful shutdown
+    this.setupGracefulShutdown();
+  }
+
+  /**
+   * Monitor a specific MIDI port
+   */
+  private async monitorPort(portName: string): Promise<void> {
+    try {
+      const input = new easymidi.Input(portName);
+      this.inputs.set(portName, input);
+
+      // Monitor all MIDI message types
+      this.setupMessageHandlers(input, portName);
+
+      if (this.config.verboseLogging) {
+        console.log(`✅ Started monitoring: ${portName}`);
+      }
+    } catch (error: any) {
+      console.error(`❌ Failed to monitor port ${portName}: ${error.message}`);
+    }
+  }
+
+  /**
+   * Set up message handlers for all MIDI message types
+   */
+  private setupMessageHandlers(input: easymidi.Input, portName: string): void {
+    // SysEx messages (most important for protocol reverse-engineering)
+    input.on('sysex', (msg: any) => {
+      this.captureMessage(portName, 'sysex', msg.bytes || msg.data || [], msg);
+    });
+
+    // Control Change messages
+    input.on('cc', (msg: any) => {
+      const data = [0xB0 | (msg.channel || 0), msg.controller || 0, msg.value || 0];
+      this.captureMessage(portName, 'cc', data, msg);
+    });
+
+    // Note On/Off messages
+    input.on('noteon', (msg: any) => {
+      const data = [0x90 | (msg.channel || 0), msg.note || 0, msg.velocity || 0];
+      this.captureMessage(portName, 'noteon', data, msg);
+    });
+
+    input.on('noteoff', (msg: any) => {
+      const data = [0x80 | (msg.channel || 0), msg.note || 0, msg.velocity || 0];
+      this.captureMessage(portName, 'noteoff', data, msg);
+    });
+
+    // Program Change messages
+    input.on('program', (msg: any) => {
+      const data = [0xC0 | (msg.channel || 0), msg.number || 0];
+      this.captureMessage(portName, 'program', data, msg);
+    });
+
+    // Pitch Bend messages
+    input.on('pitch', (msg: any) => {
+      const lsb = (msg.value || 0) & 0x7F;
+      const msb = ((msg.value || 0) >> 7) & 0x7F;
+      const data = [0xE0 | (msg.channel || 0), lsb, msb];
+      this.captureMessage(portName, 'pitch', data, msg);
+    });
+
+    // Aftertouch messages
+    // Aftertouch messages (not all MIDI libraries support these events)
+    try {
+      input.on('poly aftertouch' as any, (msg: any) => {
+        const data = [0xA0 | (msg.channel || 0), msg.note || 0, msg.pressure || 0];
+        this.captureMessage(portName, 'poly_aftertouch', data, msg);
+      });
+    } catch (e) {
+      // Ignore if not supported
+    }
+
+    try {
+      input.on('channel aftertouch' as any, (msg: any) => {
+        const data = [0xD0 | (msg.channel || 0), msg.pressure || 0];
+        this.captureMessage(portName, 'channel_aftertouch', data, msg);
+      });
+    } catch (e) {
+      // Ignore if not supported
+    }
+  }
+
+  /**
+   * Capture and process a MIDI message
+   */
+  private captureMessage(
+    portName: string,
+    messageType: string,
+    rawData: number[],
+    parsedData: any
+  ): void {
+    const timestamp = Date.now();
+    const hexData = rawData.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
+
+    const capturedMessage: CapturedMessage = {
+      timestamp,
+      portName,
+      messageType,
+      rawData: Object.freeze([...rawData]),
+      hexData,
+      parsedData: { ...parsedData },
+    };
+
+    // Buffer message if enabled
+    if (this.config.bufferMessages) {
+      this.capturedMessages.push(capturedMessage);
+    }
+
+    // Real-time console output
+    this.logMessage(capturedMessage);
+  }
+
+  /**
+   * Log message to console with formatting
+   */
+  private logMessage(message: CapturedMessage): void {
+    const timeStr = new Date(message.timestamp).toISOString().split('T')[1]?.split('.')[0] || '';
+    const portStr = message.portName.padEnd(20);
+    const typeStr = message.messageType.padEnd(12);
+
+    if (message.messageType === 'sysex') {
+      // Highlight SysEx messages - these are critical for protocol analysis
+      console.log(`🔥 ${timeStr} [${portStr}] ${typeStr} ${message.hexData}`);
+
+      // Additional SysEx analysis
+      if (message.rawData.length >= 3) {
+        const manufacturerId = message.rawData.slice(1, 3);
+        const manIdHex = manufacturerId.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
+        console.log(`   └─ Manufacturer ID: ${manIdHex} | Length: ${message.rawData.length} bytes`);
+      }
+    } else {
+      console.log(`   ${timeStr} [${portStr}] ${typeStr} ${message.hexData}`);
+    }
+  }
+
+  /**
+   * Stop monitoring and save session
+   */
+  async stopMonitoring(): Promise<MonitorSession> {
+    if (!this.isRunning) {
+      throw new Error('Monitor is not running');
+    }
+
+    console.log('\n⏹️  Stopping MIDI monitor...');
+
+    // Close all input ports
+    for (const [portName, input] of Array.from(this.inputs.entries())) {
+      try {
+        input.close();
+        if (this.config.verboseLogging) {
+          console.log(`✅ Closed port: ${portName}`);
+        }
+      } catch (error: any) {
+        console.error(`❌ Error closing port ${portName}: ${error.message}`);
+      }
+    }
+
+    this.inputs.clear();
+    this.isRunning = false;
+
+    // Create session data
+    const session = this.createSession();
+
+    // Save session to file
+    await this.saveSession(session);
+
+    console.log(`💾 Session saved: ${session.sessionId}`);
+    console.log(`📊 Captured ${session.messages.length} messages total`);
+    console.log(`   SysEx: ${session.statistics.sysexMessages}`);
+    console.log(`   CC: ${session.statistics.ccMessages}`);
+    console.log(`   Notes: ${session.statistics.noteMessages}`);
+    console.log(`   Other: ${session.statistics.otherMessages}`);
+
+    return session;
+  }
+
+  /**
+   * Create session data structure
+   */
+  private createSession(): MonitorSession {
+    const endTime = Date.now();
+    const portsCaptured = Array.from(new Set(this.capturedMessages.map(m => m.portName)));
+
+    // Calculate statistics
+    const sysexMessages = this.capturedMessages.filter(m => m.messageType === 'sysex').length;
+    const ccMessages = this.capturedMessages.filter(m => m.messageType === 'cc').length;
+    const noteMessages = this.capturedMessages.filter(m =>
+      m.messageType === 'noteon' || m.messageType === 'noteoff'
+    ).length;
+    const otherMessages = this.capturedMessages.length - sysexMessages - ccMessages - noteMessages;
+
+    return {
+      sessionId: this.sessionId,
+      startTime: this.startTime,
+      endTime,
+      config: this.config,
+      messages: Object.freeze([...this.capturedMessages]),
+      portsCaptured: Object.freeze([...portsCaptured]),
+      statistics: {
+        totalMessages: this.capturedMessages.length,
+        sysexMessages,
+        ccMessages,
+        noteMessages,
+        otherMessages,
+      },
+    };
+  }
+
+  /**
+   * Save session to JSON file
+   */
+  private async saveSession(session: MonitorSession): Promise<void> {
+    const outputDir = this.config.outputDir || './midi-captures';
+
+    // Ensure output directory exists
+    if (!existsSync(outputDir)) {
+      mkdirSync(outputDir, { recursive: true });
+    }
+
+    const sessionName = this.config.sessionName || `midi-session-${session.sessionId}`;
+    const filename = `${sessionName}.json`;
+    const filePath = join(outputDir, filename);
+
+    try {
+      const json = JSON.stringify(session, null, 2);
+      writeFileSync(filePath, json, 'utf8');
+      console.log(`💾 Session saved to: ${filePath}`);
+    } catch (error: any) {
+      console.error(`❌ Failed to save session: ${error.message}`);
+      throw error;
+    }
+  }
+
+  /**
+   * Generate unique session ID
+   */
+  private generateSessionId(): string {
+    const timestamp = Date.now().toString(36);
+    const random = Math.random().toString(36).substring(2, 8);
+    return `${timestamp}-${random}`;
+  }
+
+  /**
+   * Set up graceful shutdown on Ctrl+C
+   */
+  private setupGracefulShutdown(): void {
+    process.on('SIGINT', async () => {
+      console.log('\n🛑 Received shutdown signal...');
+      try {
+        await this.stopMonitoring();
+        process.exit(0);
+      } catch (error: any) {
+        console.error(`❌ Error during shutdown: ${error.message}`);
+        process.exit(1);
+      }
+    });
+  }
+
+  /**
+   * Get current capture statistics
+   */
+  getCurrentStats(): { messageCount: number; portCount: number; isRunning: boolean } {
+    return {
+      messageCount: this.capturedMessages.length,
+      portCount: this.inputs.size,
+      isRunning: this.isRunning,
+    };
+  }
+}
+
+// CLI interface when run directly
+if (process.argv[1] && process.argv[1].endsWith('midi-monitor.ts')) {
+  const args = process.argv.slice(2);
+  const deviceFilter = args.find(arg => arg.startsWith('--device='))?.split('=')[1];
+  const outputDir = args.find(arg => arg.startsWith('--output='))?.split('=')[1];
+  const sessionName = args.find(arg => arg.startsWith('--session='))?.split('=')[1];
+  const verbose = args.includes('--verbose');
+
+  const config: MonitorConfig = {
+    deviceFilter,
+    outputDir,
+    sessionName,
+    verboseLogging: verbose,
+  };
+
+  const monitor = new MidiMonitor(config);
+
+  monitor.startMonitoring().catch((error: any) => {
+    console.error(`❌ Failed to start monitor: ${error.message}`);
+    process.exit(1);
+  });
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/monitor-session-analyzer.ts b/modules/audio-control/modules/launch-control-xl3/utils/monitor-session-analyzer.ts
new file mode 100755
index 0000000..6eb1bf9
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/monitor-session-analyzer.ts
@@ -0,0 +1,551 @@
+#!/usr/bin/env tsx
+
+/**
+ * MIDI Monitor Session Analyzer
+ *
+ * Analyzes captured MIDI sessions to extract protocol patterns,
+ * identify SysEx message structures, and help reverse-engineer
+ * the Launch Control XL 3 communication protocol.
+ */
+
+import { readFileSync, writeFileSync, existsSync } from 'fs';
+import { basename, extname, join } from 'path';
+
+// Type definitions for captured session data
+interface CapturedMessage {
+  readonly timestamp: number;
+  readonly portName: string;
+  readonly messageType: string;
+  readonly rawData: readonly number[];
+  readonly hexData: string;
+  readonly parsedData?: any;
+}
+
+interface MonitorSession {
+  readonly sessionId: string;
+  readonly startTime: number;
+  readonly endTime?: number;
+  readonly config?: any;
+  readonly messages: readonly CapturedMessage[];
+  readonly portsCaptured: readonly string[];
+  readonly statistics?: any;
+}
+
+// Analysis result types
+interface SysExPattern {
+  readonly pattern: string;
+  readonly count: number;
+  readonly examples: readonly CapturedMessage[];
+  readonly analysis: {
+    readonly manufacturerId?: string;
+    readonly deviceId?: string;
+    readonly command?: string;
+    readonly dataLength?: number;
+    readonly description?: string;
+    readonly manufacturer?: string;
+    readonly device?: string;
+  };
+}
+
+interface ProtocolAnalysis {
+  readonly sessionId: string;
+  readonly messageCount: number;
+  readonly timeSpan: number;
+  readonly sysexPatterns: readonly SysExPattern[];
+  readonly ccPatterns: readonly any[];
+  readonly timing: {
+    readonly averageInterval: number;
+    readonly burstPatterns: readonly any[];
+  };
+  readonly novationMessages: readonly CapturedMessage[];
+  readonly unknownMessages: readonly CapturedMessage[];
+}
+
+class MonitorSessionAnalyzer {
+  private readonly knownManufacturers = new Map([
+    ['00 20 29', 'Novation Digital Music Systems'],
+    ['7E', 'Universal Non-Real Time'],
+    ['7F', 'Universal Real Time'],
+    ['43', 'Yamaha'],
+    ['41', 'Roland'],
+    ['47', 'Akai'],
+  ]);
+
+  private readonly novationDevices = new Map([
+    ['02 11', 'Launch Control XL 3'],
+    ['02 0C', 'Launchpad X'],
+    ['02 0D', 'Launchpad Mini MK3'],
+    ['02 0E', 'Launchkey Mini MK3'],
+  ]);
+
+  constructor() {}
+
+  /**
+   * Analyze a captured MIDI session
+   */
+  async analyzeSession(sessionPath: string): Promise<ProtocolAnalysis> {
+    console.log(`🔬 Analyzing MIDI session: ${basename(sessionPath)}`);
+    console.log('─'.repeat(60));
+
+    // Load session data
+    const session = this.loadSession(sessionPath);
+    console.log(`📊 Session contains ${session.messages.length} messages`);
+
+    if (session.messages.length === 0) {
+      throw new Error('Session contains no messages to analyze');
+    }
+
+    // Perform analysis
+    const analysis = this.performAnalysis(session);
+
+    // Display results
+    this.displayAnalysis(analysis);
+
+    // Save analysis results
+    const outputPath = this.saveAnalysis(sessionPath, analysis);
+    console.log(`💾 Analysis saved to: ${outputPath}`);
+
+    return analysis;
+  }
+
+  /**
+   * Load session data from JSON file
+   */
+  private loadSession(sessionPath: string): MonitorSession {
+    if (!existsSync(sessionPath)) {
+      throw new Error(`Session file not found: ${sessionPath}`);
+    }
+
+    try {
+      const content = readFileSync(sessionPath, 'utf8');
+      const session = JSON.parse(content) as MonitorSession;
+
+      if (!session.messages || !Array.isArray(session.messages)) {
+        throw new Error('Invalid session format: missing or invalid messages array');
+      }
+
+      return session;
+    } catch (error: any) {
+      throw new Error(`Failed to load session: ${error.message}`);
+    }
+  }
+
+  /**
+   * Perform comprehensive protocol analysis
+   */
+  private performAnalysis(session: MonitorSession): ProtocolAnalysis {
+    console.log('🔍 Analyzing message patterns...');
+
+    const sysexMessages = session.messages.filter(m => m.messageType === 'sysex');
+    const ccMessages = session.messages.filter(m => m.messageType === 'cc');
+
+    console.log(`   Found ${sysexMessages.length} SysEx messages`);
+    console.log(`   Found ${ccMessages.length} CC messages`);
+
+    // Analyze SysEx patterns
+    const sysexPatterns = this.analyzeSysExPatterns(sysexMessages);
+
+    // Analyze CC patterns
+    const ccPatterns = this.analyzeCCPatterns(ccMessages);
+
+    // Find Novation-specific messages
+    const novationMessages = this.findNovationMessages(session.messages);
+
+    // Analyze timing
+    const timing = this.analyzeMessageTiming(session.messages);
+
+    // Find unknown/unidentified messages
+    const unknownMessages = this.findUnknownMessages(session.messages);
+
+    const timeSpan = session.endTime && session.startTime
+      ? session.endTime - session.startTime
+      : 0;
+
+    return {
+      sessionId: session.sessionId,
+      messageCount: session.messages.length,
+      timeSpan,
+      sysexPatterns,
+      ccPatterns,
+      timing,
+      novationMessages,
+      unknownMessages,
+    };
+  }
+
+  /**
+   * Analyze SysEx message patterns
+   */
+  private analyzeSysExPatterns(messages: readonly CapturedMessage[]): SysExPattern[] {
+    const patterns = new Map<string, CapturedMessage[]>();
+
+    // Group messages by their command structure
+    for (const message of messages) {
+      if (message.rawData.length < 3) continue;
+
+      // Create pattern based on first few bytes (manufacturer + device + command)
+      const patternBytes = message.rawData.slice(0, Math.min(7, message.rawData.length));
+      const pattern = patternBytes.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' ');
+
+      if (!patterns.has(pattern)) {
+        patterns.set(pattern, []);
+      }
+      patterns.get(pattern)!.push(message);
+    }
+
+    // Convert to analysis results
+    return Array.from(patterns.entries()).map(([pattern, examples]) => {
+      const firstExample = examples[0]!;
+      const analysis = this.analyzeSysExMessage(firstExample);
+
+      return {
+        pattern,
+        count: examples.length,
+        examples: examples.slice(0, 3), // Keep first 3 examples
+        analysis,
+      };
+    }).sort((a, b) => b.count - a.count); // Sort by frequency
+  }
+
+  /**
+   * Analyze individual SysEx message
+   */
+  private analyzeSysExMessage(message: CapturedMessage): any {
+    const data = message.rawData;
+    if (data.length < 3) return { description: 'Invalid SysEx message' };
+
+    const analysis: any = {
+      dataLength: data.length,
+    };
+
+    // Manufacturer ID analysis
+    if (data[1] !== undefined && data[2] !== undefined) {
+      const manId = `${data[1].toString(16).padStart(2, '0')} ${data[2].toString(16).padStart(2, '0')}`.toUpperCase();
+      analysis.manufacturerId = manId;
+
+      const manufacturer = this.knownManufacturers.get(manId);
+      if (manufacturer) {
+        (analysis as any).manufacturer = manufacturer;
+      }
+
+      // Novation-specific analysis
+      if (manId === '00 20 29' && data.length >= 6) {
+        const deviceId = `${data[4].toString(16).padStart(2, '0')} ${data[5].toString(16).padStart(2, '0')}`.toUpperCase();
+        analysis.deviceId = deviceId;
+
+        const device = this.novationDevices.get(deviceId);
+        if (device) {
+          (analysis as any).device = device;
+        }
+
+        // Command analysis for Launch Control XL 3
+        if (deviceId === '02 11' && data.length >= 7) {
+          analysis.command = '0x' + data[6].toString(16).padStart(2, '0');
+          analysis.description = this.interpretLCXL3Command(data[6], data);
+        }
+      }
+    }
+
+    return analysis;
+  }
+
+  /**
+   * Interpret Launch Control XL 3 specific commands
+   */
+  private interpretLCXL3Command(command: number, data: readonly number[]): string {
+    switch (command) {
+      case 0x77:
+        return 'Device inquiry/handshake';
+      case 0x78:
+        return 'Device response/identification';
+      case 0x01:
+        return 'Custom mode data request';
+      case 0x02:
+        return 'Custom mode data response';
+      case 0x11:
+        return 'Write custom mode data';
+      case 0x12:
+        return 'Read custom mode data';
+      case 0x20:
+        return 'LED control/animation';
+      case 0x21:
+        return 'LED state update';
+      case 0x40:
+        return 'Control name assignment';
+      case 0x41:
+        return 'Control name response';
+      default:
+        return `Unknown command (0x${command.toString(16).padStart(2, '0')})`;
+    }
+  }
+
+  /**
+   * Analyze Control Change patterns
+   */
+  private analyzeCCPatterns(messages: readonly CapturedMessage[]): any[] {
+    const ccNumbers = new Map<number, CapturedMessage[]>();
+
+    for (const message of messages) {
+      if (message.parsedData?.controller !== undefined) {
+        const cc = message.parsedData.controller;
+        if (!ccNumbers.has(cc)) {
+          ccNumbers.set(cc, []);
+        }
+        ccNumbers.get(cc)!.push(message);
+      }
+    }
+
+    return Array.from(ccNumbers.entries()).map(([ccNumber, messages]) => ({
+      ccNumber,
+      count: messages.length,
+      valueRange: this.getValueRange(messages),
+      examples: messages.slice(0, 3),
+    })).sort((a, b) => b.count - a.count);
+  }
+
+  /**
+   * Get value range for CC messages
+   */
+  private getValueRange(messages: readonly CapturedMessage[]): { min: number; max: number } {
+    const values = messages
+      .map(m => m.parsedData?.value)
+      .filter(v => typeof v === 'number');
+
+    return {
+      min: Math.min(...values),
+      max: Math.max(...values),
+    };
+  }
+
+  /**
+   * Find messages from Novation devices
+   */
+  private findNovationMessages(messages: readonly CapturedMessage[]): CapturedMessage[] {
+    return messages.filter(message => {
+      if (message.messageType === 'sysex' && message.rawData.length >= 3) {
+        const manId = `${message.rawData[1]?.toString(16).padStart(2, '0')} ${message.rawData[2]?.toString(16).padStart(2, '0')}`.toUpperCase();
+        return manId === '00 20 29';
+      }
+      return false;
+    });
+  }
+
+  /**
+   * Analyze message timing patterns
+   */
+  private analyzeMessageTiming(messages: readonly CapturedMessage[]): any {
+    if (messages.length < 2) {
+      return { averageInterval: 0, burstPatterns: [] };
+    }
+
+    const intervals: number[] = [];
+    for (let i = 1; i < messages.length; i++) {
+      const interval = messages[i]!.timestamp - messages[i - 1]!.timestamp;
+      intervals.push(interval);
+    }
+
+    const averageInterval = intervals.reduce((a, b) => a + b, 0) / intervals.length;
+
+    // Find burst patterns (messages sent in quick succession)
+    const burstThreshold = 50; // 50ms
+    const bursts: any[] = [];
+    let currentBurst: CapturedMessage[] = [];
+
+    for (let i = 0; i < intervals.length; i++) {
+      if (intervals[i]! < burstThreshold) {
+        if (currentBurst.length === 0) {
+          currentBurst.push(messages[i]!);
+        }
+        currentBurst.push(messages[i + 1]!);
+      } else {
+        if (currentBurst.length > 1) {
+          bursts.push({
+            messageCount: currentBurst.length,
+            duration: currentBurst[currentBurst.length - 1]!.timestamp - currentBurst[0]!.timestamp,
+            messages: currentBurst.slice(0, 3), // Keep first 3 examples
+          });
+        }
+        currentBurst = [];
+      }
+    }
+
+    return {
+      averageInterval: Math.round(averageInterval),
+      burstPatterns: bursts,
+    };
+  }
+
+  /**
+   * Find unknown/unidentified messages
+   */
+  private findUnknownMessages(messages: readonly CapturedMessage[]): CapturedMessage[] {
+    return messages.filter(message => {
+      if (message.messageType === 'sysex') {
+        if (message.rawData.length >= 3) {
+          const manId = `${message.rawData[1]?.toString(16).padStart(2, '0')} ${message.rawData[2]?.toString(16).padStart(2, '0')}`.toUpperCase();
+          return !this.knownManufacturers.has(manId);
+        }
+        return true;
+      }
+      return false;
+    });
+  }
+
+  /**
+   * Display analysis results
+   */
+  private displayAnalysis(analysis: ProtocolAnalysis): void {
+    console.log('\n📈 Analysis Results:');
+    console.log('═'.repeat(60));
+
+    console.log(`Session ID: ${analysis.sessionId}`);
+    console.log(`Time Span: ${analysis.timeSpan}ms`);
+    console.log(`Total Messages: ${analysis.messageCount}`);
+
+    // SysEx patterns
+    console.log(`\n🔥 SysEx Patterns (${analysis.sysexPatterns.length}):`);
+    for (const pattern of analysis.sysexPatterns.slice(0, 10)) {
+      console.log(`   ${pattern.pattern} (${pattern.count}x)`);
+      if ((pattern.analysis as any).manufacturer) {
+        console.log(`      └─ ${(pattern.analysis as any).manufacturer}`);
+      }
+      if ((pattern.analysis as any).device) {
+        console.log(`         └─ ${(pattern.analysis as any).device}`);
+      }
+      if (pattern.analysis.description) {
+        console.log(`         └─ ${pattern.analysis.description}`);
+      }
+    }
+
+    // Novation messages
+    console.log(`\n🎛️  Novation Messages: ${analysis.novationMessages.length}`);
+    if (analysis.novationMessages.length > 0) {
+      console.log('   Recent Novation messages:');
+      for (const msg of analysis.novationMessages.slice(-3)) {
+        console.log(`      ${msg.hexData}`);
+      }
+    }
+
+    // Timing analysis
+    console.log(`\n⏱️  Timing Analysis:`);
+    console.log(`   Average interval: ${analysis.timing.averageInterval}ms`);
+    console.log(`   Burst patterns: ${analysis.timing.burstPatterns.length}`);
+
+    // Unknown messages
+    if (analysis.unknownMessages.length > 0) {
+      console.log(`\n❓ Unknown Messages: ${analysis.unknownMessages.length}`);
+      console.log('   (Messages from unrecognized manufacturers)');
+    }
+  }
+
+  /**
+   * Save analysis results to file
+   */
+  private saveAnalysis(sessionPath: string, analysis: ProtocolAnalysis): string {
+    const baseName = basename(sessionPath, extname(sessionPath));
+    const outputPath = join(sessionPath, '..', `${baseName}-analysis.json`);
+
+    try {
+      const json = JSON.stringify(analysis, null, 2);
+      writeFileSync(outputPath, json, 'utf8');
+      return outputPath;
+    } catch (error: any) {
+      throw new Error(`Failed to save analysis: ${error.message}`);
+    }
+  }
+
+  /**
+   * Batch analyze multiple sessions
+   */
+  async analyzeBatch(sessionPaths: string[]): Promise<ProtocolAnalysis[]> {
+    console.log(`🔬 Batch analyzing ${sessionPaths.length} sessions`);
+    console.log('═'.repeat(60));
+
+    const analyses: ProtocolAnalysis[] = [];
+
+    for (const sessionPath of sessionPaths) {
+      try {
+        const analysis = await this.analyzeSession(sessionPath);
+        analyses.push(analysis);
+        console.log(''); // Spacing between sessions
+      } catch (error: any) {
+        console.error(`❌ Failed to analyze ${sessionPath}: ${error.message}`);
+      }
+    }
+
+    // Cross-session analysis
+    if (analyses.length > 1) {
+      this.performCrossSessionAnalysis(analyses);
+    }
+
+    return analyses;
+  }
+
+  /**
+   * Perform cross-session analysis to find patterns
+   */
+  private performCrossSessionAnalysis(analyses: readonly ProtocolAnalysis[]): void {
+    console.log('🔗 Cross-Session Pattern Analysis:');
+    console.log('─'.repeat(40));
+
+    // Find common SysEx patterns across sessions
+    const allPatterns = new Map<string, number>();
+
+    for (const analysis of analyses) {
+      for (const pattern of analysis.sysexPatterns) {
+        allPatterns.set(pattern.pattern, (allPatterns.get(pattern.pattern) || 0) + pattern.count);
+      }
+    }
+
+    const commonPatterns = Array.from(allPatterns.entries())
+      .filter(([, count]) => count > 1)
+      .sort((a, b) => b[1] - a[1]);
+
+    console.log(`Found ${commonPatterns.length} patterns appearing across multiple sessions:`);
+    for (const [pattern, count] of commonPatterns.slice(0, 5)) {
+      console.log(`   ${pattern} (total: ${count}x)`);
+    }
+  }
+}
+
+// CLI interface when run directly
+async function main(): Promise<void> {
+  const args = process.argv.slice(2);
+
+  if (args.length === 0) {
+    console.error('Usage: ./monitor-session-analyzer.ts <session-file> [session-file...]');
+    console.error('       ./monitor-session-analyzer.ts --batch <directory>');
+    process.exit(1);
+  }
+
+  const analyzer = new MonitorSessionAnalyzer();
+
+  try {
+    if (args[0] === '--batch') {
+      // Batch mode - analyze all JSON files in directory
+      const directory = args[1];
+      if (!directory) {
+        throw new Error('Directory path required for batch mode');
+      }
+      // Implementation would scan directory for JSON files
+      console.log(`Batch analysis of directory: ${directory}`);
+      // For now, just show the usage
+      console.log('Batch mode not yet implemented - please specify individual files');
+      process.exit(1);
+    } else {
+      // Single or multiple file mode
+      const analyses = await analyzer.analyzeBatch(args);
+      console.log(`\n✅ Successfully analyzed ${analyses.length} session(s)`);
+    }
+  } catch (error: any) {
+    console.error(`❌ Analysis failed: ${error.message}`);
+    process.exit(1);
+  }
+}
+
+// Run if called directly
+if (process.argv[1] && process.argv[1].endsWith('monitor-session-analyzer.ts')) {
+  main();
+}
+
+export { MonitorSessionAnalyzer, type ProtocolAnalysis, type SysExPattern };
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-midi-monitor.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-midi-monitor.ts
new file mode 100755
index 0000000..d6e19d3
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-midi-monitor.ts
@@ -0,0 +1,325 @@
+#!/usr/bin/env tsx
+
+/**
+ * Test MIDI Monitor Functionality
+ *
+ * This script tests the MIDI monitoring capabilities and verifies
+ * that the monitor can detect and capture MIDI messages correctly.
+ */
+
+import { MidiMonitor } from './midi-monitor.js';
+import * as easymidi from 'easymidi';
+
+interface TestConfig {
+  readonly duration: number;
+  readonly deviceFilter?: string;
+  readonly testSysEx: boolean;
+  readonly testControlChange: boolean;
+  readonly testNotes: boolean;
+}
+
+class MidiMonitorTester {
+  private testOutput?: easymidi.Output;
+  private virtualInput?: easymidi.Input;
+
+  constructor() {}
+
+  /**
+   * Run comprehensive monitor tests
+   */
+  async runTests(config: TestConfig): Promise<void> {
+    console.log('🧪 MIDI Monitor Test Suite');
+    console.log('═'.repeat(50));
+
+    try {
+      // Test 1: Basic initialization
+      await this.testInitialization();
+
+      // Test 2: Port detection
+      await this.testPortDetection();
+
+      // Test 3: Filter functionality
+      if (config.deviceFilter) {
+        await this.testDeviceFilter(config.deviceFilter);
+      }
+
+      // Test 4: Message capture with virtual ports
+      await this.testMessageCapture(config);
+
+      // Test 5: Session management
+      await this.testSessionManagement();
+
+      console.log('\n✅ All tests passed!');
+
+    } catch (error: any) {
+      console.error(`❌ Test failed: ${error.message}`);
+      throw error;
+    } finally {
+      await this.cleanup();
+    }
+  }
+
+  /**
+   * Test monitor initialization
+   */
+  private async testInitialization(): Promise<void> {
+    console.log('\n📋 Test 1: Monitor Initialization');
+
+    const monitor = new MidiMonitor({
+      verboseLogging: true,
+      bufferMessages: true,
+    });
+
+    const stats = monitor.getCurrentStats();
+    if (stats.messageCount !== 0) {
+      throw new Error('Expected empty message buffer on initialization');
+    }
+
+    if (stats.isRunning) {
+      throw new Error('Expected monitor to not be running on initialization');
+    }
+
+    console.log('   ✅ Monitor initializes correctly');
+  }
+
+  /**
+   * Test port detection
+   */
+  private async testPortDetection(): Promise<void> {
+    console.log('\n📋 Test 2: Port Detection');
+
+    const availablePorts = easymidi.getInputs();
+    console.log(`   📡 Found ${availablePorts.length} MIDI input ports`);
+
+    if (availablePorts.length > 0) {
+      availablePorts.forEach((port, i) => {
+        console.log(`      ${i + 1}. ${port}`);
+      });
+    } else {
+      console.log('   ⚠️  No MIDI ports available - will test with virtual ports');
+    }
+
+    console.log('   ✅ Port detection working');
+  }
+
+  /**
+   * Test device filtering
+   */
+  private async testDeviceFilter(filter: string): Promise<void> {
+    console.log(`\n📋 Test 3: Device Filter (${filter})`);
+
+    const monitor = new MidiMonitor({
+      deviceFilter: filter,
+      verboseLogging: false,
+    });
+
+    const availablePorts = easymidi.getInputs();
+    const filteredPorts = availablePorts.filter(port =>
+      port.toLowerCase().includes(filter.toLowerCase())
+    );
+
+    console.log(`   🎯 Filter "${filter}" matches ${filteredPorts.length} ports`);
+    filteredPorts.forEach(port => {
+      console.log(`      - ${port}`);
+    });
+
+    console.log('   ✅ Device filtering working');
+  }
+
+  /**
+   * Test message capture with generated MIDI messages
+   */
+  private async testMessageCapture(config: TestConfig): Promise<void> {
+    console.log('\n📋 Test 4: Message Capture');
+
+    try {
+      // Create virtual MIDI port for testing
+      this.testOutput = new easymidi.Output('MIDI Monitor Test Output', true);
+      await this.delay(500); // Wait for port to be created
+
+      // Start monitor
+      const monitor = new MidiMonitor({
+        deviceFilter: 'MIDI Monitor Test',
+        verboseLogging: false,
+        bufferMessages: true,
+      });
+
+      console.log('   🎹 Starting monitor for virtual port...');
+
+      // Start monitoring in background
+      const monitorPromise = monitor.startMonitoring();
+
+      // Wait a bit for monitor to start
+      await this.delay(1000);
+
+      // Generate test messages
+      console.log('   🎵 Generating test MIDI messages...');
+
+      let expectedMessages = 0;
+
+      if (config.testControlChange) {
+        console.log('      - Sending CC messages...');
+        for (let i = 0; i < 5; i++) {
+          this.testOutput.send('cc', { controller: 10 + i, value: 64 + i, channel: 0 });
+          expectedMessages++;
+          await this.delay(100);
+        }
+      }
+
+      if (config.testNotes) {
+        console.log('      - Sending note messages...');
+        for (let i = 0; i < 3; i++) {
+          this.testOutput.send('noteon', { note: 60 + i, velocity: 100, channel: 0 });
+          expectedMessages++;
+          await this.delay(50);
+          this.testOutput.send('noteoff', { note: 60 + i, velocity: 0, channel: 0 });
+          expectedMessages++;
+          await this.delay(50);
+        }
+      }
+
+      if (config.testSysEx) {
+        console.log('      - Sending SysEx messages...');
+        // Test Novation Launch Control XL 3 SysEx format
+        const sysexMessage = [0xF0, 0x00, 0x20, 0x29, 0x02, 0x11, 0x77, 0x01, 0xF7];
+        this.testOutput.send('sysex', sysexMessage);
+        expectedMessages++;
+        await this.delay(100);
+      }
+
+      // Wait for capture
+      await this.delay(1000);
+
+      // Stop monitor and get session
+      const session = await monitor.stopMonitoring();
+
+      // Verify capture results
+      console.log(`   📊 Captured ${session.messages.length} messages (expected ~${expectedMessages})`);
+      console.log(`      - SysEx: ${session.statistics.sysexMessages}`);
+      console.log(`      - CC: ${session.statistics.ccMessages}`);
+      console.log(`      - Notes: ${session.statistics.noteMessages}`);
+      console.log(`      - Other: ${session.statistics.otherMessages}`);
+
+      if (session.messages.length === 0) {
+        console.log('   ⚠️  No messages captured - this might indicate an issue');
+      } else {
+        console.log('   ✅ Message capture working');
+      }
+
+    } catch (error: any) {
+      if (error.message.includes('No MIDI input ports found')) {
+        console.log('   ⚠️  Skipping capture test - no matching ports available');
+      } else {
+        throw error;
+      }
+    }
+  }
+
+  /**
+   * Test session management
+   */
+  private async testSessionManagement(): Promise<void> {
+    console.log('\n📋 Test 5: Session Management');
+
+    const monitor = new MidiMonitor({
+      outputDir: './test-captures',
+      sessionName: 'test-session',
+      bufferMessages: true,
+    });
+
+    // Simulate quick monitoring session
+    try {
+      await monitor.startMonitoring();
+      await this.delay(100); // Very brief monitoring
+      const session = await monitor.stopMonitoring();
+
+      if (!session.sessionId) {
+        throw new Error('Session ID not generated');
+      }
+
+      if (!session.startTime) {
+        throw new Error('Start time not recorded');
+      }
+
+      if (!session.endTime) {
+        throw new Error('End time not recorded');
+      }
+
+      console.log(`   📄 Session ID: ${session.sessionId}`);
+      console.log(`   ⏱️  Duration: ${session.endTime - session.startTime}ms`);
+      console.log('   ✅ Session management working');
+
+    } catch (error: any) {
+      if (error.message.includes('No MIDI input ports found')) {
+        console.log('   ⚠️  Skipping session test - no ports available');
+      } else {
+        throw error;
+      }
+    }
+  }
+
+  /**
+   * Clean up test resources
+   */
+  private async cleanup(): Promise<void> {
+    console.log('\n🧹 Cleaning up test resources...');
+
+    if (this.testOutput) {
+      try {
+        this.testOutput.close();
+        console.log('   ✅ Test output port closed');
+      } catch (error: any) {
+        console.log(`   ⚠️  Error closing test output: ${error.message}`);
+      }
+    }
+
+    if (this.virtualInput) {
+      try {
+        this.virtualInput.close();
+        console.log('   ✅ Virtual input port closed');
+      } catch (error: any) {
+        console.log(`   ⚠️  Error closing virtual input: ${error.message}`);
+      }
+    }
+  }
+
+  /**
+   * Utility delay function
+   */
+  private delay(ms: number): Promise<void> {
+    return new Promise(resolve => setTimeout(resolve, ms));
+  }
+}
+
+// CLI interface when run directly
+async function main(): Promise<void> {
+  const args = process.argv.slice(2);
+
+  const config: TestConfig = {
+    duration: 5000, // 5 seconds
+    deviceFilter: args.find(arg => arg.startsWith('--device='))?.split('=')[1],
+    testSysEx: !args.includes('--no-sysex'),
+    testControlChange: !args.includes('--no-cc'),
+    testNotes: !args.includes('--no-notes'),
+  };
+
+  console.log('Configuration:', config);
+
+  const tester = new MidiMonitorTester();
+
+  try {
+    await tester.runTests(config);
+    console.log('\n🎉 MIDI Monitor test suite completed successfully!');
+    process.exit(0);
+  } catch (error: any) {
+    console.error(`\n💥 Test suite failed: ${error.message}`);
+    process.exit(1);
+  }
+}
+
+// Run if called directly
+if (process.argv[1] && process.argv[1].endsWith('test-midi-monitor.ts')) {
+  main();
+}
+
+export { MidiMonitorTester, TestConfig };
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

feat(launch-control-xl3): implement passive MIDI monitoring infrastructure with session analysis tools

