<!-- Generated by SpecStory -->

# Launch Control XL Automation: Web MIDI Testing Framework (2025-09-30 00:00:30Z)

<!-- Claude Code Session d708291b-116d-4cb0-a2fd-d20a958b680a (2025-09-30_00-00-30Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/DAW_PORT_PROTOCOL.md b/modules/audio-control/modules/launch-control-xl3/docs/DAW_PORT_PROTOCOL.md
new file mode 100644
index 0000000..74105e7
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/docs/DAW_PORT_PROTOCOL.md
@@ -0,0 +1,153 @@
+# Launch Control XL3 DAW Port Protocol Documentation
+
+## Overview
+
+The Launch Control XL3 uses a dual-port MIDI system for communication:
+- **MIDI Port**: Standard port for SysEx data transfers (read/write custom modes, device info)
+- **DAW Port**: Out-of-band control port for slot selection, mode changes, and other control messages
+
+## Critical Discovery: Slot Selection via DAW Port
+
+The slot byte in SysEx messages (position 9) **does not control where data is written**. Instead, the device uses an out-of-band slot selection mechanism via the DAW port.
+
+### The Problem
+When writing custom mode data using only the MIDI port:
+- Sending to slot 0 (0x00) would write to physical slot 2
+- The slot byte in the SysEx message was being ignored
+- The device was using a previously selected slot or defaulting to slot 2
+
+### The Solution
+The Novation Components web editor uses the DAW port to select slots before writing:
+
+```
+1. Send slot selection via DAW port (CC message)
+2. Send SysEx write command via MIDI port (with slot byte 0x00)
+3. Device writes to the previously selected slot
+```
+
+## DAW Port Slot Selection Protocol
+
+### Message Sequence
+The complete protocol for selecting a slot consists of three MIDI messages sent to the DAW port:
+
+1. **Note On** - Start signal
+   - Note: 11
+   - Velocity: 127
+   - Channel: 15 (0x0F)
+   - Status byte: 0x9F
+
+2. **Control Change** - Slot selection
+   - Controller: 30 (0x1E)
+   - Value: Physical slot number + 5
+   - Channel: 6 (0x05)
+   - Status byte: 0xB5
+
+3. **Note Off** - End signal
+   - Note: 11
+   - Velocity: 0
+   - Channel: 15 (0x0F)
+   - Status byte: 0x9F (with velocity 0)
+
+### Slot Value Mapping
+The CC value maps to physical slots as follows:
+- CC Value 6 → Physical Slot 1 (API slot 0)
+- CC Value 7 → Physical Slot 2 (API slot 1)
+- CC Value 8 → Physical Slot 3 (API slot 2)
+- ...
+- CC Value 20 → Physical Slot 15 (API slot 14)
+
+Formula: `CC_Value = Physical_Slot + 5` or `CC_Value = API_Slot + 6`
+
+## Implementation Example
+
+### Using easymidi
+```typescript
+import easymidi from 'easymidi';
+
+// Open DAW port
+const dawOutput = new easymidi.Output('LCXL3 1 DAW In');
+
+// Select physical slot 1 (API slot 0)
+function selectSlot(apiSlot: number) {
+  const physicalSlot = apiSlot + 1;
+  const ccValue = physicalSlot + 5;
+
+  // Note On
+  dawOutput.send('noteon', {
+    note: 11,
+    velocity: 127,
+    channel: 15
+  });
+
+  // CC for slot selection
+  dawOutput.send('cc', {
+    controller: 30,
+    value: ccValue,
+    channel: 6
+  });
+
+  // Note Off
+  dawOutput.send('noteon', {
+    note: 11,
+    velocity: 0,  // velocity 0 = Note Off
+    channel: 15
+  });
+}
+```
+
+### Raw MIDI Bytes
+```typescript
+// Select physical slot 2 (API slot 1)
+const messages = [
+  [0x9F, 11, 127],  // Note On, channel 15
+  [0xB5, 30, 7],    // CC 30, value 7, channel 5 (6 in 1-based)
+  [0x9F, 11, 0]     // Note Off, channel 15
+];
+```
+
+## Complete Read/Write Flow
+
+### Writing to a Specific Slot
+1. Send slot selection messages to DAW port
+2. Wait ~50ms for device to process
+3. Send SysEx write command to MIDI port (slot byte can be 0x00)
+4. Device writes to the selected slot
+
+### Reading from a Specific Slot
+1. Send slot selection messages to DAW port (optional - device may remember)
+2. Send SysEx read command to MIDI port
+3. Device returns data from the selected slot
+
+## Web Editor Behavior
+
+The Novation Components web editor follows this exact protocol:
+1. When user clicks "Send to Launch Control XL 3", a slot selection dialog appears
+2. When user selects a slot and clicks "Overwrite Custom Mode":
+   - Sends the 3-message sequence to DAW port
+   - Sends SysEx write command with only 24 encoders (342 bytes)
+   - Slot byte in SysEx is always 0x00
+
+## Important Notes
+
+1. **Slot State Persistence**: The device appears to remember the last selected slot
+2. **Default Behavior**: Without DAW port selection, writes may go to slot 2 by default
+3. **Acknowledgment**: The device sends a 12-byte acknowledgment after successful write:
+   ```
+   F0 00 20 29 02 15 05 00 15 00 07 F7
+   ```
+   The second-to-last byte (0x07) appears to echo status information
+
+4. **Backwards Compatibility**: Libraries that don't use the DAW port will have unpredictable slot behavior
+
+## Testing Tools
+
+Several utilities are available for testing and debugging:
+- `utils/test-daw-port-monitor.ts` - Monitor DAW port messages
+- `utils/test-slot-selection.ts` - Test slot selection via DAW port
+- `utils/test-daw-port-integration.ts` - Full integration test with library
+
+## References
+
+- Discovered through reverse engineering the Novation Components web editor
+- Confirmed via Playwright automation and MIDI monitoring
+- Tested with Launch Control XL3 firmware v1.0.10.84
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/DawPortController.ts b/modules/audio-control/modules/launch-control-xl3/src/core/DawPortController.ts
new file mode 100644
index 0000000..97ff767
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/DawPortController.ts
@@ -0,0 +1,58 @@
+/**
+ * DAW Port Controller for Launch Control XL3
+ *
+ * Handles out-of-band communication via the DAW port for:
+ * - Slot selection before writing custom modes
+ * - Mode switching and other control messages
+ */
+
+export interface DawPortController {
+  selectSlot(slot: number): Promise<void>;
+  sendNoteNotification(): Promise<void>;
+}
+
+export class DawPortControllerImpl implements DawPortController {
+  constructor(
+    private sendMessage: (message: number[]) => Promise<void>
+  ) {}
+
+  /**
+   * Select the active slot for subsequent write operations
+   * @param slot 0-based slot index (0-14 for slots 1-15)
+   */
+  async selectSlot(slot: number): Promise<void> {
+    if (slot < 0 || slot > 14) {
+      throw new Error(`Invalid slot: ${slot}. Must be 0-14`);
+    }
+
+    // The web editor sends:
+    // 1. Note On (note 11, velocity 127, channel 15)
+    // 2. CC 30 on channel 6, value = physical slot + 5
+    // 3. Note Off (note 11, velocity 0, channel 15)
+
+    // Physical slot is 1-based, so add 1 to the 0-based slot
+    const physicalSlot = slot + 1;
+    const ccValue = physicalSlot + 5; // Slot 1 = CC value 6, Slot 2 = CC value 7, etc.
+
+    // Note On: note 11, velocity 127, channel 15
+    await this.sendMessage([0x9F, 11, 127]); // 0x9F = Note On channel 15
+
+    // CC: controller 30, value, channel 6
+    await this.sendMessage([0xB5, 30, ccValue]); // 0xB5 = CC channel 5 (0-based)
+
+    // Note Off: note 11, velocity 0, channel 15
+    await this.sendMessage([0x9F, 11, 0]); // Velocity 0 = Note Off
+
+    // Give the device time to process the selection
+    await new Promise(resolve => setTimeout(resolve, 50));
+  }
+
+  /**
+   * Send a note notification (might be used for mode changes)
+   */
+  async sendNoteNotification(): Promise<void> {
+    // Just the note on/off pattern without CC
+    await this.sendMessage([0x9F, 11, 127]);
+    await this.sendMessage([0x9F, 11, 0]);
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/MidiInterface.ts b/modules/audio-control/modules/launch-control-xl3/src/core/MidiInterface.ts
index 50ccf58..2a11255 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/MidiInterface.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/MidiInterface.ts
@@ -62,6 +62,15 @@ export interface MidiBackendInterface {
 
   closePort(port: MidiPort): Promise<void>;
 
+  // DAW port support (optional, for backends that support it)
+  openDawInput?(portId: string): Promise<MidiInputPort>;
+
+  openDawOutput?(portId: string): Promise<MidiOutputPort>;
+
+  getDawInputPorts?(): Promise<MidiPortInfo[]>;
+
+  getDawOutputPorts?(): Promise<MidiPortInfo[]>;
+
   cleanup(): Promise<void>;
 }
 
@@ -81,6 +90,8 @@ export class MidiInterface extends EventEmitter {
   private backend?: MidiBackendInterface | undefined;
   private inputPort?: MidiInputPort | undefined;
   private outputPort?: MidiOutputPort | undefined;
+  private dawInputPort?: MidiInputPort | undefined;
+  private dawOutputPort?: MidiOutputPort | undefined;
   private isInitialized = false;
   private messageBuffer: MidiMessage[] = [];
   private readonly maxBufferSize = 1000;
@@ -246,12 +257,122 @@ export class MidiInterface extends EventEmitter {
     }
   }
 
+  /**
+   * Open DAW input port (for out-of-band communication)
+   */
+  async openDawInput(portIdOrName: string): Promise<void> {
+    if (!this.backend) {
+      throw new Error('MIDI backend not initialized');
+    }
+
+    if (!this.backend.openDawInput || !this.backend.getDawInputPorts) {
+      throw new Error('DAW port support not available in this backend');
+    }
+
+    // Close existing DAW input if open
+    if (this.dawInputPort) {
+      await this.closeDawInput();
+    }
+
+    // Find port
+    const ports = await this.backend.getDawInputPorts();
+    const port = ports.find((p) => p.id === portIdOrName || p.name === portIdOrName);
+
+    if (!port) {
+      throw new Error(`DAW input port not found: ${portIdOrName}`);
+    }
+
+    // Open port
+    this.dawInputPort = await this.backend.openDawInput(port.id);
+
+    // Setup message handler
+    this.dawInputPort.onMessage = (message) => {
+      this.handleIncomingMessage(message);
+    };
+
+    this.emit('connected', this.dawInputPort);
+  }
+
+  /**
+   * Open DAW output port (for out-of-band communication)
+   */
+  async openDawOutput(portIdOrName: string): Promise<void> {
+    if (!this.backend) {
+      throw new Error('MIDI backend not initialized');
+    }
+
+    if (!this.backend.openDawOutput || !this.backend.getDawOutputPorts) {
+      throw new Error('DAW port support not available in this backend');
+    }
+
+    // Close existing DAW output if open
+    if (this.dawOutputPort) {
+      await this.closeDawOutput();
+    }
+
+    // Find port
+    const ports = await this.backend.getDawOutputPorts();
+    const port = ports.find((p) => p.id === portIdOrName || p.name === portIdOrName);
+
+    if (!port) {
+      throw new Error(`DAW output port not found: ${portIdOrName}`);
+    }
+
+    // Open port
+    this.dawOutputPort = await this.backend.openDawOutput(port.id);
+    this.emit('connected', this.dawOutputPort);
+  }
+
+  /**
+   * Send message to DAW port
+   */
+  async sendDawMessage(data: number[]): Promise<void> {
+    if (!this.dawOutputPort) {
+      throw new Error('No DAW output port open');
+    }
+
+    if (!this.backend) {
+      throw new Error('No MIDI backend available');
+    }
+
+    const message: MidiMessage = {
+      timestamp: Date.now(),
+      data,
+    };
+
+    await this.backend.sendMessage(this.dawOutputPort, message);
+  }
+
+  /**
+   * Close DAW input port
+   */
+  async closeDawInput(): Promise<void> {
+    if (this.dawInputPort && this.backend) {
+      await this.backend.closePort(this.dawInputPort);
+      this.emit('disconnected', this.dawInputPort);
+      this.dawInputPort = undefined;
+    }
+  }
+
+  /**
+   * Close DAW output port
+   */
+  async closeDawOutput(): Promise<void> {
+    if (this.dawOutputPort && this.backend) {
+      await this.backend.closePort(this.dawOutputPort);
+      this.emit('disconnected', this.dawOutputPort);
+      this.dawOutputPort = undefined;
+    }
+  }
+
   /**
    * Close all ports and cleanup
    */
   async cleanup(): Promise<void> {
     await this.closeInput();
     await this.closeOutput();
+    await this.closeDawInput();
+    await this.closeDawOutput();
 
     if (this.backend) {
       await this.backend.cleanup();
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
index b7372a9..60732b2 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
@@ -923,7 +923,7 @@ export class SysExParser {
       0x05,             // Sub-command
       0x00,             // Reserved
       0x45,             // Write operation
-      slot,             // Slot number
+      slot,             // Slot number (0-14 for slots 1-15)
       ...rawData,       // Custom mode data
       0xF7              // SysEx end
     ];
@@ -946,6 +946,10 @@ export class SysExParser {
     // VERIFIED PROTOCOL: Based on actual web editor traffic capture
     // Format: F0 00 20 29 02 15 05 00 45 [SLOT] [encoded data] F7
     // The web editor DOES use 0x45 for write operations with full data payload
+    // CONFIRMED: Slot byte 0x00 writes to physical slot 2
+    // This means API slot 0 -> wire slot 0x00 -> physical slot 2
+    // There appears to be an intentional offset in the device firmware
+
     return [
       0xF0,             // SysEx start
       0x00, 0x20, 0x29, // Manufacturer ID (Novation)
@@ -954,7 +958,7 @@ export class SysExParser {
       0x05,             // Sub-command
       0x00,             // Reserved
       0x45,             // Write operation with data (confirmed from web editor)
-      slot,             // Slot number (0-14 for slots 1-15)
+      slot,             // Slot number (0-14), maps to physical slots with offset
       ...encodedData,   // Encoded custom mode data
       0xF7              // SysEx end
     ];
@@ -1023,33 +1027,91 @@ export class SysExParser {
     const nameEncoded = this.encodeName(modeName);
     rawData.push(...nameEncoded);
 
-    // Sort controls by ID for consistency
-    // FIX: Accept both 'id' and 'controlId' fields to handle different formats
-    const sortedControls = Object.values(modeData.controls)
-      .filter((control: any) => control.id !== undefined || control.controlId !== undefined)
-      .map((control: any) => ({
-        ...control,
-        controlId: control.controlId ?? control.id ?? 0
-      }))
-      .sort((a: any, b: any) => (a.controlId ?? 0) - (b.controlId ?? 0));
+    // Create a map of user-provided controls by ID
+    const userControls = new Map<number, any>();
+    for (const control of modeData.controls) {
+      const controlId = control.id ?? control.controlId;
+      if (controlId !== undefined) {
+        userControls.set(controlId, control);
+      }
+    }
 
-    // Add control definitions with 0x49 marker and offset
-    for (const control of sortedControls) {
-      // Write control structure: 11 bytes
+    // CRITICAL: Device requires ALL 48 controls to be defined
+    // We must send definitions for all hardware control IDs (0x10-0x3F)
+    // even if the user didn't specify them
+
+    // Generate all 48 control definitions in order
+    const allControlIds: number[] = [];
+
+    // Encoders: 0x10-0x27 (24 total)
+    for (let i = 0x10; i <= 0x27; i++) {
+      allControlIds.push(i);
+    }
+
+    // Faders: 0x28-0x2F (8 total)
+    for (let i = 0x28; i <= 0x2F; i++) {
+      allControlIds.push(i);
+    }
+
+    // Buttons: 0x30-0x3F (16 total)
+    for (let i = 0x30; i <= 0x3F; i++) {
+      allControlIds.push(i);
+    }
+
+    // Write control definitions for ALL hardware controls
+    for (const controlId of allControlIds) {
+      const userControl = userControls.get(controlId);
+
+      // Determine control type based on ID range
+      let controlType: number;
+      let defaultCC: number;
+
+      if (controlId >= 0x10 && controlId <= 0x17) {
+        // Top row encoders
+        controlType = 0x05;
+        defaultCC = 0x0D + (controlId - 0x10); // CC 13-20
+      } else if (controlId >= 0x18 && controlId <= 0x1F) {
+        // Middle row encoders
+        controlType = 0x09;
+        defaultCC = 0x15 + (controlId - 0x18); // CC 21-28
+      } else if (controlId >= 0x20 && controlId <= 0x27) {
+        // Bottom row encoders
+        controlType = 0x0D;
+        defaultCC = 0x1D + (controlId - 0x20); // CC 29-36
+      } else if (controlId >= 0x28 && controlId <= 0x2F) {
+        // Faders
+        controlType = 0x00;
+        defaultCC = 0x05 + (controlId - 0x28); // CC 5-12
+      } else if (controlId >= 0x30 && controlId <= 0x37) {
+        // First row buttons
+        controlType = 0x19;
+        defaultCC = 0x25 + (controlId - 0x30); // CC 37-44
+      } else {
+        // Second row buttons (0x38-0x3F)
+        controlType = 0x25;
+        defaultCC = 0x2D + (controlId - 0x38); // CC 45-52
+      }
+
+      // Use user-provided CC if available, otherwise use default
+      const cc = userControl ? (userControl.ccNumber ?? userControl.cc ?? defaultCC) : defaultCC;
+
+      // Write control structure: 11 bytes (matching web editor format)
       rawData.push(0x49); // Write control marker
-      rawData.push(this.getControlId(control)); // Control ID (no offset - direct mapping)
+      rawData.push(controlId); // Control ID
       rawData.push(0x02); // Definition type
-      // Get control type based on position and type
-      rawData.push(this.getControlType(control)); // Control type based on position
-      rawData.push(0x00); // Always 0x00 (not channel)
+      rawData.push(controlType); // Control type based on position
+      rawData.push(0x00); // Always 0x00
       rawData.push(0x01); // Always 0x01
-      rawData.push(0x40); // Always 0x40 (was 0x48 in some versions)
+      rawData.push(0x40); // Always 0x40
       rawData.push(0x00); // Always 0x00
-      rawData.push(control.ccNumber ?? control.cc ?? 0); // CC number
+      rawData.push(cc); // CC number
       rawData.push(0x7F); // Max value (always 0x7F in write)
       rawData.push(0x00); // Terminator
     }
 
+    // DISABLED: The web editor doesn't send control labels, so we skip them
+    // to match the known-good protocol format
+    /*
     // Generate labels for controls with names
     for (const control of sortedControls) {
       rawData.push(0x69); // Label marker
@@ -1061,16 +1123,17 @@ export class SysExParser {
         rawData.push(label.charCodeAt(i));
       }
     }
+    */
 
-    // Add color data for controls
-    for (const control of sortedControls) {
-      const controlId = this.getControlId(control);
-      // Use control's color property directly or default
-      const colorValue = control.color ?? 0x0C; // Default color if not specified
+    // Generate color commands for ALL controls (required by device)
+    for (const controlId of allControlIds) {
+      const userControl = userControls.get(controlId);
 
-      rawData.push(0x60); // Color marker
-      rawData.push(controlId); // Control ID (no offset)
-      rawData.push(colorValue); // Actual color value
+      rawData.push(0x60); // LED color marker
+      rawData.push(controlId); // Control ID
+      // Use color from user control if specified, otherwise default (off)
+      const color = userControl?.color ?? 0x00;
+      rawData.push(color); // Color value
     }
 
     return rawData;
@@ -1094,6 +1157,9 @@ export class SysExParser {
     // Map based on type and index
     if (type === 'encoder' || type === 'knob') {
       // Encoders: 0x10-0x27 (24 total, 3 rows of 8)
+      // Top row (0-7): 0x10-0x17
+      // Middle row (8-15): 0x18-0x1F
+      // Bottom row (16-23): 0x20-0x27
       return 0x10 + Math.min(23, index);
     } else if (type === 'fader') {
       // Faders: 0x28-0x2F (8 total)
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/backends/EasyMidiBackend.ts b/modules/audio-control/modules/launch-control-xl3/src/core/backends/EasyMidiBackend.ts
index 009dc98..abd2c3a 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/backends/EasyMidiBackend.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/backends/EasyMidiBackend.ts
@@ -169,6 +169,7 @@ export class EasyMidiBackend implements MidiBackendInterface {
       const data: Array<number> = Array.from(message.data);
 
       if (data[0] === 0xf0 && data[data.length - 1] === 0xf7) {
+        // SysEx message
         this.logger.debug(
           'Sending SysEx:',
           data.map((b) => '0x' + b.toString(16).padStart(2, '0')).join(' '),
@@ -176,13 +177,144 @@ export class EasyMidiBackend implements MidiBackendInterface {
         easyOutput.send('sysex', data);
         return Promise.resolve();
       } else {
-        return Promise.reject(new Error('Only SysEx messages are currently supported by EasyMidiBackend'));
+        // Handle other MIDI messages for DAW port
+        const statusByte = data[0];
+        const channel = statusByte & 0x0F;
+
+        if ((statusByte & 0xF0) === 0x90) {
+          // Note On
+          easyOutput.send('noteon', {
+            note: data[1],
+            velocity: data[2],
+            channel
+          });
+        } else if ((statusByte & 0xF0) === 0xB0) {
+          // Control Change
+          easyOutput.send('cc', {
+            controller: data[1],
+            value: data[2],
+            channel
+          });
+        } else if ((statusByte & 0xF0) === 0x80) {
+          // Note Off
+          easyOutput.send('noteoff', {
+            note: data[1],
+            velocity: data[2],
+            channel
+          });
+        } else {
+          return Promise.reject(new Error(`Unsupported MIDI message type: 0x${statusByte.toString(16)}`));
+        }
+        return Promise.resolve();
       }
     } catch (error) {
       return Promise.reject(new Error(`Failed to send message to port ${port.id}: ${(error as Error).message}`));
     }
   }
 
+  /**
+   * Get DAW input ports
+   */
+  async getDawInputPorts(): Promise<MidiPortInfo[]> {
+    const inputNames = getInputs();
+    const dawPorts: MidiPortInfo[] = [];
+
+    for (const name of inputNames) {
+      if (name.includes('DAW Out')) {
+        dawPorts.push({
+          id: name,
+          name
+        });
+      }
+    }
+
+    return dawPorts;
+  }
+
+  /**
+   * Get DAW output ports
+   */
+  async getDawOutputPorts(): Promise<MidiPortInfo[]> {
+    const outputNames = getOutputs();
+    const dawPorts: MidiPortInfo[] = [];
+
+    for (const name of outputNames) {
+      if (name.includes('DAW In')) {
+        dawPorts.push({
+          id: name,
+          name
+        });
+      }
+    }
+
+    return dawPorts;
+  }
+
+  /**
+   * Open DAW input port
+   */
+  async openDawInput(portId: string): Promise<MidiInputPort> {
+    try {
+      const input = new Input(portId);
+
+      const port: MidiInputPort = {
+        id: portId,
+        name: portId,
+        type: 'input',
+        close: async () => {
+          if (input.close) {
+            input.close();
+          }
+          this.portWrappers.delete(portId);
+        },
+        onMessage: undefined
+      };
+
+      // Set up message handler for all MIDI message types
+      input.on('message', (deltaTime: number, message: number[]) => {
+        if (port.onMessage) {
+          port.onMessage({
+            timestamp: Date.now(),
+            data: message
+          });
+        }
+      });
+
+      this.portWrappers.set(portId, port);
+      return port;
+    } catch (error: any) {
+      throw new Error(`Failed to open DAW input port ${portId}: ${error.message}`);
+    }
+  }
+
+  /**
+   * Open DAW output port
+   */
+  async openDawOutput(portId: string): Promise<MidiOutputPort> {
+    try {
+      const output = new Output(portId);
+
+      const port: MidiOutputPort = {
+        id: portId,
+        name: portId,
+        type: 'output',
+        close: async () => {
+          if (output.close) {
+            output.close();
+          }
+          this.outputs.delete(portId);
+          this.portWrappers.delete(portId);
+        }
+      };
+
+      this.outputs.set(portId, output);
+      this.portWrappers.set(portId, port);
+      return port;
+    } catch (error: any) {
+      throw new Error(`Failed to open DAW output port ${portId}: ${error.message}`);
+    }
+  }
+
   async closePort(port: MidiPort): Promise<void> {
     await port.close();
   }
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/backends/WebMidiBackend.ts b/modules/audio-control/modules/launch-control-xl3/src/core/backends/WebMidiBackend.ts
index fa372de..db03098 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/backends/WebMidiBackend.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/backends/WebMidiBackend.ts
@@ -21,6 +21,8 @@ export class WebMidiBackend implements MidiBackendInterface {
   private midiAccess?: MIDIAccess;
   private openInputs: Map<string, MIDIInput> = new Map();
   private openOutputs: Map<string, MIDIOutput> = new Map();
+  private dawInputs: Map<string, MIDIInput> = new Map();
+  private dawOutputs: Map<string, MIDIOutput> = new Map();
   private portWrappers: Map<string, MidiInputPort | MidiOutputPort> = new Map();
   private isInitialized = false;
 
@@ -185,7 +187,12 @@ export class WebMidiBackend implements MidiBackendInterface {
   }
 
   async sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
-    const midiOutput = this.openOutputs.get(port.id);
+    // Check both regular outputs and DAW outputs
+    let midiOutput = this.openOutputs.get(port.id);
+    if (!midiOutput) {
+      midiOutput = this.dawOutputs.get(port.id);
+    }
+
     if (!midiOutput) {
       throw new Error(`Output port not open: ${port.id}`);
     }
@@ -210,6 +217,148 @@ export class WebMidiBackend implements MidiBackendInterface {
     await port.close();
   }
 
+  /**
+   * Get DAW input ports
+   */
+  async getDawInputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    const ports: MidiPortInfo[] = [];
+    this.midiAccess.inputs.forEach((port, id) => {
+      if (port.name && port.name.includes('DAW Out')) {
+        ports.push({
+          id,
+          name: port.name || `DAW Input ${id}`,
+          ...(port.manufacturer && { manufacturer: port.manufacturer }),
+          ...(port.version && { version: port.version })
+        });
+      }
+    });
+
+    return ports;
+  }
+
+  /**
+   * Get DAW output ports
+   */
+  async getDawOutputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    const ports: MidiPortInfo[] = [];
+    this.midiAccess.outputs.forEach((port, id) => {
+      if (port.name && port.name.includes('DAW In')) {
+        ports.push({
+          id,
+          name: port.name || `DAW Output ${id}`,
+          ...(port.manufacturer && { manufacturer: port.manufacturer }),
+          ...(port.version && { version: port.version })
+        });
+      }
+    });
+
+    return ports;
+  }
+
+  /**
+   * Open DAW input port
+   */
+  async openDawInput(portId: string): Promise<MidiInputPort> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    let midiInput: MIDIInput | undefined;
+    this.midiAccess.inputs.forEach((input, id) => {
+      if (id === portId) {
+        midiInput = input;
+      }
+    });
+
+    if (!midiInput) {
+      throw new Error(`DAW input port not found: ${portId}`);
+    }
+
+    try {
+      await midiInput.open();
+
+      const port: MidiInputPort = {
+        id: portId,
+        name: midiInput.name || `DAW Input ${portId}`,
+        type: 'input',
+        close: async () => {
+          await this.closeWebMidiPort(midiInput!);
+          this.dawInputs.delete(portId);
+          this.portWrappers.delete(portId);
+        },
+        onMessage: undefined
+      };
+
+      // Set up message handler
+      midiInput.onmidimessage = (event: any) => {
+        if (port.onMessage) {
+          const data: number[] = Array.from(event.data as Uint8Array);
+          port.onMessage({
+            timestamp: event.timeStamp,
+            data
+          });
+        }
+      };
+
+      this.dawInputs.set(portId, midiInput);
+      this.portWrappers.set(portId, port);
+
+      return port;
+    } catch (error: any) {
+      throw new Error(`Failed to open DAW input port ${portId}: ${error.message}`);
+    }
+  }
+
+  /**
+   * Open DAW output port
+   */
+  async openDawOutput(portId: string): Promise<MidiOutputPort> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    let midiOutput: MIDIOutput | undefined;
+    this.midiAccess.outputs.forEach((output, id) => {
+      if (id === portId) {
+        midiOutput = output;
+      }
+    });
+
+    if (!midiOutput) {
+      throw new Error(`DAW output port not found: ${portId}`);
+    }
+
+    try {
+      await midiOutput.open();
+
+      const port: MidiOutputPort = {
+        id: portId,
+        name: midiOutput.name || `DAW Output ${portId}`,
+        type: 'output',
+        close: async () => {
+          await this.closeWebMidiPort(midiOutput!);
+          this.dawOutputs.delete(portId);
+          this.portWrappers.delete(portId);
+        }
+      };
+
+      this.dawOutputs.set(portId, midiOutput);
+      this.portWrappers.set(portId, port);
+
+      return port;
+    } catch (error: any) {
+      throw new Error(`Failed to open DAW output port ${portId}: ${error.message}`);
+    }
+  }
+
   async cleanup(): Promise<void> {
     // Close all open ports
     const closePromises: Promise<void>[] = [];
@@ -222,11 +371,21 @@ export class WebMidiBackend implements MidiBackendInterface {
       closePromises.push(this.closeWebMidiPort(midiOutput));
     }
 
+    for (const [_id, dawInput] of this.dawInputs.entries()) {
+      closePromises.push(this.closeWebMidiPort(dawInput));
+    }
+
+    for (const [_id, dawOutput] of this.dawOutputs.entries()) {
+      closePromises.push(this.closeWebMidiPort(dawOutput));
+    }
+
     await Promise.all(closePromises);
 
     // Clear all maps
     this.openInputs.clear();
     this.openOutputs.clear();
+    this.dawInputs.clear();
+    this.dawOutputs.clear();
     this.portWrappers.clear();
 
     // Remove event handlers
diff --git a/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts b/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
index 4f5cac0..d557199 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
@@ -13,6 +13,7 @@ import {
   MidiBackendInterface
 } from '../core/MidiInterface.js';
 import { SysExParser } from '../core/SysExParser.js';
+import { DawPortControllerImpl, type DawPortController } from '../core/DawPortController.js';
 import {
   LaunchControlXL3Info,
   DeviceMode,
@@ -64,6 +65,7 @@ export class DeviceManager extends EventEmitter {
   private inquiryTimer?: NodeJS.Timeout | undefined;
   private reconnectTimer?: NodeJS.Timeout | undefined;
   private isInitializing = false;
+  private dawPortController?: DawPortController | undefined;
 
   constructor(options: DeviceManagerOptions = {}) {
     super();
@@ -134,6 +136,9 @@ export class DeviceManager extends EventEmitter {
       // Initialize device settings
       await this.initializeDevice();
 
+      // Initialize DAW port for slot selection
+      await this.initializeDawPort();
+
       this.setConnectionState('connected');
       this.emit('device:connected', this.deviceInfo);
       this.emit('device:ready', this.deviceInfo);
@@ -542,6 +547,9 @@ export class DeviceManager extends EventEmitter {
       throw new Error('Custom mode slot must be 0-15');
     }
 
+    // Select the slot first via DAW port (if available) for consistency
+    await this.selectSlot(slot);
+
     return new Promise((resolve, reject) => {
       const timeout = setTimeout(() => {
         this.midi.removeListener('sysex', handleResponse);
@@ -593,6 +601,9 @@ export class DeviceManager extends EventEmitter {
       throw new Error('Custom mode slot must be 0-15');
     }
 
+    // Select the slot first via DAW port (if available)
+    await this.selectSlot(slot);
+
     const modeData = {
       slot,
       name: mode.name,
@@ -769,6 +780,36 @@ export class DeviceManager extends EventEmitter {
     }
   }
 
+  /**
+   * Initialize DAW port for slot selection
+   */
+  private async initializeDawPort(): Promise<void> {
+    try {
+      // Try to open DAW output port for slot selection
+      const deviceName = this.deviceInfo?.name || 'Launch Control XL';
+      await this.midi.openDawOutput(`${deviceName} DAW In`);
+
+      // Create DAW port controller
+      this.dawPortController = new DawPortControllerImpl(
+        async (message: number[]) => {
+          await this.midi.sendDawMessage(message);
+        }
+      );
+    } catch (error) {
+      console.warn('DAW port initialization failed (slot selection will not work):', error);
+      // Don't throw - DAW port is optional, device can still work without it
+    }
+  }
+
+  /**
+   * Select slot before write operations (if DAW port is available)
+   */
+  private async selectSlot(slot: number): Promise<void> {
+    if (this.dawPortController) {
+      await this.dawPortController.selectSlot(slot);
+    }
+  }
+
   /**
    * Clean up resources
    */
diff --git a/modules/audio-control/modules/launch-control-xl3/test/core/DawPortController.test.ts b/modules/audio-control/modules/launch-control-xl3/test/core/DawPortController.test.ts
new file mode 100644
index 0000000..4cc30c2
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/core/DawPortController.test.ts
@@ -0,0 +1,158 @@
+import { describe, it, expect, vi, beforeEach } from 'vitest';
+import { DawPortControllerImpl } from '../../src/core/DawPortController';
+
+describe('DawPortController', () => {
+  let sendMessage: ReturnType<typeof vi.fn>;
+  let controller: DawPortControllerImpl;
+
+  beforeEach(() => {
+    sendMessage = vi.fn().mockResolvedValue(undefined);
+    controller = new DawPortControllerImpl(sendMessage);
+  });
+
+  describe('selectSlot', () => {
+    it('should send correct message sequence for slot 0 (physical slot 1)', async () => {
+      await controller.selectSlot(0);
+
+      expect(sendMessage).toHaveBeenCalledTimes(3);
+
+      // Note On: channel 15 (0x9F), note 11, velocity 127
+      expect(sendMessage).toHaveBeenNthCalledWith(1, [0x9F, 11, 127]);
+
+      // CC: channel 5 (0xB5), controller 30, value 6 (slot 0 + 1 + 5)
+      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, 6]);
+
+      // Note Off: channel 15 (0x9F), note 11, velocity 0
+      expect(sendMessage).toHaveBeenNthCalledWith(3, [0x9F, 11, 0]);
+    });
+
+    it('should send correct message sequence for slot 1 (physical slot 2)', async () => {
+      await controller.selectSlot(1);
+
+      expect(sendMessage).toHaveBeenCalledTimes(3);
+
+      // CC value should be 7 (slot 1 + 1 + 5)
+      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, 7]);
+    });
+
+    it('should send correct message sequence for slot 14 (physical slot 15)', async () => {
+      await controller.selectSlot(14);
+
+      expect(sendMessage).toHaveBeenCalledTimes(3);
+
+      // CC value should be 20 (slot 14 + 1 + 5)
+      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, 20]);
+    });
+
+    it('should calculate CC value correctly for all slots', async () => {
+      const expectedMappings = [
+        { slot: 0, ccValue: 6 },   // Physical slot 1
+        { slot: 1, ccValue: 7 },   // Physical slot 2
+        { slot: 2, ccValue: 8 },   // Physical slot 3
+        { slot: 3, ccValue: 9 },   // Physical slot 4
+        { slot: 4, ccValue: 10 },  // Physical slot 5
+        { slot: 5, ccValue: 11 },  // Physical slot 6
+        { slot: 6, ccValue: 12 },  // Physical slot 7
+        { slot: 7, ccValue: 13 },  // Physical slot 8
+        { slot: 8, ccValue: 14 },  // Physical slot 9
+        { slot: 9, ccValue: 15 },  // Physical slot 10
+        { slot: 10, ccValue: 16 }, // Physical slot 11
+        { slot: 11, ccValue: 17 }, // Physical slot 12
+        { slot: 12, ccValue: 18 }, // Physical slot 13
+        { slot: 13, ccValue: 19 }, // Physical slot 14
+        { slot: 14, ccValue: 20 }, // Physical slot 15
+      ];
+
+      for (const { slot, ccValue } of expectedMappings) {
+        sendMessage.mockClear();
+        await controller.selectSlot(slot);
+
+        // Check the CC message (2nd call)
+        expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, ccValue]);
+      }
+    });
+
+    it('should throw error for invalid slot number (negative)', async () => {
+      await expect(controller.selectSlot(-1)).rejects.toThrow('Invalid slot: -1. Must be 0-14');
+    });
+
+    it('should throw error for invalid slot number (> 14)', async () => {
+      await expect(controller.selectSlot(15)).rejects.toThrow('Invalid slot: 15. Must be 0-14');
+    });
+
+    it('should add delay after sending messages', async () => {
+      const start = Date.now();
+      await controller.selectSlot(0);
+      const duration = Date.now() - start;
+
+      // Should have at least 50ms delay
+      expect(duration).toBeGreaterThanOrEqual(45); // Allow some margin
+    });
+
+    it('should use correct MIDI channels', async () => {
+      await controller.selectSlot(0);
+
+      const [noteOn] = sendMessage.mock.calls[0][0];
+      const [cc] = sendMessage.mock.calls[1][0];
+      const [noteOff] = sendMessage.mock.calls[2][0];
+
+      // Note messages on channel 15 (0x9F = 0x90 | 0x0F)
+      expect(noteOn & 0xF0).toBe(0x90); // Note On status
+      expect(noteOn & 0x0F).toBe(0x0F); // Channel 15
+
+      // CC on channel 5 (0xB5 = 0xB0 | 0x05)
+      expect(cc & 0xF0).toBe(0xB0); // CC status
+      expect(cc & 0x0F).toBe(0x05); // Channel 5 (6 in 1-based)
+
+      // Note Off is Note On with velocity 0
+      expect(noteOff & 0xF0).toBe(0x90);
+      expect(noteOff & 0x0F).toBe(0x0F);
+    });
+  });
+
+  describe('sendNoteNotification', () => {
+    it('should send note on and off without CC', async () => {
+      await controller.sendNoteNotification();
+
+      expect(sendMessage).toHaveBeenCalledTimes(2);
+
+      // Note On
+      expect(sendMessage).toHaveBeenNthCalledWith(1, [0x9F, 11, 127]);
+
+      // Note Off
+      expect(sendMessage).toHaveBeenNthCalledWith(2, [0x9F, 11, 0]);
+    });
+
+    it('should not send CC message', async () => {
+      await controller.sendNoteNotification();
+
+      // Verify no CC messages were sent
+      const calls = sendMessage.mock.calls;
+      const ccMessages = calls.filter(([msg]) =>
+        (msg[0] & 0xF0) === 0xB0
+      );
+
+      expect(ccMessages).toHaveLength(0);
+    });
+  });
+
+  describe('error handling', () => {
+    it('should propagate sendMessage errors', async () => {
+      const error = new Error('MIDI port not open');
+      sendMessage.mockRejectedValueOnce(error);
+
+      await expect(controller.selectSlot(0)).rejects.toThrow('MIDI port not open');
+    });
+
+    it('should handle async errors in sendMessage', async () => {
+      sendMessage
+        .mockResolvedValueOnce(undefined) // First call succeeds
+        .mockRejectedValueOnce(new Error('Connection lost')); // Second fails
+
+      await expect(controller.selectSlot(0)).rejects.toThrow('Connection lost');
+
+      // First message should have been sent
+      expect(sendMessage).toHaveBeenCalledTimes(2);
+    });
+  });
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-compare-sysex.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-compare-sysex.ts
new file mode 100644
index 0000000..01e09a4
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-compare-sysex.ts
@@ -0,0 +1,210 @@
+#!/usr/bin/env npx tsx
+/**
+ * Compare our generated SysEx with known-good data from web editor
+ * This helps identify exactly what's different
+ */
+
+import { LaunchControlXL3 } from '../src/index.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+import { SysExParser } from '../src/core/SysExParser.js';
+
+// Exact data captured from web editor for slot 0 (342 bytes)
+const KNOWN_GOOD_DATA_SLOT_0 = Buffer.from([
+  0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00, 0x01, 0x20, 0x10, 0x2A, 0x4E, 0x65,
+  0x77, 0x20, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x49, 0x10, 0x02,
+  0x05, 0x00, 0x01, 0x40, 0x00, 0x0D, 0x7F, 0x00, 0x49, 0x11, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00,
+  0x0E, 0x7F, 0x00, 0x49, 0x12, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x0F, 0x7F, 0x00, 0x49, 0x13,
+  0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x10, 0x7F, 0x00, 0x49, 0x14, 0x02, 0x05, 0x00, 0x01, 0x40,
+  0x00, 0x11, 0x7F, 0x00, 0x49, 0x15, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x12, 0x7F, 0x00, 0x49,
+  0x16, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x13, 0x7F, 0x00, 0x49, 0x17, 0x02, 0x05, 0x00, 0x01,
+  0x40, 0x00, 0x14, 0x7F, 0x00, 0x49, 0x18, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x15, 0x7F, 0x00,
+  0x49, 0x19, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x16, 0x7F, 0x00, 0x49, 0x1A, 0x02, 0x09, 0x00,
+  0x01, 0x40, 0x00, 0x17, 0x7F, 0x00, 0x49, 0x1B, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x18, 0x7F,
+  0x00, 0x49, 0x1C, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x19, 0x7F, 0x00, 0x49, 0x1D, 0x02, 0x09,
+  0x00, 0x01, 0x40, 0x00, 0x1A, 0x7F, 0x00, 0x49, 0x1E, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1B,
+  0x7F, 0x00, 0x49, 0x1F, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1C, 0x7F, 0x00, 0x49, 0x20, 0x02,
+  0x0D, 0x00, 0x01, 0x40, 0x00, 0x1D, 0x7F, 0x00, 0x49, 0x21, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00,
+  0x1E, 0x7F, 0x00, 0x49, 0x22, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x1F, 0x7F, 0x00, 0x49, 0x23,
+  0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x20, 0x7F, 0x00, 0x49, 0x24, 0x02, 0x0D, 0x00, 0x01, 0x40,
+  0x00, 0x21, 0x7F, 0x00, 0x49, 0x25, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x22, 0x7F, 0x00, 0x49,
+  0x26, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x23, 0x7F, 0x00, 0x49, 0x27, 0x02, 0x0D, 0x00, 0x01,
+  0x40, 0x00, 0x24, 0x7F, 0x00, 0x60, 0x10, 0x60, 0x11, 0x60, 0x12, 0x60, 0x13, 0x60, 0x14, 0x60,
+  0x15, 0x60, 0x16, 0x60, 0x17, 0x60, 0x18, 0x60, 0x19, 0x60, 0x1A, 0x60, 0x1B, 0x60, 0x1C, 0x60,
+  0x1D, 0x60, 0x1E, 0x60, 0x1F, 0x60, 0x20, 0x60, 0x21, 0x60, 0x22, 0x60, 0x23, 0x60, 0x24, 0x60,
+  0x25, 0x60, 0x26, 0x60, 0x27, 0xF7
+]);
+
+function compareBuffers(a: Buffer, b: Buffer, name1: string, name2: string) {
+  console.log(`\n=== Comparing ${name1} vs ${name2} ===`);
+  console.log(`${name1} length: ${a.length} bytes`);
+  console.log(`${name2} length: ${b.length} bytes`);
+
+  if (a.length !== b.length) {
+    console.log(`⚠️ LENGTH MISMATCH: ${Math.abs(a.length - b.length)} bytes difference`);
+  }
+
+  // Find first difference
+  let firstDiff = -1;
+  let diffCount = 0;
+  const maxDiffsToShow = 20;
+
+  for (let i = 0; i < Math.max(a.length, b.length); i++) {
+    const valA = i < a.length ? a[i] : undefined;
+    const valB = i < b.length ? b[i] : undefined;
+
+    if (valA !== valB) {
+      if (firstDiff === -1) firstDiff = i;
+      diffCount++;
+
+      if (diffCount <= maxDiffsToShow) {
+        const hexA = valA !== undefined ? `0x${valA.toString(16).padStart(2, '0').toUpperCase()}` : 'MISSING';
+        const hexB = valB !== undefined ? `0x${valB.toString(16).padStart(2, '0').toUpperCase()}` : 'MISSING';
+        console.log(`  Byte ${i}: ${hexA} != ${hexB}`);
+      }
+    }
+  }
+
+  if (diffCount === 0) {
+    console.log('✅ IDENTICAL: Buffers match exactly!');
+  } else {
+    console.log(`\n❌ DIFFERENT: ${diffCount} bytes differ (first at position ${firstDiff})`);
+    if (diffCount > maxDiffsToShow) {
+      console.log(`  (showing first ${maxDiffsToShow} differences)`);
+    }
+  }
+
+  // Show context around first difference
+  if (firstDiff >= 0 && firstDiff < Math.min(a.length, b.length)) {
+    console.log('\nContext around first difference:');
+    const start = Math.max(0, firstDiff - 5);
+    const end = Math.min(Math.max(a.length, b.length), firstDiff + 10);
+
+    console.log(`${name1}:`);
+    console.log('  ' + Array.from(a.slice(start, Math.min(end, a.length)))
+      .map((b, i) => {
+        const hex = b.toString(16).padStart(2, '0').toUpperCase();
+        return (start + i === firstDiff) ? `[${hex}]` : hex;
+      }).join(' '));
+
+    console.log(`${name2}:`);
+    console.log('  ' + Array.from(b.slice(start, Math.min(end, b.length)))
+      .map((b, i) => {
+        const hex = b.toString(16).padStart(2, '0').toUpperCase();
+        return (start + i === firstDiff) ? `[${hex}]` : hex;
+      }).join(' '));
+  }
+
+  return diffCount === 0;
+}
+
+async function testSysExComparison() {
+  console.log('SysEx Message Comparison Test');
+  console.log('==============================\n');
+
+  let device: LaunchControlXL3 | null = null;
+  let capturedMessages: number[][] = [];
+
+  try {
+    // Initialize MIDI backend with message capture
+    const midiBackend = new EasyMidiBackend();
+    await midiBackend.initialize();
+
+    // Monkey-patch to capture outgoing messages
+    const originalSend = midiBackend.sendMessage.bind(midiBackend);
+    midiBackend.sendMessage = async (port: any, message: any) => {
+      console.log(`📤 Capturing outgoing message: ${message.length} bytes`);
+      if (message[0] === 0xF0) { // SysEx
+        capturedMessages.push(message);
+      }
+      return originalSend(port, message);
+    };
+
+    // Create device with custom modes enabled
+    device = new LaunchControlXL3({
+      midiBackend: midiBackend,
+      enableLedControl: false,
+      enableCustomModes: true
+    });
+
+    console.log('→ Connecting to device...');
+    await device.connect();
+    console.log('✓ Connected\n');
+
+    // Create test mode matching the web editor's data
+    const testMode = {
+      name: 'New Custom Mode',
+      controls: [],
+      colors: []
+    };
+
+    // Add 24 encoders (just the first 24 controls from web editor)
+    for (let i = 0; i < 24; i++) {
+      const controlId = 0x10 + i;
+      testMode.controls.push({
+        id: controlId,
+        controlId: controlId,
+        type: 'encoder',
+        index: i,
+        cc: 0x0D + i, // Starting at CC 13 (0x0D)
+        channel: 1,
+        minValue: 0,
+        maxValue: 127,
+        color: 0 // Default color
+      });
+      testMode.colors.push(0); // Add color to colors array
+    }
+
+    // Clear captured messages
+    capturedMessages = [];
+
+    console.log('→ Writing custom mode to slot 0...');
+    await device.writeCustomMode(0, testMode);
+    console.log('✓ Write completed\n');
+
+    // Find the write SysEx message (should be command 0x45)
+    const writeSysEx = capturedMessages.find(msg =>
+      msg.length > 10 && msg[8] === 0x45 // Write command
+    );
+
+    if (writeSysEx) {
+      console.log(`📤 Captured write SysEx: ${writeSysEx.length} bytes`);
+      const ourBuffer = Buffer.from(writeSysEx);
+
+      // Compare with known good
+      compareBuffers(ourBuffer, KNOWN_GOOD_DATA_SLOT_0, 'Our SysEx', 'Web Editor SysEx');
+
+      // Also generate using SysExParser directly for comparison
+      console.log('\n=== Testing SysExParser directly ===');
+      const directEncoded = SysExParser.encodeCustomModeData(testMode, 0);
+      const directBuffer = Buffer.from(directEncoded);
+
+      compareBuffers(directBuffer, KNOWN_GOOD_DATA_SLOT_0, 'Direct Parser', 'Web Editor SysEx');
+      compareBuffers(ourBuffer, directBuffer, 'Captured', 'Direct Parser');
+
+      // Show hex dumps of key sections
+      console.log('\n=== Key Sections ===');
+      console.log('\nHeader (first 30 bytes):');
+      console.log('Our:    ' + Array.from(ourBuffer.slice(0, 30)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' '));
+      console.log('Known:  ' + Array.from(KNOWN_GOOD_DATA_SLOT_0.slice(0, 30)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' '));
+
+      console.log('\nFirst control definition (bytes 30-40):');
+      console.log('Our:    ' + Array.from(ourBuffer.slice(30, 40)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' '));
+      console.log('Known:  ' + Array.from(KNOWN_GOOD_DATA_SLOT_0.slice(30, 40)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' '));
+
+    } else {
+      console.log('❌ No write SysEx captured!');
+    }
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (device) {
+      console.log('\n→ Disconnecting...');
+      await device.disconnect();
+      console.log('✓ Disconnected');
+    }
+  }
+}
+
+// Run the test
+testSysExComparison().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-daw-port-integration.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-daw-port-integration.ts
new file mode 100644
index 0000000..ae5f7c6
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-daw-port-integration.ts
@@ -0,0 +1,148 @@
+#!/usr/bin/env tsx
+/**
+ * Integration test using DAW port for slot selection with our library
+ */
+
+import { LaunchControlXL3 } from '../src/index.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+import { DawPortControllerImpl } from '../src/core/DawPortController.js';
+import type { CustomMode } from '../src/types.js';
+
+async function testDawPortIntegration() {
+  console.log('DAW Port Integration Test');
+  console.log('=========================\n');
+
+  let device: LaunchControlXL3 | null = null;
+  let backend: EasyMidiBackend | null = null;
+
+  try {
+    // Initialize MIDI backend
+    backend = new EasyMidiBackend();
+    await backend.initialize();
+
+    // Open DAW port for LCXL3
+    await backend.openDawPort('LCXL3');
+
+    // Create DAW port controller
+    const dawController = new DawPortControllerImpl(
+      async (port: 'daw', message: number[]) => {
+        await backend!.sendDawMessage('LCXL3', message);
+      }
+    );
+
+    // Create device
+    device = new LaunchControlXL3({
+      midiBackend: backend,
+      enableLedControl: false,
+      enableCustomModes: true
+    });
+
+    console.log('→ Connecting to device...');
+    await device.connect();
+    console.log('✓ Connected\n');
+
+    // Create test modes
+    const testMode1: CustomMode = {
+      name: 'DAW_SLOT_1',
+      controls: [],
+      colors: []
+    };
+
+    const testMode2: CustomMode = {
+      name: 'DAW_SLOT_2',
+      controls: [],
+      colors: []
+    };
+
+    // Add minimal controls (just one encoder each)
+    testMode1.controls.push({
+      id: 0x10,
+      type: 'encoder',
+      index: 0,
+      cc: 13,
+      channel: 1,
+      minValue: 0,
+      maxValue: 127,
+      color: 0
+    });
+    testMode1.colors.push(0);
+
+    testMode2.controls.push({
+      id: 0x10,
+      type: 'encoder',
+      index: 0,
+      cc: 14,  // Different CC to distinguish
+      channel: 1,
+      minValue: 0,
+      maxValue: 127,
+      color: 0
+    });
+    testMode2.colors.push(0);
+
+    // Test 1: Write to physical slot 1 (API slot 0)
+    console.log('=== Test 1: Writing to Physical Slot 1 ===');
+    console.log('→ Selecting slot 0 via DAW port (physical slot 1)...');
+    await dawController.selectSlot(0);
+    console.log('✓ Slot selected');
+
+    console.log('→ Writing "DAW_SLOT_1" to slot 0...');
+    await device.writeCustomMode(0, testMode1);
+    console.log('✓ Write completed');
+
+    await new Promise(resolve => setTimeout(resolve, 1000));
+
+    // Test 2: Write to physical slot 2 (API slot 1)
+    console.log('\n=== Test 2: Writing to Physical Slot 2 ===');
+    console.log('→ Selecting slot 1 via DAW port (physical slot 2)...');
+    await dawController.selectSlot(1);
+    console.log('✓ Slot selected');
+
+    console.log('→ Writing "DAW_SLOT_2" to slot 0 (but should go to physical slot 2)...');
+    // Note: We're still using slot 0 in the API call, but DAW port controls actual slot
+    await device.writeCustomMode(0, testMode2);
+    console.log('✓ Write completed');
+
+    await new Promise(resolve => setTimeout(resolve, 1000));
+
+    // Test 3: Read back from slots
+    console.log('\n=== Test 3: Reading Back ===');
+
+    console.log('→ Selecting slot 0 for reading...');
+    await dawController.selectSlot(0);
+    const readBack1 = await device.readCustomMode(0);
+    console.log(`✓ Slot 0 (physical 1): "${readBack1?.name || '<empty>'}"`);
+
+    console.log('→ Selecting slot 1 for reading...');
+    await dawController.selectSlot(1);
+    const readBack2 = await device.readCustomMode(0);
+    console.log(`✓ Slot 0 (physical 2 due to DAW selection): "${readBack2?.name || '<empty>'}"`);
+
+    console.log('\n📋 Summary:');
+    console.log('- DAW port CC 30 on channel 6 selects the active slot');
+    console.log('- Value = physical slot + 5 (slot 1 = 6, slot 2 = 7)');
+    console.log('- SysEx slot byte can remain 0x00');
+    console.log('- This matches the web editor behavior exactly');
+
+    console.log('\n🔍 Please verify on device:');
+    console.log('   - Physical slot 1 should show "DAW_SLOT_1"');
+    console.log('   - Physical slot 2 should show "DAW_SLOT_2"');
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+    if (error instanceof Error) {
+      console.error('Stack:', error.stack);
+    }
+  } finally {
+    if (device) {
+      console.log('\n→ Disconnecting...');
+      await device.disconnect();
+      console.log('✓ Disconnected');
+    }
+    if (backend) {
+      await backend.cleanup();
+    }
+  }
+}
+
+// Run the test
+testDawPortIntegration().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-daw-port-monitor.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-daw-port-monitor.ts
new file mode 100644
index 0000000..3762ad2
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-daw-port-monitor.ts
@@ -0,0 +1,131 @@
+#!/usr/bin/env tsx
+/**
+ * Monitor both MIDI and DAW ports to see if there's out-of-band communication
+ * that controls which slot is active for writing
+ */
+
+import easymidi from 'easymidi';
+
+async function monitorDAWPort() {
+  console.log('DAW Port Monitor - Looking for Out-of-Band Slot Control');
+  console.log('========================================================\n');
+
+  let midiInput: any = null;
+  let dawInput: any = null;
+
+  try {
+    // List available MIDI devices
+    console.log('Available MIDI inputs:', easymidi.getInputs());
+    console.log();
+
+    // Find Launch Control XL3 ports
+    const midiPortName = easymidi.getInputs().find((name: string) =>
+      name.includes('LCXL3') && name.includes('MIDI Out'));
+    const dawPortName = easymidi.getInputs().find((name: string) =>
+      name.includes('LCXL3') && name.includes('DAW Out'));
+
+    if (!midiPortName || !dawPortName) {
+      throw new Error('Launch Control XL3 ports not found');
+    }
+
+    console.log(`📡 Monitoring MIDI Port: ${midiPortName}`);
+    console.log(`📡 Monitoring DAW Port: ${dawPortName}`);
+    console.log('\n⚠️  Please use the web editor to change slots and write data');
+    console.log('   Watch for any messages that might indicate slot selection\n');
+    console.log('=' .repeat(60) + '\n');
+
+    // Monitor MIDI port
+    midiInput = new easymidi.Input(midiPortName);
+
+    midiInput.on('noteon', (msg: any) => {
+      console.log(`[MIDI] Note On: note=${msg.note}, velocity=${msg.velocity}, channel=${msg.channel}`);
+    });
+
+    midiInput.on('noteoff', (msg: any) => {
+      console.log(`[MIDI] Note Off: note=${msg.note}, velocity=${msg.velocity}, channel=${msg.channel}`);
+    });
+
+    midiInput.on('cc', (msg: any) => {
+      const hex = `0x${msg.controller.toString(16).padStart(2, '0').toUpperCase()}`;
+      console.log(`[MIDI] CC: controller=${msg.controller} (${hex}), value=${msg.value}, channel=${msg.channel}`);
+    });
+
+    midiInput.on('program', (msg: any) => {
+      console.log(`[MIDI] Program Change: number=${msg.number}, channel=${msg.channel}`);
+      console.log(`   🎯 This could be slot selection! Program ${msg.number} might = Slot ${msg.number + 1}`);
+    });
+
+    midiInput.on('sysex', (msg: any) => {
+      const preview = msg.bytes.slice(0, 12).map((b: number) =>
+        '0x' + b.toString(16).padStart(2, '0').toUpperCase()
+      ).join(' ');
+      console.log(`[MIDI] SysEx: ${msg.bytes.length} bytes - ${preview}...`);
+    });
+
+    // Monitor DAW port
+    dawInput = new easymidi.Input(dawPortName);
+
+    dawInput.on('noteon', (msg: any) => {
+      console.log(`[DAW] Note On: note=${msg.note}, velocity=${msg.velocity}, channel=${msg.channel}`);
+      console.log(`   💡 Note ${msg.note} might indicate slot or mode`);
+    });
+
+    dawInput.on('noteoff', (msg: any) => {
+      console.log(`[DAW] Note Off: note=${msg.note}, velocity=${msg.velocity}, channel=${msg.channel}`);
+    });
+
+    dawInput.on('cc', (msg: any) => {
+      const hex = `0x${msg.controller.toString(16).padStart(2, '0').toUpperCase()}`;
+      console.log(`[DAW] CC: controller=${msg.controller} (${hex}), value=${msg.value}, channel=${msg.channel}`);
+
+      // Check for special CC messages that might control slots
+      if (msg.controller >= 0x60 && msg.controller <= 0x6F) {
+        console.log(`   🎯 Possible slot control CC in range 0x60-0x6F!`);
+      }
+    });
+
+    dawInput.on('program', (msg: any) => {
+      console.log(`[DAW] Program Change: number=${msg.number}, channel=${msg.channel}`);
+      console.log(`   🎯 This could be slot selection! Program ${msg.number} might = Slot ${msg.number + 1}`);
+    });
+
+    dawInput.on('sysex', (msg: any) => {
+      const preview = msg.bytes.slice(0, 12).map((b: number) =>
+        '0x' + b.toString(16).padStart(2, '0').toUpperCase()
+      ).join(' ');
+      console.log(`[DAW] SysEx: ${msg.bytes.length} bytes - ${preview}...`);
+
+      // Check for specific commands
+      if (msg.bytes.length > 8) {
+        const cmd = msg.bytes[8];
+        if (cmd === 0x77) {
+          console.log(`   💡 Command 0x77 detected - might be mode/slot related`);
+        }
+      }
+    });
+
+    // Also monitor any other message types
+    midiInput.on('select', (msg: any) => {
+      console.log(`[MIDI] Song Select: song=${msg.song}`);
+    });
+
+    dawInput.on('select', (msg: any) => {
+      console.log(`[DAW] Song Select: song=${msg.song}`);
+    });
+
+    console.log('Monitoring... Press Ctrl+C to stop\n');
+
+    // Keep running
+    await new Promise(() => {}); // Never resolves
+
+  } catch (error) {
+    console.error('\n✗ Monitor failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (midiInput) midiInput.close();
+    if (dawInput) dawInput.close();
+    console.log('\n✓ Monitoring stopped');
+  }
+}
+
+// Run the monitor
+monitorDAWPort().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-exact-web-editor-data.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-exact-web-editor-data.ts
new file mode 100644
index 0000000..b7b8279
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-exact-web-editor-data.ts
@@ -0,0 +1,118 @@
+#!/usr/bin/env tsx
+/**
+ * Send the EXACT known-good SysEx data captured from the web editor
+ * This will help us understand what's happening with slot mapping
+ */
+
+import { LaunchControlXL3 } from '../src/index.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+
+// Exact data captured from web editor for slot 0 (342 bytes)
+const KNOWN_GOOD_DATA_SLOT_0 = Buffer.from([
+  0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00, 0x01, 0x20, 0x10, 0x2A, 0x4E, 0x65,
+  0x77, 0x20, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x49, 0x10, 0x02,
+  0x05, 0x00, 0x01, 0x40, 0x00, 0x0D, 0x7F, 0x00, 0x49, 0x11, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00,
+  0x0E, 0x7F, 0x00, 0x49, 0x12, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x0F, 0x7F, 0x00, 0x49, 0x13,
+  0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x10, 0x7F, 0x00, 0x49, 0x14, 0x02, 0x05, 0x00, 0x01, 0x40,
+  0x00, 0x11, 0x7F, 0x00, 0x49, 0x15, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x12, 0x7F, 0x00, 0x49,
+  0x16, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x13, 0x7F, 0x00, 0x49, 0x17, 0x02, 0x05, 0x00, 0x01,
+  0x40, 0x00, 0x14, 0x7F, 0x00, 0x49, 0x18, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x15, 0x7F, 0x00,
+  0x49, 0x19, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x16, 0x7F, 0x00, 0x49, 0x1A, 0x02, 0x09, 0x00,
+  0x01, 0x40, 0x00, 0x17, 0x7F, 0x00, 0x49, 0x1B, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x18, 0x7F,
+  0x00, 0x49, 0x1C, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x19, 0x7F, 0x00, 0x49, 0x1D, 0x02, 0x09,
+  0x00, 0x01, 0x40, 0x00, 0x1A, 0x7F, 0x00, 0x49, 0x1E, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1B,
+  0x7F, 0x00, 0x49, 0x1F, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1C, 0x7F, 0x00, 0x49, 0x20, 0x02,
+  0x0D, 0x00, 0x01, 0x40, 0x00, 0x1D, 0x7F, 0x00, 0x49, 0x21, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00,
+  0x1E, 0x7F, 0x00, 0x49, 0x22, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x1F, 0x7F, 0x00, 0x49, 0x23,
+  0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x20, 0x7F, 0x00, 0x49, 0x24, 0x02, 0x0D, 0x00, 0x01, 0x40,
+  0x00, 0x21, 0x7F, 0x00, 0x49, 0x25, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x22, 0x7F, 0x00, 0x49,
+  0x26, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x23, 0x7F, 0x00, 0x49, 0x27, 0x02, 0x0D, 0x00, 0x01,
+  0x40, 0x00, 0x24, 0x7F, 0x00, 0x60, 0x10, 0x60, 0x11, 0x60, 0x12, 0x60, 0x13, 0x60, 0x14, 0x60,
+  0x15, 0x60, 0x16, 0x60, 0x17, 0x60, 0x18, 0x60, 0x19, 0x60, 0x1A, 0x60, 0x1B, 0x60, 0x1C, 0x60,
+  0x1D, 0x60, 0x1E, 0x60, 0x1F, 0x60, 0x20, 0x60, 0x21, 0x60, 0x22, 0x60, 0x23, 0x60, 0x24, 0x60,
+  0x25, 0x60, 0x26, 0x60, 0x27, 0xF7
+]);
+
+async function testExactWebEditorData() {
+  console.log('Exact Web Editor Data Test');
+  console.log('===========================\n');
+
+  let device: LaunchControlXL3 | null = null;
+
+  try {
+    // Initialize MIDI backend
+    const midiBackend = new EasyMidiBackend();
+    await midiBackend.initialize();
+
+    // Monkey-patch to capture what we're sending
+    const originalSend = midiBackend.sendMessage.bind(midiBackend);
+    midiBackend.sendMessage = async (port: any, message: any) => {
+      if (message[0] === 0xF0) { // SysEx
+        console.log(`📤 Sending SysEx: ${message.length} bytes`);
+
+        // Show key bytes
+        const slotByte = message[9];
+        console.log(`   Command: 0x${message[8].toString(16).padStart(2, '0').toUpperCase()}`);
+        console.log(`   Slot byte: 0x${slotByte.toString(16).padStart(2, '0').toUpperCase()} (decimal ${slotByte})`);
+
+        // Show name if present
+        if (message.length > 30) {
+          const nameBytes = message.slice(14, 29);
+          const name = String.fromCharCode(...nameBytes);
+          console.log(`   Name: "${name}"`);
+        }
+      }
+      return originalSend(port, message);
+    };
+
+    // Create device
+    device = new LaunchControlXL3({
+      midiBackend: midiBackend,
+      enableLedControl: false,
+      enableCustomModes: true
+    });
+
+    console.log('→ Connecting to device...');
+    await device.connect();
+    console.log('✓ Connected\n');
+
+    // Send the EXACT known-good data from web editor
+    console.log('=== Sending EXACT Web Editor Data ===');
+    console.log('This is the exact 342-byte message captured from the web editor');
+    console.log('It should write "New Custom Mode" to physical slot 2\n');
+
+    // Get the device manager to access the output
+    const deviceManager = (device as any).deviceManager;
+    if (deviceManager && deviceManager.midiBackend) {
+      console.log('→ Sending exact web editor SysEx...');
+
+      // Send the exact bytes
+      await deviceManager.midiBackend.sendSysEx(Array.from(KNOWN_GOOD_DATA_SLOT_0));
+      console.log('✓ Sent successfully');
+
+      // Wait for device to process
+      await new Promise(resolve => setTimeout(resolve, 1000));
+
+      console.log('\n📋 Summary:');
+      console.log('- Sent exact 342-byte message from web editor');
+      console.log('- Slot byte was 0x00');
+      console.log('- Name was "New Custom Mode"');
+      console.log('- Message included only 24 encoders (no faders/buttons)');
+      console.log('\n🔍 Please check the device and tell me which physical slot changed!');
+    } else {
+      console.error('✗ Could not access device manager');
+    }
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (device) {
+      console.log('\n→ Disconnecting...');
+      await device.disconnect();
+      console.log('✓ Disconnected');
+    }
+  }
+}
+
+// Run the test
+testExactWebEditorData().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-known-good-data.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-known-good-data.ts
new file mode 100644
index 0000000..c86f9a5
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-known-good-data.ts
@@ -0,0 +1,218 @@
+#!/usr/bin/env npx tsx
+/**
+ * Test sending exact known-good data captured from the web editor
+ * This helps verify if the issue is with our data format or something else
+ */
+
+import { LaunchControlXL3 } from '../src/index.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+
+// Exact data captured from web editor for slot 0 (342 bytes)
+const KNOWN_GOOD_DATA_SLOT_0 = Buffer.from([
+  0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00, 0x01, 0x20, 0x10, 0x2A, 0x4E, 0x65,
+  0x77, 0x20, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x49, 0x10, 0x02,
+  0x05, 0x00, 0x01, 0x40, 0x00, 0x0D, 0x7F, 0x00, 0x49, 0x11, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00,
+  0x0E, 0x7F, 0x00, 0x49, 0x12, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x0F, 0x7F, 0x00, 0x49, 0x13,
+  0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x10, 0x7F, 0x00, 0x49, 0x14, 0x02, 0x05, 0x00, 0x01, 0x40,
+  0x00, 0x11, 0x7F, 0x00, 0x49, 0x15, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x12, 0x7F, 0x00, 0x49,
+  0x16, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x13, 0x7F, 0x00, 0x49, 0x17, 0x02, 0x05, 0x00, 0x01,
+  0x40, 0x00, 0x14, 0x7F, 0x00, 0x49, 0x18, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x15, 0x7F, 0x00,
+  0x49, 0x19, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x16, 0x7F, 0x00, 0x49, 0x1A, 0x02, 0x09, 0x00,
+  0x01, 0x40, 0x00, 0x17, 0x7F, 0x00, 0x49, 0x1B, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x18, 0x7F,
+  0x00, 0x49, 0x1C, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x19, 0x7F, 0x00, 0x49, 0x1D, 0x02, 0x09,
+  0x00, 0x01, 0x40, 0x00, 0x1A, 0x7F, 0x00, 0x49, 0x1E, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1B,
+  0x7F, 0x00, 0x49, 0x1F, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1C, 0x7F, 0x00, 0x49, 0x20, 0x02,
+  0x0D, 0x00, 0x01, 0x40, 0x00, 0x1D, 0x7F, 0x00, 0x49, 0x21, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00,
+  0x1E, 0x7F, 0x00, 0x49, 0x22, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x1F, 0x7F, 0x00, 0x49, 0x23,
+  0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x20, 0x7F, 0x00, 0x49, 0x24, 0x02, 0x0D, 0x00, 0x01, 0x40,
+  0x00, 0x21, 0x7F, 0x00, 0x49, 0x25, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x22, 0x7F, 0x00, 0x49,
+  0x26, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x23, 0x7F, 0x00, 0x49, 0x27, 0x02, 0x0D, 0x00, 0x01,
+  0x40, 0x00, 0x24, 0x7F, 0x00, 0x60, 0x10, 0x60, 0x11, 0x60, 0x12, 0x60, 0x13, 0x60, 0x14, 0x60,
+  0x15, 0x60, 0x16, 0x60, 0x17, 0x60, 0x18, 0x60, 0x19, 0x60, 0x1A, 0x60, 0x1B, 0x60, 0x1C, 0x60,
+  0x1D, 0x60, 0x1E, 0x60, 0x1F, 0x60, 0x20, 0x60, 0x21, 0x60, 0x22, 0x60, 0x23, 0x60, 0x24, 0x60,
+  0x25, 0x60, 0x26, 0x60, 0x27, 0xF7
+]);
+
+// Exact data captured from web editor for slot 3 (342 bytes)
+const KNOWN_GOOD_DATA_SLOT_3 = Buffer.from([
+  0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x03, 0x01, 0x20, 0x10, 0x2A, 0x4E, 0x65,
+  0x77, 0x20, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x49, 0x28, 0x02,
+  0x00, 0x00, 0x01, 0x40, 0x00, 0x05, 0x7F, 0x00, 0x49, 0x29, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00,
+  0x06, 0x7F, 0x00, 0x49, 0x2A, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x07, 0x7F, 0x00, 0x49, 0x2B,
+  0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x08, 0x7F, 0x00, 0x49, 0x2C, 0x02, 0x00, 0x00, 0x01, 0x40,
+  0x00, 0x09, 0x7F, 0x00, 0x49, 0x2D, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x0A, 0x7F, 0x00, 0x49,
+  0x2E, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x0B, 0x7F, 0x00, 0x49, 0x2F, 0x02, 0x00, 0x00, 0x01,
+  0x40, 0x00, 0x0C, 0x7F, 0x00, 0x60, 0x28, 0x60, 0x29, 0x60, 0x2A, 0x60, 0x2B, 0x60, 0x2C, 0x60,
+  0x2D, 0x60, 0x2E, 0x60, 0x2F, 0x49, 0x30, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x25, 0x7F, 0x00,
+  0x49, 0x31, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x26, 0x7F, 0x00, 0x49, 0x32, 0x02, 0x19, 0x03,
+  0x01, 0x50, 0x00, 0x27, 0x7F, 0x00, 0x49, 0x33, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x28, 0x7F,
+  0x00, 0x49, 0x34, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x29, 0x7F, 0x00, 0x49, 0x35, 0x02, 0x19,
+  0x03, 0x01, 0x50, 0x00, 0x2A, 0x7F, 0x00, 0x49, 0x36, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x2B,
+  0x7F, 0x00, 0x49, 0x37, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x2C, 0x7F, 0x00, 0x49, 0x38, 0x02,
+  0x25, 0x03, 0x01, 0x50, 0x00, 0x2D, 0x7F, 0x00, 0x49, 0x39, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00,
+  0x2E, 0x7F, 0x00, 0x49, 0x3A, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x2F, 0x7F, 0x00, 0x49, 0x3B,
+  0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x30, 0x7F, 0x00, 0x49, 0x3C, 0x02, 0x25, 0x03, 0x01, 0x50,
+  0x00, 0x31, 0x7F, 0x00, 0x49, 0x3D, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x32, 0x7F, 0x00, 0x49,
+  0x3E, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x33, 0x7F, 0x00, 0x49, 0x3F, 0x02, 0x25, 0x03, 0x01,
+  0x50, 0x00, 0x34, 0x7F, 0x00, 0x60, 0x30, 0x60, 0x31, 0x60, 0x32, 0x60, 0x33, 0x60, 0x34, 0x60,
+  0x35, 0x60, 0x36, 0x60, 0x37, 0x60, 0x38, 0x60, 0x39, 0x60, 0x3A, 0x60, 0x3B, 0x60, 0x3C, 0x60,
+  0x3D, 0x60, 0x3E, 0x60, 0x3F, 0xF7
+]);
+
+async function testKnownGoodData() {
+  console.log('Testing Known-Good Data from Web Editor');
+  console.log('========================================\n');
+
+  let device: LaunchControlXL3 | null = null;
+
+  try {
+    // Initialize MIDI backend
+    const midiBackend = new EasyMidiBackend();
+    await midiBackend.initialize();
+
+    // Create device with custom modes enabled
+    device = new LaunchControlXL3({
+      midiBackend: midiBackend,
+      enableLedControl: false,
+      enableCustomModes: true
+    });
+
+    console.log('→ Connecting to device...');
+    await device.connect();
+    console.log('✓ Connected\n');
+
+    // Test 1: Send known-good data to slot 0
+    console.log('=== Test 1: Sending Known-Good Data to Slot 0 ===');
+    console.log(`Data size: ${KNOWN_GOOD_DATA_SLOT_0.length} bytes`);
+    console.log(`First 20 bytes: ${Array.from(KNOWN_GOOD_DATA_SLOT_0.slice(0, 20)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ')}`);
+    console.log(`Mode name in data: "New Custom Mode"`);
+
+    console.log('\n→ Sending SysEx to device...');
+
+    // Send the raw SysEx data directly through our backend
+    await midiBackend.sendSysEx(Array.from(KNOWN_GOOD_DATA_SLOT_0));
+
+    console.log('✓ SysEx sent');
+
+    // Wait for response
+    await new Promise(resolve => setTimeout(resolve, 500));
+
+    // Try to read back
+    console.log('\n→ Reading back from slot 0...');
+    try {
+      const readMode = await device.readCustomMode(0);
+
+      if (readMode) {
+        console.log('✓ Read successful');
+        console.log(`Mode name: "${readMode.name}"`);
+        console.log(`Control count: ${readMode.controls?.length || 0}`);
+
+        // Check if it matches what we sent
+        if (readMode.name === 'New Custom Mode') {
+          console.log('✅ SUCCESS: Known-good data was written and read correctly!');
+        } else {
+          console.log('⚠️ WARNING: Data was read but name doesn\'t match');
+        }
+      } else {
+        console.log('✗ Read returned no data');
+      }
+    } catch (error) {
+      console.log(`✗ Read failed: ${error}`);
+    }
+
+    // Test 2: Send known-good data to slot 3
+    console.log('\n\n=== Test 2: Sending Known-Good Data to Slot 3 ===');
+    console.log(`Data size: ${KNOWN_GOOD_DATA_SLOT_3.length} bytes`);
+    console.log(`First 20 bytes: ${Array.from(KNOWN_GOOD_DATA_SLOT_3.slice(0, 20)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ')}`);
+
+    console.log('\n→ Sending SysEx to device...');
+
+    // Send the raw SysEx data directly through our backend
+    await midiBackend.sendSysEx(Array.from(KNOWN_GOOD_DATA_SLOT_3));
+
+    console.log('✓ SysEx sent');
+
+    // Wait for response
+    await new Promise(resolve => setTimeout(resolve, 500));
+
+    // Try to read back
+    console.log('\n→ Reading back from slot 3...');
+    try {
+      const readMode = await device.readCustomMode(3);
+
+      if (readMode) {
+        console.log('✓ Read successful');
+        console.log(`Mode name: "${readMode.name}"`);
+        console.log(`Control count: ${readMode.controls?.length || 0}`);
+
+        // Check if it matches what we sent
+        if (readMode.name === 'New Custom Mode') {
+          console.log('✅ SUCCESS: Known-good data was written and read correctly!');
+        } else {
+          console.log('⚠️ WARNING: Data was read but name doesn\'t match');
+        }
+      } else {
+        console.log('✗ Read returned no data');
+      }
+    } catch (error) {
+      console.log(`✗ Read failed: ${error}`);
+    }
+
+    // Compare with our generated data
+    console.log('\n\n=== Comparison with Our Generated Data ===');
+
+    // Generate data using our encoder
+    const testMode = {
+      name: 'New Custom Mode',
+      controls: []
+    };
+
+    // Add encoders (matching the web editor data)
+    for (let i = 0; i < 24; i++) {
+      const controlId = 0x10 + i;
+      testMode.controls.push({
+        id: controlId,
+        controlId: controlId,
+        type: 'encoder',
+        index: i,
+        cc: 0x0D + i, // Starting at CC 13
+        channel: 1,
+        minValue: 0,
+        maxValue: 127
+      });
+    }
+
+    const ourData = await (device as any).customModeManager.encodeMode(testMode, 0);
+
+    console.log(`Our data size: ${ourData.length} bytes`);
+    console.log(`Known-good size: ${KNOWN_GOOD_DATA_SLOT_0.length} bytes`);
+
+    if (ourData.length === KNOWN_GOOD_DATA_SLOT_0.length) {
+      // Find differences
+      let differences = 0;
+      for (let i = 0; i < ourData.length; i++) {
+        if (ourData[i] !== KNOWN_GOOD_DATA_SLOT_0[i]) {
+          if (differences < 10) {
+            console.log(`Difference at byte ${i}: Our=${ourData[i].toString(16).padStart(2, '0')} Known=${KNOWN_GOOD_DATA_SLOT_0[i].toString(16).padStart(2, '0')}`);
+          }
+          differences++;
+        }
+      }
+      console.log(`Total differences: ${differences} bytes`);
+    } else {
+      console.log('⚠️ Data sizes don\'t match!');
+    }
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (device) {
+      console.log('\n→ Disconnecting...');
+      await device.disconnect();
+      console.log('✓ Disconnected');
+    }
+  }
+}
+
+// Run the test
+testKnownGoodData().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-raw-sysex.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-raw-sysex.ts
new file mode 100644
index 0000000..72ccadb
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-raw-sysex.ts
@@ -0,0 +1,115 @@
+#!/usr/bin/env tsx
+/**
+ * Send the EXACT raw SysEx data using easymidi directly
+ */
+
+import easymidi from 'easymidi';
+
+// Exact data captured from web editor for slot 0 (342 bytes)
+const KNOWN_GOOD_DATA_SLOT_0 = [
+  0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00, 0x01, 0x20, 0x10, 0x2A, 0x4E, 0x65,
+  0x77, 0x20, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x49, 0x10, 0x02,
+  0x05, 0x00, 0x01, 0x40, 0x00, 0x0D, 0x7F, 0x00, 0x49, 0x11, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00,
+  0x0E, 0x7F, 0x00, 0x49, 0x12, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x0F, 0x7F, 0x00, 0x49, 0x13,
+  0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x10, 0x7F, 0x00, 0x49, 0x14, 0x02, 0x05, 0x00, 0x01, 0x40,
+  0x00, 0x11, 0x7F, 0x00, 0x49, 0x15, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x12, 0x7F, 0x00, 0x49,
+  0x16, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x13, 0x7F, 0x00, 0x49, 0x17, 0x02, 0x05, 0x00, 0x01,
+  0x40, 0x00, 0x14, 0x7F, 0x00, 0x49, 0x18, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x15, 0x7F, 0x00,
+  0x49, 0x19, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x16, 0x7F, 0x00, 0x49, 0x1A, 0x02, 0x09, 0x00,
+  0x01, 0x40, 0x00, 0x17, 0x7F, 0x00, 0x49, 0x1B, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x18, 0x7F,
+  0x00, 0x49, 0x1C, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x19, 0x7F, 0x00, 0x49, 0x1D, 0x02, 0x09,
+  0x00, 0x01, 0x40, 0x00, 0x1A, 0x7F, 0x00, 0x49, 0x1E, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1B,
+  0x7F, 0x00, 0x49, 0x1F, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1C, 0x7F, 0x00, 0x49, 0x20, 0x02,
+  0x0D, 0x00, 0x01, 0x40, 0x00, 0x1D, 0x7F, 0x00, 0x49, 0x21, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00,
+  0x1E, 0x7F, 0x00, 0x49, 0x22, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x1F, 0x7F, 0x00, 0x49, 0x23,
+  0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x20, 0x7F, 0x00, 0x49, 0x24, 0x02, 0x0D, 0x00, 0x01, 0x40,
+  0x00, 0x21, 0x7F, 0x00, 0x49, 0x25, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x22, 0x7F, 0x00, 0x49,
+  0x26, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x23, 0x7F, 0x00, 0x49, 0x27, 0x02, 0x0D, 0x00, 0x01,
+  0x40, 0x00, 0x24, 0x7F, 0x00, 0x60, 0x10, 0x60, 0x11, 0x60, 0x12, 0x60, 0x13, 0x60, 0x14, 0x60,
+  0x15, 0x60, 0x16, 0x60, 0x17, 0x60, 0x18, 0x60, 0x19, 0x60, 0x1A, 0x60, 0x1B, 0x60, 0x1C, 0x60,
+  0x1D, 0x60, 0x1E, 0x60, 0x1F, 0x60, 0x20, 0x60, 0x21, 0x60, 0x22, 0x60, 0x23, 0x60, 0x24, 0x60,
+  0x25, 0x60, 0x26, 0x60, 0x27, 0xF7
+];
+
+async function testRawSysEx() {
+  console.log('Raw SysEx Test - Exact Web Editor Data');
+  console.log('=======================================\n');
+
+  let output: any = null;
+  let input: any = null;
+
+  try {
+    // List available MIDI devices
+    console.log('Available MIDI outputs:', easymidi.getOutputs());
+    console.log('Available MIDI inputs:', easymidi.getInputs());
+    console.log();
+
+    // Find Launch Control XL3
+    const outputName = easymidi.getOutputs().find((name: string) => name.includes('LCXL3'));
+    const inputName = easymidi.getInputs().find((name: string) => name.includes('LCXL3'));
+
+    if (!outputName) {
+      throw new Error('Launch Control XL3 not found');
+    }
+
+    console.log(`→ Connecting to: ${outputName}`);
+    output = new easymidi.Output(outputName);
+
+    if (inputName) {
+      input = new easymidi.Input(inputName);
+
+      // Listen for responses
+      input.on('sysex', (msg: any) => {
+        console.log(`📥 Received SysEx response: ${msg.bytes.length} bytes`);
+        // Show first few bytes
+        const preview = msg.bytes.slice(0, 12).map((b: number) =>
+          '0x' + b.toString(16).padStart(2, '0').toUpperCase()
+        ).join(' ');
+        console.log(`   Preview: ${preview}...`);
+      });
+    }
+
+    console.log('✓ Connected\n');
+
+    // Send the EXACT known-good data
+    console.log('=== Sending EXACT Web Editor Data ===');
+    console.log(`Message length: ${KNOWN_GOOD_DATA_SLOT_0.length} bytes`);
+    console.log(`Slot byte (position 9): 0x${KNOWN_GOOD_DATA_SLOT_0[9].toString(16).padStart(2, '0').toUpperCase()}`);
+
+    // Extract and show the name
+    const nameBytes = KNOWN_GOOD_DATA_SLOT_0.slice(14, 29);
+    const name = String.fromCharCode(...nameBytes);
+    console.log(`Name in message: "${name}"`);
+    console.log();
+
+    console.log('→ Sending raw SysEx to device...');
+    output.send('sysex', KNOWN_GOOD_DATA_SLOT_0);
+    console.log('✓ Sent successfully');
+
+    // Wait for response
+    await new Promise(resolve => setTimeout(resolve, 2000));
+
+    console.log('\n📋 Summary:');
+    console.log('- Sent exact 342-byte message from web editor');
+    console.log('- Slot byte was 0x00');
+    console.log('- Name was "New Custom Mode"');
+    console.log('- Message included only 24 encoders (no faders/buttons)');
+    console.log('\n🔍 Please check the device and tell me which physical slot changed!');
+    console.log('   (The display should show the slot number that was modified)');
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (output) {
+      console.log('\n→ Closing MIDI connections...');
+      output.close();
+    }
+    if (input) {
+      input.close();
+    }
+    console.log('✓ Disconnected');
+  }
+}
+
+// Run the test
+testRawSysEx().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-round-trip.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-round-trip.ts
index 5b2ac0a..afcf31a 100644
--- a/modules/audio-control/modules/launch-control-xl3/utils/test-round-trip.ts
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-round-trip.ts
@@ -44,8 +44,18 @@ async function testRoundTrip() {
 
       const color = i % 4; // Cycle through colors
 
+      // Calculate proper control ID based on type and index
+      let controlId: number;
+      if (controlType === 'encoder') {
+        controlId = 0x10 + controlIndex; // 0x10-0x27 for encoders
+      } else if (controlType === 'fader') {
+        controlId = 0x28 + controlIndex; // 0x28-0x2F for faders
+      } else {
+        controlId = 0x30 + controlIndex; // 0x30-0x3F for buttons
+      }
+
       testMode.controls.push({
-        id: i,
+        id: controlId,  // Use proper control ID instead of sequential index
         type: controlType as 'encoder' | 'fader' | 'button',
         index: controlIndex,
         name: testName,
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-slot-debug.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-slot-debug.ts
new file mode 100644
index 0000000..e01dd26
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-slot-debug.ts
@@ -0,0 +1,155 @@
+#!/usr/bin/env tsx
+/**
+ * Debug test to capture exact SysEx bytes being sent for slot operations
+ */
+
+import { LaunchControlXL3 } from '../src/index.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+import type { CustomMode } from '../src/types.js';
+
+async function testSlotDebug() {
+  console.log('Slot Debug Test');
+  console.log('===============\n');
+
+  let device: LaunchControlXL3 | null = null;
+  let capturedMessages: number[][] = [];
+
+  try {
+    // Initialize MIDI backend with message capture
+    const midiBackend = new EasyMidiBackend();
+    await midiBackend.initialize();
+
+    // Monkey-patch to capture outgoing messages
+    const originalSend = midiBackend.sendMessage.bind(midiBackend);
+    midiBackend.sendMessage = async (port: any, message: any) => {
+      if (message[0] === 0xF0) { // SysEx
+        console.log(`📤 Capturing outgoing SysEx: ${message.length} bytes`);
+        capturedMessages.push(message);
+
+        // Show header bytes for debugging
+        const header = message.slice(0, 12).map((b: number) =>
+          b.toString(16).padStart(2, '0').toUpperCase()
+        ).join(' ');
+        console.log(`   Header: ${header}`);
+
+        // Identify the slot byte (position 9 after F0 00 20 29 02 15 05 00 45)
+        if (message[8] === 0x45) { // Write command
+          console.log(`   ⚠️ SLOT BYTE: 0x${message[9].toString(16).padStart(2, '0').toUpperCase()} (decimal ${message[9]})`);
+        }
+      }
+      return originalSend(port, message);
+    };
+
+    // Create device with custom modes enabled
+    device = new LaunchControlXL3({
+      midiBackend: midiBackend,
+      enableLedControl: false,
+      enableCustomModes: true
+    });
+
+    console.log('→ Connecting to device...');
+    await device.connect();
+    console.log('✓ Connected\n');
+
+    // Create minimal test mode
+    const testMode: CustomMode = {
+      name: 'SLOT_TEST',
+      controls: [],
+      colors: []
+    };
+
+    // Add just one encoder for testing
+    testMode.controls.push({
+      id: 0x10,  // First encoder
+      type: 'encoder',
+      index: 0,
+      cc: 13,
+      channel: 1,
+      minValue: 0,
+      maxValue: 127,
+      color: 0
+    });
+    testMode.colors.push(0);
+
+    // Test writing to slot 0
+    console.log('\n=== Testing Write to Slot 0 ===');
+    capturedMessages = [];
+    console.log('→ Writing to slot 0 (should be physical slot 1)...');
+    await device.writeCustomMode(0, testMode);
+    console.log('✓ Write completed');
+
+    if (capturedMessages.length > 0) {
+      const writeMsg = capturedMessages.find(msg => msg[8] === 0x45);
+      if (writeMsg) {
+        console.log(`\n📊 Analysis:`);
+        console.log(`   We sent slot byte: 0x${writeMsg[9].toString(16).padStart(2, '0').toUpperCase()}`);
+        console.log(`   This should write to physical slot ${writeMsg[9] + 1}`);
+      }
+    }
+
+    // Wait and then try to read back
+    await new Promise(resolve => setTimeout(resolve, 1000));
+
+    console.log('\n→ Reading back from slot 0...');
+    capturedMessages = [];
+    const readBack = await device.readCustomMode(0);
+
+    if (readBack) {
+      console.log(`✓ Read successful: "${readBack.name}"`);
+    } else {
+      console.log('✗ Read returned empty');
+    }
+
+    // Test writing to slot 1
+    console.log('\n=== Testing Write to Slot 1 ===');
+    capturedMessages = [];
+    console.log('→ Writing to slot 1 (should be physical slot 2)...');
+    testMode.name = 'SLOT_1_TEST';
+    await device.writeCustomMode(1, testMode);
+    console.log('✓ Write completed');
+
+    if (capturedMessages.length > 0) {
+      const writeMsg = capturedMessages.find(msg => msg[8] === 0x45);
+      if (writeMsg) {
+        console.log(`\n📊 Analysis:`);
+        console.log(`   We sent slot byte: 0x${writeMsg[9].toString(16).padStart(2, '0').toUpperCase()}`);
+        console.log(`   This should write to physical slot ${writeMsg[9] + 1}`);
+      }
+    }
+
+    // Try reading from different slots to see what's there
+    console.log('\n=== Checking What\'s In Each Slot ===');
+    for (let slot = 0; slot < 5; slot++) {
+      console.log(`\n→ Reading slot ${slot}...`);
+      capturedMessages = [];
+
+      try {
+        const mode = await device.readCustomMode(slot);
+        if (mode && mode.name) {
+          console.log(`   Slot ${slot}: "${mode.name}"`);
+        } else {
+          console.log(`   Slot ${slot}: <empty>`);
+        }
+      } catch (error) {
+        console.log(`   Slot ${slot}: Error reading`);
+      }
+    }
+
+    console.log('\n\n=== Summary ===');
+    console.log('If the user says slot 0 is writing to physical slot 2,');
+    console.log('then there might be a +1 offset somewhere in the chain.');
+    console.log('The captured slot bytes above show exactly what we\'re sending.');
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (device) {
+      console.log('\n→ Disconnecting...');
+      await device.disconnect();
+      console.log('✓ Disconnected');
+    }
+  }
+}
+
+// Run the test
+testSlotDebug().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-slot-selection.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-slot-selection.ts
new file mode 100644
index 0000000..6fa9dd4
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-slot-selection.ts
@@ -0,0 +1,173 @@
+#!/usr/bin/env tsx
+/**
+ * Test selecting slots via DAW port CC messages before writing
+ */
+
+import easymidi from 'easymidi';
+
+async function testSlotSelection() {
+  console.log('Slot Selection Test - Using DAW Port CC Messages');
+  console.log('=================================================\n');
+
+  let dawOutput: any = null;
+  let midiOutput: any = null;
+  let midiInput: any = null;
+
+  try {
+    // List available MIDI devices
+    console.log('Available MIDI outputs:', easymidi.getOutputs());
+    console.log('Available MIDI inputs:', easymidi.getInputs());
+    console.log();
+
+    // Find Launch Control XL3 ports
+    const midiPortName = easymidi.getOutputs().find((name: string) =>
+      name.includes('LCXL3') && name.includes('MIDI In'));
+    const dawPortName = easymidi.getOutputs().find((name: string) =>
+      name.includes('LCXL3') && name.includes('DAW In'));
+    const inputPortName = easymidi.getInputs().find((name: string) =>
+      name.includes('LCXL3') && name.includes('MIDI Out'));
+
+    if (!midiPortName || !dawPortName) {
+      throw new Error('Launch Control XL3 ports not found');
+    }
+
+    console.log(`📡 MIDI Port: ${midiPortName}`);
+    console.log(`📡 DAW Port: ${dawPortName}`);
+    console.log();
+
+    // Connect to ports
+    midiOutput = new easymidi.Output(midiPortName);
+    dawOutput = new easymidi.Output(dawPortName);
+
+    if (inputPortName) {
+      midiInput = new easymidi.Input(inputPortName);
+
+      // Listen for responses
+      midiInput.on('sysex', (msg: any) => {
+        console.log(`📥 Received SysEx response: ${msg.bytes.length} bytes`);
+        const preview = msg.bytes.slice(0, 12).map((b: number) =>
+          '0x' + b.toString(16).padStart(2, '0').toUpperCase()
+        ).join(' ');
+        console.log(`   Preview: ${preview}...`);
+      });
+    }
+
+    // Test slot selection pattern discovered:
+    // CC 30 on channel 6, value = slot + 5
+    // Also send Note 11 on channel 15 as observed
+
+    console.log('=== Testing Slot 1 Selection ===');
+    console.log('Sending to DAW port:');
+    console.log('  - Note On: note=11, velocity=127, channel=15');
+    console.log('  - CC: controller=30, value=6, channel=6');
+    console.log('  - Note Off: note=11, velocity=0, channel=15');
+    console.log();
+
+    // Send slot 1 selection (value 6)
+    dawOutput.send('noteon', {
+      note: 11,
+      velocity: 127,
+      channel: 15
+    });
+
+    dawOutput.send('cc', {
+      controller: 30,
+      value: 6,  // Slot 1
+      channel: 6
+    });
+
+    dawOutput.send('noteon', {
+      note: 11,
+      velocity: 0,  // Note off
+      channel: 15
+    });
+
+    await new Promise(resolve => setTimeout(resolve, 500));
+
+    // Now send a simple SysEx write command
+    console.log('→ Sending test write to MIDI port...');
+
+    // Create a minimal test SysEx message
+    const testData = [
+      0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00, // Header with slot 0
+      0x01, 0x20, 0x10, 0x2A, // Version and name length
+      // Name: "SLOT_1_TEST     " (15 bytes padded)
+      0x53, 0x4C, 0x4F, 0x54, 0x5F, 0x31, 0x5F, 0x54, 0x45, 0x53, 0x54, 0x20, 0x20, 0x20, 0x20,
+      // Just one encoder for testing
+      0x49, 0x10, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x0D, 0x7F, 0x00,
+      0xF7
+    ];
+
+    midiOutput.send('sysex', testData);
+    console.log('✓ Sent write command with slot byte 0x00');
+    console.log('  (Should write to physical slot 1 due to DAW port pre-selection)');
+
+    await new Promise(resolve => setTimeout(resolve, 2000));
+
+    console.log('\n=== Testing Slot 2 Selection ===');
+    console.log('Sending to DAW port:');
+    console.log('  - Note On: note=11, velocity=127, channel=15');
+    console.log('  - CC: controller=30, value=7, channel=6');
+    console.log('  - Note Off: note=11, velocity=0, channel=15');
+    console.log();
+
+    // Send slot 2 selection (value 7)
+    dawOutput.send('noteon', {
+      note: 11,
+      velocity: 127,
+      channel: 15
+    });
+
+    dawOutput.send('cc', {
+      controller: 30,
+      value: 7,  // Slot 2
+      channel: 6
+    });
+
+    dawOutput.send('noteon', {
+      note: 11,
+      velocity: 0,  // Note off
+      channel: 15
+    });
+
+    await new Promise(resolve => setTimeout(resolve, 500));
+
+    // Send another test write
+    console.log('→ Sending test write to MIDI port...');
+
+    const testData2 = [
+      0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00, // Header with slot 0
+      0x01, 0x20, 0x10, 0x2A, // Version and name length
+      // Name: "SLOT_2_TEST     " (15 bytes padded)
+      0x53, 0x4C, 0x4F, 0x54, 0x5F, 0x32, 0x5F, 0x54, 0x45, 0x53, 0x54, 0x20, 0x20, 0x20, 0x20,
+      // Just one encoder for testing
+      0x49, 0x10, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x0D, 0x7F, 0x00,
+      0xF7
+    ];
+
+    midiOutput.send('sysex', testData2);
+    console.log('✓ Sent write command with slot byte 0x00');
+    console.log('  (Should write to physical slot 2 due to DAW port pre-selection)');
+
+    await new Promise(resolve => setTimeout(resolve, 2000));
+
+    console.log('\n📋 Summary:');
+    console.log('- DAW port CC 30 on channel 6 controls active slot');
+    console.log('- Value = physical slot number + 5');
+    console.log('- Note 11 on channel 15 might be a trigger/notification');
+    console.log('\n🔍 Please check the device:');
+    console.log('   - Physical slot 1 should show "SLOT_1_TEST"');
+    console.log('   - Physical slot 2 should show "SLOT_2_TEST"');
+
+  } catch (error) {
+    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
+  } finally {
+    if (midiOutput) midiOutput.close();
+    if (dawOutput) dawOutput.close();
+    if (midiInput) midiInput.close();
+    console.log('\n✓ Test completed');
+  }
+}
+
+// Run the test
+testSlotSelection().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/vitest.config.ts b/modules/audio-control/modules/launch-control-xl3/vitest.config.ts
index 6e09ebe..471f02c 100644
--- a/modules/audio-control/modules/launch-control-xl3/vitest.config.ts
+++ b/modules/audio-control/modules/launch-control-xl3/vitest.config.ts
@@ -33,6 +33,7 @@ export default defineConfig({
       'test/utils/**/*.test.ts',
       'test/core/SysExParser.test.ts',
       'test/core/backends/WebMidiBackend.test.ts',
+      'test/core/DawPortController.test.ts',
     ],
 
     // Exclude everything else for now (focus on optimization)


---

_**Agent (claude-sonnet-4-5-20250929)**_

feat(launch-control-xl3): implement DAW port protocol for slot selection

