<!-- Generated by SpecStory -->

# MIDI Controller Custom Name Display Script Update (2025-09-29 01:49:35Z)

<!-- Claude Code Session 533d0ad7-9534-4c2b-925e-87140085da2b (2025-09-29_01-49-35Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/oletizi-launch-control-xl3-1.8.0.tgz b/modules/audio-control/modules/launch-control-xl3/oletizi-launch-control-xl3-1.8.0.tgz
new file mode 100644
index 0000000..07c43dd
Binary files /dev/null and b/modules/audio-control/modules/launch-control-xl3/oletizi-launch-control-xl3-1.8.0.tgz differ
diff --git a/modules/audio-control/modules/launch-control-xl3/package/LICENSE b/modules/audio-control/modules/launch-control-xl3/package/LICENSE
new file mode 100644
index 0000000..6b09df6
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/LICENSE
@@ -0,0 +1,24 @@
+Copyright (c) 2025 Orion Letizi
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+
+-------------------------------------------------------------------------------
+DISCLAIMER
+
+This project is not affiliated with, endorsed by, or sponsored by
+Novation. Novation and the names of its products are trademarks or
+registered trademarks of their respective owners. This software
+communicates with the device using publicly documented or
+reverse-engineered interfaces and provides no license or rights to the
+underlying hardware, firmware, or any proprietary intellectual
+property.
diff --git a/modules/audio-control/modules/launch-control-xl3/package/README.md b/modules/audio-control/modules/launch-control-xl3/package/README.md
new file mode 100644
index 0000000..677f4bf
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/README.md
@@ -0,0 +1,552 @@
+# @ol-dsp/launch-control-xl3
+
+[![TypeScript](https://img.shields.io/badge/TypeScript-5.3-blue)](https://www.typescriptlang.org/)
+[![Node](https://img.shields.io/badge/Node-18+-green)](https://nodejs.org/)
+[![License](https://img.shields.io/badge/License-MIT-yellow)](LICENSE)
+[![Status](https://img.shields.io/badge/Status-Production%20Ready-brightgreen)]()
+
+TypeScript library for controlling the Novation Launch Control XL 3 hardware MIDI controller. Provides complete device control including custom modes, LED management, and advanced control mapping with value transformations.
+
+## ‚ú® Features
+
+- üéõÔ∏è **Complete Device Control** - Full control over all 24 knobs, 8 faders, and 16 buttons
+- üîå **Platform Agnostic** - Works with Node.js and browser (Web MIDI API)
+- üí° **LED Management** - Control all button LEDs with colors and animations
+- üìù **Custom Modes** - Read, write, and manage all 16 device custom modes
+- üîÑ **Advanced Mapping** - 7 value transformers (exponential, logarithmic, stepped, etc.)
+- üéØ **Type Safety** - Full TypeScript support with comprehensive types
+- üîß **Error Recovery** - Automatic reconnection and error handling
+- üì¶ **Minimal Dependencies** - Only 4 runtime dependencies
+- üñ•Ô∏è **CLI Tool** - Comprehensive command-line interface for testing
+
+## üì¶ Installation
+
+```bash
+npm install @ol-dsp/launch-control-xl3
+```
+
+### Optional MIDI Backend
+
+The library supports multiple MIDI backends. Install one based on your platform:
+
+```bash
+# For node-midi (Node.js - recommended)
+npm install midi
+
+# For JZZ (cross-platform alternative)
+npm install jzz
+
+# For Web MIDI API (browser)
+# No additional installation needed
+```
+
+## üöÄ Quick Start
+
+```typescript
+import { LaunchControlXL3 } from '@ol-dsp/launch-control-xl3';
+
+// Create controller
+const controller = new LaunchControlXL3({
+  enableLedControl: true,
+  enableCustomModes: true,
+});
+
+// Connect to device
+await controller.connect();
+
+// Listen for control changes
+controller.on('control:change', (controlId, value) => {
+  console.log(`${controlId}: ${value}`);
+});
+
+// Control LEDs
+await controller.setLed('FOCUS1', 'GREEN_FULL');
+await controller.flashLed('CONTROL1', 'RED_FULL', 500);
+
+// Load custom mode
+const mode = await controller.loadCustomMode(0);
+console.log(`Loaded mode: ${mode.name}`);
+
+// Clean up when done
+await controller.cleanup();
+```
+
+## üìö Core Concepts
+
+### Device Connection
+
+The library automatically discovers and connects to the Launch Control XL 3:
+
+```typescript
+const controller = new LaunchControlXL3({
+  autoConnect: true,        // Auto-connect on initialization
+  deviceNameFilter: 'Launch Control XL', // Device name filter
+  reconnectOnError: true,   // Auto-reconnect on disconnect
+  maxReconnectAttempts: 5,  // Maximum reconnection attempts
+});
+
+// Manual connection
+await controller.connect();
+
+// Check connection status
+if (controller.isConnected()) {
+  const status = controller.getStatus();
+  console.log(`Firmware: ${status.deviceInfo.firmwareVersion}`);
+}
+```
+
+### Control Mapping
+
+Map hardware controls to MIDI with advanced transformations:
+
+```typescript
+// Simple linear mapping
+controller.mapControl('FADER1', 0, 7, {
+  min: 0,
+  max: 127,
+  behaviour: 'absolute',
+});
+
+// Exponential mapping (perfect for volume)
+controller.mapControl('FADER2', 0, 11, {
+  min: 0,
+  max: 127,
+  behaviour: 'absolute',
+  transform: {
+    type: 'exponential',
+    curve: 2.5, // Higher = more dramatic curve
+  },
+});
+
+// Stepped/quantized values
+controller.mapControl('SEND_A1', 0, 20, {
+  min: 0,
+  max: 127,
+  behaviour: 'absolute',
+  transform: {
+    type: 'stepped',
+    steps: 8, // Quantize to 8 values
+  },
+});
+
+// Relative encoder modes
+controller.mapControl('PAN1', 0, 50, {
+  behaviour: 'relative1', // Two's complement
+});
+```
+
+### Value Transformations
+
+The library provides 7 value transformation functions:
+
+| Transform | Description | Use Case |
+|-----------|-------------|----------|
+| **Linear** | Direct 1:1 mapping (default) | General controls |
+| **Exponential** | Curved response | Volume/filter controls |
+| **Logarithmic** | Inverse exponential curve | Frequency controls |
+| **Stepped** | Quantize to discrete steps | Mode/preset selection |
+| **Toggle** | Binary on/off at threshold | Mute/solo buttons |
+| **Invert** | Reverse the value range | Reverse faders |
+| **Bipolar** | Center at zero (-64 to +63) | Pan controls |
+
+### LED Control
+
+Full control over all 16 button LEDs with colors and effects:
+
+```typescript
+import { LED_COLOR_VALUES } from '@ol-dsp/launch-control-xl3';
+
+// Set static color
+await controller.setLed('FOCUS1', LED_COLOR_VALUES.GREEN_FULL);
+
+// Flash effect
+await controller.flashLed('CONTROL1', LED_COLOR_VALUES.RED_FULL, 500);
+
+// Pulse effect
+await controller.setLed('FOCUS2', LED_COLOR_VALUES.AMBER_FULL, 'pulse');
+
+// Animations
+controller.startLedAnimation('rainbow', {
+  type: 'rainbow',
+  duration: 5000,
+  controls: ['FOCUS1', 'FOCUS2', 'FOCUS3', 'FOCUS4'],
+  repeat: 'infinite',
+});
+
+// Turn off all LEDs
+await controller.turnOffAllLeds();
+```
+
+Available LED colors:
+- **Red**: `RED_LOW`, `RED_MEDIUM`, `RED_FULL`
+- **Amber**: `AMBER_LOW`, `AMBER_MEDIUM`, `AMBER_FULL`
+- **Yellow**: `YELLOW_LOW`, `YELLOW_FULL`
+- **Green**: `GREEN_LOW`, `GREEN_MEDIUM`, `GREEN_FULL`
+- **Off**: `OFF`
+
+Available animations:
+- `rainbow` - Cycle through colors
+- `chase` - Sequential LED chase
+- `pulse` - Synchronized pulsing
+- `flash` - Synchronized flashing
+- `fade` - Fade between colors
+- `custom` - Custom animation callback
+
+### Custom Modes
+
+Manage all 16 device custom modes with full read/write support:
+
+```typescript
+// Create a new mode
+const mode = controller.createCustomMode('My DAW Mode');
+
+// Configure controls
+mode.controls['FADER1'] = {
+  type: 'fader',
+  channel: 0,
+  cc: 7,
+  min: 0,
+  max: 127,
+  behaviour: 'absolute',
+};
+
+// Configure LEDs
+mode.leds['FOCUS1'] = {
+  color: 'GREEN_FULL',
+  behaviour: 'static',
+};
+
+// Save to device (slot 0-15)
+await controller.saveCustomMode(0, mode);
+
+// Load from device
+const loaded = await controller.loadCustomMode(0);
+
+// Export to JSON
+const json = JSON.stringify(mode);
+
+// Import from JSON
+const imported = JSON.parse(json);
+await controller.saveCustomMode(1, imported);
+```
+
+## üñ•Ô∏è CLI Tool
+
+The library includes a comprehensive CLI tool for testing:
+
+```bash
+# Install globally
+npm install -g @ol-dsp/launch-control-xl3
+
+# Commands
+lcxl3 connect              # Connect to device
+lcxl3 status               # Show device status
+lcxl3 monitor              # Monitor control changes
+lcxl3 led-test             # Run LED test pattern
+lcxl3 load-mode <slot>     # Load custom mode (0-15)
+
+# Example workflow
+lcxl3 connect
+lcxl3 status
+lcxl3 monitor              # Move controls to see values
+lcxl3 led-test             # Test all LEDs
+lcxl3 load-mode 0          # Load first custom mode
+```
+
+## üìñ API Reference
+
+### Main Class
+
+#### `new LaunchControlXL3(options?)`
+
+Creates a new controller instance.
+
+**Options:**
+| Option | Type | Default | Description |
+|--------|------|---------|-------------|
+| `midiBackend` | `MidiBackendInterface` | auto-detect | Custom MIDI backend |
+| `autoConnect` | `boolean` | `true` | Auto-connect on init |
+| `enableLedControl` | `boolean` | `true` | Enable LED control |
+| `enableCustomModes` | `boolean` | `true` | Enable custom modes |
+| `enableValueSmoothing` | `boolean` | `false` | Smooth control values |
+| `smoothingFactor` | `number` | `3` | Smoothing amount (1-10) |
+| `deviceNameFilter` | `string` | `'Launch Control XL'` | Device name filter |
+| `reconnectOnError` | `boolean` | `true` | Auto-reconnect |
+| `maxReconnectAttempts` | `number` | `5` | Max reconnect tries |
+
+### Methods
+
+#### Device Control
+| Method | Description |
+|--------|-------------|
+| `connect()` | Connect to device (automatically initializes) |
+| `disconnect()` | Disconnect from device |
+| `getStatus()` | Get device status |
+| `isConnected()` | Check connection state |
+| `cleanup()` | Clean up all resources |
+
+#### Control Mapping
+| Method | Description |
+|--------|-------------|
+| `mapControl(id, channel, cc, options)` | Map a control |
+| `unmapControl(id)` | Unmap a control |
+| `getControlMapping(id)` | Get control mapping |
+| `updateControlMapping(id, updates)` | Update mapping |
+
+#### LED Control
+| Method | Description |
+|--------|-------------|
+| `setLed(id, color, behaviour?)` | Set LED state |
+| `turnOffLed(id)` | Turn off specific LED |
+| `turnOffAllLeds()` | Turn off all LEDs |
+| `flashLed(id, color, duration?)` | Flash LED once |
+| `startLedAnimation(id, animation)` | Start animation |
+| `stopLedAnimation(id)` | Stop animation |
+
+#### Custom Modes
+| Method | Description |
+|--------|-------------|
+| `createCustomMode(name)` | Create new mode |
+| `loadCustomMode(slot)` | Load from device |
+| `saveCustomMode(slot, mode)` | Save to device |
+| `exportCurrentAsCustomMode(name)` | Export current state |
+
+### Events
+
+```typescript
+controller.on('device:connected', (device) => { });
+controller.on('device:disconnected', (reason) => { });
+controller.on('device:ready', () => { });
+controller.on('device:error', (error) => { });
+controller.on('control:change', (id, value, channel) => { });
+controller.on('control:mapped', (id, mapping) => { });
+controller.on('mode:changed', (slot, mode) => { });
+controller.on('mode:loaded', (slot, mode) => { });
+controller.on('mode:saved', (slot, mode) => { });
+controller.on('led:changed', (id, color, behaviour) => { });
+controller.on('midi:in', (message) => { });
+controller.on('midi:out', (message) => { });
+```
+
+## üéØ Examples
+
+Complete working examples are available in the [examples](examples/) directory:
+
+| Example | Description | Run Command |
+|---------|-------------|-------------|
+| [Basic Connection](examples/basic-connection.ts) | Device connection and events | `npm run example:basic` |
+| [LED Animations](examples/led-animations.ts) | LED control and animations | `npm run example:leds` |
+| [Custom Modes](examples/custom-modes.ts) | Mode management | `npm run example:modes` |
+| [Control Mapping](examples/control-mapping.ts) | Advanced mappings | `npm run example:mapping` |
+
+## üèóÔ∏è Architecture
+
+```
+src/
+‚îú‚îÄ‚îÄ core/                    # Core functionality
+‚îÇ   ‚îú‚îÄ‚îÄ MidiInterface.ts     # Platform-agnostic MIDI
+‚îÇ   ‚îú‚îÄ‚îÄ SysExParser.ts        # SysEx protocol (490 lines)
+‚îÇ   ‚îî‚îÄ‚îÄ Midimunge.ts          # 7-bit encoding (326 lines)
+‚îú‚îÄ‚îÄ device/
+‚îÇ   ‚îî‚îÄ‚îÄ DeviceManager.ts      # Device management (500+ lines)
+‚îú‚îÄ‚îÄ modes/
+‚îÇ   ‚îî‚îÄ‚îÄ CustomModeManager.ts  # Custom modes (500+ lines)
+‚îú‚îÄ‚îÄ mapping/
+‚îÇ   ‚îî‚îÄ‚îÄ ControlMapper.ts      # Control mapping (500+ lines)
+‚îú‚îÄ‚îÄ led/
+‚îÇ   ‚îî‚îÄ‚îÄ LedController.ts      # LED control (500+ lines)
+‚îú‚îÄ‚îÄ cli/
+‚îÇ   ‚îî‚îÄ‚îÄ cli.ts                # CLI tool
+‚îî‚îÄ‚îÄ LaunchControlXL3.ts       # Main class (500+ lines)
+```
+
+**Total:** 36 TypeScript files, ~6,000 lines of production code
+
+## üîß Development
+
+### Building
+
+```bash
+# Install dependencies
+npm install
+
+# Build library
+npm run build
+
+# Watch mode
+npm run dev
+
+# Type checking
+npm run typecheck
+```
+
+### Testing
+
+```bash
+# Run all tests
+npm test
+
+# Watch mode
+npm run test:watch
+
+# Coverage report
+npm run test:coverage
+```
+
+## üñ•Ô∏è System Requirements
+
+### Hardware
+- Novation Launch Control XL (Mark 3 recommended)
+- USB connection
+
+### Software
+- Node.js 18+ or modern browser with Web MIDI API
+- TypeScript 5.3+ (for development)
+
+### Platform Support
+- ‚úÖ **macOS** (12+ tested)
+- ‚úÖ **Windows** (10/11 tested)
+- ‚úÖ **Linux** (Ubuntu 20.04+ tested)
+- ‚úÖ **Browser** (Chrome 90+, Edge 90+)
+
+## üåê Browser Support
+
+As of v2.0.0, `@ol-dsp/launch-control-xl3` supports browser environments using the Web MIDI API!
+
+### Browser Requirements
+
+- Chrome 43+ or Edge 79+ (Chromium-based)
+- Opera 30+
+- HTTPS required (or localhost for development)
+- User permission for MIDI access
+
+**Note**: Safari does not currently support Web MIDI API.
+
+### Browser Usage Example
+
+```typescript
+import { LaunchControlXL3 } from '@ol-dsp/launch-control-xl3';
+
+// Auto-detects Web MIDI API in browser
+const device = new LaunchControlXL3({
+  enableCustomModes: true
+});
+
+// Request permission and connect
+await device.connect();
+
+// Use just like in Node.js!
+device.on('device:connected', () => {
+  console.log('LCXL3 connected!');
+});
+
+// Load custom mode from device
+const mode = await device.loadCustomMode(0);
+console.log('Current mode:', mode);
+```
+
+### React Example
+
+```typescript
+import { useEffect, useState } from 'react';
+import { LaunchControlXL3 } from '@ol-dsp/launch-control-xl3';
+
+function useLCXL3Device() {
+  const [device] = useState(() => new LaunchControlXL3({
+    autoConnect: true,
+    enableCustomModes: true
+  }));
+  const [connected, setConnected] = useState(false);
+
+  useEffect(() => {
+    device.on('device:connected', () => setConnected(true));
+    device.on('device:disconnected', () => setConnected(false));
+
+    device.connect().catch(console.error);
+
+    return () => device.cleanup();
+  }, [device]);
+
+  return { device, connected };
+}
+```
+
+### Troubleshooting Browser Usage
+
+**Permission Denied**
+- Web MIDI requires user permission on first access
+- Must be served over HTTPS (localhost is ok for dev)
+- Some browsers may block in iframes
+
+**Device Not Found**
+- Ensure LCXL3 is connected before initializing
+- Check browser's MIDI permission settings
+- Try refreshing the page after connecting device
+
+**SysEx Not Working**
+- Ensure you're requesting SysEx permission (done automatically)
+- Some browsers may have additional SysEx restrictions
+
+## üêõ Troubleshooting
+
+### Device Not Found
+```bash
+# Check device is connected
+ls /dev/midi*  # Linux
+ls /dev/cu.*   # macOS
+
+# Check MIDI permissions
+# macOS: System Preferences > Security & Privacy > Privacy
+# Linux: Add user to audio group
+sudo usermod -a -G audio $USER
+```
+
+### Permission Errors
+```bash
+# Linux: Add udev rule
+echo 'SUBSYSTEM=="usb", ATTR{idVendor}=="1235", MODE="0666"' | \
+  sudo tee /etc/udev/rules.d/50-launch-control.rules
+sudo udevadm control --reload-rules
+```
+
+### MIDI Backend Issues
+```bash
+# Try different backends
+npm install midi    # node-midi
+npm install jzz     # JZZ
+npm install easymidi # easymidi
+```
+
+## üìä Performance
+
+- **< 1ms** MIDI message processing latency
+- **< 100ms** device connection time
+- **< 50MB** memory usage
+- **30 FPS** LED animation capability
+- **100%** TypeScript type coverage
+
+## ü§ù Contributing
+
+Contributions are welcome! See [CONTRIBUTING.md](CONTRIBUTING.md) for guidelines.
+
+## üìÑ License
+
+MIT ¬© OL DSP Team
+
+## üôè Acknowledgments
+
+- Novation for the Launch Control XL hardware
+- MIDI community for protocol documentation
+- Contributors and beta testers
+
+## üìû Support
+
+- **Issues**: [GitHub Issues](https://github.com/ol-dsp/launch-control/issues)
+- **Docs**: [API Documentation](docs/API.md)
+- **Protocol**: [Protocol Specification](docs/PROTOCOL.md)
+
+---
+
+**Made with ‚ù§Ô∏è for the audio community**
+
+*Launch Control XL is a trademark of Focusrite Audio Engineering Limited*
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/package.json b/modules/audio-control/modules/launch-control-xl3/package/package.json
new file mode 100644
index 0000000..b89f7e4
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/package.json
@@ -0,0 +1,100 @@
+{
+  "name": "@oletizi/launch-control-xl3",
+  "version": "1.8.0",
+  "description": "TypeScript library for Novation Launch Control XL 3 device control and MIDI mapping",
+  "type": "module",
+  "main": "./dist/index.js",
+  "types": "./dist/index.d.ts",
+  "bin": {
+    "lcxl3": "./dist/cli/cli.js"
+  },
+  "exports": {
+    ".": {
+      "types": "./dist/index.d.ts",
+      "browser": "./dist/index.js",
+      "node": "./dist/index.js",
+      "import": "./dist/index.js",
+      "default": "./dist/index.js"
+    },
+    "./cli": {
+      "types": "./dist/cli/index.d.ts",
+      "node": "./dist/cli/index.js",
+      "import": "./dist/cli/index.js"
+    }
+  },
+  "files": [
+    "dist",
+    "src",
+    "LICENSE"
+  ],
+  "scripts": {
+    "build": "tsc -b && vite build",
+    "clean": "rm -rf dist *.tsbuildinfo",
+    "dev": "tsc -b --watch",
+    "test": "vitest run --coverage",
+    "test:fast": "vitest run --run",
+    "test:parallel": "vitest run --reporter=verbose --threads",
+    "test:all": "vitest run --config vitest.all.config.ts",
+    "test:unit": "vitest run test/core test/device test/unit test/utils",
+    "test:integration": "vitest run test/integration",
+    "test:coverage": "vitest --coverage",
+    "test:watch": "vitest --watch",
+    "test:handshake:node": "tsx utils/test-handshake-node.ts",
+    "test:fetch-mode:node": "tsx utils/test-fetch-custom-mode-node.ts",
+    "lint": "eslint . --ext .ts,.tsx",
+    "lint:fix": "eslint . --ext .ts,.tsx --fix",
+    "typecheck": "tsc --noEmit",
+    "cli": "tsx src/cli/cli.ts",
+    "example:basic": "tsx examples/basic-connection.ts",
+    "example:leds": "tsx examples/led-animations.ts",
+    "example:modes": "tsx examples/custom-modes.ts",
+    "example:mapping": "tsx examples/control-mapping.ts",
+    "prepublishOnly": "npm run clean && npm run build"
+  },
+  "keywords": [
+    "novation",
+    "launch-control",
+    "xl3",
+    "midi",
+    "controller",
+    "sysex",
+    "audio",
+    "daw",
+    "typescript"
+  ],
+  "author": "",
+  "license": "Apache-2.0",
+  "engines": {
+    "node": ">=18"
+  },
+  "dependencies": {
+    "@types/js-yaml": "^4.0.9",
+    "chalk": "^5.3.0",
+    "commander": "^11.1.0",
+    "eventemitter3": "^5.0.1",
+    "inquirer": "^9.2.12",
+    "js-yaml": "^4.1.0",
+    "ora": "^7.0.1",
+    "zod": "^3.22.4"
+  },
+  "devDependencies": {
+    "@oletizi/mulder-specs": "^0.6.0",
+    "@types/node": "^20.11.0",
+    "@vitest/coverage-v8": "^1.2.0",
+    "easymidi": "^3.1.0",
+    "jazz-midi-headless": "^1.1.5",
+    "jzz": "^1.9.6",
+    "tsx": "^4.7.0",
+    "typescript": "^5.3.3",
+    "vite": "^5.0.0",
+    "vitest": "^1.2.0"
+  },
+  "peerDependencies": {
+    "midi": "^2.0.0"
+  },
+  "peerDependenciesMeta": {
+    "midi": {
+      "optional": true
+    }
+  }
+}
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/LaunchControlXL3.ts b/modules/audio-control/modules/launch-control-xl3/package/src/LaunchControlXL3.ts
new file mode 100644
index 0000000..c69009a
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/LaunchControlXL3.ts
@@ -0,0 +1,671 @@
+/**
+ * Launch Control XL 3 - Main Controller Class
+ *
+ * High-level interface for interacting with the Novation Launch Control XL 3
+ * hardware controller. Provides a unified API for device management, control
+ * mapping, LED control, and custom modes.
+ */
+
+import { EventEmitter } from 'eventemitter3';
+import type { Logger } from './core/Logger.js';
+import { ConsoleLogger } from './core/Logger.js';
+import { MidiBackendInterface, MidiMessage } from './core/MidiInterface.js';
+import { DeviceManager, DeviceStatus } from './device/DeviceManager.js';
+import { CustomModeManager, CONTROL_IDS, LED_COLORS } from './modes/CustomModeManager.js';
+import { ControlMapper, ValueTransformers } from './mapping/ControlMapper.js';
+import { LedController, LED_COLOR_VALUES } from './led/LedController.js';
+import {
+  LaunchControlXL3Info,
+  CustomMode,
+  CustomModeSlot,
+  ControlMapping,
+  ControlType,
+  LedColor,
+  LedBehaviour,
+  MidiChannel,
+  CCNumber,
+} from './types/index.js';
+
+export interface LaunchControlXL3Options {
+  midiBackend?: MidiBackendInterface;
+  logger?: Logger;
+  enableLedControl?: boolean;
+  enableCustomModes?: boolean;
+  enableValueSmoothing?: boolean;
+  smoothingFactor?: number;
+  deviceNameFilter?: string;
+  reconnectOnError?: boolean;
+  reconnectDelay?: number;
+  maxReconnectAttempts?: number;
+}
+
+export interface LaunchControlXL3Events {
+  // Device events
+  'device:connected': (device: LaunchControlXL3Info) => void;
+  'device:disconnected': (reason?: string) => void;
+  'device:ready': () => void;
+  'device:error': (error: Error) => void;
+
+  // Control events
+  'control:change': (controlId: string, value: number, channel?: number) => void;
+  'control:mapped': (controlId: string, mapping: ControlMapping) => void;
+
+  // MIDI events
+  'midi:in': (message: MidiMessage) => void;
+  'midi:out': (message: MidiMessage) => void;
+
+  // Mode events
+  'mode:changed': (slot: number, mode: CustomMode) => void;
+  'mode:loaded': (slot: number, mode: CustomMode) => void;
+  'mode:saved': (slot: number, mode: CustomMode) => void;
+
+  // LED events
+  'led:changed': (controlId: string, color: LedColor, behaviour: LedBehaviour) => void;
+}
+
+/**
+ * Main Launch Control XL 3 Controller
+ */
+export class LaunchControlXL3 extends EventEmitter {
+  private options: Required<Omit<LaunchControlXL3Options, 'midiBackend' | 'logger'>> & {
+    midiBackend?: MidiBackendInterface | undefined;
+    logger?: Logger | undefined;
+  };
+  private readonly logger: Logger;
+  private deviceManager: DeviceManager;
+  private customModeManager?: CustomModeManager | undefined;
+  private controlMapper: ControlMapper;
+  private ledController?: LedController | undefined;
+  private isInitialized = false;
+  private currentMode?: CustomMode | undefined;
+  private currentSlot?: CustomModeSlot | undefined;
+
+  // Public static exports
+  static readonly CONTROL_IDS = CONTROL_IDS;
+  static readonly LED_COLORS = LED_COLORS;
+  static readonly LED_COLOR_VALUES = LED_COLOR_VALUES;
+  static readonly ValueTransformers = ValueTransformers;
+
+  constructor(options: LaunchControlXL3Options = {}) {
+    super();
+
+    this.logger = options.logger ?? new ConsoleLogger({ prefix: 'LaunchControlXL3' });
+
+    this.options = {
+      midiBackend: options.midiBackend,
+      logger: options.logger,
+      enableLedControl: options.enableLedControl ?? true,
+      enableCustomModes: options.enableCustomModes ?? true,
+      enableValueSmoothing: options.enableValueSmoothing ?? false,
+      smoothingFactor: options.smoothingFactor ?? 3,
+      deviceNameFilter: options.deviceNameFilter ?? 'Launch Control XL',
+      reconnectOnError: options.reconnectOnError ?? true,
+      reconnectDelay: options.reconnectDelay ?? 2000,
+      maxReconnectAttempts: options.maxReconnectAttempts ?? 5,
+    };
+
+    // Initialize core components
+    this.deviceManager = new DeviceManager({
+      midiBackend: this.options.midiBackend,
+      autoConnect: false,
+      deviceNameFilter: this.options.deviceNameFilter,
+      retryAttempts: this.options.maxReconnectAttempts,
+      retryDelay: this.options.reconnectDelay,
+    });
+
+    this.controlMapper = new ControlMapper({
+      enableValueSmoothing: this.options.enableValueSmoothing,
+      smoothingFactor: this.options.smoothingFactor,
+    });
+
+    this.setupEventHandlers();
+  }
+
+  /**
+   * Connect to device
+   *
+   * Automatically initializes the controller if needed.
+   */
+  async connect(): Promise<void> {
+    this.logger.info('Connecting to device...');
+
+    // Initialize if needed
+    if (!this.isInitialized) {
+      try {
+        this.logger.debug('Initializing device manager...');
+        await this.deviceManager.initialize();
+        this.isInitialized = true;
+        this.logger.debug('Device manager initialized');
+      } catch (error) {
+        this.logger.error('Failed to initialize device manager:', (error as Error).message);
+        this.emit('device:error', error as Error);
+        throw error;
+      }
+    }
+
+    try {
+      await this.deviceManager.connect();
+
+      this.logger.info('Device connected successfully');
+
+      // Initialize optional components after connection
+      if (this.options.enableCustomModes) {
+        this.logger.debug('Initializing custom mode manager...');
+        this.customModeManager = new CustomModeManager({
+          deviceManager: this.deviceManager,
+          autoSync: true,
+        });
+      }
+
+      if (this.options.enableLedControl) {
+        this.logger.debug('Initializing LED controller...');
+        this.ledController = new LedController({
+          deviceManager: this.deviceManager,
+          enableAnimations: true,
+        });
+
+        // Play startup animation
+        await this.ledController.playStartupAnimation();
+      }
+
+      // Load default mappings
+      this.loadDefaultMappings();
+
+      this.logger.info('Device ready');
+      this.emit('device:ready');
+    } catch (error) {
+      this.logger.error('Connection failed:', (error as Error).message);
+      this.emit('device:error', error as Error);
+      throw error;
+    }
+  }
+
+  /**
+   * Disconnect from device
+   */
+  async disconnect(): Promise<void> {
+    this.logger.info('Disconnecting from device...');
+
+    await this.deviceManager.disconnect();
+
+    if (this.customModeManager) {
+      this.customModeManager.cleanup();
+      this.customModeManager = undefined;
+    }
+
+    if (this.ledController) {
+      this.ledController.cleanup();
+      this.ledController = undefined;
+    }
+
+    this.controlMapper.resetAll();
+    this.currentMode = undefined;
+    this.currentSlot = undefined;
+
+    this.logger.info('Disconnected from device');
+  }
+
+  /**
+   * Setup event handlers
+   */
+  private setupEventHandlers(): void {
+    // Device events
+
+    this.deviceManager.on('device:connected', (device) => {
+      this.logger.debug('Device connected event received', device);
+      this.emit('device:connected', device);
+    });
+
+    this.deviceManager.on('device:disconnected', (reason) => {
+      this.logger.info('Device disconnected', reason ? `Reason: ${reason}` : '');
+      this.emit('device:disconnected', reason);
+    });
+
+    this.deviceManager.on('device:error', (error: Error) => {
+      this.handleError(error);
+    });
+
+    // Control events
+    this.deviceManager.on('control:change', (controlId: string, value: number, channel) => {
+      // Process through control mapper
+      const message = this.controlMapper.processControlValue(controlId, value);
+
+      if (message) {
+        this.emit('midi:out', message);
+      }
+
+      this.emit('control:change', controlId, value, channel);
+    });
+
+    // Control mapper events
+    this.controlMapper.on('control:mapped', (controlId, mapping) => {
+      this.emit('control:mapped', controlId, mapping);
+    });
+
+    this.controlMapper.on('midi:out', (message) => {
+      this.emit('midi:out', message);
+    });
+
+    // Custom mode events
+    if (this.customModeManager) {
+      this.customModeManager.on('mode:loaded', (slot, mode) => {
+        this.emit('mode:loaded', slot, mode);
+      });
+
+      this.customModeManager.on('mode:saved', (slot, mode) => {
+        this.emit('mode:saved', slot, mode);
+      });
+    }
+
+    // LED controller events
+    if (this.ledController) {
+      this.ledController.on('led:changed', (controlId, state) => {
+        this.emit('led:changed', controlId, state.color, state.behaviour);
+      });
+    }
+
+    // MIDI input events
+    this.deviceManager.on('sysex:received', (data) => {
+      this.emit('midi:in', {
+        type: 'sysex',
+        data,
+      });
+    });
+  }
+
+  /**
+   * Handle errors
+   */
+  private handleError(error: Error): void {
+    this.logger.error('Error:', error.message);
+    this.emit('device:error', error);
+
+    // Attempt reconnection if enabled
+    if (this.options.reconnectOnError && this.isInitialized) {
+      this.logger.info(`Attempting reconnection in ${this.options.reconnectDelay}ms...`);
+      setTimeout(() => {
+        this.connect().catch((e) => {
+          this.logger.error('Reconnection failed:', e.message);
+        });
+      }, this.options.reconnectDelay);
+    }
+  }
+
+  /**
+   * Load default control mappings
+   */
+  private loadDefaultMappings(): void {
+    const defaultMappings = ControlMapper.createDefaultMappings();
+
+    for (const [controlId, mapping] of defaultMappings.entries()) {
+      const type = mapping.type ?? mapping.controlType ?? 'knob';
+      this.controlMapper.mapControl(controlId, type as ControlType, mapping);
+    }
+  }
+
+  // ============================================
+  // Custom Mode Management
+  // ============================================
+
+  /**
+   * Load a custom mode
+   */
+  async loadCustomMode(slot: CustomModeSlot): Promise<CustomMode> {
+    if (!this.customModeManager) {
+      throw new Error('Custom modes not enabled');
+    }
+
+    const mode = await this.customModeManager.readMode(slot);
+
+    // Apply control mappings
+    this.controlMapper.loadFromCustomMode(mode);
+
+    // Apply LED settings
+    if (this.ledController && mode.leds) {
+      const updates = Object.entries(mode.leds).map(([controlId, led]) => ({
+        controlId,
+        color: led.color,
+        behaviour: led.behaviour,
+      }));
+
+      await this.ledController.setMultipleLeds(updates);
+    }
+
+    this.currentMode = mode;
+    this.currentSlot = slot;
+
+    this.emit('mode:changed', slot, mode);
+
+    return mode;
+  }
+
+  /**
+   * Save a custom mode
+   */
+  async saveCustomMode(slot: CustomModeSlot, mode: CustomMode): Promise<void> {
+    if (!this.customModeManager) {
+      throw new Error('Custom modes not enabled');
+    }
+
+    await this.customModeManager.writeMode(slot, mode);
+  }
+
+  /**
+   * Create a new custom mode
+   */
+  createCustomMode(name?: string): CustomMode {
+    if (!this.customModeManager) {
+      throw new Error('Custom modes not enabled');
+    }
+
+    return this.customModeManager.createDefaultMode(name);
+  }
+
+  /**
+   * Read a custom mode from the device
+   * @param slot - Slot number (0-14 for slots 1-15)
+   * @returns Promise resolving to the custom mode or null if slot is empty
+   */
+  async readCustomMode(slot: number): Promise<CustomMode | null> {
+    if (!this.isConnected()) {
+      throw new Error('Device is not connected');
+    }
+    return this.deviceManager.readCustomMode(slot);
+  }
+
+  /**
+   * Write a custom mode to the device
+   * @param slot - Slot number (0-14 for slots 1-15)
+   * @param mode - Custom mode to write
+   */
+  async writeCustomMode(slot: number, mode: CustomMode): Promise<void> {
+    if (!this.isConnected()) {
+      throw new Error('Device is not connected');
+    }
+    return this.deviceManager.writeCustomMode(slot, mode);
+  }
+
+  /**
+   * Export current mappings as custom mode
+   */
+  exportCurrentAsCustomMode(name: string): CustomMode {
+    const controls = this.controlMapper.exportToCustomMode();
+
+    const leds = new Map<number, { color: number; behaviour: string }>();
+    if (this.ledController) {
+      const ledStates = this.ledController.getAllLedStates();
+      for (const [controlId, state] of ledStates.entries()) {
+        if (state.active) {
+          const numericId = parseInt(controlId, 10);
+          if (!isNaN(numericId)) {
+            leds.set(numericId, {
+              color: typeof state.color === 'string' ? parseInt(state.color, 16) : state.color,
+              behaviour: state.behaviour,
+            });
+          }
+        }
+      }
+    }
+
+    return {
+      name,
+      controls,
+      leds,
+      metadata: {
+        createdAt: new Date(),
+        modifiedAt: new Date(),
+      },
+    };
+  }
+
+  // ============================================
+  // Control Mapping
+  // ============================================
+
+  /**
+   * Map a control
+   */
+  mapControl(
+    controlId: string,
+    channel: MidiChannel,
+    cc: CCNumber,
+    options?: Partial<ControlMapping>,
+  ): void {
+    const controlType = this.getControlType(controlId);
+    const mapping: ControlMapping = {
+      type: controlType,
+      channel,
+      cc,
+      min: options?.min ?? 0,
+      max: options?.max ?? 127,
+      behaviour: options?.behaviour ?? 'absolute',
+      ...(options?.transform && { transform: options.transform }),
+    };
+
+    this.controlMapper.mapControl(controlId, controlType ?? 'knob', mapping);
+  }
+
+  /**
+   * Unmap a control
+   */
+  unmapControl(controlId: string): void {
+    this.controlMapper.unmapControl(controlId);
+  }
+
+  /**
+   * Get control mapping
+   */
+  getControlMapping(controlId: string): ControlMapping | undefined {
+    const mapped = this.controlMapper.getMapping(controlId);
+    return mapped?.mapping;
+  }
+
+  /**
+   * Update control mapping
+   */
+  updateControlMapping(controlId: string, updates: Partial<ControlMapping>): void {
+    this.controlMapper.updateMapping(controlId, updates);
+  }
+
+  // ============================================
+  // LED Control
+  // ============================================
+
+  /**
+   * Set LED color
+   */
+  async setLed(
+    controlId: string,
+    color: LedColor | number,
+    behaviour?: LedBehaviour,
+  ): Promise<void> {
+    if (!this.ledController) {
+      throw new Error('LED control not enabled');
+    }
+
+    await this.ledController.setLed(controlId, color, behaviour);
+  }
+
+  /**
+   * Turn off LED
+   */
+  async turnOffLed(controlId: string): Promise<void> {
+    if (!this.ledController) {
+      throw new Error('LED control not enabled');
+    }
+
+    await this.ledController.turnOff(controlId);
+  }
+
+  /**
+   * Turn off all LEDs
+   */
+  async turnOffAllLeds(): Promise<void> {
+    if (!this.ledController) {
+      throw new Error('LED control not enabled');
+    }
+
+    await this.ledController.turnOffAll();
+  }
+
+  /**
+   * Flash LED
+   */
+  async flashLed(controlId: string, color: LedColor | number, duration?: number): Promise<void> {
+    if (!this.ledController) {
+      throw new Error('LED control not enabled');
+    }
+
+    await this.ledController.flashLed(controlId, color, duration);
+  }
+
+  /**
+   * Start LED animation
+   */
+  startLedAnimation(id: string, animation: any): void {
+    if (!this.ledController) {
+      throw new Error('LED control not enabled');
+    }
+
+    this.ledController.startAnimation(id, animation);
+  }
+
+  /**
+   * Stop LED animation
+   */
+  stopLedAnimation(id: string): void {
+    if (!this.ledController) {
+      throw new Error('LED control not enabled');
+    }
+
+    this.ledController.stopAnimation(id);
+  }
+
+  // ============================================
+  // Utility Methods
+  // ============================================
+
+  /**
+   * Get control type from control ID
+   */
+  private getControlType(controlId: string): 'knob' | 'fader' | 'button' {
+    if (controlId.includes('SEND') || controlId.includes('PAN')) {
+      return 'knob';
+    } else if (controlId.includes('FADER')) {
+      return 'fader';
+    } else {
+      return 'button';
+    }
+  }
+
+  /**
+   * Send raw MIDI message
+   */
+  async sendMidi(message: MidiMessage): Promise<void> {
+    await this.deviceManager.sendCC(
+      message.controller ?? 0,
+      message.value ?? 0,
+      message.channel ?? 0,
+    );
+  }
+
+  /**
+   * Send SysEx message
+   */
+  async sendSysEx(data: number[]): Promise<void> {
+    await this.deviceManager.sendSysEx(data);
+  }
+
+  /**
+   * Select template
+   */
+  async selectTemplate(slot: number): Promise<void> {
+    await this.deviceManager.selectTemplate(slot);
+  }
+
+  /**
+   * Get device status
+   */
+  getStatus(): DeviceStatus {
+    return this.deviceManager.getStatus();
+  }
+
+  /**
+   * Check if connected
+   */
+  isConnected(): boolean {
+    const status = this.getStatus();
+    return status.connected;
+  }
+
+  /**
+   * Get current mode
+   */
+  getCurrentMode(): CustomMode | undefined {
+    return this.currentMode;
+  }
+
+  /**
+   * Get current slot
+   */
+  getCurrentSlot(): CustomModeSlot | undefined {
+    return this.currentSlot;
+  }
+
+  /**
+   * Verify device identity and retrieve hardware information
+   * @returns Device information
+   * @throws Error if not connected or handshake fails
+   */
+  async verifyDevice(): Promise<LaunchControlXL3Info> {
+    if (!this.isConnected()) {
+      throw new Error('Device not connected. Call connect() first before verifying device.');
+    }
+
+    const status = this.getStatus();
+    if (!status.deviceInfo) {
+      throw new Error(
+        'Device connected but device information not available. Device handshake may have failed.',
+      );
+    }
+
+    // Perform fresh device identity query to verify current connection
+    try {
+      // Access private method through device manager's queryDeviceIdentity
+      // Since DeviceManager doesn't expose this publicly, we'll trigger a reconnection
+      // which forces a fresh handshake
+      await this.disconnect();
+      await this.connect();
+
+      const updatedStatus = this.getStatus();
+      if (!updatedStatus.deviceInfo) {
+        throw new Error(
+          'Device verification failed: Unable to retrieve device information after reconnection.',
+        );
+      }
+
+      return updatedStatus.deviceInfo;
+    } catch (error) {
+      const errorMessage = error instanceof Error ? error.message : String(error);
+      throw new Error(`Device verification failed: ${errorMessage}`);
+    }
+  }
+
+  /**
+   * Clean up resources
+   */
+  async cleanup(): Promise<void> {
+    this.logger.info('Cleaning up resources...');
+    await this.disconnect();
+    await this.deviceManager.cleanup();
+    this.controlMapper.cleanup();
+    this.removeAllListeners();
+    this.isInitialized = false;
+    this.logger.info('Cleanup complete');
+  }
+}
+
+// Export everything for convenience
+export * from './types/index.js';
+
+export default LaunchControlXL3;
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/browser.ts b/modules/audio-control/modules/launch-control-xl3/package/src/browser.ts
new file mode 100644
index 0000000..ea4a8cd
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/browser.ts
@@ -0,0 +1,8 @@
+/**
+ * Browser-only entry point for Launch Control XL3
+ * Only includes Web MIDI backend
+ */
+
+export { LaunchControlXL3 } from './LaunchControlXL3.js';
+export { WebMidiBackend } from './core/backends/WebMidiBackend.js';
+export * from './types/index.js';
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/builders/CustomModeBuilder.ts b/modules/audio-control/modules/launch-control-xl3/package/src/builders/CustomModeBuilder.ts
new file mode 100644
index 0000000..a50c23b
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/builders/CustomModeBuilder.ts
@@ -0,0 +1,341 @@
+/**
+ * High-level API for building Launch Control XL 3 custom modes
+ * Provides a fluent interface for defining control mappings, labels, and colors
+ */
+
+import type { CustomMode, Control, ControlType } from '@/types/CustomMode.js';
+
+export enum Color {
+  OFF = 0x0C,
+  RED_LOW = 0x0D,
+  RED_FULL = 0x0F,
+  AMBER_LOW = 0x1D,
+  AMBER_FULL = 0x3F,
+  YELLOW = 0x3E,
+  GREEN_LOW = 0x1C,
+  GREEN_FULL = 0x3C
+}
+
+interface ControlConfig {
+  cc: number;
+  channel?: number;
+  min?: number;
+  max?: number;
+}
+
+interface LabelColorData {
+  labels: Map<number, string>;
+  colors: Map<number, Color>;
+}
+
+/**
+ * Builder for creating Launch Control XL 3 custom modes
+ * Provides a fluent API for defining controls, labels, and colors
+ */
+export class CustomModeBuilder {
+  private modeName: string = '';
+  private controls: Control[] = [];
+  private labelData: LabelColorData = {
+    labels: new Map(),
+    colors: new Map()
+  };
+
+  /**
+   * Set the custom mode name (max 8 characters)
+   */
+  name(name: string): this {
+    if (name.length > 8) {
+      throw new Error('Mode name must be 8 characters or less');
+    }
+    this.modeName = name;
+    return this;
+  }
+
+  /**
+   * Add a fader control mapping
+   * @param faderNumber 1-8
+   * @param config Control configuration
+   */
+  addFader(faderNumber: number, config: ControlConfig): this {
+    if (faderNumber < 1 || faderNumber > 8) {
+      throw new Error('Fader number must be 1-8');
+    }
+
+    const controlId = faderNumber - 1; // 0x00-0x07
+    this.addControl(controlId, 0x00, config);
+    return this;
+  }
+
+  /**
+   * Add a top row encoder control mapping
+   * @param row 1 (always 1 for top row)
+   * @param encoderNumber 1-8
+   * @param config Control configuration
+   */
+  addEncoder(row: 1, encoderNumber: number, config: ControlConfig): this;
+  /**
+   * Add a middle row encoder control mapping
+   * @param row 2 (for middle row)
+   * @param encoderNumber 1-8
+   * @param config Control configuration
+   */
+  addEncoder(row: 2, encoderNumber: number, config: ControlConfig): this;
+  /**
+   * Add a bottom row encoder control mapping
+   * @param row 3 (for bottom row)
+   * @param encoderNumber 1-8
+   * @param config Control configuration
+   */
+  addEncoder(row: 3, encoderNumber: number, config: ControlConfig): this;
+  addEncoder(row: 1 | 2 | 3, encoderNumber: number, config: ControlConfig): this {
+    if (encoderNumber < 1 || encoderNumber > 8) {
+      throw new Error('Encoder number must be 1-8');
+    }
+
+    let controlId: number;
+    let controlType: ControlType;
+
+    switch (row) {
+      case 1: // Top row
+        controlId = 0x10 + (encoderNumber - 1); // 0x10-0x17
+        controlType = 0x05;
+        break;
+      case 2: // Middle row
+        controlId = 0x18 + (encoderNumber - 1); // 0x18-0x1F
+        controlType = 0x09;
+        break;
+      case 3: // Bottom row
+        controlId = 0x20 + (encoderNumber - 1); // 0x20-0x27
+        controlType = 0x0D;
+        break;
+      default:
+        throw new Error('Row must be 1, 2, or 3');
+    }
+
+    this.addControl(controlId, controlType, config);
+    return this;
+  }
+
+  /**
+   * Add a side button control mapping
+   * @param buttonNumber 1-8
+   * @param config Control configuration
+   */
+  addSideButton(buttonNumber: number, config: ControlConfig): this {
+    if (buttonNumber < 1 || buttonNumber > 8) {
+      throw new Error('Side button number must be 1-8');
+    }
+
+    const controlId = 0x28 + (buttonNumber - 1); // 0x28-0x2F
+    this.addControl(controlId, 0x19, config);
+    return this;
+  }
+
+  /**
+   * Add a bottom button control mapping
+   * @param buttonNumber 1-16
+   * @param config Control configuration
+   */
+  addBottomButton(buttonNumber: number, config: ControlConfig): this {
+    if (buttonNumber < 1 || buttonNumber > 16) {
+      throw new Error('Bottom button number must be 1-16');
+    }
+
+    const controlId = 0x30 + (buttonNumber - 1); // 0x30-0x3F
+    this.addControl(controlId, 0x25, config);
+    return this;
+  }
+
+  /**
+   * Add a label for a control
+   * @param controlId The hardware control ID (or use helper methods)
+   * @param label The label text
+   */
+  addLabel(controlId: number, label: string): this {
+    this.labelData.labels.set(controlId, label);
+    return this;
+  }
+
+  /**
+   * Add a label for a fader
+   * @param faderNumber 1-8
+   * @param label The label text
+   */
+  addFaderLabel(faderNumber: number, label: string): this {
+    if (faderNumber < 1 || faderNumber > 8) {
+      throw new Error('Fader number must be 1-8');
+    }
+    return this.addLabel(faderNumber - 1, label);
+  }
+
+  /**
+   * Add a label for an encoder
+   * @param row 1, 2, or 3
+   * @param encoderNumber 1-8
+   * @param label The label text
+   */
+  addEncoderLabel(row: 1 | 2 | 3, encoderNumber: number, label: string): this {
+    if (encoderNumber < 1 || encoderNumber > 8) {
+      throw new Error('Encoder number must be 1-8');
+    }
+
+    let controlId: number;
+    switch (row) {
+      case 1:
+        controlId = 0x10 + (encoderNumber - 1);
+        break;
+      case 2:
+        controlId = 0x18 + (encoderNumber - 1);
+        break;
+      case 3:
+        controlId = 0x20 + (encoderNumber - 1);
+        break;
+      default:
+        throw new Error('Row must be 1, 2, or 3');
+    }
+
+    return this.addLabel(controlId, label);
+  }
+
+  /**
+   * Add a color for a control
+   * @param controlId The hardware control ID
+   * @param color The color value
+   */
+  addColor(controlId: number, color: Color): this {
+    this.labelData.colors.set(controlId, color);
+    return this;
+  }
+
+  /**
+   * Add a color for a side button
+   * @param buttonNumber 1-8
+   * @param color The color value
+   */
+  addSideButtonColor(buttonNumber: number, color: Color): this {
+    if (buttonNumber < 1 || buttonNumber > 8) {
+      throw new Error('Side button number must be 1-8');
+    }
+    return this.addColor(0x28 + (buttonNumber - 1), color);
+  }
+
+  /**
+   * Add a color for a bottom button
+   * @param buttonNumber 1-16
+   * @param color The color value
+   */
+  addBottomButtonColor(buttonNumber: number, color: Color): this {
+    if (buttonNumber < 1 || buttonNumber > 16) {
+      throw new Error('Bottom button number must be 1-16');
+    }
+    return this.addColor(0x30 + (buttonNumber - 1), color);
+  }
+
+  /**
+   * Build the custom mode object
+   */
+  build(): CustomMode {
+    if (!this.modeName) {
+      throw new Error('Mode name is required');
+    }
+
+    if (this.controls.length === 0) {
+      throw new Error('At least one control mapping is required');
+    }
+
+    // Convert controls array to Record for CustomMode interface
+    const controlsRecord: Record<string, any> = {};
+    for (const control of this.controls) {
+      controlsRecord[`control_${control.controlId}`] = control;
+    }
+
+    return {
+      name: this.modeName,
+      controls: controlsRecord,
+      labels: this.labelData.labels,
+      colors: this.labelData.colors
+    };
+  }
+
+  /**
+   * Create a builder pre-configured for a simple test mode
+   */
+  static createTestMode(): CustomModeBuilder {
+    return new CustomModeBuilder()
+      .name('TEST')
+      .addFader(1, { cc: 10, channel: 1 })
+      .addEncoder(1, 1, { cc: 13, channel: 1 })
+      .addEncoderLabel(1, 1, 'Filter')
+      .addFaderLabel(1, 'Volume');
+  }
+
+  /**
+   * Create a builder pre-configured for the CHANNEV mode
+   */
+  static createChannevMode(): CustomModeBuilder {
+    const builder = new CustomModeBuilder().name('CHANNEV');
+
+    // Top row encoders (CC 13-20)
+    for (let i = 1; i <= 8; i++) {
+      builder.addEncoder(1, i, { cc: 12 + i, channel: 1 });
+    }
+
+    // Middle row encoders (CC 21-28)
+    for (let i = 1; i <= 8; i++) {
+      builder.addEncoder(2, i, { cc: 20 + i, channel: 1 });
+    }
+
+    // Bottom row encoders (CC 29-36)
+    for (let i = 1; i <= 8; i++) {
+      builder.addEncoder(3, i, { cc: 28 + i, channel: 1 });
+    }
+
+    // Add labels for key controls
+    builder
+      .addEncoderLabel(1, 1, 'Mic Gain')
+      .addEncoderLabel(1, 2, 'Line Amp Gain')
+      .addEncoderLabel(1, 4, 'Low Pass')
+      .addEncoderLabel(2, 1, 'High Shelf')
+      .addEncoderLabel(2, 2, 'Low Freq')
+      .addEncoderLabel(2, 3, 'Low Mid Freq')
+      .addEncoderLabel(2, 4, 'High Mid Freq')
+      .addEncoderLabel(2, 5, 'High Freq')
+      .addEncoderLabel(3, 1, 'Low Shelf')
+      .addEncoderLabel(3, 2, 'Low Gain')
+      .addEncoderLabel(3, 3, 'Low Mid Gain')
+      .addEncoderLabel(3, 4, 'High Mid Gain')
+      .addEncoderLabel(3, 5, 'High Gain');
+
+    return builder;
+  }
+
+  private addControl(controlId: number, controlType: ControlType, config: ControlConfig): void {
+    // Check for duplicate control
+    if (this.controls.find(c => c.controlId === controlId)) {
+      throw new Error(`Control ${controlId.toString(16)} already defined`);
+    }
+
+    // Validate CC range
+    if (config.cc < 0 || config.cc > 127) {
+      throw new Error('CC number must be 0-127');
+    }
+
+    // Validate channel
+    const channel = config.channel ?? 1;
+    if (channel < 1 || channel > 16) {
+      throw new Error('MIDI channel must be 1-16');
+    }
+
+    const control: Control = {
+      controlId,
+      controlType,
+      midiChannel: channel - 1, // Convert to 0-based
+      ccNumber: config.cc,
+      minValue: config.min ?? 0,
+      maxValue: config.max ?? 127,
+      behavior: 'absolute'
+    };
+
+    this.controls.push(control);
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/cli/cli.ts b/modules/audio-control/modules/launch-control-xl3/package/src/cli/cli.ts
new file mode 100644
index 0000000..4c0ea4e
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/cli/cli.ts
@@ -0,0 +1,196 @@
+#!/usr/bin/env node
+
+/**
+ * Launch Control XL 3 CLI Tool
+ *
+ * Simple command-line interface for testing the Launch Control XL 3 library
+ */
+
+import { Command } from 'commander';
+import { LaunchControlXL3 } from '../LaunchControlXL3.js';
+import { LED_COLOR_VALUES } from '../led/LedController.js';
+
+const program = new Command();
+const VERSION = '0.1.0';
+
+// Controller instance
+let controller: LaunchControlXL3 | null = null;
+
+/**
+ * Connect to device
+ */
+async function connect(): Promise<LaunchControlXL3> {
+  if (controller && controller.isConnected()) {
+    return controller;
+  }
+
+  console.log('Connecting to Launch Control XL 3...');
+
+  try {
+    controller = new LaunchControlXL3({
+      enableLedControl: true,
+      enableCustomModes: true,
+      deviceNameFilter: 'LCXL3 1'  // Use LCXL3 ports
+    });
+
+    await controller.connect();
+    console.log('‚úì Connected successfully');
+
+    // Setup basic event listeners
+    controller.on('control:change', (controlId: string, value: number) => {
+      console.log(`[Control] ${controlId}: ${value}`);
+    });
+
+    controller.on('device:disconnected', () => {
+      console.log('[Device] Disconnected');
+      controller = null;
+    });
+
+    return controller;
+  } catch (error) {
+    console.error(`Failed to connect: ${(error as Error).message}`);
+    process.exit(1);
+  }
+}
+
+// Cleanup on exit
+process.on('SIGINT', async () => {
+  console.log('\nShutting down...');
+  if (controller) {
+    await controller.cleanup();
+  }
+  process.exit(0);
+});
+
+// ============================================
+// CLI Setup
+// ============================================
+
+program
+  .name('lcxl3')
+  .description('Launch Control XL 3 CLI Tool')
+  .version(VERSION);
+
+// Connect command
+program
+  .command('connect')
+  .description('Connect to Launch Control XL 3')
+  .action(async () => {
+    try {
+      await connect();
+      console.log('Device ready for use');
+    } catch (error) {
+      console.error(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// Status command
+program
+  .command('status')
+  .description('Show device status')
+  .action(async () => {
+    try {
+      const ctrl = await connect();
+      const status = ctrl.getStatus();
+
+      console.log('\nDevice Status:');
+      console.log('‚îÄ'.repeat(30));
+      console.log(`Connected: ${status.connected ? 'Yes' : 'No'}`);
+      console.log(`State: ${status.state}`);
+
+      if (status.deviceInfo) {
+        console.log(`Firmware: ${status.deviceInfo.firmwareVersion}`);
+      }
+    } catch (error) {
+      console.error(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// LED test command
+program
+  .command('led-test')
+  .description('Run LED test pattern')
+  .action(async () => {
+    try {
+      const ctrl = await connect();
+      console.log('Running LED test...');
+
+      // Test focus buttons
+      for (let i = 1; i <= 8; i++) {
+        await ctrl.setLed(`FOCUS${i}`, LED_COLOR_VALUES.GREEN_FULL);
+        await new Promise(r => setTimeout(r, 100));
+      }
+
+      // Test control buttons
+      for (let i = 1; i <= 8; i++) {
+        await ctrl.setLed(`CONTROL${i}`, LED_COLOR_VALUES.AMBER_FULL);
+        await new Promise(r => setTimeout(r, 100));
+      }
+
+      // Turn off
+      await new Promise(r => setTimeout(r, 500));
+      await ctrl.turnOffAllLeds();
+
+      console.log('‚úì LED test complete');
+    } catch (error) {
+      console.error(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// Monitor command
+program
+  .command('monitor')
+  .description('Monitor control changes')
+  .action(async () => {
+    try {
+      const ctrl = await connect();
+      console.log('Monitoring controls (Ctrl+C to exit)...');
+      console.log('‚îÄ'.repeat(30));
+
+      ctrl.on('control:change', (controlId: string, value: number) => {
+        const bar = '‚ñà'.repeat(Math.round((value / 127) * 20));
+        const empty = '‚ñë'.repeat(20 - bar.length);
+        console.log(`${controlId.padEnd(12)} [${bar}${empty}] ${value}`);
+      });
+
+      // Keep alive
+      await new Promise(() => {});
+    } catch (error) {
+      console.error(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// Load mode command
+program
+  .command('load-mode <slot>')
+  .description('Load custom mode (0-15)')
+  .action(async (slot: string) => {
+    try {
+      const ctrl = await connect();
+      const slotNum = parseInt(slot, 10);
+
+      if (slotNum < 0 || slotNum > 15) {
+        console.error('Slot must be 0-15');
+        process.exit(1);
+      }
+
+      console.log(`Loading mode from slot ${slotNum}...`);
+      const mode = await ctrl.loadCustomMode(slotNum as any);
+      console.log(`‚úì Loaded mode: ${mode.name}`);
+    } catch (error) {
+      console.error(`Error: ${(error as Error).message}`);
+      process.exit(1);
+    }
+  });
+
+// Parse arguments
+program.parse();
+
+// Show help if no command
+if (!process.argv.slice(2).length) {
+  program.outputHelp();
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/cli/index.ts b/modules/audio-control/modules/launch-control-xl3/package/src/cli/index.ts
new file mode 100644
index 0000000..a6cd5c4
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/cli/index.ts
@@ -0,0 +1,58 @@
+#!/usr/bin/env node
+
+/**
+ * CLI entry point for Launch Control XL 3 utilities
+ */
+
+import { Command } from 'commander';
+
+const program = new Command();
+
+program
+  .name('xl3-cli')
+  .description('Launch Control XL 3 command-line interface')
+  .version('0.1.0');
+
+// Placeholder commands that will be implemented in Phase 4
+program
+  .command('connect')
+  .description('Connect to Launch Control XL 3 device')
+  .action(() => {
+    console.log('Device connection not yet implemented');
+    console.log('This CLI will be fully implemented in Phase 4 of the development plan');
+    process.exit(1);
+  });
+
+program
+  .command('read')
+  .description('Read custom mode from device')
+  .option('-s, --slot <number>', 'Mode slot number (1-8)')
+  .action(() => {
+    console.log('Mode reading not yet implemented');
+    console.log('This CLI will be fully implemented in Phase 4 of the development plan');
+    process.exit(1);
+  });
+
+program
+  .command('write')
+  .description('Write custom mode to device')
+  .option('-s, --slot <number>', 'Mode slot number (1-8)')
+  .option('-f, --file <path>', 'Configuration file path')
+  .action(() => {
+    console.log('Mode writing not yet implemented');
+    console.log('This CLI will be fully implemented in Phase 4 of the development plan');
+    process.exit(1);
+  });
+
+program
+  .command('monitor')
+  .description('Monitor MIDI messages in real-time')
+  .option('-v, --verbose', 'Verbose output')
+  .action(() => {
+    console.log('MIDI monitoring not yet implemented');
+    console.log('This CLI will be fully implemented in Phase 4 of the development plan');
+    process.exit(1);
+  });
+
+// Parse command line arguments
+program.parse();
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/cli/list-ports.ts b/modules/audio-control/modules/launch-control-xl3/package/src/cli/list-ports.ts
new file mode 100644
index 0000000..0fe3b42
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/cli/list-ports.ts
@@ -0,0 +1,31 @@
+#!/usr/bin/env tsx
+
+import { createRequire } from 'module';
+
+const require = createRequire(import.meta.url);
+const midi = require('midi');
+
+console.log('Available MIDI Ports:\n');
+
+// List input ports
+const input = new midi.Input();
+const inputCount = input.getPortCount();
+console.log(`Input Ports (${inputCount}):`);
+for (let i = 0; i < inputCount; i++) {
+  const name = input.getPortName(i);
+  console.log(`  ${i}: "${name}"`);
+}
+
+// List output ports
+console.log('');
+const output = new midi.Output();
+const outputCount = output.getPortCount();
+console.log(`Output Ports (${outputCount}):`);
+for (let i = 0; i < outputCount; i++) {
+  const name = output.getPortName(i);
+  console.log(`  ${i}: "${name}"`);
+}
+
+// Close ports
+input.closePort();
+output.closePort();
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/Device.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/Device.ts
new file mode 100644
index 0000000..019fcf8
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/Device.ts
@@ -0,0 +1,25 @@
+/**
+ * Device communication and state management for Launch Control XL 3
+ * 
+ * This class will be implemented in Phase 2: Protocol Implementation
+ */
+
+import type { DeviceOptions, DeviceState } from '@/types/device.js';
+
+export class LaunchControlXL3 {
+  constructor(_options?: DeviceOptions) {
+    throw new Error('LaunchControlXL3 class not yet implemented - Phase 2: Protocol Implementation');
+  }
+
+  async connect(): Promise<void> {
+    throw new Error('Device connection not yet implemented');
+  }
+
+  async disconnect(): Promise<void> {
+    throw new Error('Device disconnection not yet implemented');
+  }
+
+  getState(): DeviceState {
+    throw new Error('Device state management not yet implemented');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/Logger.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/Logger.ts
new file mode 100644
index 0000000..725a699
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/Logger.ts
@@ -0,0 +1,53 @@
+export interface Logger {
+  debug(msg: string, ...args: unknown[]): void;
+  info(msg: string, ...args: unknown[]): void;
+  warn(msg: string, ...args: unknown[]): void;
+  error(msg: string, ...args: unknown[]): void;
+}
+
+export interface LoggerOptions {
+  prefix?: string;
+  includeTimestamp?: boolean;
+}
+
+export class ConsoleLogger implements Logger {
+  private readonly prefix: string | undefined;
+  private readonly includeTimestamp: boolean;
+
+  constructor(options: LoggerOptions = {}) {
+    this.prefix = options.prefix;
+    this.includeTimestamp = options.includeTimestamp ?? false;
+  }
+
+  private formatMessage(msg: string): string {
+    const parts: string[] = [];
+
+    if (this.includeTimestamp) {
+      parts.push(`[${new Date().toISOString()}]`);
+    }
+
+    if (this.prefix) {
+      parts.push(`[${this.prefix}]`);
+    }
+
+    parts.push(msg);
+
+    return parts.join(' ');
+  }
+
+  debug(msg: string, ...args: unknown[]): void {
+    console.debug(this.formatMessage(msg), ...args);
+  }
+
+  info(msg: string, ...args: unknown[]): void {
+    console.info(this.formatMessage(msg), ...args);
+  }
+
+  warn(msg: string, ...args: unknown[]): void {
+    console.warn(this.formatMessage(msg), ...args);
+  }
+
+  error(msg: string, ...args: unknown[]): void {
+    console.error(this.formatMessage(msg), ...args);
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/MessageQueue.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/MessageQueue.ts
new file mode 100644
index 0000000..65f45ef
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/MessageQueue.ts
@@ -0,0 +1,11 @@
+/**
+ * Message queuing for reliable delivery
+ * 
+ * This class will be implemented in Phase 2: Protocol Implementation
+ */
+
+export class MessageQueue {
+  constructor() {
+    throw new Error('MessageQueue class not yet implemented - Phase 2: Protocol Implementation');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/MidiInterface.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/MidiInterface.ts
new file mode 100644
index 0000000..50ccf58
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/MidiInterface.ts
@@ -0,0 +1,389 @@
+/**
+ * Platform-agnostic MIDI interface
+ *
+ * Provides abstraction layer for different MIDI backends (node-midi, Web MIDI API, etc.)
+ */
+
+import { EventEmitter } from 'eventemitter3';
+
+// Base MIDI Message type
+export interface MidiMessage {
+  readonly timestamp: number;
+  readonly data: readonly number[];
+  type?: string;
+  channel?: number;
+  controller?: number;
+  value?: number;
+  note?: number;
+  velocity?: number;
+}
+
+// Port information
+export interface MidiPortInfo {
+  readonly id: string;
+  readonly name: string;
+  readonly manufacturer?: string;
+  readonly version?: string;
+}
+
+// MIDI Port abstraction
+export interface MidiPort {
+  readonly id: string;
+  readonly name: string;
+  readonly type: 'input' | 'output';
+
+  close(): Promise<void>;
+}
+
+// Input port with message handler
+export interface MidiInputPort extends MidiPort {
+  readonly type: 'input';
+  onMessage?: ((message: MidiMessage) => void) | undefined;
+}
+
+// Output port
+export interface MidiOutputPort extends MidiPort {
+  readonly type: 'output';
+}
+
+// Backend interface that different MIDI implementations must satisfy
+export interface MidiBackendInterface {
+  initialize(): Promise<void>;
+
+  getInputPorts(): Promise<MidiPortInfo[]>;
+
+  getOutputPorts(): Promise<MidiPortInfo[]>;
+
+  openInput(portId: string): Promise<MidiInputPort>;
+
+  openOutput(portId: string): Promise<MidiOutputPort>;
+
+  sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void>;
+
+  closePort(port: MidiPort): Promise<void>;
+
+  cleanup(): Promise<void>;
+}
+
+// Events emitted by MidiInterface
+export interface MidiInterfaceEvents {
+  message: (message: MidiMessage) => void;
+  connected: (port: MidiPort) => void;
+  disconnected: (port: MidiPort) => void;
+  error: (error: Error) => void;
+}
+
+/**
+ * Main MIDI interface class
+ * Manages MIDI connections and message routing
+ */
+export class MidiInterface extends EventEmitter {
+  private backend?: MidiBackendInterface | undefined;
+  private inputPort?: MidiInputPort | undefined;
+  private outputPort?: MidiOutputPort | undefined;
+  private isInitialized = false;
+  private messageBuffer: MidiMessage[] = [];
+  private readonly maxBufferSize = 1000;
+
+  constructor(backend?: MidiBackendInterface) {
+    super();
+    this.backend = backend;
+  }
+
+  /**
+   * Initialize the MIDI interface
+   */
+  async initialize(): Promise<void> {
+    if (this.isInitialized) {
+      return;
+    }
+
+    // If no backend provided, try to auto-detect
+    if (!this.backend) {
+      throw new Error('MIDI backend is not initialized');
+      //this.backend = await this.autoDetectBackend();
+    }
+
+    await this.backend.initialize();
+    this.isInitialized = true;
+  }
+
+  /**
+   * Get available input ports
+   */
+  async getInputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized) {
+      throw new Error('MidiInterface not initialized');
+    }
+
+    if (!this.backend) {
+      throw new Error('No MIDI backend available');
+    }
+
+    return this.backend.getInputPorts();
+  }
+
+  /**
+   * Get available output ports
+   */
+  async getOutputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized) {
+      throw new Error('MidiInterface not initialized');
+    }
+
+    if (!this.backend) {
+      throw new Error('No MIDI backend available');
+    }
+
+    return this.backend.getOutputPorts();
+  }
+
+  /**
+   * Open input port by ID or name
+   */
+  async openInput(portIdOrName: string): Promise<void> {
+    if (!this.isInitialized) {
+      throw new Error('MidiInterface not initialized');
+    }
+
+    if (!this.backend) {
+      throw new Error('No MIDI backend available');
+    }
+
+    // Close existing input if open
+    if (this.inputPort) {
+      await this.closeInput();
+    }
+
+    // Find port
+    const ports = await this.backend.getInputPorts();
+    const port = ports.find((p) => p.id === portIdOrName || p.name === portIdOrName);
+
+    if (!port) {
+      throw new Error(`Input port not found: ${portIdOrName}`);
+    }
+
+    // Open port
+    this.inputPort = await this.backend.openInput(port.id);
+
+    // Set up message handler
+    this.inputPort.onMessage = (message: MidiMessage) => {
+      this.handleIncomingMessage(message);
+    };
+
+    this.emit('connected', this.inputPort);
+  }
+
+  /**
+   * Open output port by ID or name
+   */
+  async openOutput(portIdOrName: string): Promise<void> {
+    if (!this.isInitialized) {
+      throw new Error('MidiInterface not initialized');
+    }
+
+    if (!this.backend) {
+      throw new Error('No MIDI backend available');
+    }
+
+    // Close existing output if open
+    if (this.outputPort) {
+      await this.closeOutput();
+    }
+
+    // Find port
+    const ports = await this.backend.getOutputPorts();
+    const port = ports.find((p) => p.id === portIdOrName || p.name === portIdOrName);
+
+    if (!port) {
+      throw new Error(`Output port not found: ${portIdOrName}`);
+    }
+
+    // Open port
+    this.outputPort = await this.backend.openOutput(port.id);
+    this.emit('connected', this.outputPort);
+  }
+
+  /**
+   * Send MIDI message
+   */
+  async sendMessage(data: number[]): Promise<void> {
+    if (!this.outputPort) {
+      throw new Error('No output port open');
+    }
+
+    if (!this.backend) {
+      throw new Error('No MIDI backend available');
+    }
+
+    const message: MidiMessage = {
+      timestamp: Date.now(),
+      data,
+    };
+
+    await this.backend.sendMessage(this.outputPort, message);
+  }
+
+  /**
+   * Close input port
+   */
+  async closeInput(): Promise<void> {
+    if (this.inputPort && this.backend) {
+      await this.backend.closePort(this.inputPort);
+      this.emit('disconnected', this.inputPort);
+      this.inputPort = undefined;
+    }
+  }
+
+  /**
+   * Close output port
+   */
+  async closeOutput(): Promise<void> {
+    if (this.outputPort && this.backend) {
+      await this.backend.closePort(this.outputPort);
+      this.emit('disconnected', this.outputPort);
+      this.outputPort = undefined;
+    }
+  }
+
+  /**
+   * Close all ports and cleanup
+   */
+  async cleanup(): Promise<void> {
+    await this.closeInput();
+    await this.closeOutput();
+
+    if (this.backend) {
+      await this.backend.cleanup();
+    }
+
+    this.isInitialized = false;
+    this.messageBuffer = [];
+  }
+
+  /**
+   * Get current connection status
+   */
+  isConnected(): boolean {
+    return !!(this.inputPort || this.outputPort);
+  }
+
+  /**
+   * Get buffered messages
+   */
+  getBufferedMessages(): MidiMessage[] {
+    return [...this.messageBuffer];
+  }
+
+  /**
+   * Clear message buffer
+   */
+  clearBuffer(): void {
+    this.messageBuffer = [];
+  }
+
+  /**
+   * Handle incoming MIDI message
+   */
+  private handleIncomingMessage(message: MidiMessage): void {
+    // Add to buffer
+    this.messageBuffer.push(message);
+
+    // Limit buffer size
+    if (this.messageBuffer.length > this.maxBufferSize) {
+      this.messageBuffer.shift();
+    }
+
+    // Parse and emit typed MIDI events
+    const data = message.data;
+    if (data.length > 0) {
+      const statusByte = data[0];
+      if (statusByte === undefined) return;
+      const channel = statusByte & 0x0f;
+      const messageType = statusByte & 0xf0;
+
+      const parsedMessage: MidiMessage = {
+        timestamp: message.timestamp,
+        data: data,
+        type: 'unknown',
+        channel,
+      };
+
+      switch (messageType) {
+        case 0xb0: // Control Change
+          parsedMessage.type = 'controlchange';
+          parsedMessage.controller = data[1] ?? 0;
+          parsedMessage.value = data[2] ?? 0;
+          this.emit('controlchange', parsedMessage);
+          break;
+
+        case 0x90: // Note On
+          parsedMessage.type = 'noteon';
+          parsedMessage.note = data[1] ?? 0;
+          parsedMessage.velocity = data[2] ?? 0;
+          this.emit('noteon', parsedMessage);
+          break;
+
+        case 0x80: // Note Off
+          parsedMessage.type = 'noteoff';
+          parsedMessage.note = data[1] ?? 0;
+          parsedMessage.velocity = data[2] ?? 0;
+          this.emit('noteoff', parsedMessage);
+          break;
+
+        case 0xf0: // System Exclusive
+          if (data[data.length - 1] === 0xf7) {
+            parsedMessage.type = 'sysex';
+            this.emit('sysex', parsedMessage);
+          }
+          break;
+      }
+
+      // Always emit the generic message event
+      this.emit('message', message);
+    }
+  }
+
+  /**
+   * Auto-detect available MIDI backend
+   */
+  // private async autoDetectBackend(): Promise<MidiBackendInterface> {
+  //   // Try Web MIDI API first (browser environment with native support)
+  //   try {
+  //     const { WebMidiBackend } = await import('./backends/WebMidiBackend.js');
+  //     if (WebMidiBackend.isAvailable()) {
+  //       return new WebMidiBackend();
+  //     }
+  //   } catch (err) {
+  //     console.debug('Web MIDI API not available:', err);
+  //   }
+  //
+  //   // Try easymidi (Node.js with native bindings)
+  //   try {
+  //     const { EasyMidiBackend } = await import('./backends/EasyMidiBackend.js');
+  //     const backend = new EasyMidiBackend();
+  //     await backend.initialize();
+  //     return backend;
+  //   } catch (err) {
+  //     console.debug('easymidi not available:', err);
+  //   }
+  //
+  //   // Try JZZ (pure JavaScript, works in Node.js and browsers)
+  //   try {
+  //     const { JzzBackend } = await import('./backends/JzzBackend.js');
+  //     const backend = new JzzBackend();
+  //     await backend.initialize();
+  //     return backend;
+  //   } catch (err) {
+  //     console.debug('JZZ not available:', err);
+  //   }
+  //
+  //   // Try node-midi (Node.js with native bindings - fallback if easymidi unavailable)
+  //   try {
+  //     const { NodeMidiBackend } = await import('./backends/NodeMidiBackend.js');
+  //     return new NodeMidiBackend();
+  //   } catch (err) {
+  //     console.debug('node-midi not available:', err);
+  //   }
+  // }
+}
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/Midimunge.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/Midimunge.ts
new file mode 100644
index 0000000..2d5f99b
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/Midimunge.ts
@@ -0,0 +1,344 @@
+/**
+ * Midimunge 7-bit encoding/decoding for MIDI SysEx data transmission
+ *
+ * The Midimunge algorithm encodes 8-bit data into 7-bit values suitable for
+ * MIDI SysEx transmission. It processes data in chunks of 7 bytes, using an
+ * additional header byte to store the MSBs.
+ *
+ * Encoding format:
+ * - Every 7 bytes of input data becomes 8 bytes of encoded output
+ * - First byte contains the MSBs of the following 7 bytes (bit 0 = MSB of byte 1, etc.)
+ * - Following 7 bytes contain the lower 7 bits of the original data
+ *
+ * Example:
+ * Input:  [0x81, 0x02, 0x83, 0x04, 0x85, 0x06, 0x87]
+ * Output: [0x55, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07]
+ *         (0x55 = 0b01010101 contains all the MSBs)
+ */
+
+export class Midimunge {
+  /**
+   * Encode 8-bit data into 7-bit MIDI SysEx format
+   * @param data - Array of 8-bit values to encode
+   * @returns Array of 7-bit values suitable for MIDI SysEx
+   * @throws Error if input contains values > 255
+   */
+  static encode(data: number[]): number[] {
+    // Validate input
+    for (let i = 0; i < data.length; i++) {
+      const value = data[i];
+      if (value === undefined || value > 255 || value < 0) {
+        throw new Error(`Invalid data value at index ${i}: ${value}. Must be 0-255.`);
+      }
+    }
+
+    const encoded: number[] = [];
+    let index = 0;
+
+    while (index < data.length) {
+      // Process up to 7 bytes at a time
+      const chunkSize = Math.min(7, data.length - index);
+      let headerByte = 0;
+
+      // Collect MSBs into header byte
+      for (let i = 0; i < chunkSize; i++) {
+        const value = data[index + i];
+        if (value !== undefined && (value & 0x80)) {
+          headerByte |= (1 << i);
+        }
+      }
+
+      // Add header byte
+      encoded.push(headerByte);
+
+      // Add 7-bit data bytes
+      for (let i = 0; i < chunkSize; i++) {
+        const value = data[index + i];
+        encoded.push((value ?? 0) & 0x7F);
+      }
+
+      index += chunkSize;
+    }
+
+    return encoded;
+  }
+
+  /**
+   * Decode 7-bit MIDI SysEx data back to 8-bit format
+   * @param data - Array of 7-bit MIDI SysEx values to decode
+   * @returns Array of decoded 8-bit values
+   * @throws Error if input contains invalid 7-bit values or malformed data
+   */
+  static decode(data: number[]): number[] {
+    // Validate input
+    for (let i = 0; i < data.length; i++) {
+      const value = data[i];
+      if (value === undefined || value > 127 || value < 0) {
+        throw new Error(`Invalid 7-bit value at index ${i}: ${value}. Must be 0-127.`);
+      }
+    }
+
+    const decoded: number[] = [];
+    let index = 0;
+
+    while (index < data.length) {
+      if (index >= data.length) {
+        break;
+      }
+
+      // Get header byte containing MSBs
+      const headerByte = data[index];
+      index++;
+
+      // Calculate how many data bytes follow (up to 7)
+      const remainingBytes = data.length - index;
+      const chunkSize = Math.min(7, remainingBytes);
+
+      // Decode each data byte
+      for (let i = 0; i < chunkSize; i++) {
+        if (index >= data.length) {
+          throw new Error('Unexpected end of data during decode');
+        }
+
+        const dataByte = data[index];
+        if (dataByte === undefined) {
+          throw new Error('Unexpected end of data during decode');
+        }
+
+        let value = dataByte & 0x7F;
+
+        // Restore MSB if set in header
+        if (headerByte !== undefined && (headerByte & (1 << i))) {
+          value |= 0x80;
+        }
+
+        decoded.push(value);
+        index++;
+      }
+    }
+
+    return decoded;
+  }
+
+  /**
+   * Calculate the encoded size for a given data length
+   * @param dataLength - Length of data to encode
+   * @returns Size of encoded data
+   */
+  static getEncodedSize(dataLength: number): number {
+    const fullChunks = Math.floor(dataLength / 7);
+    const remainder = dataLength % 7;
+
+    // Each full chunk of 7 bytes becomes 8 bytes
+    let size = fullChunks * 8;
+
+    // Partial chunk adds header + remaining bytes
+    if (remainder > 0) {
+      size += 1 + remainder;
+    }
+
+    return size;
+  }
+
+  /**
+   * Calculate the maximum decoded size for a given encoded data length
+   * @param encodedLength - Length of encoded data
+   * @returns Maximum size of decoded data
+   */
+  static getMaxDecodedSize(encodedLength: number): number {
+    const fullChunks = Math.floor(encodedLength / 8);
+    const remainder = encodedLength % 8;
+
+    // Each full chunk of 8 bytes becomes 7 bytes
+    let size = fullChunks * 7;
+
+    // Partial chunk: header byte + up to 7 data bytes
+    if (remainder > 1) {
+      size += remainder - 1;
+    }
+
+    return size;
+  }
+
+  /**
+   * Encode a string to 7-bit MIDI SysEx format
+   * @param text - String to encode
+   * @returns Array of 7-bit values
+   */
+  static encodeString(text: string): number[] {
+    const bytes: number[] = [];
+    for (let i = 0; i < text.length; i++) {
+      const code = text.charCodeAt(i);
+      if (code > 255) {
+        throw new Error(`Character at position ${i} is not ASCII: ${text[i]}`);
+      }
+      bytes.push(code);
+    }
+    return this.encode(bytes);
+  }
+
+  /**
+   * Decode 7-bit MIDI SysEx data to a string
+   * @param data - Array of 7-bit values to decode
+   * @returns Decoded string
+   */
+  static decodeString(data: number[]): string {
+    const bytes = this.decode(data);
+    let result = '';
+    for (const byte of bytes) {
+      result += String.fromCharCode(byte);
+    }
+    return result;
+  }
+
+  /**
+   * Validate that data is properly encoded Midimunge format
+   * @param data - Data to validate
+   * @returns True if data appears to be valid Midimunge encoding
+   */
+  static isValidEncoding(data: number[]): boolean {
+    // All values must be 7-bit
+    for (const value of data) {
+      if (value < 0 || value > 127) {
+        return false;
+      }
+    }
+
+    // Check structure: should be chunks of (1 header + up to 7 data bytes)
+    let index = 0;
+    while (index < data.length) {
+      if (index >= data.length) {
+        break;
+      }
+
+      // Skip header byte
+      index++;
+
+      // Count data bytes (up to 7)
+      const remainingBytes = data.length - index;
+      const chunkSize = Math.min(7, remainingBytes);
+
+      index += chunkSize;
+    }
+
+    return true;
+  }
+
+  /**
+   * Create a hex string representation of encoded data for debugging
+   * @param data - Encoded data
+   * @returns Hex string with chunk separators
+   */
+  static toHexString(data: number[]): string {
+    const chunks: string[] = [];
+    let index = 0;
+
+    while (index < data.length) {
+      const chunkSize = Math.min(8, data.length - index);
+      const chunk = data.slice(index, index + chunkSize);
+      chunks.push(chunk.map(b => b.toString(16).padStart(2, '0')).join(' '));
+      index += chunkSize;
+    }
+
+    return chunks.join(' | ');
+  }
+}
+
+/**
+ * Utility class for working with packed bit fields in Midimunge data
+ */
+export class MidimungeBitField {
+  private data: number[];
+
+  constructor(sizeInBits: number = 0) {
+    const sizeInBytes = Math.ceil(sizeInBits / 8);
+    this.data = new Array(sizeInBytes).fill(0);
+  }
+
+  /**
+   * Set a bit at the specified index
+   */
+  setBit(index: number, value: boolean): void {
+    const byteIndex = Math.floor(index / 8);
+    const bitIndex = index % 8;
+
+    if (byteIndex >= this.data.length) {
+      throw new Error(`Bit index ${index} out of range`);
+    }
+
+    if (value) {
+      this.data[byteIndex] = (this.data[byteIndex] ?? 0) | (1 << bitIndex);
+    } else {
+      this.data[byteIndex] = (this.data[byteIndex] ?? 0) & ~(1 << bitIndex);
+    }
+  }
+
+  /**
+   * Get a bit at the specified index
+   */
+  getBit(index: number): boolean {
+    const byteIndex = Math.floor(index / 8);
+    const bitIndex = index % 8;
+
+    if (byteIndex >= this.data.length) {
+      throw new Error(`Bit index ${index} out of range`);
+    }
+
+    return ((this.data[byteIndex] ?? 0) & (1 << bitIndex)) !== 0;
+  }
+
+  /**
+   * Set a range of bits from a value
+   */
+  setBits(startIndex: number, length: number, value: number): void {
+    for (let i = 0; i < length; i++) {
+      this.setBit(startIndex + i, (value & (1 << i)) !== 0);
+    }
+  }
+
+  /**
+   * Get a range of bits as a value
+   */
+  getBits(startIndex: number, length: number): number {
+    let value = 0;
+    for (let i = 0; i < length; i++) {
+      if (this.getBit(startIndex + i)) {
+        value |= (1 << i);
+      }
+    }
+    return value;
+  }
+
+  /**
+   * Get the raw byte array
+   */
+  toBytes(): number[] {
+    return [...this.data];
+  }
+
+  /**
+   * Create from a byte array
+   */
+  static fromBytes(bytes: number[]): MidimungeBitField {
+    const field = new MidimungeBitField(bytes.length * 8);
+    field.data = [...bytes];
+    return field;
+  }
+
+  /**
+   * Encode to Midimunge format
+   */
+  encode(): number[] {
+    return Midimunge.encode(this.data);
+  }
+
+  /**
+   * Decode from Midimunge format
+   */
+  static decode(encoded: number[]): MidimungeBitField {
+    const bytes = Midimunge.decode(encoded);
+    return MidimungeBitField.fromBytes(bytes);
+  }
+}
+
+export default Midimunge;
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/Protocol.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/Protocol.ts
new file mode 100644
index 0000000..e469718
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/Protocol.ts
@@ -0,0 +1,11 @@
+/**
+ * XL3 protocol implementation
+ * 
+ * This class will be implemented in Phase 2: Protocol Implementation
+ */
+
+export class Protocol {
+  constructor() {
+    throw new Error('Protocol class not yet implemented - Phase 2: Protocol Implementation');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/SysExParser.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/SysExParser.ts
new file mode 100644
index 0000000..c6d84db
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/SysExParser.ts
@@ -0,0 +1,972 @@
+/**
+ * SysEx message parsing and building for Novation Launch Control XL 3
+ *
+ * Handles all SysEx communication with the device including:
+ * - Device inquiry/response
+ * - Template changes
+ * - Custom mode read/write
+ * - LED control
+ * - Configuration management
+ */
+
+import { Midimunge } from './Midimunge.js';
+import type { CustomMode, ControlMapping, ColorMapping } from '../types/CustomMode.js';
+
+// Novation/Focusrite manufacturer ID
+export const MANUFACTURER_ID = [0x00, 0x20, 0x29];
+
+// Device family codes
+export const DEVICE_FAMILY = {
+  LAUNCH_CONTROL_XL: 0x11,
+  LAUNCH_CONTROL_XL_MK3: 0x61,
+};
+
+// SysEx message types
+export enum SysExMessageType {
+  // Standard MIDI messages
+  DEVICE_INQUIRY = 0x06,
+  DEVICE_INQUIRY_RESPONSE = 0x06,
+
+  // Novation specific messages
+  TEMPLATE_CHANGE = 0x77,
+  LED_CONTROL = 0x78,
+  CUSTOM_MODE_READ = 0x62,
+  CUSTOM_MODE_WRITE = 0x63,
+  CUSTOM_MODE_RESPONSE = 0x62,
+  RESET_LED = 0x79,
+}
+
+// Base SysEx message interface
+export interface SysExMessage {
+  type: string;
+  manufacturerId: number[];
+  data: number[];
+}
+
+// Device inquiry response
+export interface DeviceInquiryResponse extends SysExMessage {
+  type: 'device_inquiry_response';
+  familyCode: number;
+  familyMember: number;
+  softwareRevision: number[];
+  serialNumber?: string | number[];
+}
+
+// Template change message
+export interface TemplateChangeMessage extends SysExMessage {
+  type: 'template_change';
+  templateNumber: number;
+}
+
+// Custom mode message
+export interface CustomModeMessage extends SysExMessage {
+  type: 'custom_mode_response' | 'custom_mode_write';
+  slot: number;
+  name?: string;
+  controls: ControlMapping[];
+  colors: ColorMapping[];
+}
+
+// Control mapping for custom modes
+// ControlMapping and ColorMapping interfaces are now imported from types/CustomMode.ts
+
+/**
+ * SysEx message parser and builder
+ */
+export class SysExParser {
+  /**
+   * Parse a SysEx message
+   */
+  static parse(data: number[]): SysExMessage {
+    // Check start byte first
+    if (data.length === 0 || data[0] !== 0xF0) {
+      throw new Error('Invalid SysEx message: missing start byte');
+    }
+
+    // Then check end byte
+    if (data[data.length - 1] !== 0xF7) {
+      throw new Error('Invalid SysEx message: missing end byte');
+    }
+
+    // Finally check minimum length
+    if (data.length < 5) {
+      throw new Error('Invalid SysEx message: too short');
+    }
+
+    // Remove start and end bytes
+    const content = data.slice(1, -1);
+
+    // Check for universal device inquiry response
+    if (content[0] === 0x7E && content[2] === 0x06) {
+      return this.parseDeviceInquiryResponse(content);
+    }
+
+    // Check for Novation manufacturer ID
+    if (content[0] === MANUFACTURER_ID[0] &&
+        content[1] === MANUFACTURER_ID[1] &&
+        content[2] === MANUFACTURER_ID[2]) {
+      return this.parseNovationMessage(content);
+    }
+
+    throw new Error('Unknown SysEx message format');
+  }
+
+  /**
+   * Parse universal device inquiry response
+   */
+  private static parseDeviceInquiryResponse(data: number[]): DeviceInquiryResponse {
+    // Format: 7E <device ID> 06 02 <manufacturer ID> <family> <member> <version>
+    if (data.length < 15) {
+      throw new Error('Invalid device inquiry response');
+    }
+
+    return {
+      type: 'device_inquiry_response',
+      manufacturerId: [data[4] ?? 0, data[5] ?? 0, data[6] ?? 0],
+      familyCode: ((data[7] ?? 0) << 8) | (data[8] ?? 0),
+      familyMember: ((data[9] ?? 0) << 8) | (data[10] ?? 0),
+      softwareRevision: [data[11] ?? 0, data[12] ?? 0, data[13] ?? 0, data[14] ?? 0],
+      data,
+    };
+  }
+
+  /**
+   * Parse Novation-specific message
+   */
+  private static parseNovationMessage(data: number[]): SysExMessage {
+    // Skip manufacturer ID (first 3 bytes: 00 20 29)
+    const messageData = data.slice(3);
+
+    if (messageData.length < 2) {
+      throw new Error('Invalid Novation SysEx message');
+    }
+
+    // Check for Launch Control XL 3 format: 02 15 05 00 [operation] [slot]
+    if (messageData.length >= 7 &&
+        messageData[0] === 0x02 &&  // Device ID (Launch Control XL 3)
+        messageData[1] === 0x15 &&  // Command (Custom mode)
+        messageData[2] === 0x05 &&  // Sub-command
+        messageData[3] === 0x00) {  // Reserved
+
+      const operation = messageData[4];
+
+      // Check if this is a custom mode response (operation 0x10)
+      if (operation === 0x10) {
+        return this.parseCustomModeResponseXL3(messageData); // Pass message data (F0/F7 and manufacturer ID stripped)
+      }
+    }
+
+    // Fallback to legacy format parsing
+    const messageType = messageData[1];
+
+    switch (messageType) {
+      case SysExMessageType.TEMPLATE_CHANGE:
+        return this.parseTemplateChange(messageData);
+
+      case SysExMessageType.CUSTOM_MODE_RESPONSE:
+        return this.parseCustomModeResponse(data);
+
+      default:
+        return {
+          type: 'unknown',
+          manufacturerId: MANUFACTURER_ID,
+          data: messageData,
+        };
+    }
+  }
+
+  /**
+   * Parse template change message
+   */
+  private static parseTemplateChange(data: number[]): TemplateChangeMessage {
+    if (data.length < 3) {
+      throw new Error('Invalid template change message');
+    }
+
+    return {
+      type: 'template_change',
+      manufacturerId: MANUFACTURER_ID,
+      templateNumber: data[2] ?? 0,
+      data,
+    };
+  }
+
+  /**
+   * Parse Launch Control XL 3 custom mode response (expects messageData without F0/F7 and manufacturer ID)
+   */
+  private static parseCustomModeResponseXL3(data: number[]): CustomModeMessage {
+    if (data.length < 6) {
+      throw new Error('Invalid Launch Control XL 3 custom mode response');
+    }
+
+    // Expected format after F0/F7 and manufacturer ID stripped by parseNovationMessage:
+    // 02 15 05 00 10 [SLOT] [419 bytes of data]
+    // Positions: 0  1  2  3  4     5
+    const operation = data[4];
+    const slot = data[5] ?? 0;
+
+    if (operation !== 0x10) {
+      throw new Error(`Unexpected operation in Launch Control XL 3 response: 0x${(operation ?? 0).toString(16)}`);
+    }
+
+    // Parse the actual custom mode data (starts after slot byte at position 6)
+    const rawModeData = data.slice(6);
+    const { controls, colors, name } = this.parseCustomModeData(rawModeData);
+
+    const message: CustomModeMessage = {
+      type: 'custom_mode_response',
+      manufacturerId: MANUFACTURER_ID,
+      slot,
+      controls,
+      colors,
+      data,
+    };
+
+    if (name !== undefined) {
+      message.name = name;
+    }
+
+    return message;
+  }
+
+  /**
+   * Parse legacy custom mode response (for older devices)
+   */
+  private static parseCustomModeResponse(data: number[]): CustomModeMessage {
+    if (data.length < 4) {
+      throw new Error('Invalid custom mode response');
+    }
+
+    const slot = data[2];
+    if (slot === undefined) {
+      throw new Error('Invalid slot in custom mode response');
+    }
+    const encodedData = data.slice(3);
+
+    // Decode the Midimunge-encoded custom mode data
+    const decodedData = Midimunge.decode(encodedData);
+
+    // Parse the decoded data into control and color mappings
+    const { controls, colors } = this.parseCustomModeData(decodedData);
+
+    return {
+      type: 'custom_mode_response',
+      manufacturerId: MANUFACTURER_ID,
+      slot,
+      controls,
+      colors,
+      data,
+    };
+  }
+
+  /**
+   * Parse custom mode data from raw bytes
+   * Updated to handle Launch Control XL 3 format (not Midimunge)
+   * Note: Device uses 0x48 in READ responses, 0x49 in WRITE commands
+   */
+  private static parseCustomModeData(data: number[]): {
+    controls: ControlMapping[];
+    colors: ColorMapping[];
+    name?: string;
+  } {
+    const controls: ControlMapping[] = [];
+    const colors: ColorMapping[] = [];
+    let modeName: string | undefined;
+
+    // Parse mode name - look for ASCII after header pattern
+    let nameStart = -1;
+    let nameEnd = -1;
+
+    // Look for the 0x06 0x20 0x08 or 0x00 0x20 0x08 header pattern first
+    for (let i = 0; i < data.length - 3; i++) {
+      if ((data[i] === 0x06 || data[i] === 0x00) && data[i + 1] === 0x20 && data[i + 2] === 0x08) {
+        nameStart = i + 3;
+        break;
+      }
+    }
+
+    if (nameStart > 0) {
+      const nameBytes = [];
+      for (let i = nameStart; i < data.length - 1; i++) {
+        // FIXED: Stop at explicit terminator 0x21 0x00 first
+        if (data[i] === 0x21 && data[i + 1] === 0x00) {
+          nameEnd = i;
+          break;
+        }
+
+        // Only break on control marker if we haven't found a name terminator
+        // and we're at least 8 bytes past the start (max mode name length)
+        if (data[i] === 0x48 && i >= nameStart + 8) {
+          // Double-check this is actually a control marker by validating structure
+          if (i + 9 < data.length &&
+              data[i + 2] === 0x02 && // Definition type
+              data[i + 1] !== undefined && data[i + 1]! <= 0x3F) {  // Valid control ID range
+            nameEnd = i;
+            break;
+          }
+        }
+
+        const byte = data[i];
+        if (byte !== undefined && byte >= 32 && byte <= 126) { // Printable ASCII
+          nameBytes.push(byte);
+        }
+      }
+
+      if (nameBytes.length > 0) {
+        modeName = String.fromCharCode(...nameBytes);
+      }
+    }
+
+    // Parse control definitions
+    // In READ responses: 0x48 [ID] 0x02 [TYPE] [CH] 0x01 0x48 [MIN] [CC] [MAX]
+    // In WRITE commands: 0x49 [ID] 0x02 [TYPE] [CH] 0x01 0x40 [MIN] [CC] [MAX] 0x00
+
+    // Find where controls actually start (after name and terminator)
+    let controlsStart = nameEnd > 0 ? nameEnd + 2 : 0; // Skip 0x21 0x00 after name
+
+    for (let i = controlsStart; i < data.length - 9; i++) {
+      // Handle both 0x48 (read) and 0x49 (write) markers
+      if (data[i] === 0x48 || data[i] === 0x49) {
+        if (i + 9 < data.length) {
+          const controlId = data[i + 1];
+          const defType = data[i + 2];
+          const _controlType = data[i + 3];
+          const channel = data[i + 4];
+          const param1 = data[i + 5];
+
+          // Validate it's a control structure (not part of name or other data)
+          const isValidControl = defType === 0x02 &&
+                                (param1 === 0x01 || param1 === 0x00) &&
+                                controlId !== undefined && controlId <= 0x3F; // Valid control ID range
+
+          if (isValidControl && controlId !== undefined) {
+            const minValue = data[i + 7];
+            const ccNumber = data[i + 8];
+            const maxValue = data[i + 9];
+
+            // Ensure all required values are defined
+            if (minValue !== undefined && ccNumber !== undefined && maxValue !== undefined &&
+                channel !== undefined && _controlType !== undefined) {
+              // Determine control behavior
+              let behaviour = 'absolute';
+
+              controls.push({
+                controlId,
+                channel,
+                ccNumber,
+                minValue,
+                maxValue,
+                behaviour: behaviour as any,
+              });
+
+              // Create color mapping based on control ID
+              let color = 0x3F; // Default
+              if (controlId >= 0x10 && controlId <= 0x17) {
+                color = 0x60; // Blue for top row encoders
+              } else if (controlId >= 0x18 && controlId <= 0x1F) {
+                color = 0x48; // Yellow for middle row encoders
+              } else if (controlId >= 0x20 && controlId <= 0x27) {
+                color = 0x3C; // Green for bottom row encoders
+              } else if (controlId >= 0x28 && controlId <= 0x3F) {
+                color = 0x0F; // Red for buttons/other controls
+              } else if (controlId <= 0x07) {
+                color = 0x0F; // Red for faders
+              }
+
+              colors.push({
+                controlId,
+                color,
+                behaviour: 'static', // Default behavior
+              });
+            }
+
+            // Skip to next potential control (9 bytes processed)
+            i += 9;
+          }
+        }
+      }
+    }
+
+    const result: { controls: ControlMapping[]; colors: ColorMapping[]; name?: string } = {
+      controls,
+      colors
+    };
+
+    if (modeName !== undefined) {
+      result.name = modeName;
+    }
+
+    return result;
+  }
+
+  /**
+   * Build device inquiry request
+   * @deprecated Use the complete handshake sequence with buildNovationSyn()
+   * and buildUniversalDeviceInquiry() instead. This method only performs
+   * partial handshake and uses incorrect device ID.
+   */
+  static buildDeviceQuery(): number[] {
+    return [
+      0xF0, // SysEx start
+      0x7E, // Universal non-realtime
+      0x00, // Device ID (broadcast)
+      0x06, // General information
+      0x01, // Identity request
+      0xF7, // SysEx end
+    ];
+  }
+
+  /**
+   * Build Novation SYN message for complete handshake sequence
+   *
+   * This is the first message in the 4-message handshake protocol.
+   * The device will respond with a SYN-ACK containing its serial number.
+   *
+   * Message format: F0 00 20 29 00 42 02 F7 (8 bytes)
+   *
+   * @returns {number[]} SysEx message bytes for Novation SYN request
+   */
+  static buildNovationSyn(): number[] {
+    return [
+      0xF0,              // SysEx start
+      0x00, 0x20, 0x29,  // Novation manufacturer ID
+      0x00,              // Device model (Launch Control)
+      0x42,              // Command (handshake)
+      0x02,              // Sub-command (SYN)
+      0xF7               // SysEx end
+    ];
+  }
+
+  /**
+   * Build Universal Device Inquiry message with correct device ID
+   *
+   * This is the third message in the 4-message handshake protocol (ACK).
+   * Uses the correct broadcast device ID (0x7F) instead of 0x00.
+   *
+   * Message format: F0 7E 7F 06 01 F7 (6 bytes)
+   *
+   * @returns {number[]} SysEx message bytes for Universal Device Inquiry
+   */
+  static buildUniversalDeviceInquiry(): number[] {
+    return [
+      0xF0,              // SysEx start
+      0x7E,              // Universal Non-Realtime
+      0x7F,              // Device ID (broadcast)
+      0x06,              // Sub-ID 1 (Device Inquiry)
+      0x01,              // Sub-ID 2 (Inquiry Request)
+      0xF7               // SysEx end
+    ];
+  }
+
+  /**
+   * Parse Novation SYN-ACK response and extract serial number
+   *
+   * This parses the second message in the 4-message handshake protocol.
+   * The SYN-ACK response contains the device's serial number.
+   *
+   * Expected format: F0 00 20 29 00 42 02 [SERIAL_NUMBER] F7 (22 bytes)
+   * Serial number is 14 ASCII characters at bytes 7-20.
+   *
+   * @param {number[]} data - Raw SysEx message bytes including F0/F7
+   * @returns {object} Parsing result with validity flag and optional serial number
+   * @returns {boolean} returns.valid - True if message is valid SYN-ACK
+   * @returns {string} [returns.serialNumber] - Device serial number if valid
+   */
+  static parseNovationSynAck(data: number[]): { valid: boolean; serialNumber?: string } {
+    // Validate message length (should be exactly 22 bytes)
+    if (data.length !== 22) {
+      return { valid: false };
+    }
+
+    // Validate SysEx start and end bytes
+    if (data[0] !== 0xF0 || data[data.length - 1] !== 0xF7) {
+      return { valid: false };
+    }
+
+    // Verify Novation manufacturer ID (bytes 1-3)
+    if (data[1] !== 0x00 || data[2] !== 0x20 || data[3] !== 0x29) {
+      return { valid: false };
+    }
+
+    // Verify command bytes (bytes 4-6)
+    if (data[4] !== 0x00 || data[5] !== 0x42 || data[6] !== 0x02) {
+      return { valid: false };
+    }
+
+    // Extract serial number (bytes 7-20, 14 characters)
+    const serialBytes = data.slice(7, 21);
+
+    // Validate that all serial bytes are printable ASCII
+    for (const byte of serialBytes) {
+      if (byte < 32 || byte > 126) {
+        return { valid: false };
+      }
+    }
+
+    const serialNumber = String.fromCharCode(...serialBytes);
+
+    // Basic validation of Launch Control XL3 serial number format
+    // Should start with "LX2" followed by digits
+    if (!serialNumber.startsWith('LX2') || serialNumber.length !== 14) {
+      return { valid: false };
+    }
+
+    return { valid: true, serialNumber };
+  }
+
+  /**
+   * Build template change message
+   */
+  static buildTemplateChange(templateNumber: number): number[] {
+    if (templateNumber < 0 || templateNumber > 15) {
+      throw new Error('Template number must be 0-15');
+    }
+
+    return [
+      0xF0, // SysEx start
+      ...MANUFACTURER_ID,
+      0x11, // Device ID (Launch Control XL)
+      SysExMessageType.TEMPLATE_CHANGE,
+      templateNumber,
+      0xF7, // SysEx end
+    ];
+  }
+
+  /**
+   * Build custom mode read request
+   */
+  static buildCustomModeReadRequest(slot: number): number[] {
+    if (slot < 0 || slot > 15) {
+      throw new Error('Custom mode slot must be 0-15');
+    }
+
+    // CORRECTED PROTOCOL: Based on working MIDI capture from web editor
+    // Format: F0 00 20 29 02 15 05 00 40 [SLOT] 00 F7
+    return [
+      0xF0,             // SysEx start
+      0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+      0x02,             // Device ID (Launch Control XL 3)
+      0x15,             // Command (Custom mode)
+      0x05,             // Sub-command
+      0x00,             // Reserved
+      0x40,             // Read operation (CORRECTED from 0x15)
+      slot,             // Slot number (0-14 for slots 1-15)
+      0x00,             // Parameter (CORRECTED from nothing)
+      0xF7              // SysEx end
+    ];
+  }
+
+  /**
+   * Build custom mode write message from CustomMode object
+   */
+  static buildCustomModeWriteMessage(slot: number, customMode: CustomMode): number[] {
+    if (slot < 0 || slot > 15) {
+      throw new Error('Custom mode slot must be 0-15');
+    }
+
+    const rawData: number[] = [];
+
+    // Header: Mode data format indicator
+    rawData.push(0x00, 0x20, 0x08);
+
+    // Mode name: Direct ASCII encoding (max 8 chars)
+    const nameBytes = customMode.name.substring(0, 8);
+    for (let i = 0; i < nameBytes.length; i++) {
+      rawData.push(nameBytes.charCodeAt(i));
+    }
+
+    // Sort controls by ID for consistency
+    const sortedControls = Object.values(customMode.controls)
+      .filter(control => control.controlId !== undefined)
+      .sort((a, b) => (a.controlId ?? 0) - (b.controlId ?? 0));
+
+    // Add control definitions with 0x49 marker and offset
+    for (const control of sortedControls) {
+      // Write control structure: 11 bytes
+      rawData.push(0x49); // Write control marker
+      rawData.push((control.controlId ?? 0) + 0x28); // Control ID with offset
+      rawData.push(0x02); // Definition type
+      // Convert control type to number if it's a string
+      const controlType = control.controlType ?? control.type ?? 0x00;
+      const controlTypeNum = typeof controlType === 'string' ?
+        (controlType === 'knob' ? 0x05 : controlType === 'fader' ? 0x00 : controlType === 'button' ? 0x09 : 0x00) :
+        controlType;
+      rawData.push(controlTypeNum); // Control type
+      rawData.push(control.midiChannel ?? control.channel ?? 0); // MIDI channel (0-15)
+      rawData.push(0x01); // Parameter 1
+      rawData.push(0x40); // Parameter 2
+      rawData.push(0x00); // Min value (always 0 in write)
+      rawData.push(control.ccNumber ?? control.cc ?? 0); // CC number
+      rawData.push(0x7F); // Max value (always 0x7F in write)
+      rawData.push(0x00); // Terminator
+    }
+
+    // Add label data if present
+    if (customMode.labels && customMode.labels.size > 0) {
+      for (const [controlId, label] of customMode.labels) {
+        rawData.push(0x69); // Label marker
+        rawData.push(controlId + 0x28); // Control ID with offset
+        // Add label text
+        for (let i = 0; i < label.length; i++) {
+          rawData.push(label.charCodeAt(i));
+        }
+      }
+    } else {
+      // Generate default labels for controls
+      for (const control of sortedControls) {
+        const controlId = control.controlId ?? 0;
+        rawData.push(0x69); // Label marker
+        rawData.push(controlId + 0x28); // Control ID with offset
+        const label = this.generateControlLabel(controlId);
+        for (let i = 0; i < label.length; i++) {
+          rawData.push(label.charCodeAt(i));
+        }
+      }
+    }
+
+    // Add color data if present
+    if (customMode.colors && customMode.colors.size > 0) {
+      for (const [controlId, color] of customMode.colors) {
+        rawData.push(0x60); // Color marker
+        rawData.push(controlId + 0x28); // Control ID with offset
+        rawData.push(color); // Color value
+      }
+    } else {
+      // Add default colors (off) for all controls
+      for (const control of sortedControls) {
+        const controlId = control.controlId ?? 0;
+        rawData.push(0x60); // Color marker
+        rawData.push(controlId + 0x28); // Control ID with offset
+      }
+    }
+
+    // Build complete message
+    return [
+      0xF0,             // SysEx start
+      0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+      0x02,             // Device ID (Launch Control XL 3)
+      0x15,             // Command (Custom mode)
+      0x05,             // Sub-command
+      0x00,             // Reserved
+      0x45,             // Write operation
+      slot,             // Slot number
+      ...rawData,       // Custom mode data
+      0xF7              // SysEx end
+    ];
+  }
+
+  /**
+   * Build custom mode write request
+   */
+  static buildCustomModeWriteRequest(slot: number, modeData: CustomModeMessage): number[] {
+    if (slot < 0 || slot > 15) {
+      throw new Error('Custom mode slot must be 0-15');
+    }
+
+    // Validate the custom mode data
+    this.validateCustomModeData(modeData);
+
+    // Encode the custom mode data
+    const encodedData = this.encodeCustomModeData(modeData);
+
+    // CORRECTED PROTOCOL: Based on Launch Control XL 3 format
+    // Format: F0 00 20 29 02 15 05 00 45 [SLOT] [encoded data] F7
+    return [
+      0xF0,             // SysEx start
+      0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+      0x02,             // Device ID (Launch Control XL 3)
+      0x15,             // Command (Custom mode)
+      0x05,             // Sub-command
+      0x00,             // Reserved
+      0x45,             // Write operation (assumed based on pattern)
+      slot,             // Slot number (0-14 for slots 1-15)
+      ...encodedData,   // Encoded custom mode data
+      0xF7              // SysEx end
+    ];
+  }
+
+  /**
+   * Validate custom mode data
+   */
+  static validateCustomModeData(modeData: CustomModeMessage): void {
+    if (!modeData.controls || !Array.isArray(modeData.controls)) {
+      throw new Error('Custom mode must have controls array');
+    }
+
+    if (!modeData.colors || !Array.isArray(modeData.colors)) {
+      throw new Error('Custom mode must have colors array');
+    }
+
+    // Validate each control mapping
+    for (const control of modeData.controls) {
+      const ccNumber = control.ccNumber ?? control.cc ?? 0;
+      if (ccNumber < 0 || ccNumber > 127) {
+        throw new Error('CC number must be 0-127');
+      }
+
+      const channel = control.channel ?? control.midiChannel ?? 0;
+      if (channel < 0 || channel > 15) {
+        throw new Error('Channel must be 0-15');
+      }
+
+      const minValue = control.minValue ?? control.min ?? 0;
+      if (minValue < 0 || minValue > 127) {
+        throw new Error('Min value must be 0-127');
+      }
+
+      const maxValue = control.maxValue ?? control.max ?? 127;
+      if (maxValue < 0 || maxValue > 127) {
+        throw new Error('Max value must be 0-127');
+      }
+
+      if (minValue > maxValue) {
+        throw new Error('Min value cannot be greater than max value');
+      }
+    }
+
+    // Validate each color mapping
+    for (const color of modeData.colors) {
+      if (color.color < 0 || color.color > 127) {
+        throw new Error('Color value must be 0-127');
+      }
+    }
+  }
+
+  /**
+   * Encode custom mode data for Launch Control XL 3 transmission
+   * Based on actual web editor protocol analysis
+   */
+  private static encodeCustomModeData(modeData: CustomModeMessage): number[] {
+    const rawData: number[] = [];
+
+    // Header: Mode data format indicator
+    rawData.push(0x00, 0x20, 0x08);
+
+    // Mode name: Direct ASCII encoding (not Midimunge!)
+    if (modeData.name) {
+      for (let i = 0; i < modeData.name.length && i < 16; i++) {
+        rawData.push(modeData.name.charCodeAt(i));
+      }
+    }
+
+    // Add control definitions - must be in specific order for device to accept
+    // Sort controls by ID to ensure proper order
+    const sortedControls = [...modeData.controls]
+      .filter(control => control.controlId !== undefined)
+      .sort((a, b) => (a.controlId ?? 0) - (b.controlId ?? 0));
+
+    for (const control of sortedControls) {
+      // Control format from web editor for WRITE operation:
+      // Faders: 0x49 [ID] 0x02 0x00 [CH] 0x01 0x40 0x00 [CC] 0x7F 0x00
+      // Top encoders: 0x49 [ID] 0x02 0x05 [CH] 0x01 0x40 0x00 [CC] 0x7F 0x00
+      // Mid encoders: 0x49 [ID] 0x02 0x09 [CH] 0x01 0x40 0x00 [CC] 0x7F 0x00
+      // Bot encoders: 0x49 [ID] 0x02 0x0D [CH] 0x01 0x40 0x00 [CC] 0x7F 0x00
+
+      const controlId = control.controlId ?? 0;
+      const channel = control.channel ?? control.midiChannel ?? 0;
+      const ccNumber = control.ccNumber ?? control.cc ?? 0;
+
+      rawData.push(0x49); // Control marker for WRITE
+      rawData.push(controlId + 0x28); // IMPORTANT: Add 0x28 offset for controls!
+      rawData.push(0x02); // Control definition type
+
+      // Control type based on hardware position
+      let controlType = 0x00;
+      if (controlId >= 0x10 && controlId <= 0x17) {
+        controlType = 0x05; // Top row encoders
+      } else if (controlId >= 0x18 && controlId <= 0x1F) {
+        controlType = 0x09; // Middle row encoders
+      } else if (controlId >= 0x20 && controlId <= 0x27) {
+        controlType = 0x0D; // Bottom row encoders
+      } else if (controlId >= 0x00 && controlId <= 0x07) {
+        controlType = 0x00; // Faders
+      }
+
+      rawData.push(controlType);
+      rawData.push(channel); // Channel (0-based)
+      rawData.push(0x01); // Parameter 1
+      rawData.push(0x40); // Parameter 2 (behavior)
+      rawData.push(0x00); // Min value (always 0x00 in write)
+      rawData.push(ccNumber); // CC number
+      rawData.push(0x7F); // Max value (always 0x7F in write)
+      rawData.push(0x00); // Terminator
+    }
+
+    // CRITICAL: Add label/color data after controls - REQUIRED by device!
+    // Without this section, the device rejects the message
+
+    // Add label data for each control (recommended for usability)
+    for (const control of sortedControls) {
+      const controlId = control.controlId ?? 0;
+      rawData.push(0x69); // Label marker
+      rawData.push(controlId + 0x28); // Control ID with offset
+
+      // Add a simple label based on control type and ID
+      const labelText = this.generateControlLabel(controlId);
+      for (let i = 0; i < labelText.length; i++) {
+        rawData.push(labelText.charCodeAt(i));
+      }
+    }
+
+    // Add color data for each control (required for device acceptance)
+    for (const control of sortedControls) {
+      const controlId = control.controlId ?? 0;
+      rawData.push(0x60); // Color marker
+      rawData.push(controlId + 0x28); // Control ID with offset
+    }
+
+    return rawData;
+  }
+
+
+  /**
+   * Generate a simple label for a control based on its ID and type
+   */
+  private static generateControlLabel(controlId: number): string {
+    if (controlId >= 0x00 && controlId <= 0x07) {
+      return `Fader ${controlId + 1}`;
+    } else if (controlId >= 0x10 && controlId <= 0x17) {
+      return `Top ${controlId - 0x10 + 1}`;
+    } else if (controlId >= 0x18 && controlId <= 0x1F) {
+      return `Mid ${controlId - 0x18 + 1}`;
+    } else if (controlId >= 0x20 && controlId <= 0x27) {
+      return `Bot ${controlId - 0x20 + 1}`;
+    } else if (controlId >= 0x28 && controlId <= 0x3F) {
+      return `Btn ${controlId - 0x28 + 1}`;
+    } else {
+      return `Ctrl ${controlId}`;
+    }
+  }
+
+  /**
+   * Build LED control message
+   */
+  static buildLedControl(controlId: number, color: number, behaviour: 'static' | 'flash' | 'pulse' | 'flashing' | 'pulsing' = 'static'): number[] {
+    if (controlId < 0 || controlId > 127) {
+      throw new Error('Control ID must be 0-127');
+    }
+
+    if (color < 0 || color > 127) {
+      throw new Error('Color must be 0-127');
+    }
+
+    let behaviorByte = color;
+
+    if (behaviour === 'flash' || behaviour === 'flashing') {
+      behaviorByte |= 0x08;
+    } else if (behaviour === 'pulse' || behaviour === 'pulsing') {
+      behaviorByte |= 0x10;
+    }
+
+    return [
+      0xF0, // SysEx start
+      ...MANUFACTURER_ID,
+      0x11, // Device ID
+      SysExMessageType.LED_CONTROL,
+      controlId,
+      behaviorByte,
+      0xF7, // SysEx end
+    ];
+  }
+
+  /**
+   * Build LED reset message
+   */
+  static buildLedReset(): number[] {
+    return [
+      0xF0, // SysEx start
+      ...MANUFACTURER_ID,
+      0x11, // Device ID
+      SysExMessageType.RESET_LED,
+      0x00, // Reset all LEDs
+      0xF7, // SysEx end
+    ];
+  }
+
+  /**
+   * Check if SysEx message is a device inquiry response
+   *
+   * This validates the fourth message in the 4-message handshake protocol.
+   * Device inquiry responses follow the Universal Non-Realtime format.
+   *
+   * Expected format: F0 7E [device_id] 06 02 [manufacturer_id] [device_info] F7
+   *
+   * @param {number[]} data - Raw SysEx message bytes including F0/F7
+   * @returns {boolean} True if message is a valid device inquiry response
+   */
+  static isDeviceInquiryResponse(data: number[]): boolean {
+    // Minimum length check (F0 7E XX 06 02 + at least 3 bytes manufacturer ID + F7)
+    if (data.length < 9) {
+      return false;
+    }
+
+    // Validate SysEx start and end bytes
+    if (data[0] !== 0xF0 || data[data.length - 1] !== 0xF7) {
+      return false;
+    }
+
+    // Check Universal Non-Realtime header
+    if (data[1] !== 0x7E) {
+      return false;
+    }
+
+    // Device ID can be any value (data[2])
+
+    // Check Sub-ID1 (General Information)
+    if (data[3] !== 0x06) {
+      return false;
+    }
+
+    // Check Sub-ID2 (Identity Reply)
+    if (data[4] !== 0x02) {
+      return false;
+    }
+
+    // Must have at least manufacturer ID (3 bytes minimum)
+    if (data.length < 9) {
+      return false;
+    }
+
+    return true;
+  }
+
+  /**
+   * Check if data is a valid SysEx message
+   */
+  static isValidSysEx(data: number[]): boolean {
+    if (data.length < 3) {
+      return false;
+    }
+
+    return data[0] === 0xF0 && data[data.length - 1] === 0xF7;
+  }
+
+  /**
+   * Extract manufacturer ID from SysEx message
+   */
+  static getManufacturerId(data: number[]): number[] | null {
+    if (!this.isValidSysEx(data)) {
+      return null;
+    }
+
+    // Universal messages don't have manufacturer ID
+    const manufacturerByte = data[1];
+    if (manufacturerByte === undefined) {
+      return null;
+    }
+
+    if (manufacturerByte === 0x7E || manufacturerByte === 0x7F) {
+      return null;
+    }
+
+    // Extract 3-byte manufacturer ID
+    if (manufacturerByte === 0x00) {
+      return data.slice(1, 4);
+    }
+
+    // Single byte manufacturer ID
+    return [manufacturerByte];
+  }
+}
+
+export default SysExParser;
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/backends/EasyMidiBackend.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/backends/EasyMidiBackend.ts
new file mode 100644
index 0000000..009dc98
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/backends/EasyMidiBackend.ts
@@ -0,0 +1,204 @@
+import type {
+  MidiBackendInterface,
+  MidiPortInfo,
+  MidiInputPort,
+  MidiOutputPort,
+  MidiPort,
+  MidiMessage,
+} from '@/core/MidiInterface.js';
+import type { Logger } from '@/core/Logger.js';
+import { ConsoleLogger } from '@/core/Logger.js';
+
+import { ControlChange, getInputs, getOutputs, Input, Note, Output, Sysex } from 'easymidi';
+
+export class EasyMidiBackend implements MidiBackendInterface {
+  private inputs: Map<string, Input> = new Map();
+  private outputs: Map<string, Output> = new Map();
+  private portWrappers: Map<string, MidiPort> = new Map();
+  private isInitialized = false;
+  private readonly logger: Logger;
+
+  constructor(logger: Logger = new ConsoleLogger({ prefix: 'EasyMidiBackend' })) {
+    this.logger = logger;
+  }
+
+  async initialize(): Promise<void> {
+    this.logger.info(`Initializing!`)
+    this.isInitialized = true;
+    return Promise.resolve();
+  }
+
+  getInputPorts(): Promise<MidiPortInfo[]> {
+
+    if (!this.isInitialized) {
+      throw new Error('Backend not initialized');
+    }
+
+    try {
+      const inputs = getInputs();
+      return Promise.resolve(inputs.map((name: string) => ({
+        id: name,
+        name: name,
+      })));
+    } catch (error) {
+      return Promise.reject(new Error(`Failed to get input ports: ${(error as Error).message}`));
+    }
+  }
+
+  getOutputPorts(): Promise<MidiPortInfo[]> {
+
+    try {
+      const outputs = getOutputs();
+      return Promise.resolve(outputs.map((name: string) => ({
+        id: name,
+        name: name,
+      })));
+    } catch (error) {
+      return Promise.reject(new Error(`Failed to get output ports: ${(error as Error).message}`));
+    }
+  }
+
+  openInput(portId: string): Promise<MidiInputPort> {
+    try {
+      const easyInput = new Input(portId);
+      this.logger.info(`Opening input: ${easyInput.name}`);
+      const port: MidiInputPort = {
+        id: portId,
+        name: portId,
+        type: 'input',
+        close: () => {
+          if (easyInput && easyInput.close) {
+            easyInput.close();
+          }
+          this.inputs.delete(portId);
+          this.portWrappers.delete(portId);
+          return Promise.resolve();
+        },
+        onMessage: undefined,
+      };
+
+      easyInput.on('sysex', (sysex: Sysex) => {
+        this.logger.debug(
+          'Received SysEx:',
+          sysex.bytes.map((b) => '0x' + b.toString(16).padStart(2, '0')).join(' '),
+        );
+        if (port.onMessage) {
+          port.onMessage({
+            timestamp: Date.now(),
+            data: sysex.bytes,
+          });
+        }
+      });
+
+      easyInput.on('cc', (msg: ControlChange) => {
+        this.logger.debug('Received CC:', msg);
+        if (port.onMessage) {
+          const data = [0xb0 | (msg.channel & 0x0f), msg.controller, msg.value];
+          port.onMessage({
+            timestamp: Date.now(),
+            data,
+          });
+        }
+      });
+
+      easyInput.on('noteon', (msg: Note) => {
+        if (port.onMessage) {
+          const data = [0x90 | (msg.channel & 0x0f), msg.note, msg.velocity];
+          port.onMessage({
+            timestamp: Date.now(),
+            data,
+          });
+        }
+      });
+
+      easyInput.on('noteoff', (msg: Note) => {
+        if (port.onMessage) {
+          const data = [0x80 | (msg.channel & 0x0f), msg.note, msg.velocity];
+          port.onMessage({
+            timestamp: Date.now(),
+            data,
+          });
+        }
+      });
+
+      this.inputs.set(portId, easyInput);
+      this.portWrappers.set(portId, port);
+      return Promise.resolve(port);
+    } catch (error) {
+      return Promise.reject(new Error(`Failed to open input port ${portId}: ${(error as Error).message}`));
+    }
+  }
+
+  openOutput(portId: string): Promise<MidiOutputPort> {
+    if (!this.isInitialized) {
+      throw new Error('Backend not initialized');
+    }
+
+    try {
+      const easyOutput = new Output(portId);
+
+      const port: MidiOutputPort = {
+        id: portId,
+        name: portId,
+        type: 'output',
+        close: () => {
+          if (easyOutput && easyOutput.close) {
+            easyOutput.close();
+          }
+          this.outputs.delete(portId);
+          this.portWrappers.delete(portId);
+          return Promise.resolve();
+        },
+      };
+
+      this.outputs.set(portId, easyOutput);
+      this.portWrappers.set(portId, port);
+      return Promise.resolve(port);
+    } catch (error) {
+      return Promise.reject(new Error(`Failed to open output port ${portId}: ${(error as Error).message}`));
+    }
+  }
+
+  sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
+    const easyOutput = this.outputs.get(port.id);
+    if (!easyOutput) {
+      throw new Error(`Output port not open: ${port.id}`);
+    }
+
+    try {
+      const data: Array<number> = Array.from(message.data);
+
+      if (data[0] === 0xf0 && data[data.length - 1] === 0xf7) {
+        this.logger.debug(
+          'Sending SysEx:',
+          data.map((b) => '0x' + b.toString(16).padStart(2, '0')).join(' '),
+        );
+        easyOutput.send('sysex', data);
+        return Promise.resolve();
+      } else {
+        return Promise.reject(new Error('Only SysEx messages are currently supported by EasyMidiBackend'));
+      }
+    } catch (error) {
+      return Promise.reject(new Error(`Failed to send message to port ${port.id}: ${(error as Error).message}`));
+    }
+  }
+
+  async closePort(port: MidiPort): Promise<void> {
+    await port.close();
+  }
+
+  async cleanup(): Promise<void> {
+    const closePromises: Promise<void>[] = [];
+
+    for (const [_id, wrapper] of this.portWrappers.entries()) {
+      closePromises.push(wrapper.close());
+    }
+
+    await Promise.all(closePromises);
+
+    this.inputs.clear();
+    this.outputs.clear();
+    this.portWrappers.clear();
+    this.isInitialized = false;
+  }
+}
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/core/backends/WebMidiBackend.ts b/modules/audio-control/modules/launch-control-xl3/package/src/core/backends/WebMidiBackend.ts
new file mode 100644
index 0000000..fa372de
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/core/backends/WebMidiBackend.ts
@@ -0,0 +1,267 @@
+/**
+ * Web MIDI API backend for browser environments
+ *
+ * Implements MIDI interface using the Web MIDI API for browser-based applications.
+ * Requires HTTPS in production environments and explicit SysEx permission.
+ */
+
+import type {
+  MidiBackendInterface,
+  MidiPortInfo,
+  MidiInputPort,
+  MidiOutputPort,
+  MidiPort,
+  MidiMessage
+} from '@/core/MidiInterface.js';
+
+/**
+ * WebMidiBackend implementation using Web MIDI API
+ */
+export class WebMidiBackend implements MidiBackendInterface {
+  private midiAccess?: MIDIAccess;
+  private openInputs: Map<string, MIDIInput> = new Map();
+  private openOutputs: Map<string, MIDIOutput> = new Map();
+  private portWrappers: Map<string, MidiInputPort | MidiOutputPort> = new Map();
+  private isInitialized = false;
+
+  async initialize(): Promise<void> {
+    if (this.isInitialized) return;
+
+    // Check if Web MIDI API is available
+    if (typeof navigator === 'undefined' || !navigator.requestMIDIAccess) {
+      throw new Error('Web MIDI API not available. Requires modern browser with MIDI support and HTTPS.');
+    }
+
+    try {
+      // Request MIDI access with SysEx permission (critical for custom modes)
+      this.midiAccess = await navigator.requestMIDIAccess({ sysex: true });
+
+      // Set up connection state change handler
+      this.midiAccess.onstatechange = (event) => {
+        if (event.port) {
+          console.debug('MIDI port state changed:', event.port.name, event.port.state);
+        }
+      };
+
+      this.isInitialized = true;
+    } catch (error: any) {
+      if (error.name === 'SecurityError') {
+        throw new Error('MIDI access denied. Web MIDI requires user permission and HTTPS in production.');
+      } else if (error.name === 'NotSupportedError') {
+        throw new Error('Web MIDI API not supported in this browser.');
+      } else {
+        throw new Error(`Failed to initialize Web MIDI API: ${error.message}`);
+      }
+    }
+  }
+
+  async getInputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    const ports: MidiPortInfo[] = [];
+    this.midiAccess.inputs.forEach((port, id) => {
+      ports.push({
+        id,
+        name: port.name || `Input ${id}`,
+        ...(port.manufacturer && { manufacturer: port.manufacturer }),
+        ...(port.version && { version: port.version })
+      });
+    });
+
+    return ports;
+  }
+
+  async getOutputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    const ports: MidiPortInfo[] = [];
+    this.midiAccess.outputs.forEach((port, id) => {
+      ports.push({
+        id,
+        name: port.name || `Output ${id}`,
+        ...(port.manufacturer && { manufacturer: port.manufacturer }),
+        ...(port.version && { version: port.version })
+      });
+    });
+
+    return ports;
+  }
+
+  async openInput(portId: string): Promise<MidiInputPort> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    let midiInput: MIDIInput | undefined;
+    this.midiAccess.inputs.forEach((input, id) => {
+      if (id === portId) {
+        midiInput = input;
+      }
+    });
+
+    if (!midiInput) {
+      throw new Error(`Input port not found: ${portId}`);
+    }
+
+    try {
+      // Open the Web MIDI port
+      await midiInput.open();
+
+      const port: MidiInputPort = {
+        id: portId,
+        name: midiInput.name || `Input ${portId}`,
+        type: 'input',
+        close: async () => {
+          await this.closeWebMidiPort(midiInput!);
+          this.openInputs.delete(portId);
+          this.portWrappers.delete(portId);
+        },
+        onMessage: undefined
+      };
+
+      // Set up message handler
+      midiInput.onmidimessage = (event: any) => {
+        if (port.onMessage) {
+          // Convert Uint8Array to number array
+          const data: number[] = Array.from(event.data as Uint8Array);
+          port.onMessage({
+            timestamp: event.timeStamp,
+            data
+          });
+        }
+      };
+
+      this.openInputs.set(portId, midiInput);
+      this.portWrappers.set(portId, port);
+
+      return port;
+    } catch (error: any) {
+      throw new Error(`Failed to open input port ${portId}: ${error.message}`);
+    }
+  }
+
+  async openOutput(portId: string): Promise<MidiOutputPort> {
+    if (!this.isInitialized || !this.midiAccess) {
+      throw new Error('Backend not initialized');
+    }
+
+    let midiOutput: MIDIOutput | undefined;
+    this.midiAccess.outputs.forEach((output, id) => {
+      if (id === portId) {
+        midiOutput = output;
+      }
+    });
+
+    if (!midiOutput) {
+      throw new Error(`Output port not found: ${portId}`);
+    }
+
+    try {
+      // Open the Web MIDI port
+      await midiOutput.open();
+
+      const port: MidiOutputPort = {
+        id: portId,
+        name: midiOutput.name || `Output ${portId}`,
+        type: 'output',
+        close: async () => {
+          await this.closeWebMidiPort(midiOutput!);
+          this.openOutputs.delete(portId);
+          this.portWrappers.delete(portId);
+        }
+      };
+
+      this.openOutputs.set(portId, midiOutput);
+      this.portWrappers.set(portId, port);
+
+      return port;
+    } catch (error: any) {
+      throw new Error(`Failed to open output port ${portId}: ${error.message}`);
+    }
+  }
+
+  async sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
+    const midiOutput = this.openOutputs.get(port.id);
+    if (!midiOutput) {
+      throw new Error(`Output port not open: ${port.id}`);
+    }
+
+    try {
+      // Convert message data to array format expected by Web MIDI
+      const data: number[] = Array.isArray(message.data)
+        ? message.data as number[]
+        : Array.from(message.data);
+
+      // Send message immediately (no timestamp)
+      // Note: We don't pass message.timestamp because it uses Date.now()
+      // which is incompatible with Web MIDI's performance.now() timestamps.
+      // Web MIDI expects timestamps relative to page load, not Unix epoch.
+      midiOutput.send(data);
+    } catch (error: any) {
+      throw new Error(`Failed to send message to port ${port.id}: ${error.message}`);
+    }
+  }
+
+  async closePort(port: MidiPort): Promise<void> {
+    await port.close();
+  }
+
+  async cleanup(): Promise<void> {
+    // Close all open ports
+    const closePromises: Promise<void>[] = [];
+
+    for (const [_id, midiInput] of this.openInputs.entries()) {
+      closePromises.push(this.closeWebMidiPort(midiInput));
+    }
+
+    for (const [_id, midiOutput] of this.openOutputs.entries()) {
+      closePromises.push(this.closeWebMidiPort(midiOutput));
+    }
+
+    await Promise.all(closePromises);
+
+    // Clear all maps
+    this.openInputs.clear();
+    this.openOutputs.clear();
+    this.portWrappers.clear();
+
+    // Remove event handlers
+    if (this.midiAccess) {
+      this.midiAccess.onstatechange = null;
+    }
+
+    this.isInitialized = false;
+  }
+
+  /**
+   * Check if Web MIDI API is available in the current environment
+   */
+  static isAvailable(): boolean {
+    return typeof navigator !== 'undefined' &&
+           typeof navigator.requestMIDIAccess === 'function';
+  }
+
+  /**
+   * Check if SysEx is supported (requires permission)
+   */
+  isSysExEnabled(): boolean {
+    return this.midiAccess?.sysexEnabled || false;
+  }
+
+  /**
+   * Helper method to close Web MIDI ports with error handling
+   */
+  private async closeWebMidiPort(port: MIDIPort): Promise<void> {
+    try {
+      if (port.connection === 'open') {
+        await port.close();
+      }
+    } catch (error: any) {
+      console.warn(`Warning: Failed to close MIDI port ${port.name}: ${error.message}`);
+    }
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/device/DeviceManager.ts b/modules/audio-control/modules/launch-control-xl3/package/src/device/DeviceManager.ts
new file mode 100644
index 0000000..4f5cac0
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/device/DeviceManager.ts
@@ -0,0 +1,783 @@
+/**
+ * Device Manager for Novation Launch Control XL 3
+ *
+ * Handles device discovery, connection, initialization, and communication
+ * with the Launch Control XL 3 hardware via MIDI and SysEx.
+ */
+
+import { EventEmitter } from 'eventemitter3';
+import {
+  MidiInterface,
+  MidiPortInfo,
+  MidiMessage,
+  MidiBackendInterface
+} from '../core/MidiInterface.js';
+import { SysExParser } from '../core/SysExParser.js';
+import {
+  LaunchControlXL3Info,
+  DeviceMode,
+  DeviceConnectionState,
+  CustomMode,
+  DeviceInquiryResponse
+} from '../types/index.js';
+import { z } from 'zod';
+
+export interface DeviceManagerOptions {
+  midiBackend?: MidiBackendInterface | undefined;
+  autoConnect?: boolean;
+  deviceNameFilter?: string;
+  inquiryTimeout?: number;
+  retryAttempts?: number;
+  retryDelay?: number;
+}
+
+export interface DeviceStatus {
+  connected: boolean;
+  state: DeviceConnectionState;
+  deviceInfo?: LaunchControlXL3Info | undefined;
+  currentMode?: DeviceMode | undefined;
+  lastSeen?: Date;
+  error?: string;
+}
+
+export interface DeviceEvents {
+  'device:connected': (device: LaunchControlXL3Info) => void;
+  'device:disconnected': (reason?: string) => void;
+  'device:ready': (device: LaunchControlXL3Info) => void;
+  'device:error': (error: Error) => void;
+  'device:modeChanged': (mode: DeviceMode) => void;
+  'control:change': (control: string, value: number, channel?: number) => void;
+  'sysex:received': (message: number[]) => void;
+}
+
+/**
+ * Main device manager for Launch Control XL 3
+ */
+export class DeviceManager extends EventEmitter {
+  private midi: MidiInterface;
+  private options: Required<Omit<DeviceManagerOptions, 'midiBackend'>> & { midiBackend?: MidiBackendInterface | undefined };
+  private deviceInfo?: LaunchControlXL3Info | undefined;
+  private connectionState: DeviceConnectionState = 'disconnected';
+  private inputPortId?: string | undefined;
+  private outputPortId?: string | undefined;
+  private currentMode?: DeviceMode | undefined;
+  private inquiryTimer?: NodeJS.Timeout | undefined;
+  private reconnectTimer?: NodeJS.Timeout | undefined;
+  private isInitializing = false;
+
+  constructor(options: DeviceManagerOptions = {}) {
+    super();
+
+    this.options = {
+      midiBackend: options.midiBackend,
+      autoConnect: options.autoConnect ?? true,
+      deviceNameFilter: options.deviceNameFilter ?? 'Launch Control XL',
+      inquiryTimeout: options.inquiryTimeout ?? 5000,
+      retryAttempts: options.retryAttempts ?? 3,
+      retryDelay: options.retryDelay ?? 1000,
+    };
+
+    this.midi = new MidiInterface(this.options.midiBackend);
+    this.setupMidiHandlers();
+  }
+
+  /**
+   * Initialize the device manager and optionally connect to device
+   */
+  async initialize(): Promise<void> {
+    try {
+      await this.midi.initialize();
+
+      if (this.options.autoConnect) {
+        await this.connect();
+      }
+    } catch (error) {
+      this.handleError(error as Error);
+      throw error;
+    }
+  }
+
+  /**
+   * Connect to Launch Control XL 3 device
+   */
+  async connect(): Promise<void> {
+    if (this.connectionState === 'connected' || this.connectionState === 'connecting') {
+      return;
+    }
+
+    this.setConnectionState('connecting');
+    this.isInitializing = true;
+
+    try {
+      // Find device ports
+      const { inputPort, outputPort } = await this.findDevicePorts();
+
+      if (!inputPort || !outputPort) {
+        throw new Error('Launch Control XL 3 not found');
+      }
+
+      // Open ports
+      await this.midi.openInput(inputPort.id);
+      await this.midi.openOutput(outputPort.id);
+
+      this.inputPortId = inputPort.id;
+      this.outputPortId = outputPort.id;
+
+      // Query device identity using complete 4-message handshake (NO FALLBACK)
+      const deviceInfo = await this.queryDeviceIdentity();
+      if (deviceInfo) {
+        this.deviceInfo = this.parseDeviceInfo(deviceInfo);
+      } else {
+        throw new Error('Device inquiry returned null response. Device may not be compatible or may be in an invalid state.');
+      }
+
+      // Initialize device settings
+      await this.initializeDevice();
+
+      this.setConnectionState('connected');
+      this.emit('device:connected', this.deviceInfo);
+      this.emit('device:ready', this.deviceInfo);
+
+    } catch (error) {
+      this.setConnectionState('error');
+      await this.disconnect();
+      throw error;
+    } finally {
+      this.isInitializing = false;
+    }
+  }
+
+  /**
+   * Disconnect from device
+   */
+  async disconnect(reason?: string): Promise<void> {
+    this.clearTimers();
+
+    if (this.inputPortId) {
+      await this.midi.closeInput();
+      this.inputPortId = undefined;
+    }
+
+    if (this.outputPortId) {
+      await this.midi.closeOutput();
+      this.outputPortId = undefined;
+    }
+
+    if (this.connectionState !== 'disconnected') {
+      this.setConnectionState('disconnected');
+      this.emit('device:disconnected', reason);
+    }
+
+    this.deviceInfo = undefined;
+    this.currentMode = undefined;
+  }
+
+  /**
+   * Find Launch Control XL 3 ports
+   */
+  private async findDevicePorts(): Promise<{
+    inputPort?: MidiPortInfo | undefined;
+    outputPort?: MidiPortInfo | undefined;
+  }> {
+    const inputPorts = await this.midi.getInputPorts();
+    const outputPorts = await this.midi.getOutputPorts();
+
+    // For LCXL3, we need:
+    // - Input: "LCXL3 1 MIDI Out" (for receiving control changes from device)
+    // - Output: "LCXL3 1 MIDI In" (for sending SysEx/LED control to device)
+
+    // First try to find the specific ports we need
+    let inputPort = inputPorts.find(port =>
+      port.name === 'LCXL3 1 MIDI Out'
+    );
+
+    let outputPort = outputPorts.find(port =>
+      port.name === 'LCXL3 1 MIDI In'
+    );
+
+    // Fall back to filter-based search if specific ports not found
+    if (!inputPort) {
+      inputPort = inputPorts.find(port =>
+        port.name.includes(this.options.deviceNameFilter)
+      );
+    }
+
+    if (!outputPort) {
+      outputPort = outputPorts.find(port =>
+        port.name.includes(this.options.deviceNameFilter)
+      );
+    }
+
+    console.log('[DeviceManager] Found ports:', {
+      input: inputPort?.name,
+      output: outputPort?.name
+    });
+
+    return { inputPort, outputPort };
+  }
+
+  /**
+   * Query device identity using the complete 4-message handshake protocol
+   */
+  private async queryDeviceIdentity(): Promise<DeviceInquiryResponse | null> {
+    let serialNumber: string | undefined;
+
+    // Step 1: Send Novation SYN
+    console.log('[DeviceManager] Handshake Step 1: Sending Novation SYN...');
+    const synMessage = SysExParser.buildNovationSyn();
+    await this.sendSysEx(synMessage);
+
+    // Step 2: Wait for SYN-ACK response
+    try {
+      const synAckData = await this.waitForMessage(
+        (data) => {
+          const result = SysExParser.parseNovationSynAck(data);
+          return result.valid;
+        },
+        this.options.inquiryTimeout,
+        'SYN-ACK'
+      );
+
+      const synAckResult = SysExParser.parseNovationSynAck(synAckData);
+      serialNumber = synAckResult.serialNumber;
+      console.log('[DeviceManager] Handshake Step 2: Received SYN-ACK with serial:', serialNumber);
+    } catch (error) {
+      throw new Error(
+        `Handshake failed at SYN-ACK step: ${(error as Error).message}. ` +
+        'Device may not support complete handshake protocol.'
+      );
+    }
+
+    // Step 3: Send Universal Device Inquiry (ACK) with correct device ID
+    console.log('[DeviceManager] Handshake Step 3: Sending Universal Device Inquiry (ACK)...');
+    const ackMessage = SysExParser.buildUniversalDeviceInquiry();
+    await this.sendSysEx(ackMessage);
+
+    // Step 4: Wait for Device Response
+    try {
+      const deviceResponseData = await this.waitForMessage(
+        (data) => SysExParser.isDeviceInquiryResponse(data),
+        this.options.inquiryTimeout,
+        'Device Response'
+      );
+
+      console.log('[DeviceManager] Handshake Step 4: Received device response');
+      const parsed = SysExParser.parse(deviceResponseData);
+
+      if (parsed.type === 'device_inquiry_response') {
+        // Cast parsed to DeviceInquiryResponse from SysExParser
+        const parsedResponse = parsed as any; // Type from SysExParser
+
+        // Create response object for validation with type field
+        const response = {
+          type: 'device_inquiry_response' as const,
+          manufacturerId: parsedResponse.manufacturerId || [],
+          deviceFamily: parsedResponse.familyCode || 0,
+          deviceModel: parsedResponse.familyMember || 0,
+          firmwareVersion: parsedResponse.softwareRevision || [],
+          ...(serialNumber ? { serialNumber: serialNumber.split('').map(c => c.charCodeAt(0)) } : {}),
+          // Include optional properties if present
+          ...(parsedResponse.familyCode !== undefined ? { familyCode: parsedResponse.familyCode } : {}),
+          ...(parsedResponse.familyMember !== undefined ? { familyMember: parsedResponse.familyMember } : {}),
+          ...(parsedResponse.softwareRevision !== undefined ? { softwareRevision: parsedResponse.softwareRevision } : {}),
+        };
+        const validatedResponse = this.validateDeviceInquiryResponse(response);
+        return validatedResponse;
+      }
+
+      throw new Error('Invalid device response type');
+    } catch (error) {
+      throw new Error(
+        `Handshake failed at device response step: ${(error as Error).message}. ` +
+        'Troubleshooting steps: 1) Verify device is powered and connected, ' +
+        '2) Check MIDI cable/USB connection, 3) Ensure device firmware is up to date.'
+      );
+    }
+  }
+
+  /**
+   * Wait for a specific MIDI message with timeout
+   */
+  private async waitForMessage(
+    validator: (data: number[]) => boolean,
+    timeoutMs: number,
+    messageName: string
+  ): Promise<number[]> {
+    return new Promise((resolve, reject) => {
+      const timeout = setTimeout(() => {
+        this.midi.removeListener('sysex', handleResponse);
+        reject(new Error(`Handshake timeout waiting for ${messageName} after ${timeoutMs}ms`));
+      }, timeoutMs);
+
+      const handleResponse = (message: MidiMessage) => {
+        if (message.type === 'sysex' && validator([...message.data])) {
+          clearTimeout(timeout);
+          this.midi.removeListener('sysex', handleResponse);
+          resolve([...message.data]);
+        }
+      };
+
+      this.midi.on('sysex', handleResponse);
+    });
+  }
+
+  /**
+   * Parse device info from inquiry response
+   */
+  private parseDeviceInfo(response: DeviceInquiryResponse): LaunchControlXL3Info {
+    const validatedInfo = this.validateDeviceInfo({
+      manufacturerId: response.manufacturerId.map(b =>
+        b.toString(16).padStart(2, '0')
+      ).join(' '),
+      deviceFamily: response.familyCode ?? response.deviceFamily ?? 0,
+      modelNumber: response.familyMember ?? response.deviceModel ?? 0,
+      firmwareVersion: response.softwareRevision ?
+        `${response.softwareRevision[0]}.${response.softwareRevision[1]}.${response.softwareRevision[2]}.${response.softwareRevision[3]}` :
+        (response.firmwareVersion ? Array.from(response.firmwareVersion).join('.') : 'unknown'),
+      serialNumber: typeof response.serialNumber === 'string' ?
+        response.serialNumber :
+        (response.serialNumber ? Array.from(response.serialNumber).join('') : undefined),
+    });
+
+    return validatedInfo;
+  }
+
+  /**
+   * Initialize device after connection
+   */
+  private async initializeDevice(): Promise<void> {
+    // Additional initialization steps can be added here
+    // For example: loading custom modes, setting initial LED states, etc.
+
+    // Set initial mode to User mode
+    await this.selectTemplate(0);
+  }
+
+  /**
+   * Setup MIDI event handlers
+   */
+  private setupMidiHandlers(): void {
+    this.midi.on('controlchange', (message: MidiMessage) => {
+      if (!this.isInitializing && this.connectionState === 'connected') {
+        const control = this.getControlName(message.controller!, message.channel!);
+        this.emit('control:change', control, message.value!, message.channel);
+      }
+    });
+
+    this.midi.on('sysex', (message: MidiMessage) => {
+      if (!this.isInitializing && this.connectionState === 'connected') {
+        this.emit('sysex:received', message.data);
+        this.handleSysExMessage([...message.data]);
+      }
+    });
+
+    this.midi.on('error', (error: Error) => {
+      this.handleError(error);
+    });
+  }
+
+  /**
+   * Handle incoming SysEx messages
+   */
+  private handleSysExMessage(data: number[]): void {
+    try {
+      const parsed = SysExParser.parse(data);
+
+      switch (parsed.type) {
+        case 'template_change':
+          const templateChange = this.validateTemplateChangeResponse(parsed);
+          this.currentMode = {
+            type: 'template',
+            slot: templateChange.templateNumber,
+          };
+          this.emit('device:modeChanged', this.currentMode);
+          break;
+
+        // Add more SysEx message handlers as needed
+      }
+    } catch {
+      // Ignore unrecognized SysEx messages
+    }
+  }
+
+  /**
+   * Get human-readable control name
+   */
+  private getControlName(controller: number, _channel: number): string {
+    // Map CC numbers to control names based on Launch Control XL 3 layout
+    const controlMap: Record<number, string> = {
+      // Send A knobs
+      13: 'sendA1', 14: 'sendA2', 15: 'sendA3', 16: 'sendA4',
+      17: 'sendA5', 18: 'sendA6', 19: 'sendA7', 20: 'sendA8',
+
+      // Send B knobs
+      29: 'sendB1', 30: 'sendB2', 31: 'sendB3', 32: 'sendB4',
+      33: 'sendB5', 34: 'sendB6', 35: 'sendB7', 36: 'sendB8',
+
+      // Pan/Device knobs
+      49: 'pan1', 50: 'pan2', 51: 'pan3', 52: 'pan4',
+      53: 'pan5', 54: 'pan6', 55: 'pan7', 56: 'pan8',
+
+      // Faders
+      77: 'fader1', 78: 'fader2', 79: 'fader3', 80: 'fader4',
+      81: 'fader5', 82: 'fader6', 83: 'fader7', 84: 'fader8',
+    };
+
+    return controlMap[controller] || `cc${controller}`;
+  }
+
+  /**
+   * Set connection state
+   */
+  private setConnectionState(state: DeviceConnectionState): void {
+    this.connectionState = state;
+  }
+
+  /**
+   * Handle errors
+   */
+  private handleError(error: Error): void {
+    console.error('[DeviceManager] Error:', error.message);
+    this.emit('device:error', error);
+
+    if (this.connectionState === 'connected') {
+      this.attemptReconnect();
+    }
+  }
+
+  /**
+   * Attempt to reconnect after connection loss
+   */
+  private attemptReconnect(): void {
+    if (this.reconnectTimer) {
+      return;
+    }
+
+    let attempts = 0;
+
+    const tryReconnect = async () => {
+      if (attempts >= this.options.retryAttempts) {
+        this.clearTimers();
+        await this.disconnect('Max reconnection attempts reached');
+        return;
+      }
+
+      attempts++;
+
+      try {
+        await this.connect();
+        this.clearTimers();
+      } catch {
+        this.reconnectTimer = setTimeout(tryReconnect, this.options.retryDelay);
+      }
+    };
+
+    this.reconnectTimer = setTimeout(tryReconnect, this.options.retryDelay);
+  }
+
+  /**
+   * Clear all timers
+   */
+  private clearTimers(): void {
+    if (this.inquiryTimer) {
+      clearTimeout(this.inquiryTimer as NodeJS.Timeout);
+      this.inquiryTimer = undefined;
+    }
+
+    if (this.reconnectTimer) {
+      clearTimeout(this.reconnectTimer as NodeJS.Timeout);
+      this.reconnectTimer = undefined;
+    }
+  }
+
+  /**
+   * Send SysEx message to device
+   */
+  async sendSysEx(data: number[]): Promise<void> {
+    if (!this.outputPortId) {
+      throw new Error('Device not connected');
+    }
+
+    await this.midi.sendMessage(data);
+  }
+
+  /**
+   * Send CC message to device
+   */
+  async sendCC(controller: number, value: number, channel: number = 0): Promise<void> {
+    if (!this.outputPortId) {
+      throw new Error('Device not connected');
+    }
+
+    // Build CC message: status byte (0xB0 + channel), controller, value
+    const data = [0xB0 | (channel & 0x0F), controller, value];
+    await this.midi.sendMessage(data);
+  }
+
+  /**
+   * Select a template slot (0-15)
+   */
+  async selectTemplate(slot: number): Promise<void> {
+    if (slot < 0 || slot > 15) {
+      throw new Error('Template slot must be 0-15');
+    }
+
+    // Send template change message
+    const message = SysExParser.buildTemplateChange(slot);
+    await this.sendSysEx(message);
+
+    this.currentMode = {
+      type: 'template',
+      slot,
+    };
+
+    this.emit('device:modeChanged', this.currentMode);
+  }
+
+  /**
+   * Read custom mode from device
+   */
+  async readCustomMode(slot: number): Promise<CustomMode> {
+    if (slot < 0 || slot > 15) {
+      throw new Error('Custom mode slot must be 0-15');
+    }
+
+    return new Promise((resolve, reject) => {
+      const timeout = setTimeout(() => {
+        this.midi.removeListener('sysex', handleResponse);
+        reject(new Error(
+          `Custom mode read timeout after ${this.options.inquiryTimeout}ms for slot ${slot}. ` +
+          'The device may be unresponsive or the slot may be empty. ' +
+          'Troubleshooting steps: 1) Verify device connection, ' +
+          '2) Check if custom mode exists in the specified slot, ' +
+          '3) Try reading a different slot, 4) Power cycle the device.'
+        ));
+      }, this.options.inquiryTimeout);
+
+      const handleResponse = (message: MidiMessage) => {
+        if (message.type === 'sysex') {
+          try {
+            const parsed = SysExParser.parse([...message.data]);
+
+            if (parsed.type === 'custom_mode_response') {
+              clearTimeout(timeout);
+              this.midi.removeListener('sysex', handleResponse);
+
+              const response = this.validateCustomModeResponse(parsed);
+              resolve({
+                slot: response.slot ?? slot,
+                name: response.name || `Custom ${slot + 1}`,
+                controls: response.controls || {},
+                colors: response.colors || {},
+              });
+            }
+          } catch {
+            // Ignore parse errors
+          }
+        }
+      };
+
+      this.midi.on('sysex', handleResponse);
+
+      // Send custom mode read request
+      const message = SysExParser.buildCustomModeReadRequest(slot);
+      this.sendSysEx(message);
+    });
+  }
+
+  /**
+   * Write custom mode to device
+   */
+  async writeCustomMode(slot: number, mode: CustomMode): Promise<void> {
+    if (slot < 0 || slot > 15) {
+      throw new Error('Custom mode slot must be 0-15');
+    }
+
+    const modeData = {
+      slot,
+      name: mode.name,
+      controls: mode.controls,
+      colors: mode.colors,
+    };
+
+    const validatedModeData = this.validateCustomModeData(modeData);
+    const message = SysExParser.buildCustomModeWriteRequest(slot, validatedModeData);
+    await this.sendSysEx(message);
+  }
+
+  /**
+   * Get current device status
+   */
+  getStatus(): DeviceStatus {
+    const status: DeviceStatus = {
+      connected: this.connectionState === 'connected',
+      state: this.connectionState,
+      deviceInfo: this.deviceInfo,
+      currentMode: this.currentMode,
+    };
+
+    if (this.deviceInfo) {
+      status.lastSeen = new Date();
+    }
+
+    return status;
+  }
+
+
+  /**
+   * Validate device inquiry response with proper type checking
+   */
+  private validateDeviceInquiryResponse(response: unknown): DeviceInquiryResponse {
+    const schema = z.object({
+      type: z.literal('device_inquiry_response'),
+      manufacturerId: z.array(z.number().min(0).max(127)),
+      deviceFamily: z.number().optional(),
+      deviceModel: z.number().optional(),
+      familyCode: z.number().optional(),
+      familyMember: z.number().optional(),
+      firmwareVersion: z.array(z.number()).optional(),
+      softwareRevision: z.array(z.number()).optional(),
+      serialNumber: z.union([z.string(), z.array(z.number())]).optional(),
+    });
+
+    try {
+      const validated = schema.parse(response);
+      // Ensure serialNumber is in the correct format (number array)
+      const serialNumberArray = validated.serialNumber
+        ? (typeof validated.serialNumber === 'string'
+          ? validated.serialNumber.split('').map(c => c.charCodeAt(0))
+          : validated.serialNumber)
+        : undefined;
+
+      const result: DeviceInquiryResponse = {
+        manufacturerId: validated.manufacturerId,
+        deviceFamily: validated.deviceFamily ?? validated.familyCode ?? 0,
+        deviceModel: validated.deviceModel ?? validated.familyMember ?? 0,
+        firmwareVersion: validated.firmwareVersion ?? validated.softwareRevision ?? [],
+        ...(serialNumberArray ? { serialNumber: serialNumberArray } : {}),
+        // Include optional properties
+        ...(validated.familyCode !== undefined ? { familyCode: validated.familyCode } : {}),
+        ...(validated.familyMember !== undefined ? { familyMember: validated.familyMember } : {}),
+        ...(validated.softwareRevision !== undefined ? { softwareRevision: validated.softwareRevision } : {}),
+      };
+
+      return result;
+    } catch (error) {
+      throw new Error(`Invalid device inquiry response format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate device info with proper typing
+   */
+  private validateDeviceInfo(info: unknown): LaunchControlXL3Info {
+    const schema = z.object({
+      manufacturerId: z.string(),
+      deviceFamily: z.number(),
+      modelNumber: z.number(),
+      firmwareVersion: z.string(),
+      serialNumber: z.string().optional(),
+      deviceName: z.string().optional(),
+      portInfo: z.any().optional(), // MidiPortInfo type is complex, allow any for now
+    });
+
+    try {
+      const validated = schema.parse(info);
+      // Construct object with only defined optional properties
+      const result: LaunchControlXL3Info = {
+        manufacturerId: validated.manufacturerId,
+        deviceFamily: validated.deviceFamily,
+        modelNumber: validated.modelNumber,
+        firmwareVersion: validated.firmwareVersion,
+        ...(validated.serialNumber !== undefined && { serialNumber: validated.serialNumber }),
+        ...(validated.deviceName !== undefined && { deviceName: validated.deviceName }),
+        ...(validated.portInfo !== undefined && { portInfo: validated.portInfo }),
+      };
+
+      return result;
+    } catch (error) {
+      throw new Error(`Invalid device info format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate custom mode response with type guards
+   */
+  private validateCustomModeResponse(response: unknown): { slot?: number; name?: string; controls?: any; colors?: any } {
+    const schema = z.object({
+      type: z.literal('custom_mode_response'),
+      slot: z.number().min(0).max(15).optional(),
+      name: z.string().optional(),
+      controls: z.any().optional(), // Complex type, validate separately
+      colors: z.any().optional(),
+    });
+
+    try {
+      const validated = schema.parse(response);
+      const result: { slot?: number; name?: string; controls?: any; colors?: any } = {};
+
+      if (validated.slot !== undefined) {
+        result.slot = validated.slot;
+      }
+      if (validated.name !== undefined) {
+        result.name = validated.name;
+      }
+      if (validated.controls !== undefined) {
+        result.controls = validated.controls;
+      }
+      if (validated.colors !== undefined) {
+        result.colors = validated.colors;
+      }
+
+      return result;
+    } catch (error) {
+      throw new Error(`Invalid custom mode response format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate custom mode data before sending
+   */
+  private validateCustomModeData(data: unknown): any {
+    const schema = z.object({
+      slot: z.number().min(0).max(15),
+      name: z.string(),
+      controls: z.any(),
+      colors: z.any(),
+    });
+
+    try {
+      return schema.parse(data);
+    } catch (error) {
+      throw new Error(`Invalid custom mode data format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate template change response with type guards
+   */
+  private validateTemplateChangeResponse(response: unknown): { templateNumber: number } {
+    const schema = z.object({
+      type: z.literal('template_change'),
+      templateNumber: z.number().min(0).max(15),
+    });
+
+    try {
+      return schema.parse(response);
+    } catch (error) {
+      throw new Error(`Invalid template change response format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Clean up resources
+   */
+  async cleanup(): Promise<void> {
+    this.clearTimers();
+    await this.disconnect();
+    await this.midi.cleanup();
+    this.removeAllListeners();
+  }
+}
+
+export default DeviceManager;
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/factories.ts b/modules/audio-control/modules/launch-control-xl3/package/src/factories.ts
new file mode 100644
index 0000000..f53d239
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/factories.ts
@@ -0,0 +1,36 @@
+/**
+ * Factory functions for common library use cases
+ */
+
+import type { DeviceOptions } from '@/types/device.js';
+
+// Placeholder exports for factory functions that will be implemented
+// These will be implemented as the core classes are developed
+
+/**
+ * Create a new Launch Control XL 3 device instance with default configuration
+ */
+export function createDevice(_options?: DeviceOptions) {
+  throw new Error('createDevice factory not yet implemented - requires Device class');
+}
+
+/**
+ * Create a device service with dependency injection
+ */
+export function createDeviceService(_options?: DeviceOptions) {
+  throw new Error('createDeviceService factory not yet implemented - requires DeviceService class');
+}
+
+/**
+ * Create a device with automatic discovery and connection
+ */
+export async function createConnectedDevice(_options?: DeviceOptions) {
+  throw new Error('createConnectedDevice factory not yet implemented - requires Device class');
+}
+
+/**
+ * Create a mode manager for handling custom modes
+ */
+export function createModeManager() {
+  throw new Error('createModeManager factory not yet implemented - requires ModeManager class');
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/index.ts b/modules/audio-control/modules/launch-control-xl3/package/src/index.ts
new file mode 100644
index 0000000..fa17c13
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/index.ts
@@ -0,0 +1,163 @@
+/**
+ * @ol-dsp/launch-control-xl3
+ *
+ * TypeScript library for controlling the Novation Launch Control XL 3
+ * hardware MIDI controller.
+ *
+ * @packageDocumentation
+ */
+
+// Main controller class
+export { LaunchControlXL3 } from './LaunchControlXL3.js';
+export type { LaunchControlXL3Options, LaunchControlXL3Events } from './LaunchControlXL3.js';
+export { default } from './LaunchControlXL3.js';
+
+// Core components
+export * from './core/MidiInterface.js';
+export * from './core/SysExParser.js';
+export * from './core/Midimunge.js';
+
+// Device management
+export * from './device/DeviceManager.js';
+
+// Custom modes
+export * from './modes/CustomModeManager.js';
+
+// Builders
+export { CustomModeBuilder, Color } from './builders/CustomModeBuilder.js';
+
+// Control mapping
+export * from './mapping/ControlMapper.js';
+
+// LED control
+export * from './led/LedController.js';
+
+// Type definitions (exclude types already exported by core modules)
+export type {
+  CCNumber,
+  MidiChannel,
+  MidiValue,
+  NoteNumber,
+  Velocity,
+  ControlChangeMessage,
+  NoteOnMessage,
+  NoteOffMessage,
+  PitchBendMessage,
+  ParsedMidiMessage,
+  MidiParseResult,
+  MidiEventHandlers,
+  SlotNumber,
+  DeviceState,
+  DeviceOptions,
+  RetryPolicy,
+  HeartbeatConfig,
+  ErrorRecoveryConfig,
+  TimeoutConfig,
+  DeviceOperationResult,
+  DeviceError,
+  DeviceErrorCode,
+  DeviceCapabilities,
+  LaunchControlXL3Info,
+  LaunchControlXL3Config,
+  DeviceMode,
+  DeviceConnectionState,
+  ControlId,
+  ControlConfig,
+  ControlColor,
+  ControlRange,
+  ModeTemplate,
+  TemplatePreset,
+  MidiMapping,
+  MidiTarget,
+  ValueTransform,
+  FactoryPreset,
+  PresetCategory,
+  ProtocolValidation,
+  KnobPosition,
+  KnobRow,
+  ButtonPosition,
+  FaderPosition,
+  LowLevelControlType,
+  LowLevelCustomMode,
+  CustomMode,
+  ControlBehavior,
+  Control,
+  CustomModeResponse,
+  ProtocolCustomMode,
+  ProtocolControlType,
+  CustomModeSlot,
+  LedColor,
+  LedBehaviour,
+  ControlBehaviour,
+  ControlType
+} from './types/index.js';
+
+export {
+  createCCNumber,
+  createMidiChannel,
+  createMidiValue,
+  createNoteNumber,
+  createVelocity,
+  DEVICE_LAYOUT,
+  DEFAULT_KNOB_CONFIG,
+  DEFAULT_BUTTON_CONFIG,
+  DEFAULT_FADER_CONFIG
+} from './types/index.js';
+
+// Utilities
+export * from './utils/validators.js';
+export * from './utils/converters.js';
+export * from './utils/helpers.js';
+export * from './utils/bitwise.js';
+
+// Re-export constants for convenience
+export {
+  CONTROL_IDS,
+  LED_COLORS,
+} from './modes/CustomModeManager.js';
+
+export {
+  LED_COLOR_VALUES,
+  LED_NOTE_MAP,
+} from './led/LedController.js';
+
+export {
+  ValueTransformers,
+  RelativeHandlers,
+} from './mapping/ControlMapper.js';
+
+// Version information
+export const VERSION = '0.1.0';
+export const LIBRARY_NAME = '@ol-dsp/launch-control-xl3';
+export const SUPPORTED_DEVICE = 'Novation Launch Control XL 3';
+
+/**
+ * Quick start example:
+ *
+ * ```typescript
+ * import { LaunchControlXL3 } from '@ol-dsp/launch-control-xl3';
+ *
+ * // Create controller instance
+ * const controller = new LaunchControlXL3({
+ *   enableLedControl: true,
+ *   enableCustomModes: true,
+ * });
+ *
+ * // Connect to device
+ * await controller.connect();
+ *
+ * // Listen for control changes
+ * controller.on('control:change', (controlId, value) => {
+ *   console.log(`Control ${controlId} changed to ${value}`);
+ * });
+ *
+ * // Set LED colors
+ * await controller.setLed('FOCUS1', 'GREEN_FULL');
+ *
+ * // Load custom mode
+ * const mode = await controller.loadCustomMode(0);
+ *
+ * // Clean up when done
+ * await controller.cleanup();
+ * ```
+ */
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/led/LedController.ts b/modules/audio-control/modules/launch-control-xl3/package/src/led/LedController.ts
new file mode 100644
index 0000000..f9239d6
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/led/LedController.ts
@@ -0,0 +1,549 @@
+/**
+ * LED Controller for Launch Control XL 3
+ *
+ * Manages LED states, colors, and animations for all controls
+ * on the Launch Control XL 3 device.
+ */
+
+import { EventEmitter } from 'eventemitter3';
+import { DeviceManager } from '../device/DeviceManager.js';
+import { SysExParser } from '../core/SysExParser.js';
+import { LedColor, LedBehaviour } from '../types/index.js';
+
+export interface LedControllerOptions {
+  deviceManager: DeviceManager;
+  enableAnimations?: boolean;
+  animationFrameRate?: number;
+  enableColorCorrection?: boolean;
+}
+
+export interface LedState {
+  controlId: string;
+  color: LedColor;
+  behaviour: LedBehaviour;
+  brightness?: number;
+  active: boolean;
+}
+
+export interface LedAnimation {
+  type: 'fade' | 'pulse' | 'flash' | 'rainbow' | 'chase' | 'custom';
+  duration: number;
+  repeat?: number | 'infinite';
+  controls?: string[];
+  colors?: LedColor[];
+  callback?: (frame: number) => void;
+}
+
+export interface LedControllerEvents {
+  'led:changed': (controlId: string, state: LedState) => void;
+  'led:batch': (states: LedState[]) => void;
+  'animation:started': (animation: LedAnimation) => void;
+  'animation:completed': (animation: LedAnimation) => void;
+  'error': (error: Error) => void;
+}
+
+/**
+ * LED color definitions with velocity values
+ */
+export const LED_COLOR_VALUES = {
+  OFF: 0x0C,
+
+  // Red colors
+  RED_LOW: 0x0D,
+  RED_MEDIUM: 0x0E,
+  RED_FULL: 0x0F,
+
+  // Amber colors
+  AMBER_LOW: 0x1D,
+  AMBER_MEDIUM: 0x2E,
+  AMBER_FULL: 0x3F,
+
+  // Yellow colors
+  YELLOW_LOW: 0x2D,
+  YELLOW_FULL: 0x3E,
+
+  // Green colors
+  GREEN_LOW: 0x1C,
+  GREEN_MEDIUM: 0x2C,
+  GREEN_FULL: 0x3C,
+} as const;
+
+/**
+ * Control ID to note mapping for LED control
+ */
+export const LED_NOTE_MAP = {
+  // Track focus buttons (top row)
+  FOCUS1: 0x29, FOCUS2: 0x2A, FOCUS3: 0x2B, FOCUS4: 0x2C,
+  FOCUS5: 0x2D, FOCUS6: 0x2E, FOCUS7: 0x2F, FOCUS8: 0x30,
+
+  // Track control buttons (bottom row)
+  CONTROL1: 0x39, CONTROL2: 0x3A, CONTROL3: 0x3B, CONTROL4: 0x3C,
+  CONTROL5: 0x3D, CONTROL6: 0x3E, CONTROL7: 0x3F, CONTROL8: 0x40,
+
+  // Side buttons
+  DEVICE: 0x69, MUTE: 0x6A, SOLO: 0x6B, RECORD: 0x6C,
+  UP: 0x68, DOWN: 0x6D, LEFT: 0x6E, RIGHT: 0x6F,
+
+  // Send select buttons (not on all models)
+  SEND_SELECT_UP: 0x2E, SEND_SELECT_DOWN: 0x2F,
+} as const;
+
+/**
+ * LED Controller
+ */
+export class LedController extends EventEmitter {
+  private deviceManager: DeviceManager;
+  private options: Required<LedControllerOptions>;
+  private ledStates: Map<string, LedState> = new Map();
+  private animations: Map<string, LedAnimation> = new Map();
+  private animationTimers: Map<string, NodeJS.Timeout> = new Map();
+  private animationFrames: Map<string, number> = new Map();
+
+  constructor(options: LedControllerOptions) {
+    super();
+
+    this.deviceManager = options.deviceManager;
+    this.options = {
+      deviceManager: options.deviceManager,
+      enableAnimations: options.enableAnimations ?? true,
+      animationFrameRate: options.animationFrameRate ?? 30,
+      enableColorCorrection: options.enableColorCorrection ?? false,
+    };
+
+    this.initializeLedStates();
+  }
+
+  /**
+   * Initialize LED states for all controls
+   */
+  private initializeLedStates(): void {
+    // Initialize all button LEDs as off
+    for (const [controlId, _noteValue] of Object.entries(LED_NOTE_MAP)) {
+      this.ledStates.set(controlId, {
+        controlId,
+        color: LED_COLOR_VALUES.OFF as any,
+        behaviour: 'static',
+        active: false,
+        brightness: 0,
+      });
+    }
+  }
+
+  /**
+   * Set LED color and behaviour
+   */
+  async setLed(
+    controlId: string,
+    color: LedColor | number,
+    behaviour: LedBehaviour = 'static'
+  ): Promise<void> {
+    const noteValue = this.getLedNoteValue(controlId);
+    if (noteValue === undefined) {
+      throw new Error(`Invalid control ID for LED: ${controlId}`);
+    }
+
+    // Convert color to velocity value if needed
+    const colorValue = typeof color === 'number' ? color : this.getColorValue(color);
+
+    // Apply color correction if enabled
+    const correctedColor = this.options.enableColorCorrection
+      ? this.applyColorCorrection(colorValue)
+      : colorValue;
+
+    // Build and send SysEx message
+    const message = SysExParser.buildLedControl(noteValue, correctedColor, behaviour);
+    await this.deviceManager.sendSysEx(message);
+
+    // Update internal state
+    const state: LedState = {
+      controlId,
+      color: color as LedColor,
+      behaviour,
+      active: colorValue !== LED_COLOR_VALUES.OFF,
+      brightness: this.getBrightness(colorValue),
+    };
+
+    this.ledStates.set(controlId, state);
+    this.emit('led:changed', controlId, state);
+  }
+
+  /**
+   * Set multiple LEDs at once
+   */
+  async setMultipleLeds(updates: Array<{
+    controlId: string;
+    color: LedColor | number;
+    behaviour?: LedBehaviour;
+  }>): Promise<void> {
+    const states: LedState[] = [];
+
+    for (const update of updates) {
+      await this.setLed(update.controlId, update.color, update.behaviour);
+
+      const state = this.ledStates.get(update.controlId);
+      if (state) {
+        states.push(state);
+      }
+    }
+
+    this.emit('led:batch', states);
+  }
+
+  /**
+   * Turn off a single LED
+   */
+  async turnOff(controlId: string): Promise<void> {
+    await this.setLed(controlId, LED_COLOR_VALUES.OFF, 'static');
+  }
+
+  /**
+   * Turn off all LEDs
+   */
+  async turnOffAll(): Promise<void> {
+    const message = SysExParser.buildLedReset();
+    await this.deviceManager.sendSysEx(message);
+
+    // Update all states to off
+    for (const [_controlId, state] of this.ledStates.entries()) {
+      state.color = LED_COLOR_VALUES.OFF as any;
+      state.behaviour = 'static';
+      state.active = false;
+      state.brightness = 0;
+    }
+  }
+
+  /**
+   * Flash an LED
+   */
+  async flashLed(
+    controlId: string,
+    color: LedColor | number,
+    duration: number = 100
+  ): Promise<void> {
+    await this.setLed(controlId, color, 'flash');
+
+    if (duration > 0) {
+      setTimeout(() => {
+        this.turnOff(controlId);
+      }, duration);
+    }
+  }
+
+  /**
+   * Pulse an LED
+   */
+  async pulseLed(
+    controlId: string,
+    color: LedColor | number
+  ): Promise<void> {
+    await this.setLed(controlId, color, 'pulse');
+  }
+
+  /**
+   * Start an animation
+   */
+  startAnimation(id: string, animation: LedAnimation): void {
+    if (!this.options.enableAnimations) {
+      return;
+    }
+
+    // Stop existing animation with same ID
+    this.stopAnimation(id);
+
+    this.animations.set(id, animation);
+    this.animationFrames.set(id, 0);
+
+    const frameInterval = 1000 / this.options.animationFrameRate;
+    let repeatCount = 0;
+
+    const animate = () => {
+      const frame = this.animationFrames.get(id) ?? 0;
+
+      try {
+        this.processAnimationFrame(id, animation, frame);
+      } catch (error) {
+        this.emit('error', error as Error);
+        this.stopAnimation(id);
+        return;
+      }
+
+      // Update frame counter
+      this.animationFrames.set(id, frame + 1);
+
+      // Check if animation should repeat
+      const totalFrames = (animation.duration / frameInterval);
+      if (frame >= totalFrames) {
+        repeatCount++;
+
+        if (animation.repeat === 'infinite' ||
+            (typeof animation.repeat === 'number' && repeatCount < animation.repeat)) {
+          this.animationFrames.set(id, 0);
+        } else {
+          this.stopAnimation(id);
+          this.emit('animation:completed', animation);
+        }
+      }
+    };
+
+    const timer = setInterval(animate, frameInterval);
+    this.animationTimers.set(id, timer);
+
+    this.emit('animation:started', animation);
+    animate(); // Run first frame immediately
+  }
+
+  /**
+   * Process animation frame
+   */
+  private processAnimationFrame(_id: string, animation: LedAnimation, _frame: number): void {
+    switch (animation.type) {
+      case 'fade':
+        this.processFadeAnimation(animation, _frame);
+        break;
+
+      case 'pulse':
+        this.processPulseAnimation(animation, _frame);
+        break;
+
+      case 'flash':
+        this.processFlashAnimation(animation, _frame);
+        break;
+
+      case 'rainbow':
+        this.processRainbowAnimation(animation, _frame);
+        break;
+
+      case 'chase':
+        this.processChaseAnimation(animation, _frame);
+        break;
+
+      case 'custom':
+        if (animation.callback) {
+          animation.callback(_frame);
+        }
+        break;
+    }
+  }
+
+  /**
+   * Process fade animation
+   */
+  private processFadeAnimation(animation: LedAnimation, frame: number): void {
+    if (!animation.controls || !animation.colors || animation.colors.length < 2) {
+      return;
+    }
+
+    const progress = frame / (animation.duration / (1000 / this.options.animationFrameRate));
+    const fromColor = animation.colors[0];
+    const toColor = animation.colors[1];
+
+    // Simple color interpolation
+    const color = progress < 0.5 ? fromColor : toColor;
+
+    for (const controlId of animation.controls) {
+      if (color !== undefined) {
+        this.setLed(controlId, color, 'static').catch(() => {});
+      }
+    }
+  }
+
+  /**
+   * Process pulse animation
+   */
+  private processPulseAnimation(animation: LedAnimation, _frame: number): void {
+    if (!animation.controls || !animation.colors) {
+      return;
+    }
+
+    const color = animation.colors[0] ?? LED_COLOR_VALUES.GREEN_FULL;
+
+    for (const controlId of animation.controls) {
+      this.setLed(controlId, color as any, 'pulse').catch(() => {});
+    }
+  }
+
+  /**
+   * Process flash animation
+   */
+  private processFlashAnimation(animation: LedAnimation, frame: number): void {
+    if (!animation.controls || !animation.colors) {
+      return;
+    }
+
+    const color = animation.colors[0] ?? LED_COLOR_VALUES.RED_FULL;
+    const flashRate = 4; // Flashes per second
+    const on = Math.floor(frame / (this.options.animationFrameRate / flashRate)) % 2 === 0;
+
+    for (const controlId of animation.controls) {
+      this.setLed(controlId, on ? color as any : LED_COLOR_VALUES.OFF, 'static').catch(() => {});
+    }
+  }
+
+  /**
+   * Process rainbow animation
+   */
+  private processRainbowAnimation(animation: LedAnimation, frame: number): void {
+    if (!animation.controls) {
+      return;
+    }
+
+    const colors = [
+      LED_COLOR_VALUES.RED_FULL,
+      LED_COLOR_VALUES.AMBER_FULL,
+      LED_COLOR_VALUES.YELLOW_FULL,
+      LED_COLOR_VALUES.GREEN_FULL,
+    ];
+
+    const colorIndex = Math.floor(frame / 10) % colors.length;
+    const color = colors[colorIndex];
+
+    for (const controlId of animation.controls) {
+      if (color !== undefined) {
+        this.setLed(controlId, color, 'static').catch(() => {});
+      }
+    }
+  }
+
+  /**
+   * Process chase animation
+   */
+  private processChaseAnimation(animation: LedAnimation, frame: number): void {
+    if (!animation.controls || !animation.colors) {
+      return;
+    }
+
+    const color = animation.colors[0] ?? LED_COLOR_VALUES.GREEN_FULL;
+    const activeIndex = frame % animation.controls.length;
+
+    for (let i = 0; i < animation.controls.length; i++) {
+      const controlId = animation.controls[i];
+      if (!controlId) continue; // Skip undefined controlIds
+      const isActive = i === activeIndex;
+
+      this.setLed(
+        controlId,
+        isActive ? color as any : LED_COLOR_VALUES.OFF,
+        'static'
+      ).catch(() => {});
+    }
+  }
+
+  /**
+   * Stop an animation
+   */
+  stopAnimation(id: string): void {
+    const timer = this.animationTimers.get(id);
+    if (timer) {
+      clearInterval(timer);
+      this.animationTimers.delete(id);
+    }
+
+    this.animations.delete(id);
+    this.animationFrames.delete(id);
+  }
+
+  /**
+   * Stop all animations
+   */
+  stopAllAnimations(): void {
+    for (const id of this.animations.keys()) {
+      this.stopAnimation(id);
+    }
+  }
+
+  /**
+   * Get LED note value from control ID
+   */
+  private getLedNoteValue(controlId: string): number | undefined {
+    return (LED_NOTE_MAP as any)[controlId];
+  }
+
+  /**
+   * Get color value from color name
+   */
+  private getColorValue(color: LedColor | number): number {
+    if (typeof color === 'number') {
+      return color;
+    }
+    return (LED_COLOR_VALUES as any)[color] ?? LED_COLOR_VALUES.OFF;
+  }
+
+  /**
+   * Apply color correction
+   */
+  private applyColorCorrection(color: number): number {
+    // Simple gamma correction
+    // This would need to be calibrated for the actual hardware
+    return color;
+  }
+
+  /**
+   * Get brightness from color value
+   */
+  private getBrightness(colorValue: number): number {
+    // Extract brightness from velocity value
+    // This is a simplified calculation
+    if (colorValue === LED_COLOR_VALUES.OFF) {
+      return 0;
+    }
+
+    const brightness = (colorValue & 0x0F) / 15;
+    return Math.round(brightness * 100);
+  }
+
+  /**
+   * Get current LED state
+   */
+  getLedState(controlId: string): LedState | undefined {
+    return this.ledStates.get(controlId);
+  }
+
+  /**
+   * Get all LED states
+   */
+  getAllLedStates(): Map<string, LedState> {
+    return new Map(this.ledStates);
+  }
+
+  /**
+   * Create startup animation
+   */
+  async playStartupAnimation(): Promise<void> {
+    const focusButtons = ['FOCUS1', 'FOCUS2', 'FOCUS3', 'FOCUS4', 'FOCUS5', 'FOCUS6', 'FOCUS7', 'FOCUS8'];
+    const controlButtons = ['CONTROL1', 'CONTROL2', 'CONTROL3', 'CONTROL4', 'CONTROL5', 'CONTROL6', 'CONTROL7', 'CONTROL8'];
+
+    // Chase animation on focus buttons
+    this.startAnimation('startup-focus', {
+      type: 'chase',
+      duration: 2000,
+      controls: focusButtons,
+      colors: [LED_COLOR_VALUES.GREEN_FULL.toString()],
+    });
+
+    // Chase animation on control buttons (delayed)
+    setTimeout(() => {
+      this.startAnimation('startup-control', {
+        type: 'chase',
+        duration: 2000,
+        controls: controlButtons,
+        colors: [LED_COLOR_VALUES.AMBER_FULL.toString()],
+      });
+    }, 500);
+
+    // Turn off after animation
+    setTimeout(() => {
+      this.turnOffAll();
+    }, 3000);
+  }
+
+  /**
+   * Clean up resources
+   */
+  cleanup(): void {
+    this.stopAllAnimations();
+    this.ledStates.clear();
+    this.removeAllListeners();
+  }
+}
+
+export default LedController;
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/mapping/ControlMapper.ts b/modules/audio-control/modules/launch-control-xl3/package/src/mapping/ControlMapper.ts
new file mode 100644
index 0000000..10747a8
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/mapping/ControlMapper.ts
@@ -0,0 +1,550 @@
+/**
+ * Control Mapper for Launch Control XL 3
+ *
+ * Maps hardware controls to MIDI messages and handles value transformation,
+ * scaling, and behavior management for different control types.
+ */
+
+import { EventEmitter } from 'eventemitter3';
+import {
+  ControlMapping,
+  ControlBehaviour,
+  ControlChangeMessage,
+  ControlType,
+  ValueTransform,
+  CCNumber,
+  createCCNumber,
+  createMidiChannel,
+  createMidiValue
+} from '../types/index.js';
+import { MidiMessage } from '../core/MidiInterface.js';
+
+export interface ControlMapperOptions {
+  defaultChannel?: number;
+  enableValueSmoothing?: boolean;
+  smoothingFactor?: number;
+  enableDeadzone?: boolean;
+  deadzoneThreshold?: number;
+}
+
+export interface MappedControl {
+  id: string;
+  type: ControlType;
+  mapping: ControlMapping;
+  currentValue: number;
+  lastValue: number;
+  timestamp: number;
+}
+
+export interface ControlMapperEvents {
+  'value:changed': (controlId: string, value: number, mapping: ControlMapping) => void;
+  'midi:out': (message: MidiMessage) => void;
+  'control:mapped': (controlId: string, mapping: ControlMapping) => void;
+  'control:unmapped': (controlId: string) => void;
+}
+
+/**
+ * Value transformer functions
+ */
+export class ValueTransformers {
+  /**
+   * Linear scaling
+   */
+  static linear(value: number, min: number, max: number): number {
+    return Math.round(min + (value / 127) * (max - min));
+  }
+
+  /**
+   * Exponential scaling
+   */
+  static exponential(value: number, min: number, max: number, curve: number = 2): number {
+    const normalized = value / 127;
+    const curved = Math.pow(normalized, curve);
+    return Math.round(min + curved * (max - min));
+  }
+
+  /**
+   * Logarithmic scaling
+   */
+  static logarithmic(value: number, min: number, max: number): number {
+    const normalized = value / 127;
+    const curved = Math.log10(normalized * 9 + 1);
+    return Math.round(min + curved * (max - min));
+  }
+
+  /**
+   * Stepped scaling (quantize to steps)
+   */
+  static stepped(value: number, min: number, max: number, steps: number): number {
+    const range = max - min;
+    const stepSize = range / (steps - 1);
+    const stepIndex = Math.round((value / 127) * (steps - 1));
+    return Math.round(min + stepIndex * stepSize);
+  }
+
+  /**
+   * Toggle (binary)
+   */
+  static toggle(value: number, threshold: number = 64): number {
+    return value >= threshold ? 127 : 0;
+  }
+
+  /**
+   * Invert
+   */
+  static invert(value: number): number {
+    return 127 - value;
+  }
+
+  /**
+   * Bipolar (-64 to +63)
+   */
+  static bipolar(value: number): number {
+    return value - 64;
+  }
+}
+
+/**
+ * Relative value handlers
+ */
+export class RelativeHandlers {
+  /**
+   * Relative mode 1: Two's complement
+   */
+  static twosComplement(value: number, currentValue: number, speed: number = 1): number {
+    const delta = value > 64 ? value - 128 : value;
+    const newValue = currentValue + (delta * speed);
+    return Math.max(0, Math.min(127, newValue));
+  }
+
+  /**
+   * Relative mode 2: Binary offset
+   */
+  static binaryOffset(value: number, currentValue: number, speed: number = 1): number {
+    const delta = value >= 64 ? -(value - 64) : value;
+    const newValue = currentValue + (delta * speed);
+    return Math.max(0, Math.min(127, newValue));
+  }
+
+  /**
+   * Relative mode 3: Sign magnitude
+   */
+  static signMagnitude(value: number, currentValue: number, speed: number = 1): number {
+    const direction = (value & 0x40) ? -1 : 1;
+    const magnitude = value & 0x3F;
+    const newValue = currentValue + (direction * magnitude * speed);
+    return Math.max(0, Math.min(127, newValue));
+  }
+}
+
+/**
+ * Control Mapper
+ */
+export class ControlMapper extends EventEmitter {
+  private options: Required<ControlMapperOptions>;
+  private mappings: Map<string, MappedControl> = new Map();
+  private smoothingBuffers: Map<string, number[]> = new Map();
+  private relativeAccumulators: Map<string, number> = new Map();
+
+  constructor(options: ControlMapperOptions = {}) {
+    super();
+
+    this.options = {
+      defaultChannel: options.defaultChannel ?? 0,
+      enableValueSmoothing: options.enableValueSmoothing ?? false,
+      smoothingFactor: options.smoothingFactor ?? 3,
+      enableDeadzone: options.enableDeadzone ?? false,
+      deadzoneThreshold: options.deadzoneThreshold ?? 2,
+    };
+  }
+
+  /**
+   * Map a control to MIDI
+   */
+  mapControl(controlId: string, type: ControlType, mapping: ControlMapping): void {
+    const mappedControl: MappedControl = {
+      id: controlId,
+      type,
+      mapping,
+      currentValue: 0,
+      lastValue: 0,
+      timestamp: Date.now(),
+    };
+
+    this.mappings.set(controlId, mappedControl);
+
+    // Initialize smoothing buffer if needed
+    if (this.options.enableValueSmoothing) {
+      this.smoothingBuffers.set(controlId, []);
+    }
+
+    // Initialize relative accumulator if needed
+    const behaviour = (mapping.behaviour ?? mapping.behavior ?? 'absolute') as ControlBehaviour;
+    if (this.isRelativeBehaviour(behaviour)) {
+      this.relativeAccumulators.set(controlId, 64); // Middle value
+    }
+
+    this.emit('control:mapped', controlId, mapping);
+  }
+
+  /**
+   * Unmap a control
+   */
+  unmapControl(controlId: string): void {
+    if (this.mappings.delete(controlId)) {
+      this.smoothingBuffers.delete(controlId);
+      this.relativeAccumulators.delete(controlId);
+      this.emit('control:unmapped', controlId);
+    }
+  }
+
+  /**
+   * Process incoming control value
+   */
+  processControlValue(controlId: string, rawValue: number): MidiMessage | null {
+    const mapped = this.mappings.get(controlId);
+    if (!mapped) {
+      return null;
+    }
+
+    // Apply deadzone if enabled
+    if (this.options.enableDeadzone) {
+      const delta = Math.abs(rawValue - mapped.lastValue);
+      if (delta < this.options.deadzoneThreshold) {
+        return null;
+      }
+    }
+
+    // Apply smoothing if enabled
+    let processedValue = rawValue;
+    if (this.options.enableValueSmoothing) {
+      processedValue = this.smoothValue(controlId, rawValue);
+    }
+
+    // Handle different control behaviours
+    let outputValue: number;
+
+    switch (mapped.mapping.behaviour) {
+      case 'absolute':
+        outputValue = this.processAbsoluteValue(processedValue, mapped.mapping);
+        break;
+
+      case 'relative1':
+        outputValue = this.processRelativeValue(processedValue, controlId, 'twosComplement');
+        break;
+
+      case 'relative2':
+        outputValue = this.processRelativeValue(processedValue, controlId, 'binaryOffset');
+        break;
+
+      case 'relative3':
+        outputValue = this.processRelativeValue(processedValue, controlId, 'signMagnitude');
+        break;
+
+      default:
+        outputValue = processedValue;
+    }
+
+    // Apply value transform if specified
+    if (mapped.mapping.transform) {
+      if (typeof mapped.mapping.transform === 'function') {
+        outputValue = mapped.mapping.transform(outputValue);
+      } else if (typeof mapped.mapping.transform === 'object') {
+        outputValue = this.applyTransform(outputValue, mapped.mapping.transform);
+      }
+      // If it's a string, we could add string-based transform handling here
+    }
+
+    // Scale to min/max range
+    outputValue = ValueTransformers.linear(
+      outputValue,
+      mapped.mapping.min ?? mapped.mapping.minValue ?? 0,
+      mapped.mapping.max ?? mapped.mapping.maxValue ?? 127
+    );
+
+    // Update state
+    mapped.lastValue = rawValue;
+    mapped.currentValue = outputValue;
+    mapped.timestamp = Date.now();
+
+    // Emit events
+    this.emit('value:changed', controlId, outputValue, mapped.mapping);
+
+    // Create MIDI message
+    const message: ControlChangeMessage = {
+      type: 'controlChange',
+      timestamp: Date.now(),
+      channel: createMidiChannel(mapped.mapping.midiChannel ?? mapped.mapping.channel ?? 0),
+      cc: createCCNumber(mapped.mapping.ccNumber ?? mapped.mapping.cc ?? 0),
+      value: createMidiValue(outputValue),
+      data: [0xB0 | ((mapped.mapping.midiChannel ?? mapped.mapping.channel ?? 0) - 1), mapped.mapping.ccNumber ?? mapped.mapping.cc ?? 0, outputValue],
+    };
+
+    this.emit('midi:out', message);
+
+    return message;
+  }
+
+  /**
+   * Process absolute value
+   */
+  private processAbsoluteValue(value: number, _mapping: ControlMapping): number {
+    // For absolute mode, just pass through the value
+    return value;
+  }
+
+  /**
+   * Process relative value
+   */
+  private processRelativeValue(
+    value: number,
+    controlId: string,
+    mode: 'twosComplement' | 'binaryOffset' | 'signMagnitude'
+  ): number {
+    const currentValue = this.relativeAccumulators.get(controlId) ?? 64;
+    let newValue: number;
+
+    switch (mode) {
+      case 'twosComplement':
+        newValue = RelativeHandlers.twosComplement(value, currentValue);
+        break;
+      case 'binaryOffset':
+        newValue = RelativeHandlers.binaryOffset(value, currentValue);
+        break;
+      case 'signMagnitude':
+        newValue = RelativeHandlers.signMagnitude(value, currentValue);
+        break;
+    }
+
+    this.relativeAccumulators.set(controlId, newValue);
+    return newValue;
+  }
+
+  /**
+   * Apply value transform
+   */
+  private applyTransform(value: number, transform: ValueTransform): number {
+    switch (transform.type) {
+      case 'linear':
+        return value; // Already linear
+
+      case 'exponential':
+        return ValueTransformers.exponential(
+          value,
+          0,
+          127,
+          typeof transform.curve === 'number' ? transform.curve : 2
+        );
+
+      case 'logarithmic':
+        return ValueTransformers.logarithmic(value, 0, 127);
+
+      case 'stepped':
+        return ValueTransformers.stepped(
+          value,
+          0,
+          127,
+          transform.steps ?? 8
+        );
+
+      case 'toggle':
+        return ValueTransformers.toggle(value, transform.threshold ?? 64);
+
+      case 'invert':
+        return ValueTransformers.invert(value);
+
+      case 'bipolar':
+        return ValueTransformers.bipolar(value);
+
+      default:
+        return value;
+    }
+  }
+
+  /**
+   * Smooth value using moving average
+   */
+  private smoothValue(controlId: string, value: number): number {
+    const buffer = this.smoothingBuffers.get(controlId) ?? [];
+
+    // Add new value to buffer
+    buffer.push(value);
+
+    // Keep buffer size limited
+    if (buffer.length > this.options.smoothingFactor) {
+      buffer.shift();
+    }
+
+    // Calculate average
+    const sum = buffer.reduce((a, b) => a + b, 0);
+    const smoothed = Math.round(sum / buffer.length);
+
+    // Update buffer
+    this.smoothingBuffers.set(controlId, buffer);
+
+    return smoothed;
+  }
+
+  /**
+   * Check if behaviour is relative
+   */
+  private isRelativeBehaviour(behaviour: ControlBehaviour): boolean {
+    return behaviour.startsWith('relative');
+  }
+
+  /**
+   * Get mapping for control
+   */
+  getMapping(controlId: string): MappedControl | undefined {
+    return this.mappings.get(controlId);
+  }
+
+  /**
+   * Get all mappings
+   */
+  getAllMappings(): Map<string, MappedControl> {
+    return new Map(this.mappings);
+  }
+
+  /**
+   * Update control mapping
+   */
+  updateMapping(controlId: string, updates: Partial<ControlMapping>): void {
+    const mapped = this.mappings.get(controlId);
+    if (!mapped) {
+      throw new Error(`Control ${controlId} is not mapped`);
+    }
+
+    mapped.mapping = {
+      ...mapped.mapping,
+      ...updates,
+    };
+
+    this.emit('control:mapped', controlId, mapped.mapping);
+  }
+
+  /**
+   * Reset control state
+   */
+  resetControl(controlId: string): void {
+    const mapped = this.mappings.get(controlId);
+    if (mapped) {
+      mapped.currentValue = 0;
+      mapped.lastValue = 0;
+      mapped.timestamp = Date.now();
+    }
+
+    this.smoothingBuffers.delete(controlId);
+    this.relativeAccumulators.delete(controlId);
+  }
+
+  /**
+   * Reset all controls
+   */
+  resetAll(): void {
+    for (const controlId of this.mappings.keys()) {
+      this.resetControl(controlId);
+    }
+  }
+
+  /**
+   * Create default mappings for Launch Control XL 3
+   */
+  static createDefaultMappings(): Map<string, ControlMapping> {
+    const mappings = new Map<string, ControlMapping>();
+
+    // Send A knobs - CC 13-20
+    for (let i = 0; i < 8; i++) {
+      mappings.set(`SEND_A${i + 1}`, {
+        type: 'knob',
+        channel: 0,
+        cc: (13 + i) as CCNumber,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      });
+    }
+
+    // Send B knobs - CC 29-36
+    for (let i = 0; i < 8; i++) {
+      mappings.set(`SEND_B${i + 1}`, {
+        type: 'knob',
+        channel: 0,
+        cc: (29 + i) as CCNumber,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      });
+    }
+
+    // Pan knobs - CC 49-56
+    for (let i = 0; i < 8; i++) {
+      mappings.set(`PAN${i + 1}`, {
+        type: 'knob',
+        channel: 0,
+        cc: (49 + i) as CCNumber,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      });
+    }
+
+    // Faders - CC 77-84
+    for (let i = 0; i < 8; i++) {
+      mappings.set(`FADER${i + 1}`, {
+        type: 'fader',
+        channel: 0,
+        cc: (77 + i) as CCNumber,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      });
+    }
+
+    return mappings;
+  }
+
+  /**
+   * Load mappings from custom mode
+   */
+  loadFromCustomMode(mode: any): void {
+    // Clear existing mappings
+    this.mappings.clear();
+    this.smoothingBuffers.clear();
+    this.relativeAccumulators.clear();
+
+    // Load control mappings
+    if (mode.controls) {
+      for (const [controlId, control] of Object.entries(mode.controls)) {
+        const mapping = control as ControlMapping;
+        const controlType = (mapping.type ?? mapping.controlType ?? 'knob') as ControlType;
+        this.mapControl(controlId, controlType, mapping);
+      }
+    }
+  }
+
+  /**
+   * Export mappings to custom mode format
+   */
+  exportToCustomMode(): Record<string, ControlMapping> {
+    const controls: Record<string, ControlMapping> = {};
+
+    for (const [controlId, mapped] of this.mappings.entries()) {
+      controls[controlId] = mapped.mapping;
+    }
+
+    return controls;
+  }
+
+  /**
+   * Clean up resources
+   */
+  cleanup(): void {
+    this.mappings.clear();
+    this.smoothingBuffers.clear();
+    this.relativeAccumulators.clear();
+    this.removeAllListeners();
+  }
+}
+
+export default ControlMapper;
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/models/Constants.ts b/modules/audio-control/modules/launch-control-xl3/package/src/models/Constants.ts
new file mode 100644
index 0000000..8435190
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/models/Constants.ts
@@ -0,0 +1,11 @@
+/**
+ * Device constants and enums
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class Constants {
+  constructor() {
+    throw new Error('Constants class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/models/Control.ts b/modules/audio-control/modules/launch-control-xl3/package/src/models/Control.ts
new file mode 100644
index 0000000..f711206
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/models/Control.ts
@@ -0,0 +1,11 @@
+/**
+ * Control definitions and types
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class Control {
+  constructor() {
+    throw new Error('Control class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/models/CustomMode.ts b/modules/audio-control/modules/launch-control-xl3/package/src/models/CustomMode.ts
new file mode 100644
index 0000000..0b97ee5
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/models/CustomMode.ts
@@ -0,0 +1,11 @@
+/**
+ * Custom mode data structure
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class CustomMode {
+  constructor() {
+    throw new Error('CustomMode class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/models/Mapping.ts b/modules/audio-control/modules/launch-control-xl3/package/src/models/Mapping.ts
new file mode 100644
index 0000000..ac443f6
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/models/Mapping.ts
@@ -0,0 +1,11 @@
+/**
+ * MIDI mapping definitions
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class Mapping {
+  constructor() {
+    throw new Error('Mapping class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/models/Template.ts b/modules/audio-control/modules/launch-control-xl3/package/src/models/Template.ts
new file mode 100644
index 0000000..b767688
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/models/Template.ts
@@ -0,0 +1,11 @@
+/**
+ * Template configuration model
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class Template {
+  constructor() {
+    throw new Error('Template class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/modes/CustomModeManager.ts b/modules/audio-control/modules/launch-control-xl3/package/src/modes/CustomModeManager.ts
new file mode 100644
index 0000000..a7aaf6e
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/modes/CustomModeManager.ts
@@ -0,0 +1,574 @@
+/**
+ * Custom Mode Manager for Launch Control XL 3
+ *
+ * Handles reading, writing, and managing custom mode configurations
+ * for the Launch Control XL 3 device. Each custom mode defines how
+ * controls map to MIDI messages and LED states.
+ */
+
+import { EventEmitter } from 'eventemitter3';
+import { DeviceManager } from '../device/DeviceManager.js';
+import { ControlMapping, ColorMapping } from '../types/CustomMode.js';
+import {
+  CustomMode,
+  CustomModeSlot,
+  ControlBehaviour,
+  ControlType
+} from '../types/index.js';
+
+export interface CustomModeManagerOptions {
+  deviceManager: DeviceManager;
+  autoSync?: boolean;
+  cacheTimeout?: number;
+}
+
+export interface CustomModeEvents {
+  'mode:loaded': (slot: number, mode: CustomMode) => void;
+  'mode:saved': (slot: number, mode: CustomMode) => void;
+  'mode:error': (error: Error) => void;
+  'cache:updated': (slot: number) => void;
+  'cache:cleared': () => void;
+}
+
+/**
+ * Control ID mapping for Launch Control XL 3
+ */
+export const CONTROL_IDS = {
+  // Send A knobs (top row)
+  SEND_A1: 0x0D, SEND_A2: 0x0E, SEND_A3: 0x0F, SEND_A4: 0x10,
+  SEND_A5: 0x11, SEND_A6: 0x12, SEND_A7: 0x13, SEND_A8: 0x14,
+
+  // Send B knobs (middle row)
+  SEND_B1: 0x1D, SEND_B2: 0x1E, SEND_B3: 0x1F, SEND_B4: 0x20,
+  SEND_B5: 0x21, SEND_B6: 0x22, SEND_B7: 0x23, SEND_B8: 0x24,
+
+  // Pan/Device knobs (bottom row)
+  PAN1: 0x31, PAN2: 0x32, PAN3: 0x33, PAN4: 0x34,
+  PAN5: 0x35, PAN6: 0x36, PAN7: 0x37, PAN8: 0x38,
+
+  // Faders
+  FADER1: 0x4D, FADER2: 0x4E, FADER3: 0x4F, FADER4: 0x50,
+  FADER5: 0x51, FADER6: 0x52, FADER7: 0x53, FADER8: 0x54,
+
+  // Track focus buttons
+  FOCUS1: 0x29, FOCUS2: 0x2A, FOCUS3: 0x2B, FOCUS4: 0x2C,
+  FOCUS5: 0x2D, FOCUS6: 0x2E, FOCUS7: 0x2F, FOCUS8: 0x30,
+
+  // Track control buttons
+  CONTROL1: 0x39, CONTROL2: 0x3A, CONTROL3: 0x3B, CONTROL4: 0x3C,
+  CONTROL5: 0x3D, CONTROL6: 0x3E, CONTROL7: 0x3F, CONTROL8: 0x40,
+
+  // Side buttons
+  DEVICE: 0x69, MUTE: 0x6A, SOLO: 0x6B, RECORD: 0x6C,
+  UP: 0x68, DOWN: 0x6D, LEFT: 0x6E, RIGHT: 0x6F,
+} as const;
+
+/**
+ * LED color values for Launch Control XL 3
+ */
+export const LED_COLORS = {
+  OFF: 0x0C,
+  RED_LOW: 0x0D,
+  RED_FULL: 0x0F,
+  AMBER_LOW: 0x1D,
+  AMBER_FULL: 0x3F,
+  YELLOW: 0x3E,
+  GREEN_LOW: 0x1C,
+  GREEN_FULL: 0x3C,
+} as const;
+
+/**
+ * Custom Mode Manager
+ */
+export class CustomModeManager extends EventEmitter {
+  private deviceManager: DeviceManager;
+  private options: Required<CustomModeManagerOptions>;
+  private modeCache: Map<number, { mode: CustomMode; timestamp: number }> = new Map();
+  private pendingOperations: Map<number, Promise<CustomMode>> = new Map();
+
+  constructor(options: CustomModeManagerOptions) {
+    super();
+
+    this.deviceManager = options.deviceManager;
+    this.options = {
+      deviceManager: options.deviceManager,
+      autoSync: options.autoSync ?? true,
+      cacheTimeout: options.cacheTimeout ?? 300000, // 5 minutes
+    };
+
+    this.setupEventHandlers();
+  }
+
+  /**
+   * Setup event handlers
+   */
+  private setupEventHandlers(): void {
+    // Listen for device connection changes
+    this.deviceManager.on('device:connected', () => {
+      if (this.options.autoSync) {
+        this.syncAllModes().catch(error => {
+          this.emit('mode:error', error);
+        });
+      }
+    });
+
+    this.deviceManager.on('device:disconnected', () => {
+      this.clearCache();
+    });
+  }
+
+  /**
+   * Read a custom mode from the device
+   */
+  async readMode(slot: CustomModeSlot): Promise<CustomMode> {
+    this.validateSlot(slot);
+
+    // Check if we have a pending operation for this slot
+    const pending = this.pendingOperations.get(slot);
+    if (pending) {
+      return pending;
+    }
+
+    // Check cache
+    const cached = this.getCachedMode(slot);
+    if (cached) {
+      return cached;
+    }
+
+    // Create read operation
+    const operation = this.performReadMode(slot);
+    this.pendingOperations.set(slot, operation);
+
+    try {
+      const mode = await operation;
+      this.cacheMode(slot, mode);
+      this.emit('mode:loaded', slot, mode);
+      return mode;
+    } finally {
+      this.pendingOperations.delete(slot);
+    }
+  }
+
+  /**
+   * Perform actual mode read from device
+   */
+  private async performReadMode(slot: CustomModeSlot): Promise<CustomMode> {
+    const response = await this.deviceManager.readCustomMode(slot);
+    return this.parseCustomModeResponse(slot, response);
+  }
+
+  /**
+   * Write a custom mode to the device
+   */
+  async writeMode(slot: CustomModeSlot, mode: CustomMode): Promise<void> {
+    this.validateSlot(slot);
+    this.validateMode(mode);
+
+    // Convert to device format
+    const deviceMode = this.convertToDeviceFormat(slot, mode);
+
+    // Send to device
+    await this.deviceManager.writeCustomMode(slot, deviceMode);
+
+    // Update cache
+    this.cacheMode(slot, mode);
+    this.emit('mode:saved', slot, mode);
+  }
+
+  /**
+   * Parse custom mode response from device
+   */
+  private parseCustomModeResponse(slot: number, response: any): CustomMode {
+    // The response from DeviceManager is already partially parsed
+    // We need to enhance it with our type system
+
+    const mode: CustomMode = {
+      name: response.name || `Custom ${slot + 1}`,
+      controls: {},
+      leds: new Map(),
+      metadata: {
+        slot,
+        createdAt: new Date(),
+        modifiedAt: new Date(),
+      }
+    };
+
+    // Parse control mappings
+    if (response.controls) {
+      for (const control of response.controls) {
+        const controlId = this.getControlIdName(control.controlId);
+        if (controlId) {
+          mode.controls[controlId] = {
+            type: this.getControlType(control.controlId),
+            channel: control.channel,
+            cc: control.ccNumber,
+            min: control.minValue,
+            max: control.maxValue,
+            behaviour: control.behaviour as ControlBehaviour,
+          };
+        }
+      }
+    }
+
+    // Parse LED mappings
+    if (response.colors) {
+      for (const color of response.colors) {
+        const controlId = this.getControlIdName(color.controlId);
+        if (controlId && mode.leds) {
+          mode.leds.set(color.controlId, {
+            color: color.color,
+            behaviour: color.behaviour ?? 'static',
+          });
+        }
+      }
+    }
+
+    return mode;
+  }
+
+  /**
+   * Convert custom mode to device format
+   */
+  private convertToDeviceFormat(slot: number, mode: CustomMode): CustomMode {
+    const controls: ControlMapping[] = [];
+    const colors: ColorMapping[] = [];
+
+    // Convert control mappings
+    for (const [key, control] of Object.entries(mode.controls)) {
+      const controlId = this.getControlIdValue(key);
+      if (controlId !== undefined) {
+        const ctrl = control as any;
+        controls.push({
+          controlId,
+          channel: ctrl.channel,
+          ccNumber: ctrl.cc,
+          minValue: ctrl.min,
+          maxValue: ctrl.max,
+          behaviour: ctrl.behaviour,
+        });
+      }
+    }
+
+    // Convert LED mappings
+    for (const [key, led] of Object.entries(mode.leds || {})) {
+      const controlId = this.getControlIdValue(key);
+      if (controlId !== undefined) {
+        const ledConfig = led as any;
+        colors.push({
+          controlId,
+          color: ledConfig.color as number,
+          behaviour: ledConfig.behaviour,
+        });
+      }
+    }
+
+    return {
+      slot,
+      name: mode.name,
+      controls,
+      colors,
+    } as any;
+  }
+
+  /**
+   * Get control ID value from name
+   */
+  private getControlIdValue(name: string): number | undefined {
+    return (CONTROL_IDS as any)[name];
+  }
+
+  /**
+   * Get control ID name from value
+   */
+  private getControlIdName(value: number): string | undefined {
+    for (const [key, val] of Object.entries(CONTROL_IDS)) {
+      if (val === value) {
+        return key;
+      }
+    }
+    return undefined;
+  }
+
+  /**
+   * Get control type from control ID
+   */
+  private getControlType(controlId: number): ControlType {
+    if (controlId >= 0x0D && controlId <= 0x38) {
+      return 'knob';
+    } else if (controlId >= 0x4D && controlId <= 0x54) {
+      return 'fader';
+    } else {
+      return 'button';
+    }
+  }
+
+  /**
+   * Sync all modes from device
+   */
+  async syncAllModes(): Promise<CustomMode[]> {
+    const modes: CustomMode[] = [];
+
+    for (let slot = 0; slot < 16; slot++) {
+      try {
+        const mode = await this.readMode(slot as CustomModeSlot);
+        modes.push(mode);
+      } catch (error) {
+        // Log error but continue syncing other slots
+        console.error(`Failed to read mode from slot ${slot}:`, error);
+      }
+    }
+
+    return modes;
+  }
+
+  /**
+   * Copy a mode from one slot to another
+   */
+  async copyMode(sourceSlot: CustomModeSlot, targetSlot: CustomModeSlot): Promise<void> {
+    const sourceMode = await this.readMode(sourceSlot);
+
+    // Create a copy with new metadata
+    const targetMode: CustomMode = {
+      ...sourceMode,
+      metadata: {
+        ...sourceMode.metadata,
+        slot: targetSlot,
+        modifiedAt: new Date(),
+      }
+    };
+
+    await this.writeMode(targetSlot, targetMode);
+  }
+
+  /**
+   * Create a default mode
+   */
+  createDefaultMode(name?: string): CustomMode {
+    const mode: CustomMode = {
+      name: name || 'Default Mode',
+      controls: {},
+      leds: new Map(),
+      metadata: {
+        createdAt: new Date(),
+        modifiedAt: new Date(),
+      }
+    };
+
+    // Setup default control mappings
+    // Send A knobs - CC 13-20
+    for (let i = 0; i < 8; i++) {
+      const key = `SEND_A${i + 1}`;
+      mode.controls[key] = {
+        type: 'knob',
+        channel: 0,
+        cc: 13 + i,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      };
+    }
+
+    // Send B knobs - CC 29-36
+    for (let i = 0; i < 8; i++) {
+      const key = `SEND_B${i + 1}`;
+      mode.controls[key] = {
+        type: 'knob',
+        channel: 0,
+        cc: 29 + i,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      };
+    }
+
+    // Pan knobs - CC 49-56
+    for (let i = 0; i < 8; i++) {
+      const key = `PAN${i + 1}`;
+      mode.controls[key] = {
+        type: 'knob',
+        channel: 0,
+        cc: 49 + i,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      };
+    }
+
+    // Faders - CC 77-84
+    for (let i = 0; i < 8; i++) {
+      const key = `FADER${i + 1}`;
+      mode.controls[key] = {
+        type: 'fader',
+        channel: 0,
+        cc: 77 + i,
+        min: 0,
+        max: 127,
+        behaviour: 'absolute',
+      };
+    }
+
+    // Setup default LED colors
+    for (let i = 0; i < 8; i++) {
+      mode.leds!.set(i + 0x10, { // Focus buttons start at 0x10
+        color: LED_COLORS.AMBER_LOW as any,
+        behaviour: 'static',
+      });
+
+      mode.leds!.set(i + 0x28, { // Control buttons start at 0x28
+        color: LED_COLORS.GREEN_LOW as any,
+        behaviour: 'static',
+      });
+    }
+
+    return mode;
+  }
+
+  /**
+   * Export mode to JSON
+   */
+  exportMode(mode: CustomMode): string {
+    return JSON.stringify(mode, null, 2);
+  }
+
+  /**
+   * Import mode from JSON
+   */
+  importMode(json: string): CustomMode {
+    const parsed = JSON.parse(json);
+    this.validateMode(parsed);
+    return parsed;
+  }
+
+  /**
+   * Validate slot number
+   */
+  private validateSlot(slot: number): void {
+    if (slot < 0 || slot > 15) {
+      throw new Error(`Invalid slot number: ${slot}. Must be 0-15.`);
+    }
+  }
+
+  /**
+   * Validate custom mode
+   */
+  private validateMode(mode: CustomMode): void {
+    if (!mode.name || typeof mode.name !== 'string') {
+      throw new Error('Mode must have a name');
+    }
+
+    if (!mode.controls || typeof mode.controls !== 'object') {
+      throw new Error('Mode must have controls object');
+    }
+
+    // Validate each control mapping
+    for (const [key, control] of Object.entries(mode.controls)) {
+      if (!this.getControlIdValue(key)) {
+        throw new Error(`Invalid control ID: ${key}`);
+      }
+
+      const ctrl = control as any; // Type assertion for validation
+
+      if (ctrl.channel < 0 || ctrl.channel > 15) {
+        throw new Error(`Invalid channel for ${key}: ${ctrl.channel}`);
+      }
+
+      if (ctrl.cc !== undefined && (ctrl.cc < 0 || ctrl.cc > 127)) {
+        throw new Error(`Invalid CC for ${key}: ${ctrl.cc}`);
+      }
+
+      if (ctrl.min !== undefined && (ctrl.min < 0 || ctrl.min > 127)) {
+        throw new Error(`Invalid min value for ${key}: ${ctrl.min}`);
+      }
+
+      if (ctrl.max !== undefined && (ctrl.max < 0 || ctrl.max > 127)) {
+        throw new Error(`Invalid max value for ${key}: ${ctrl.max}`);
+      }
+
+      if (ctrl.min !== undefined && ctrl.max !== undefined && ctrl.min > ctrl.max) {
+        throw new Error(`Min value greater than max for ${key}`);
+      }
+    }
+
+    // Validate LED mappings if present
+    if (mode.leds) {
+      for (const [key, led] of Object.entries(mode.leds)) {
+        if (!this.getControlIdValue(key)) {
+          throw new Error(`Invalid LED control ID: ${key}`);
+        }
+
+        const ledConfig = led as any; // Type assertion for validation
+        const validBehaviours = ['static', 'flash', 'pulse'];
+        if (ledConfig.behaviour && !validBehaviours.includes(ledConfig.behaviour)) {
+          throw new Error(`Invalid LED behaviour for ${key}: ${ledConfig.behaviour}`);
+        }
+      }
+    }
+  }
+
+  /**
+   * Get cached mode
+   */
+  private getCachedMode(slot: number): CustomMode | null {
+    const cached = this.modeCache.get(slot);
+
+    if (!cached) {
+      return null;
+    }
+
+    // Check if cache has expired
+    const now = Date.now();
+    if (now - cached.timestamp > this.options.cacheTimeout) {
+      this.modeCache.delete(slot);
+      return null;
+    }
+
+    return cached.mode;
+  }
+
+  /**
+   * Cache a mode
+   */
+  private cacheMode(slot: number, mode: CustomMode): void {
+    this.modeCache.set(slot, {
+      mode,
+      timestamp: Date.now(),
+    });
+
+    this.emit('cache:updated', slot);
+  }
+
+  /**
+   * Clear cache
+   */
+  clearCache(): void {
+    this.modeCache.clear();
+    this.emit('cache:cleared');
+  }
+
+  /**
+   * Get all cached modes
+   */
+  getCachedModes(): Map<number, CustomMode> {
+    const modes = new Map<number, CustomMode>();
+
+    for (const [slot, cached] of this.modeCache.entries()) {
+      const now = Date.now();
+      if (now - cached.timestamp <= this.options.cacheTimeout) {
+        modes.set(slot, cached.mode);
+      }
+    }
+
+    return modes;
+  }
+
+  /**
+   * Clean up resources
+   */
+  cleanup(): void {
+    this.clearCache();
+    this.pendingOperations.clear();
+    this.removeAllListeners();
+  }
+}
+
+export default CustomModeManager;
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/services/ConfigManager.ts b/modules/audio-control/modules/launch-control-xl3/package/src/services/ConfigManager.ts
new file mode 100644
index 0000000..e71556c
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/services/ConfigManager.ts
@@ -0,0 +1,11 @@
+/**
+ * Configuration import/export
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class ConfigManager {
+  constructor() {
+    throw new Error('ConfigManager class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/services/DeviceService.ts b/modules/audio-control/modules/launch-control-xl3/package/src/services/DeviceService.ts
new file mode 100644
index 0000000..d0c546f
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/services/DeviceService.ts
@@ -0,0 +1,11 @@
+/**
+ * High-level device operations
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class DeviceService {
+  constructor() {
+    throw new Error('DeviceService class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/services/ModeManager.ts b/modules/audio-control/modules/launch-control-xl3/package/src/services/ModeManager.ts
new file mode 100644
index 0000000..a00cc74
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/services/ModeManager.ts
@@ -0,0 +1,11 @@
+/**
+ * Custom mode management
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class ModeManager {
+  constructor() {
+    throw new Error('ModeManager class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/services/PresetManager.ts b/modules/audio-control/modules/launch-control-xl3/package/src/services/PresetManager.ts
new file mode 100644
index 0000000..7b64406
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/services/PresetManager.ts
@@ -0,0 +1,11 @@
+/**
+ * Factory preset handling
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class PresetManager {
+  constructor() {
+    throw new Error('PresetManager class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/services/ValidationService.ts b/modules/audio-control/modules/launch-control-xl3/package/src/services/ValidationService.ts
new file mode 100644
index 0000000..809da1c
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/services/ValidationService.ts
@@ -0,0 +1,11 @@
+/**
+ * Data validation and verification
+ * 
+ * This class will be implemented in Phase 3: Data Models & Services
+ */
+
+export class ValidationService {
+  constructor() {
+    throw new Error('ValidationService class not yet implemented - Phase 3: Data Models & Services');
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/types/CustomMode.ts b/modules/audio-control/modules/launch-control-xl3/package/src/types/CustomMode.ts
new file mode 100644
index 0000000..55633d2
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/types/CustomMode.ts
@@ -0,0 +1,73 @@
+/**
+ * Type definitions for Launch Control XL 3 custom modes
+ */
+
+export type ControlType = 0x00 | 0x05 | 0x09 | 0x0D | 0x19 | 0x25 | 'knob' | 'fader' | 'button';
+
+export type ControlBehavior = 'absolute' | 'relative' | 'toggle';
+
+export interface Control {
+  controlId: number;      // Hardware control ID (0x00-0x3F)
+  controlType: ControlType; // Type determines row/type of control
+  midiChannel: number;    // 0-15 (0-based)
+  ccNumber: number;       // CC number 0-127
+  minValue: number;       // Minimum value (usually 0)
+  maxValue: number;       // Maximum value (usually 127)
+  behavior: ControlBehavior;
+}
+
+export interface CustomMode {
+  name: string;           // Mode name (max 8 chars)
+  controls: Record<string, ControlMapping>;    // Control mappings by ID
+  labels?: Map<number, string>;  // Control labels by ID
+  colors?: Map<number, number>;  // Control colors by ID
+  leds?: Map<number, { color: number; behaviour: string }>; // LED mappings
+  metadata?: {
+    name?: string;
+    description?: string;
+    version?: string;
+    [key: string]: any;
+  };
+  slot?: number;          // Mode slot (0-15)
+}
+
+export interface CustomModeMessage {
+  type: 'custom_mode_response';
+  manufacturerId: number[];
+  slot: number;           // Target slot (0-15)
+  name?: string;
+  controls: Control[];
+  colors: ColorMapping[];
+  data: number[];         // Complete message bytes
+}
+
+export interface ColorMapping {
+  controlId: number;
+  color: number;
+  behaviour?: string; // LED behavior: 'static', 'flash', 'pulse'
+}
+
+export interface ControlMapping {
+  controlId?: number; // Optional - can use string keys in Record instead
+  type?: ControlType; // Optional control type
+  controlType?: ControlType; // Legacy compatibility
+  midiChannel?: number; // Required OR use 'channel' alternative
+  ccNumber?: number; // Required OR use 'cc' alternative
+  cc?: number; // Alternative CC property
+  channel?: number; // Alternative channel property
+  minValue?: number; // Minimum value (default 0)
+  maxValue?: number; // Maximum value (default 127)
+  min?: number; // Alternative min property
+  max?: number; // Alternative max property
+  behavior?: ControlBehavior;
+  behaviour?: string; // Alternative spelling
+  transform?: string | ((value: number) => number); // Value transformation
+}
+
+export interface CustomModeResponse {
+  type: 'custom_mode_response';
+  slot: number;
+  name?: string;
+  controls: Control[];
+  rawData?: number[];
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/types/device.ts b/modules/audio-control/modules/launch-control-xl3/package/src/types/device.ts
new file mode 100644
index 0000000..480daf3
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/types/device.ts
@@ -0,0 +1,164 @@
+/**
+ * Launch Control XL 3 device-specific types
+ */
+
+// Device slot numbers (1-8 for custom modes)
+export type SlotNumber = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;
+
+// Device state machine
+export type DeviceState =
+  | { readonly status: 'disconnected' }
+  | { readonly status: 'connecting'; readonly startTime: number }
+  | {
+      readonly status: 'connected';
+      readonly deviceName: string;
+      readonly portInfo: MidiPortInfo;
+      readonly lastHeartbeat: number;
+    }
+  | {
+      readonly status: 'error';
+      readonly error: Error;
+      readonly retryCount: number;
+    };
+
+// MIDI port information
+export interface MidiPortInfo {
+  readonly id: string;
+  readonly name: string;
+  readonly manufacturer?: string;
+  readonly version?: string;
+  readonly state: 'connected' | 'disconnected';
+  readonly type: 'input' | 'output';
+}
+
+// Device configuration options
+export interface DeviceOptions {
+  readonly retryPolicy?: RetryPolicy;
+  readonly heartbeat?: HeartbeatConfig;
+  readonly errorRecovery?: ErrorRecoveryConfig;
+  readonly timeout?: TimeoutConfig;
+}
+
+export interface RetryPolicy {
+  readonly maxRetries: number;
+  readonly backoffMs: number;
+  readonly exponentialBackoff?: boolean;
+}
+
+export interface HeartbeatConfig {
+  readonly intervalMs: number;
+  readonly timeoutMs?: number;
+  readonly enabled?: boolean;
+}
+
+export interface ErrorRecoveryConfig {
+  readonly autoReconnect: boolean;
+  readonly reconnectDelayMs?: number;
+  readonly maxReconnectAttempts?: number;
+}
+
+export interface TimeoutConfig {
+  readonly connectionMs: number;
+  readonly commandMs: number;
+  readonly sysexMs: number;
+}
+
+// Device operation results
+export interface DeviceOperationResult<T = void> {
+  readonly success: boolean;
+  readonly data?: T;
+  readonly error?: DeviceError;
+  readonly timestamp: number;
+  readonly duration: number; // Operation duration in milliseconds
+}
+
+export interface DeviceError {
+  readonly code: DeviceErrorCode;
+  readonly message: string;
+  readonly originalError?: Error;
+  readonly context?: Record<string, unknown>;
+}
+
+export type DeviceErrorCode =
+  | 'NO_MIDI_SUPPORT'
+  | 'DEVICE_NOT_FOUND'
+  | 'CONNECTION_FAILED'
+  | 'CONNECTION_TIMEOUT'
+  | 'COMMAND_TIMEOUT'
+  | 'SYSEX_ERROR'
+  | 'VALIDATION_ERROR'
+  | 'PROTOCOL_ERROR'
+  | 'DEVICE_BUSY'
+  | 'UNEXPECTED_RESPONSE'
+  | 'MIDIMUNGE_ERROR'
+  | 'CHECKSUM_ERROR';
+
+// Device capabilities and limits
+export interface DeviceCapabilities {
+  readonly customModeSlots: number; // 8 for XL3
+  readonly controlsPerMode: number; // 40 for XL3 (24 knobs + 8 buttons + 8 faders)
+  readonly maxMidiChannels: number; // 16
+  readonly maxCCNumbers: number; // 128
+  readonly firmwareVersion?: string;
+  readonly serialNumber?: string;
+  readonly modelName: string;
+}
+
+// Launch Control XL 3 device information
+export interface LaunchControlXL3Info {
+  readonly manufacturerId: string;
+  readonly deviceFamily: number;
+  readonly modelNumber: number;
+  readonly firmwareVersion: string;
+  readonly serialNumber?: string;
+  readonly deviceName?: string;
+  readonly portInfo?: MidiPortInfo;
+}
+
+// Launch Control XL 3 configuration options
+export interface LaunchControlXL3Config {
+  readonly midiBackend?: unknown; // MidiBackendInterface but avoiding circular dependency
+  readonly autoConnect?: boolean;
+  readonly enableLedControl?: boolean;
+  readonly enableCustomModes?: boolean;
+  readonly enableValueSmoothing?: boolean;
+  readonly smoothingFactor?: number;
+  readonly deviceNameFilter?: string;
+  readonly reconnectOnError?: boolean;
+  readonly reconnectDelay?: number;
+  readonly maxReconnectAttempts?: number;
+  readonly inquiryTimeout?: number;
+  readonly retryAttempts?: number;
+  readonly retryDelay?: number;
+}
+
+// Device modes (factory presets and user modes)
+export type DeviceMode =
+  | 'factory_1'
+  | 'factory_2'
+  | 'factory_3'
+  | 'factory_4'
+  | 'factory_5'
+  | 'factory_6'
+  | 'factory_7'
+  | 'factory_8'
+  | 'user_1'
+  | 'user_2'
+  | 'user_3'
+  | 'user_4'
+  | 'user_5'
+  | 'user_6'
+  | 'user_7'
+  | 'user_8'
+  | 'unknown'
+  | { type: string; slot: number };
+
+// Device connection states
+export type DeviceConnectionState =
+  | 'disconnected'
+  | 'connecting'
+  | 'connected'
+  | 'initializing'
+  | 'ready'
+  | 'error'
+  | 'reconnecting';
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/types/index.ts b/modules/audio-control/modules/launch-control-xl3/package/src/types/index.ts
new file mode 100644
index 0000000..acb9ae5
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/types/index.ts
@@ -0,0 +1,104 @@
+// Re-export types from individual modules (excluding conflicting ones)
+export type {
+  CCNumber,
+  MidiChannel,
+  MidiValue,
+  NoteNumber,
+  Velocity,
+  ControlChangeMessage,
+  NoteOnMessage,
+  NoteOffMessage,
+  PitchBendMessage,
+  SysExMessage,
+  ParsedMidiMessage,
+  MidiParseResult,
+  MidiEventHandlers
+} from './midi.js';
+
+// Export smart constructors (named exports, not types)
+export {
+  CCNumber as createCCNumber,
+  MidiChannel as createMidiChannel,
+  MidiValue as createMidiValue,
+  NoteNumber as createNoteNumber,
+  Velocity as createVelocity
+} from './midi.js';
+
+export type {
+  SlotNumber,
+  DeviceState,
+  DeviceOptions,
+  RetryPolicy,
+  HeartbeatConfig,
+  ErrorRecoveryConfig,
+  TimeoutConfig,
+  DeviceOperationResult,
+  DeviceError,
+  DeviceErrorCode,
+  DeviceCapabilities,
+  LaunchControlXL3Info,
+  LaunchControlXL3Config,
+  DeviceMode,
+  DeviceConnectionState
+} from './device.js';
+
+export type {
+  DeviceInquiryResponse
+} from './sysex.js';
+
+// Re-export protocol types (high-level API)
+export type {
+  ControlId,
+  ControlConfig,
+  ControlColor,
+  ControlRange,
+  ModeTemplate,
+  TemplatePreset,
+  MidiMapping,
+  MidiTarget,
+  ValueTransform,
+  FactoryPreset,
+  PresetCategory,
+  ProtocolValidation,
+  KnobPosition,
+  KnobRow,
+  ButtonPosition,
+  FaderPosition
+} from './protocol.js';
+
+export {
+  DEVICE_LAYOUT,
+  DEFAULT_KNOB_CONFIG,
+  DEFAULT_BUTTON_CONFIG,
+  DEFAULT_FADER_CONFIG
+} from './protocol.js';
+
+// Re-export custom mode types (low-level protocol)
+export type {
+  ControlType as LowLevelControlType,
+  CustomMode as LowLevelCustomMode,
+  CustomMode,
+  ControlBehavior,
+  Control,
+  CustomModeMessage,
+  CustomModeResponse,
+  ControlMapping,
+  ColorMapping
+} from './CustomMode.js';
+
+// Export convenient aliases for commonly used types
+export type { CustomMode as ProtocolCustomMode } from './protocol.js';
+export type { ControlType as ProtocolControlType } from './protocol.js';
+
+// Additional missing exports
+export type CustomModeSlot = number; // 0-15
+export type LedColor = string;
+export type LedBehaviour = 'static' | 'flash' | 'pulse' | 'flashing' | 'pulsing';
+export type ControlBehaviour = 'absolute' | 'relative' | 'toggle';
+
+// Note: These types are already exported above from device.js and sysex.js
+
+// Export control type from CustomMode
+export type {
+  ControlType
+} from './CustomMode.js';
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/types/midi.ts b/modules/audio-control/modules/launch-control-xl3/package/src/types/midi.ts
new file mode 100644
index 0000000..adc8d65
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/types/midi.ts
@@ -0,0 +1,110 @@
+/**
+ * MIDI message types for Launch Control XL 3
+ */
+
+// Branded types for type safety
+export type CCNumber = number & { readonly __brand: 'CCNumber' };
+export type MidiChannel = number & { readonly __brand: 'MidiChannel' };
+export type MidiValue = number & { readonly __brand: 'MidiValue' };
+export type NoteNumber = number & { readonly __brand: 'NoteNumber' };
+export type Velocity = number & { readonly __brand: 'Velocity' };
+
+// Smart constructors with validation
+export const CCNumber = (value: number): CCNumber => {
+  if (value < 0 || value > 127) {
+    throw new Error(`Invalid CC number: ${value}. Must be 0-127.`);
+  }
+  return value as CCNumber;
+};
+
+export const MidiChannel = (value: number): MidiChannel => {
+  if (value < 1 || value > 16) {
+    throw new Error(`Invalid MIDI channel: ${value}. Must be 1-16.`);
+  }
+  return value as MidiChannel;
+};
+
+export const MidiValue = (value: number): MidiValue => {
+  if (value < 0 || value > 127) {
+    throw new Error(`Invalid MIDI value: ${value}. Must be 0-127.`);
+  }
+  return value as MidiValue;
+};
+
+export const NoteNumber = (value: number): NoteNumber => {
+  if (value < 0 || value > 127) {
+    throw new Error(`Invalid note number: ${value}. Must be 0-127.`);
+  }
+  return value as NoteNumber;
+};
+
+export const Velocity = (value: number): Velocity => {
+  if (value < 0 || value > 127) {
+    throw new Error(`Invalid velocity: ${value}. Must be 0-127.`);
+  }
+  return value as Velocity;
+};
+
+// MIDI message interfaces
+export interface MidiMessage {
+  readonly timestamp: number;
+  readonly data: readonly number[];
+}
+
+export interface ControlChangeMessage extends MidiMessage {
+  readonly type: 'controlChange';
+  readonly channel: MidiChannel;
+  readonly cc: CCNumber;
+  readonly value: MidiValue;
+}
+
+export interface NoteOnMessage extends MidiMessage {
+  readonly type: 'noteOn';
+  readonly channel: MidiChannel;
+  readonly note: NoteNumber;
+  readonly velocity: Velocity;
+}
+
+export interface NoteOffMessage extends MidiMessage {
+  readonly type: 'noteOff';
+  readonly channel: MidiChannel;
+  readonly note: NoteNumber;
+  readonly velocity: Velocity;
+}
+
+export interface PitchBendMessage extends MidiMessage {
+  readonly type: 'pitchBend';
+  readonly channel: MidiChannel;
+  readonly value: number; // 14-bit value (0-16383)
+}
+
+export interface SysExMessage extends MidiMessage {
+  readonly type: 'sysEx';
+  readonly manufacturerId: readonly number[];
+  readonly deviceId?: number;
+  readonly data: readonly number[];
+}
+
+export type ParsedMidiMessage =
+  | ControlChangeMessage
+  | NoteOnMessage
+  | NoteOffMessage
+  | PitchBendMessage
+  | SysExMessage;
+
+// MIDI message parsing results
+export interface MidiParseResult {
+  readonly success: boolean;
+  readonly message?: ParsedMidiMessage;
+  readonly error?: string;
+}
+
+// MIDI event handlers
+export interface MidiEventHandlers {
+  readonly controlChange?: (message: ControlChangeMessage) => void;
+  readonly noteOn?: (message: NoteOnMessage) => void;
+  readonly noteOff?: (message: NoteOffMessage) => void;
+  readonly pitchBend?: (message: PitchBendMessage) => void;
+  readonly sysEx?: (message: SysExMessage) => void;
+  readonly raw?: (message: MidiMessage) => void;
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/types/protocol.ts b/modules/audio-control/modules/launch-control-xl3/package/src/types/protocol.ts
new file mode 100644
index 0000000..1c92926
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/types/protocol.ts
@@ -0,0 +1,155 @@
+/**
+ * Launch Control XL 3 protocol message types and control definitions
+ */
+
+import type { CCNumber, MidiChannel } from './midi.js';
+import type { SlotNumber } from './device.js';
+
+// Control types and behaviors
+export type ControlType =
+  | { readonly type: 'knob'; readonly behavior: 'absolute' | 'relative' }
+  | { readonly type: 'button'; readonly behavior: 'momentary' | 'toggle' | 'trigger' }
+  | { readonly type: 'fader'; readonly behavior: 'absolute' };
+
+// Physical control layout positions
+export type KnobPosition = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8; // Row position
+export type KnobRow = 1 | 2 | 3; // 3 rows of 8 knobs each
+export type ButtonPosition = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8; // 8 buttons
+export type FaderPosition = 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8; // 8 faders
+
+// Control identifier combining physical position and type
+export interface ControlId {
+  readonly type: 'knob' | 'button' | 'fader';
+  readonly position: number; // 1-based position
+  readonly row?: KnobRow; // Only for knobs
+}
+
+// Individual control configuration
+export interface ControlConfig {
+  readonly id: ControlId;
+  readonly midiChannel: MidiChannel;
+  readonly ccNumber: CCNumber;
+  readonly controlType: ControlType;
+  readonly name?: string;
+  readonly color?: ControlColor;
+  readonly range?: ControlRange;
+}
+
+// Control color for LED feedback (if supported)
+export interface ControlColor {
+  readonly red: number; // 0-127
+  readonly green: number; // 0-127
+  readonly blue: number; // 0-127
+}
+
+// Control value range mapping
+export interface ControlRange {
+  readonly min: number;
+  readonly max: number;
+  readonly default?: number;
+}
+
+// Complete custom mode configuration
+export interface CustomMode {
+  readonly slot: SlotNumber;
+  readonly name: string;
+  readonly controls: readonly ControlConfig[];
+  readonly globalChannel?: MidiChannel;
+  readonly description?: string;
+  readonly createdAt?: Date;
+  readonly modifiedAt?: Date;
+}
+
+// Template for creating custom modes
+export interface ModeTemplate {
+  readonly name: string;
+  readonly description?: string;
+  readonly controls: readonly Omit<ControlConfig, 'id'>[];
+  readonly presets?: readonly TemplatePreset[];
+}
+
+export interface TemplatePreset {
+  readonly name: string;
+  readonly description?: string;
+  readonly values: Record<string, number>; // Control ID -> value mapping
+}
+
+// MIDI mapping definition
+export interface MidiMapping {
+  readonly source: ControlId;
+  readonly target: MidiTarget;
+  readonly transform?: ValueTransform;
+}
+
+export interface MidiTarget {
+  readonly type: 'cc' | 'note' | 'pitchBend' | 'aftertouch';
+  readonly channel: MidiChannel;
+  readonly number?: CCNumber; // For CC and note messages
+}
+
+export interface ValueTransform {
+  readonly type: 'linear' | 'logarithmic' | 'exponential' | 'curve' | 'stepped' | 'toggle' | 'invert' | 'bipolar';
+  readonly inputRange: [number, number];
+  readonly outputRange: [number, number];
+  readonly curve?: readonly number[]; // For custom curve transforms
+  readonly steps?: number; // For stepped transforms
+  readonly threshold?: number; // For toggle transforms
+}
+
+// Device layout constants
+export const DEVICE_LAYOUT = {
+  KNOBS: {
+    TOTAL: 24,
+    ROWS: 3,
+    PER_ROW: 8,
+  },
+  BUTTONS: {
+    TOTAL: 8,
+  },
+  FADERS: {
+    TOTAL: 8,
+  },
+} as const;
+
+// Default control configurations
+export const DEFAULT_KNOB_CONFIG: Omit<ControlConfig, 'id'> = {
+  midiChannel: 1 as MidiChannel,
+  ccNumber: 1 as CCNumber,
+  controlType: { type: 'knob', behavior: 'absolute' },
+} as const;
+
+export const DEFAULT_BUTTON_CONFIG: Omit<ControlConfig, 'id'> = {
+  midiChannel: 1 as MidiChannel,
+  ccNumber: 1 as CCNumber,
+  controlType: { type: 'button', behavior: 'momentary' },
+} as const;
+
+export const DEFAULT_FADER_CONFIG: Omit<ControlConfig, 'id'> = {
+  midiChannel: 1 as MidiChannel,
+  ccNumber: 1 as CCNumber,
+  controlType: { type: 'fader', behavior: 'absolute' },
+} as const;
+
+// Factory preset mode definitions
+export interface FactoryPreset {
+  readonly id: string;
+  readonly name: string;
+  readonly description: string;
+  readonly mode: Omit<CustomMode, 'slot'>;
+  readonly category: PresetCategory;
+}
+
+export type PresetCategory =
+  | 'daw'
+  | 'synthesizer'
+  | 'drums'
+  | 'effects'
+  | 'utility'
+  | 'custom';
+
+// Protocol validation schemas (runtime types)
+export interface ProtocolValidation {
+  readonly customMode: (data: unknown) => data is CustomMode;
+  readonly controlConfig: (data: unknown) => data is ControlConfig;
+  readonly modeTemplate: (data: unknown) => data is ModeTemplate;
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/types/sysex.ts b/modules/audio-control/modules/launch-control-xl3/package/src/types/sysex.ts
new file mode 100644
index 0000000..d95db17
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/types/sysex.ts
@@ -0,0 +1,117 @@
+/**
+ * SysEx message types for Launch Control XL 3 communication
+ */
+
+import type { SlotNumber } from './device.js';
+
+// Novation manufacturer ID and device-specific identifiers
+export const NOVATION_MANUFACTURER_ID = [0x00, 0x20, 0x29] as const;
+export const XL3_DEVICE_ID = [0x02, 0x0D] as const; // Device family and model
+
+// SysEx command types
+export type SysExCommand =
+  | 'deviceInquiry'
+  | 'modeRead'
+  | 'modeWrite'
+  | 'factoryReset'
+  | 'heartbeat'
+  | 'versionRequest'
+  | 'serialNumberRequest';
+
+// Template literal types for SysEx message validation
+export type SysExHeader = `F0 ${string}`;
+export type NovationSysExHeader = `F0 00 20 29 ${string}`;
+export type XL3SysExHeader = `${NovationSysExHeader} 02 0D ${string}`;
+
+// SysEx message structure
+export interface SysExMessageData {
+  readonly command: SysExCommand;
+  readonly slot?: SlotNumber;
+  readonly payload?: readonly number[];
+  readonly checksum?: number;
+}
+
+// Parsed SysEx message
+export interface ParsedSysExMessage {
+  readonly manufacturerId: readonly number[];
+  readonly deviceId: readonly number[];
+  readonly command: SysExCommand;
+  readonly slot?: SlotNumber;
+  readonly payload: readonly number[];
+  readonly checksum: number;
+  readonly rawData: readonly number[];
+}
+
+// SysEx parsing result
+export interface SysExParseResult {
+  readonly success: boolean;
+  readonly message?: ParsedSysExMessage;
+  readonly error?: string;
+}
+
+// SysEx command definitions with their opcodes
+export const SYSEX_COMMANDS = {
+  deviceInquiry: 0x7E, // Standard MIDI device inquiry
+  modeRead: 0x45, // Read custom mode from slot
+  modeWrite: 0x46, // Write custom mode to slot
+  factoryReset: 0x47, // Reset device to factory settings
+  heartbeat: 0x48, // Heartbeat/ping command
+  versionRequest: 0x49, // Request firmware version
+  serialNumberRequest: 0x4A, // Request device serial number
+} as const;
+
+export type SysExOpcode = typeof SYSEX_COMMANDS[keyof typeof SYSEX_COMMANDS];
+
+// SysEx message builder options
+export interface SysExMessageOptions {
+  readonly command: SysExCommand;
+  readonly slot?: SlotNumber;
+  readonly payload?: readonly number[];
+  readonly includeChecksum?: boolean;
+}
+
+// Midimunge encoding/decoding for 7-bit safe data transmission
+export interface MidimungeResult {
+  readonly success: boolean;
+  readonly data?: readonly number[];
+  readonly error?: string;
+  readonly originalLength?: number;
+  readonly encodedLength?: number;
+}
+
+// Device response types
+export interface DeviceInquiryResponse {
+  readonly manufacturerId: readonly number[];
+  readonly deviceFamily: number;
+  readonly deviceModel: number;
+  readonly firmwareVersion: readonly number[];
+  readonly serialNumber?: readonly number[];
+  // Additional properties used in code
+  readonly familyCode?: number;
+  readonly familyMember?: number;
+  readonly softwareRevision?: readonly number[];
+}
+
+export interface ModeReadResponse {
+  readonly slot: SlotNumber;
+  readonly modeData: readonly number[];
+  readonly checksum: number;
+}
+
+export interface ModeWriteResponse {
+  readonly slot: SlotNumber;
+  readonly success: boolean;
+  readonly error?: string;
+}
+
+export interface VersionResponse {
+  readonly major: number;
+  readonly minor: number;
+  readonly patch: number;
+  readonly build?: number;
+}
+
+export interface HeartbeatResponse {
+  readonly timestamp: number;
+  readonly deviceStatus: number;
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/utils/bitwise.ts b/modules/audio-control/modules/launch-control-xl3/package/src/utils/bitwise.ts
new file mode 100644
index 0000000..d30fedb
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/utils/bitwise.ts
@@ -0,0 +1,231 @@
+/**
+ * Bit manipulation helpers for MIDI data processing
+ */
+
+/**
+ * Extract specific bits from a byte
+ */
+export function extractBits(byte: number, startBit: number, length: number): number {
+  const mask = (1 << length) - 1;
+  return (byte >>> startBit) & mask;
+}
+
+/**
+ * Set specific bits in a byte
+ */
+export function setBits(byte: number, startBit: number, length: number, value: number): number {
+  const mask = ((1 << length) - 1) << startBit;
+  return (byte & ~mask) | ((value << startBit) & mask);
+}
+
+/**
+ * Check if a specific bit is set
+ */
+export function isBitSet(byte: number, bitIndex: number): boolean {
+  return (byte & (1 << bitIndex)) !== 0;
+}
+
+/**
+ * Set a specific bit to 1
+ */
+export function setBit(byte: number, bitIndex: number): number {
+  return byte | (1 << bitIndex);
+}
+
+/**
+ * Clear a specific bit (set to 0)
+ */
+export function clearBit(byte: number, bitIndex: number): number {
+  return byte & ~(1 << bitIndex);
+}
+
+/**
+ * Toggle a specific bit
+ */
+export function toggleBit(byte: number, bitIndex: number): number {
+  return byte ^ (1 << bitIndex);
+}
+
+/**
+ * Convert two 7-bit bytes to a 14-bit value (MSB, LSB)
+ */
+export function bytes7To14Bit(msb: number, lsb: number): number {
+  return ((msb & 0x7F) << 7) | (lsb & 0x7F);
+}
+
+/**
+ * Convert a 14-bit value to two 7-bit bytes [MSB, LSB]
+ */
+export function value14To7Bit(value: number): [number, number] {
+  const clamped = Math.max(0, Math.min(16383, value));
+  const msb = (clamped >>> 7) & 0x7F;
+  const lsb = clamped & 0x7F;
+  return [msb, lsb];
+}
+
+/**
+ * Ensure a value is within 7-bit range (0-127)
+ */
+export function clampTo7Bit(value: number): number {
+  return Math.max(0, Math.min(127, Math.floor(value)));
+}
+
+/**
+ * Ensure a value is within 14-bit range (0-16383)
+ */
+export function clampTo14Bit(value: number): number {
+  return Math.max(0, Math.min(16383, Math.floor(value)));
+}
+
+/**
+ * Calculate XOR checksum for data integrity
+ */
+export function calculateXORChecksum(data: readonly number[]): number {
+  return data.reduce((checksum, byte) => checksum ^ byte, 0) & 0x7F;
+}
+
+/**
+ * Calculate sum checksum for data integrity
+ */
+export function calculateSumChecksum(data: readonly number[]): number {
+  return data.reduce((checksum, byte) => checksum + byte, 0) & 0x7F;
+}
+
+/**
+ * Pack multiple 4-bit values into bytes
+ */
+export function pack4BitValues(values: readonly number[]): number[] {
+  const result: number[] = [];
+
+  for (let i = 0; i < values.length; i += 2) {
+    const high = (values[i] || 0) & 0x0F;
+    const low = (values[i + 1] || 0) & 0x0F;
+    result.push((high << 4) | low);
+  }
+
+  return result;
+}
+
+/**
+ * Unpack bytes into 4-bit values
+ */
+export function unpack4BitValues(data: readonly number[]): number[] {
+  const result: number[] = [];
+
+  for (const byte of data) {
+    result.push((byte >>> 4) & 0x0F);
+    result.push(byte & 0x0F);
+  }
+
+  return result;
+}
+
+/**
+ * Convert byte array to binary string representation
+ */
+export function bytesToBinary(data: readonly number[]): string {
+  return data.map(byte => byte.toString(2).padStart(8, '0')).join(' ');
+}
+
+/**
+ * Convert binary string to byte array
+ */
+export function binaryToBytes(binary: string): number[] {
+  const cleanBinary = binary.replace(/\s/g, '');
+  const result: number[] = [];
+
+  for (let i = 0; i < cleanBinary.length; i += 8) {
+    const chunk = cleanBinary.slice(i, i + 8);
+    if (chunk.length === 8) {
+      result.push(parseInt(chunk, 2));
+    }
+  }
+
+  return result;
+}
+
+/**
+ * Rotate bits left
+ */
+export function rotateLeft(value: number, positions: number, width: number = 8): number {
+  const mask = (1 << width) - 1;
+  const normalizedValue = value & mask;
+  const normalizedPositions = positions % width;
+
+  return ((normalizedValue << normalizedPositions) | (normalizedValue >>> (width - normalizedPositions))) & mask;
+}
+
+/**
+ * Rotate bits right
+ */
+export function rotateRight(value: number, positions: number, width: number = 8): number {
+  const mask = (1 << width) - 1;
+  const normalizedValue = value & mask;
+  const normalizedPositions = positions % width;
+
+  return ((normalizedValue >>> normalizedPositions) | (normalizedValue << (width - normalizedPositions))) & mask;
+}
+
+/**
+ * Count the number of set bits in a byte
+ */
+export function popCount(byte: number): number {
+  let count = 0;
+  let value = byte;
+
+  while (value) {
+    count += value & 1;
+    value >>>= 1;
+  }
+
+  return count;
+}
+
+/**
+ * Find the position of the least significant bit
+ */
+export function findLSB(byte: number): number {
+  if (byte === 0) return -1;
+
+  let position = 0;
+  let value = byte;
+
+  while ((value & 1) === 0) {
+    value >>>= 1;
+    position++;
+  }
+
+  return position;
+}
+
+/**
+ * Find the position of the most significant bit
+ */
+export function findMSB(byte: number): number {
+  if (byte === 0) return -1;
+
+  let position = 0;
+  let value = byte;
+
+  while (value > 1) {
+    value >>>= 1;
+    position++;
+  }
+
+  return position;
+}
+
+/**
+ * Reverse the bits in a byte
+ */
+export function reverseBits(byte: number): number {
+  let result = 0;
+  let value = byte;
+
+  for (let i = 0; i < 8; i++) {
+    result = (result << 1) | (value & 1);
+    value >>>= 1;
+  }
+
+  return result;
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/utils/constants.ts b/modules/audio-control/modules/launch-control-xl3/package/src/utils/constants.ts
new file mode 100644
index 0000000..b2e0bf4
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/utils/constants.ts
@@ -0,0 +1,90 @@
+/**
+ * Device constants with const assertions for zero-cost abstractions
+ */
+
+// Novation manufacturer and device identification
+export const NOVATION_MANUFACTURER_ID = [0x00, 0x20, 0x29] as const;
+export const XL3_DEVICE_ID = [0x02, 0x0D] as const;
+export const DEVICE_NAME = 'Launch Control XL 3' as const;
+
+// SysEx message constants
+export const SYSEX_START = 0xF0 as const;
+export const SYSEX_END = 0xF7 as const;
+
+// Device capabilities
+export const DEVICE_CAPABILITIES = {
+  CUSTOM_MODE_SLOTS: 8,
+  KNOBS_TOTAL: 24,
+  KNOBS_PER_ROW: 8,
+  KNOBS_ROWS: 3,
+  BUTTONS_TOTAL: 8,
+  FADERS_TOTAL: 8,
+  MAX_MIDI_CHANNELS: 16,
+  MAX_CC_NUMBERS: 128,
+} as const;
+
+// MIDI value ranges
+export const MIDI_RANGES = {
+  CHANNEL: { MIN: 1, MAX: 16 } as const,
+  CC_NUMBER: { MIN: 0, MAX: 127 } as const,
+  CC_VALUE: { MIN: 0, MAX: 127 } as const,
+  NOTE: { MIN: 0, MAX: 127 } as const,
+  VELOCITY: { MIN: 0, MAX: 127 } as const,
+  PITCH_BEND: { MIN: 0, MAX: 16383 } as const,
+} as const;
+
+// Protocol timing constants
+export const TIMING = {
+  CONNECTION_TIMEOUT_MS: 5000,
+  COMMAND_TIMEOUT_MS: 2000,
+  SYSEX_TIMEOUT_MS: 3000,
+  HEARTBEAT_INTERVAL_MS: 5000,
+  RETRY_DELAY_MS: 1000,
+  MAX_RETRIES: 3,
+} as const;
+
+// SysEx command opcodes
+export const SYSEX_OPCODES = {
+  DEVICE_INQUIRY: 0x7E,
+  MODE_READ: 0x45,
+  MODE_WRITE: 0x46,
+  FACTORY_RESET: 0x47,
+  HEARTBEAT: 0x48,
+  VERSION_REQUEST: 0x49,
+  SERIAL_NUMBER_REQUEST: 0x4A,
+} as const;
+
+// Default control configurations
+export const DEFAULT_CONTROLS = {
+  KNOB: {
+    CHANNEL: 1,
+    CC_START: 21,
+    BEHAVIOR: 'absolute',
+  },
+  BUTTON: {
+    CHANNEL: 1,
+    CC_START: 41,
+    BEHAVIOR: 'momentary',
+  },
+  FADER: {
+    CHANNEL: 1,
+    CC_START: 77,
+    BEHAVIOR: 'absolute',
+  },
+} as const;
+
+// Error codes
+export const ERROR_CODES = {
+  NO_MIDI_SUPPORT: 'NO_MIDI_SUPPORT',
+  DEVICE_NOT_FOUND: 'DEVICE_NOT_FOUND',
+  CONNECTION_FAILED: 'CONNECTION_FAILED',
+  CONNECTION_TIMEOUT: 'CONNECTION_TIMEOUT',
+  COMMAND_TIMEOUT: 'COMMAND_TIMEOUT',
+  SYSEX_ERROR: 'SYSEX_ERROR',
+  VALIDATION_ERROR: 'VALIDATION_ERROR',
+  PROTOCOL_ERROR: 'PROTOCOL_ERROR',
+  DEVICE_BUSY: 'DEVICE_BUSY',
+  UNEXPECTED_RESPONSE: 'UNEXPECTED_RESPONSE',
+  MIDIMUNGE_ERROR: 'MIDIMUNGE_ERROR',
+  CHECKSUM_ERROR: 'CHECKSUM_ERROR',
+} as const;
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/utils/converters.ts b/modules/audio-control/modules/launch-control-xl3/package/src/utils/converters.ts
new file mode 100644
index 0000000..d1206a8
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/utils/converters.ts
@@ -0,0 +1,206 @@
+/**
+ * Format converters with type guards for data transformation
+ */
+
+import type { CustomMode, ControlConfig } from '@/types/protocol.js';
+import type { ParsedMidiMessage } from '@/types/midi.js';
+
+/**
+ * Convert custom mode to JSON-serializable format
+ */
+export function customModeToJSON(mode: CustomMode): string {
+  return JSON.stringify(
+    {
+      ...mode,
+      createdAt: mode.createdAt?.toISOString(),
+      modifiedAt: mode.modifiedAt?.toISOString(),
+    },
+    null,
+    2
+  );
+}
+
+/**
+ * Convert JSON back to CustomMode with proper Date objects
+ */
+export function customModeFromJSON(json: string): CustomMode {
+  const parsed = JSON.parse(json);
+
+  return {
+    ...parsed,
+    createdAt: parsed.createdAt ? new Date(parsed.createdAt) : undefined,
+    modifiedAt: parsed.modifiedAt ? new Date(parsed.modifiedAt) : undefined,
+  };
+}
+
+/**
+ * Convert CustomMode to YAML-compatible object
+ */
+export function customModeToYAML(mode: CustomMode): Record<string, unknown> {
+  return {
+    slot: mode.slot,
+    name: mode.name,
+    description: mode.description,
+    globalChannel: mode.globalChannel,
+    controls: mode.controls.map(controlToYAML),
+    metadata: {
+      createdAt: mode.createdAt?.toISOString(),
+      modifiedAt: mode.modifiedAt?.toISOString(),
+    },
+  };
+}
+
+/**
+ * Convert ControlConfig to YAML-compatible object
+ */
+function controlToYAML(control: ControlConfig): Record<string, unknown> {
+  return {
+    id: {
+      type: control.id.type,
+      position: control.id.position,
+      row: control.id.row,
+    },
+    midi: {
+      channel: control.midiChannel,
+      cc: control.ccNumber,
+    },
+    behavior: control.controlType.behavior,
+    name: control.name,
+    color: control.color,
+    range: control.range,
+  };
+}
+
+/**
+ * Convert MIDI message to human-readable string
+ */
+export function midiMessageToString(message: ParsedMidiMessage): string {
+  switch (message.type) {
+    case 'controlChange':
+      return `CC ${message.cc} = ${message.value} (ch ${message.channel})`;
+
+    case 'noteOn':
+      return `Note On ${message.note} vel ${message.velocity} (ch ${message.channel})`;
+
+    case 'noteOff':
+      return `Note Off ${message.note} (ch ${message.channel})`;
+
+    case 'pitchBend':
+      return `Pitch Bend ${message.value} (ch ${message.channel})`;
+
+    case 'sysEx':
+      return `SysEx ${message.data.length} bytes`;
+
+    default:
+      return `Unknown MIDI message`;
+  }
+}
+
+/**
+ * Convert raw MIDI data to hex string
+ */
+export function midiDataToHex(data: readonly number[]): string {
+  return data.map(byte => byte.toString(16).toUpperCase().padStart(2, '0')).join(' ');
+}
+
+/**
+ * Convert hex string to MIDI data array
+ */
+export function hexToMidiData(hex: string): number[] {
+  return hex
+    .split(/\s+/)
+    .filter(byte => byte.length > 0)
+    .map(byte => parseInt(byte, 16))
+    .filter(byte => !isNaN(byte) && byte >= 0 && byte <= 255);
+}
+
+/**
+ * Type guard to check if data represents a valid CustomMode
+ */
+export function isCustomModeData(data: unknown): data is CustomMode {
+  return (
+    typeof data === 'object' &&
+    data !== null &&
+    'slot' in data &&
+    'name' in data &&
+    'controls' in data
+  );
+}
+
+/**
+ * Type guard to check if data represents a valid ControlConfig
+ */
+export function isControlConfigData(data: unknown): data is ControlConfig {
+  return (
+    typeof data === 'object' &&
+    data !== null &&
+    'id' in data &&
+    'midiChannel' in data &&
+    'ccNumber' in data &&
+    'controlType' in data
+  );
+}
+
+/**
+ * Convert control position to linear index
+ */
+export function controlPositionToIndex(type: 'knob' | 'button' | 'fader', position: number, row?: number): number {
+  switch (type) {
+    case 'knob':
+      if (!row || row < 1 || row > 3) {
+        throw new Error('Knob controls require a row number (1-3)');
+      }
+      return (row - 1) * 8 + (position - 1);
+
+    case 'button':
+      return position - 1;
+
+    case 'fader':
+      return position - 1;
+
+    default:
+      throw new Error(`Unknown control type: ${type}`);
+  }
+}
+
+/**
+ * Convert linear index back to control position
+ */
+export function indexToControlPosition(type: 'knob' | 'button' | 'fader', index: number): { position: number; row?: number } {
+  switch (type) {
+    case 'knob':
+      const row = Math.floor(index / 8) + 1;
+      const position = (index % 8) + 1;
+      return { position, row };
+
+    case 'button':
+    case 'fader':
+      return { position: index + 1 };
+
+    default:
+      throw new Error(`Unknown control type: ${type}`);
+  }
+}
+
+/**
+ * Convert between different CC numbering schemes
+ */
+export function convertCCNumbering(
+  ccNumber: number,
+  fromScheme: 'zero-based' | 'one-based',
+  toScheme: 'zero-based' | 'one-based'
+): number {
+  if (fromScheme === toScheme) {
+    return ccNumber;
+  }
+
+  if (fromScheme === 'zero-based' && toScheme === 'one-based') {
+    return ccNumber + 1;
+  }
+
+  if (fromScheme === 'one-based' && toScheme === 'zero-based') {
+    return ccNumber - 1;
+  }
+
+  return ccNumber;
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/utils/helpers.ts b/modules/audio-control/modules/launch-control-xl3/package/src/utils/helpers.ts
new file mode 100644
index 0000000..69ae30a
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/utils/helpers.ts
@@ -0,0 +1,265 @@
+/**
+ * Utility functions with overloads for common operations
+ */
+
+import type { SlotNumber, DeviceOperationResult } from '@/types/device.js';
+import type { CCNumber, MidiChannel, MidiValue } from '@/types/midi.js';
+
+/**
+ * Create a DeviceOperationResult with timing information
+ */
+export function createOperationResult<T = void>(
+  success: boolean,
+  data?: T,
+  error?: Error,
+  startTime: number = Date.now()
+): DeviceOperationResult<T> {
+  const timestamp = Date.now();
+  const duration = timestamp - startTime;
+
+  const result: DeviceOperationResult<T> = {
+    success,
+    timestamp,
+    duration,
+  };
+
+  if (data !== undefined) {
+    (result as any).data = data;
+  }
+
+  if (error !== undefined) {
+    (result as any).error = {
+      code: 'PROTOCOL_ERROR' as const,
+      message: error.message,
+      originalError: error,
+    };
+  }
+
+  return result;
+}
+
+/**
+ * Delay execution for specified milliseconds
+ */
+export function delay(ms: number): Promise<void> {
+  return new Promise(resolve => setTimeout(resolve, ms));
+}
+
+/**
+ * Retry an async operation with exponential backoff
+ */
+export async function retryWithBackoff<T>(
+  operation: () => Promise<T>,
+  maxRetries: number = 3,
+  baseDelayMs: number = 1000,
+  exponential: boolean = true
+): Promise<T> {
+  let lastError: Error | undefined;
+
+  for (let attempt = 0; attempt <= maxRetries; attempt++) {
+    try {
+      return await operation();
+    } catch (error) {
+      lastError = error instanceof Error ? error : new Error(String(error));
+
+      if (attempt === maxRetries) {
+        break;
+      }
+
+      const delayMs = exponential
+        ? baseDelayMs * Math.pow(2, attempt)
+        : baseDelayMs;
+
+      await delay(delayMs);
+    }
+  }
+
+  throw lastError || new Error('Maximum retry attempts exceeded');
+}
+
+/**
+ * Create a timeout promise that rejects after specified milliseconds
+ */
+export function withTimeout<T>(promise: Promise<T>, timeoutMs: number): Promise<T> {
+  const timeoutPromise = new Promise<never>((_, reject) => {
+    setTimeout(() => reject(new Error(`Operation timed out after ${timeoutMs}ms`)), timeoutMs);
+  });
+
+  return Promise.race([promise, timeoutPromise]);
+}
+
+/**
+ * Clamp a number between min and max values
+ */
+export function clamp(value: number, min: number, max: number): number {
+  return Math.min(Math.max(value, min), max);
+}
+
+/**
+ * Map a value from one range to another
+ */
+export function mapRange(
+  value: number,
+  fromMin: number,
+  fromMax: number,
+  toMin: number,
+  toMax: number
+): number {
+  if (fromMin === fromMax) {
+    return toMin;
+  }
+
+  const normalized = (value - fromMin) / (fromMax - fromMin);
+  return toMin + normalized * (toMax - toMin);
+}
+
+/**
+ * Validate slot number (overloaded for type safety)
+ */
+export function validateSlotNumber(slot: number): SlotNumber;
+export function validateSlotNumber(slot: unknown): SlotNumber;
+export function validateSlotNumber(slot: unknown): SlotNumber {
+  const num = typeof slot === 'number' ? slot : Number(slot);
+
+  if (!Number.isInteger(num) || num < 1 || num > 8) {
+    throw new Error(`Invalid slot number: ${slot}. Must be 1-8.`);
+  }
+
+  return num as SlotNumber;
+}
+
+/**
+ * Validate MIDI channel (overloaded for type safety)
+ */
+export function validateMidiChannel(channel: number): MidiChannel;
+export function validateMidiChannel(channel: unknown): MidiChannel;
+export function validateMidiChannel(channel: unknown): MidiChannel {
+  const num = typeof channel === 'number' ? channel : Number(channel);
+
+  if (!Number.isInteger(num) || num < 1 || num > 16) {
+    throw new Error(`Invalid MIDI channel: ${channel}. Must be 1-16.`);
+  }
+
+  return num as MidiChannel;
+}
+
+/**
+ * Validate CC number (overloaded for type safety)
+ */
+export function validateCCNumber(cc: number): CCNumber;
+export function validateCCNumber(cc: unknown): CCNumber;
+export function validateCCNumber(cc: unknown): CCNumber {
+  const num = typeof cc === 'number' ? cc : Number(cc);
+
+  if (!Number.isInteger(num) || num < 0 || num > 127) {
+    throw new Error(`Invalid CC number: ${cc}. Must be 0-127.`);
+  }
+
+  return num as CCNumber;
+}
+
+/**
+ * Validate MIDI value (overloaded for type safety)
+ */
+export function validateMidiValue(value: number): MidiValue;
+export function validateMidiValue(value: unknown): MidiValue;
+export function validateMidiValue(value: unknown): MidiValue {
+  const num = typeof value === 'number' ? value : Number(value);
+
+  if (!Number.isInteger(num) || num < 0 || num > 127) {
+    throw new Error(`Invalid MIDI value: ${value}. Must be 0-127.`);
+  }
+
+  return num as MidiValue;
+}
+
+/**
+ * Generate a unique ID for tracking operations
+ */
+export function generateOperationId(): string {
+  return `${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
+}
+
+/**
+ * Calculate checksum for data integrity
+ */
+export function calculateChecksum(data: readonly number[]): number {
+  return data.reduce((sum, byte) => (sum + byte) & 0x7F, 0);
+}
+
+/**
+ * Verify checksum matches expected value
+ */
+export function verifyChecksum(data: readonly number[], expectedChecksum: number): boolean {
+  return calculateChecksum(data) === expectedChecksum;
+}
+
+/**
+ * Convert milliseconds to human-readable duration string
+ */
+export function formatDuration(milliseconds: number): string {
+  if (milliseconds < 1000) {
+    return `${milliseconds}ms`;
+  }
+
+  if (milliseconds < 60000) {
+    return `${(milliseconds / 1000).toFixed(1)}s`;
+  }
+
+  const minutes = Math.floor(milliseconds / 60000);
+  const seconds = ((milliseconds % 60000) / 1000).toFixed(1);
+  return `${minutes}m ${seconds}s`;
+}
+
+/**
+ * Create a debounced function that delays execution
+ */
+export function debounce<T extends (...args: any[]) => any>(
+  func: T,
+  delayMs: number
+): (...args: Parameters<T>) => void {
+  let timeoutId: NodeJS.Timeout | undefined;
+
+  return (...args: Parameters<T>) => {
+    if (timeoutId) {
+      clearTimeout(timeoutId);
+    }
+
+    timeoutId = setTimeout(() => {
+      func(...args);
+    }, delayMs);
+  };
+}
+
+/**
+ * Create a throttled function that limits execution frequency
+ */
+export function throttle<T extends (...args: any[]) => any>(
+  func: T,
+  delayMs: number
+): (...args: Parameters<T>) => void {
+  let lastExecution = 0;
+
+  return (...args: Parameters<T>) => {
+    const now = Date.now();
+
+    if (now - lastExecution >= delayMs) {
+      lastExecution = now;
+      func(...args);
+    }
+  };
+}
+
+/**
+ * Safe JSON parsing with error handling
+ */
+export function safeJsonParse<T = unknown>(json: string): { success: boolean; data?: T; error?: string } {
+  try {
+    return { success: true, data: JSON.parse(json) };
+  } catch (error) {
+    return {
+      success: false,
+      error: error instanceof Error ? error.message : 'Unknown parsing error',
+    };
+  }
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/utils/performance.ts b/modules/audio-control/modules/launch-control-xl3/package/src/utils/performance.ts
new file mode 100644
index 0000000..651c554
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/utils/performance.ts
@@ -0,0 +1,336 @@
+/**
+ * Performance utilities and metrics for real-time MIDI operations
+ */
+
+/**
+ * High-resolution performance timer
+ */
+export class PerformanceTimer {
+  private startTime: number;
+  private measurements: number[] = [];
+
+  constructor() {
+    this.startTime = performance.now();
+  }
+
+  /**
+   * Start a new measurement
+   */
+  start(): void {
+    this.startTime = performance.now();
+  }
+
+  /**
+   * End the current measurement and return duration in milliseconds
+   */
+  end(): number {
+    const duration = performance.now() - this.startTime;
+    this.measurements.push(duration);
+    return duration;
+  }
+
+  /**
+   * Get statistics for all measurements
+   */
+  getStats(): PerformanceStats {
+    if (this.measurements.length === 0) {
+      return {
+        count: 0,
+        min: 0,
+        max: 0,
+        mean: 0,
+        median: 0,
+        p95: 0,
+        p99: 0,
+      };
+    }
+
+    const sorted = [...this.measurements].sort((a, b) => a - b);
+    const count = sorted.length;
+    const sum = sorted.reduce((a, b) => a + b, 0);
+
+    return {
+      count,
+      min: sorted[0]!,
+      max: sorted[count - 1]!,
+      mean: sum / count,
+      median: sorted[Math.floor(count / 2)]!,
+      p95: sorted[Math.floor(count * 0.95)]!,
+      p99: sorted[Math.floor(count * 0.99)]!,
+    };
+  }
+
+  /**
+   * Reset all measurements
+   */
+  reset(): void {
+    this.measurements = [];
+  }
+}
+
+export interface PerformanceStats {
+  count: number;
+  min: number;
+  max: number;
+  mean: number;
+  median: number;
+  p95: number;
+  p99: number;
+}
+
+/**
+ * Memory usage tracker
+ */
+export class MemoryTracker {
+  private initialUsage: NodeJS.MemoryUsage;
+  private measurements: NodeJS.MemoryUsage[] = [];
+
+  constructor() {
+    this.initialUsage = process.memoryUsage();
+  }
+
+  /**
+   * Take a memory usage snapshot
+   */
+  snapshot(): NodeJS.MemoryUsage {
+    const usage = process.memoryUsage();
+    this.measurements.push(usage);
+    return usage;
+  }
+
+  /**
+   * Get memory usage delta from initial snapshot
+   */
+  getDelta(): MemoryDelta {
+    const current = process.memoryUsage();
+    return {
+      rss: current.rss - this.initialUsage.rss,
+      heapTotal: current.heapTotal - this.initialUsage.heapTotal,
+      heapUsed: current.heapUsed - this.initialUsage.heapUsed,
+      external: current.external - this.initialUsage.external,
+      arrayBuffers: current.arrayBuffers - this.initialUsage.arrayBuffers,
+    };
+  }
+
+  /**
+   * Format memory usage in human-readable format
+   */
+  formatUsage(usage: NodeJS.MemoryUsage): string {
+    const formatBytes = (bytes: number): string => {
+      const mb = bytes / (1024 * 1024);
+      return `${mb.toFixed(1)}MB`;
+    };
+
+    return [
+      `RSS: ${formatBytes(usage.rss)}`,
+      `Heap Total: ${formatBytes(usage.heapTotal)}`,
+      `Heap Used: ${formatBytes(usage.heapUsed)}`,
+      `External: ${formatBytes(usage.external)}`,
+      `Array Buffers: ${formatBytes(usage.arrayBuffers)}`,
+    ].join(', ');
+  }
+}
+
+export interface MemoryDelta {
+  rss: number;
+  heapTotal: number;
+  heapUsed: number;
+  external: number;
+  arrayBuffers: number;
+}
+
+/**
+ * MIDI latency measurement
+ */
+export class LatencyMeasurement {
+  private sendTimes = new Map<string, number>();
+  private latencies: number[] = [];
+
+  /**
+   * Record when a MIDI message was sent
+   */
+  recordSend(messageId: string): void {
+    this.sendTimes.set(messageId, performance.now());
+  }
+
+  /**
+   * Record when a MIDI response was received
+   */
+  recordReceive(messageId: string): number | undefined {
+    const sendTime = this.sendTimes.get(messageId);
+    if (sendTime === undefined) {
+      return undefined;
+    }
+
+    const latency = performance.now() - sendTime;
+    this.latencies.push(latency);
+    this.sendTimes.delete(messageId);
+
+    return latency;
+  }
+
+  /**
+   * Get latency statistics
+   */
+  getStats(): PerformanceStats {
+    if (this.latencies.length === 0) {
+      return {
+        count: 0,
+        min: 0,
+        max: 0,
+        mean: 0,
+        median: 0,
+        p95: 0,
+        p99: 0,
+      };
+    }
+
+    const sorted = [...this.latencies].sort((a, b) => a - b);
+    const count = sorted.length;
+    const sum = sorted.reduce((a, b) => a + b, 0);
+
+    return {
+      count,
+      min: sorted[0]!,
+      max: sorted[count - 1]!,
+      mean: sum / count,
+      median: sorted[Math.floor(count / 2)]!,
+      p95: sorted[Math.floor(count * 0.95)]!,
+      p99: sorted[Math.floor(count * 0.99)]!,
+    };
+  }
+
+  /**
+   * Clear all measurements
+   */
+  clear(): void {
+    this.sendTimes.clear();
+    this.latencies = [];
+  }
+}
+
+/**
+ * Throughput measurement for MIDI messages
+ */
+export class ThroughputMeasurement {
+  private messageCount = 0;
+  private startTime = performance.now();
+  private measurements: { timestamp: number; count: number }[] = [];
+
+  /**
+   * Record a processed message
+   */
+  recordMessage(): void {
+    this.messageCount++;
+  }
+
+  /**
+   * Take a throughput measurement
+   */
+  measure(): ThroughputStats {
+    const now = performance.now();
+    const elapsed = (now - this.startTime) / 1000; // Convert to seconds
+    const messagesPerSecond = elapsed > 0 ? this.messageCount / elapsed : 0;
+
+    const stats = {
+      messagesPerSecond,
+      totalMessages: this.messageCount,
+      elapsedSeconds: elapsed,
+      timestamp: now,
+    };
+
+    this.measurements.push({ timestamp: now, count: this.messageCount });
+    return stats;
+  }
+
+  /**
+   * Get recent throughput over specified window
+   */
+  getRecentThroughput(windowSeconds: number = 10): number {
+    const now = performance.now();
+    const cutoff = now - (windowSeconds * 1000);
+
+    // Find measurements within the window
+    const recentMeasurements = this.measurements.filter(m => m.timestamp >= cutoff);
+
+    if (recentMeasurements.length < 2) {
+      return 0;
+    }
+
+    const oldest = recentMeasurements[0]!;
+    const newest = recentMeasurements[recentMeasurements.length - 1]!;
+
+    const messagesDiff = newest.count - oldest.count;
+    const timeDiff = (newest.timestamp - oldest.timestamp) / 1000;
+
+    return timeDiff > 0 ? messagesDiff / timeDiff : 0;
+  }
+
+  /**
+   * Reset measurements
+   */
+  reset(): void {
+    this.messageCount = 0;
+    this.startTime = performance.now();
+    this.measurements = [];
+  }
+}
+
+export interface ThroughputStats {
+  messagesPerSecond: number;
+  totalMessages: number;
+  elapsedSeconds: number;
+  timestamp: number;
+}
+
+/**
+ * Comprehensive performance monitor for the entire library
+ */
+export class PerformanceMonitor {
+  readonly connection = new PerformanceTimer();
+  readonly commands = new PerformanceTimer();
+  readonly sysex = new PerformanceTimer();
+  readonly parsing = new PerformanceTimer();
+  readonly memory = new MemoryTracker();
+  readonly latency = new LatencyMeasurement();
+  readonly throughput = new ThroughputMeasurement();
+
+  /**
+   * Get a comprehensive performance report
+   */
+  getReport(): PerformanceReport {
+    return {
+      connection: this.connection.getStats(),
+      commands: this.commands.getStats(),
+      sysex: this.sysex.getStats(),
+      parsing: this.parsing.getStats(),
+      memory: this.memory.getDelta(),
+      latency: this.latency.getStats(),
+      throughput: this.throughput.measure(),
+      timestamp: Date.now(),
+    };
+  }
+
+  /**
+   * Reset all measurements
+   */
+  reset(): void {
+    this.connection.reset();
+    this.commands.reset();
+    this.sysex.reset();
+    this.parsing.reset();
+    this.latency.clear();
+    this.throughput.reset();
+  }
+}
+
+export interface PerformanceReport {
+  connection: PerformanceStats;
+  commands: PerformanceStats;
+  sysex: PerformanceStats;
+  parsing: PerformanceStats;
+  memory: MemoryDelta;
+  latency: PerformanceStats;
+  throughput: ThroughputStats;
+  timestamp: number;
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/package/src/utils/validators.ts b/modules/audio-control/modules/launch-control-xl3/package/src/utils/validators.ts
new file mode 100644
index 0000000..8f1f6e6
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/package/src/utils/validators.ts
@@ -0,0 +1,186 @@
+/**
+ * Zod schemas with custom refinements for runtime validation
+ */
+
+import { z } from 'zod';
+import { MIDI_RANGES, DEVICE_CAPABILITIES } from '@/utils/constants.js';
+
+// Basic MIDI value schemas
+export const MidiChannelSchema = z
+  .number()
+  .int()
+  .min(MIDI_RANGES.CHANNEL.MIN)
+  .max(MIDI_RANGES.CHANNEL.MAX)
+  .brand('MidiChannel');
+
+export const CCNumberSchema = z
+  .number()
+  .int()
+  .min(MIDI_RANGES.CC_NUMBER.MIN)
+  .max(MIDI_RANGES.CC_NUMBER.MAX)
+  .brand('CCNumber');
+
+export const MidiValueSchema = z
+  .number()
+  .int()
+  .min(MIDI_RANGES.CC_VALUE.MIN)
+  .max(MIDI_RANGES.CC_VALUE.MAX)
+  .brand('MidiValue');
+
+export const SlotNumberSchema = z.union([
+  z.literal(1),
+  z.literal(2),
+  z.literal(3),
+  z.literal(4),
+  z.literal(5),
+  z.literal(6),
+  z.literal(7),
+  z.literal(8),
+]);
+
+// Control type schemas
+export const ControlTypeSchema = z.discriminatedUnion('type', [
+  z.object({
+    type: z.literal('knob'),
+    behavior: z.enum(['absolute', 'relative']),
+  }),
+  z.object({
+    type: z.literal('button'),
+    behavior: z.enum(['momentary', 'toggle', 'trigger']),
+  }),
+  z.object({
+    type: z.literal('fader'),
+    behavior: z.literal('absolute'),
+  }),
+]);
+
+// Control ID schema
+export const ControlIdSchema = z.object({
+  type: z.enum(['knob', 'button', 'fader']),
+  position: z.number().int().min(1),
+  row: z.number().int().min(1).max(3).optional(),
+});
+
+// Control configuration schema
+export const ControlConfigSchema = z.object({
+  id: ControlIdSchema,
+  midiChannel: MidiChannelSchema,
+  ccNumber: CCNumberSchema,
+  controlType: ControlTypeSchema,
+  name: z.string().optional(),
+  color: z
+    .object({
+      red: MidiValueSchema,
+      green: MidiValueSchema,
+      blue: MidiValueSchema,
+    })
+    .optional(),
+  range: z
+    .object({
+      min: z.number(),
+      max: z.number(),
+      default: z.number().optional(),
+    })
+    .optional(),
+});
+
+// Custom mode schema
+export const CustomModeSchema = z
+  .object({
+    slot: SlotNumberSchema,
+    name: z.string().min(1).max(16), // Device limitation
+    controls: z.array(ControlConfigSchema),
+    globalChannel: MidiChannelSchema.optional(),
+    description: z.string().optional(),
+    createdAt: z.date().optional(),
+    modifiedAt: z.date().optional(),
+  })
+  .refine(
+    (mode) => mode.controls.length <= DEVICE_CAPABILITIES.KNOBS_TOTAL + DEVICE_CAPABILITIES.BUTTONS_TOTAL + DEVICE_CAPABILITIES.FADERS_TOTAL,
+    {
+      message: `Cannot exceed ${DEVICE_CAPABILITIES.KNOBS_TOTAL + DEVICE_CAPABILITIES.BUTTONS_TOTAL + DEVICE_CAPABILITIES.FADERS_TOTAL} controls per mode`,
+    }
+  );
+
+// SysEx message schema
+export const SysExMessageSchema = z.object({
+  manufacturerId: z.array(z.number().int().min(0).max(127)),
+  deviceId: z.array(z.number().int().min(0).max(127)).optional(),
+  data: z.array(z.number().int().min(0).max(127)),
+});
+
+// MIDI message schemas
+export const ControlChangeMessageSchema = z.object({
+  type: z.literal('controlChange'),
+  channel: MidiChannelSchema,
+  cc: CCNumberSchema,
+  value: MidiValueSchema,
+  timestamp: z.number(),
+  data: z.array(z.number()),
+});
+
+export const NoteMessageSchema = z.object({
+  type: z.enum(['noteOn', 'noteOff']),
+  channel: MidiChannelSchema,
+  note: z.number().int().min(0).max(127).brand('NoteNumber'),
+  velocity: z.number().int().min(0).max(127).brand('Velocity'),
+  timestamp: z.number(),
+  data: z.array(z.number()),
+});
+
+// Device configuration validation
+export const DeviceOptionsSchema = z.object({
+  retryPolicy: z
+    .object({
+      maxRetries: z.number().int().min(0),
+      backoffMs: z.number().int().min(0),
+      exponentialBackoff: z.boolean().optional(),
+    })
+    .optional(),
+  heartbeat: z
+    .object({
+      intervalMs: z.number().int().min(1000),
+      timeoutMs: z.number().int().min(1000).optional(),
+      enabled: z.boolean().optional(),
+    })
+    .optional(),
+  errorRecovery: z
+    .object({
+      autoReconnect: z.boolean(),
+      reconnectDelayMs: z.number().int().min(0).optional(),
+      maxReconnectAttempts: z.number().int().min(0).optional(),
+    })
+    .optional(),
+  timeout: z
+    .object({
+      connectionMs: z.number().int().min(1000),
+      commandMs: z.number().int().min(100),
+      sysexMs: z.number().int().min(100),
+    })
+    .optional(),
+});
+
+// Export type inference helpers
+export type ValidatedCustomMode = z.infer<typeof CustomModeSchema>;
+export type ValidatedControlConfig = z.infer<typeof ControlConfigSchema>;
+export type ValidatedDeviceOptions = z.infer<typeof DeviceOptionsSchema>;
+export type ValidatedMidiChannel = z.infer<typeof MidiChannelSchema>;
+export type ValidatedCCNumber = z.infer<typeof CCNumberSchema>;
+export type ValidatedMidiValue = z.infer<typeof MidiValueSchema>;
+
+// Validation helper functions
+export function validateCustomMode(data: unknown): ValidatedCustomMode {
+  return CustomModeSchema.parse(data);
+}
+
+export function validateControlConfig(data: unknown): ValidatedControlConfig {
+  return ControlConfigSchema.parse(data);
+}
+
+export function validateDeviceOptions(data: unknown): ValidatedDeviceOptions {
+  return DeviceOptionsSchema.parse(data);
+}
+
+export function isValidSlotNumber(value: unknown): value is 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 {
+  return SlotNumberSchema.safeParse(value).success;
+}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
index c6d84db..ce0259e 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
@@ -323,6 +323,7 @@ export class SysExParser {
 
     // Find where controls actually start (after name and terminator)
     let controlsStart = nameEnd > 0 ? nameEnd + 2 : 0; // Skip 0x21 0x00 after name
+    let controlNamesStart = -1;
 
     for (let i = controlsStart; i < data.length - 9; i++) {
       // Handle both 0x48 (read) and 0x49 (write) markers
@@ -387,6 +388,91 @@ export class SysExParser {
       }
     }
 
+    // Parse control names - they appear after all control definitions
+    // Look for the control names section which starts with byte patterns like 0x62, 0x68, 0x69
+    if (controls.length > 0) {
+      // Find where control names section starts - usually after last control definition
+      // Look for patterns like 0x62, 0x68, 0x69 followed by ASCII text
+      for (let i = controlsStart; i < data.length - 2; i++) {
+        // Check if we've passed all control definitions and found name markers
+        const byte = data[i];
+        if ((byte === 0x62 || byte === 0x68 || byte === 0x69 || byte === 0x60 || byte === 0x6A || byte === 0x6F) &&
+            data[i + 1] !== undefined && data[i + 1]! >= 0x30) { // Followed by ASCII
+          controlNamesStart = i;
+          break;
+        }
+      }
+
+      if (controlNamesStart >= 0) {
+        // Parse control names
+        const controlNames: Map<number, string> = new Map();
+        let currentControlId = -1;
+        let currentName = '';
+
+        for (let i = controlNamesStart; i < data.length; i++) {
+          const byte = data[i];
+
+          // Check for control ID markers (0x60-0x6F range often used)
+          if (byte !== undefined && byte >= 0x60 && byte <= 0x6F) {
+            // Save previous name if exists
+            if (currentControlId >= 0 && currentName.length > 0) {
+              controlNames.set(currentControlId, currentName.trim());
+            }
+
+            // Map marker to control ID (this mapping may need adjustment)
+            // Based on hex dump: 0x69 = control 0x28-0x2F range, 0x62 = 0x30 range, etc.
+            if (byte === 0x69) {
+              // Next byte after 0x69 is the control index
+              const nextByte = data[i + 1];
+              if (nextByte !== undefined && nextByte >= 0x28 && nextByte <= 0x3F) {
+                currentControlId = nextByte;
+                i++; // Skip the control ID byte
+              }
+            } else if (byte === 0x62 || byte === 0x68 || byte === 0x6A || byte === 0x6F) {
+              // These seem to be followed by control index
+              const nextByte = data[i + 1];
+              if (nextByte !== undefined && nextByte >= 0x30 && nextByte <= 0x3F) {
+                currentControlId = nextByte;
+                i++; // Skip the control ID byte
+              }
+            } else if (byte === 0x60) {
+              // 0x60 followed by control ID
+              const nextByte = data[i + 1];
+              if (nextByte !== undefined && (nextByte >= 0x28 && nextByte <= 0x3F)) {
+                currentControlId = nextByte;
+                i++; // Skip the control ID byte
+              }
+            }
+            currentName = '';
+          } else if (byte !== undefined && byte >= 32 && byte <= 126) {
+            // ASCII printable character - part of name
+            currentName += String.fromCharCode(byte);
+          } else if (currentName.length > 0 && (byte === 0x60 || byte === 0x00 || byte === 0xF7)) {
+            // End of current name
+            if (currentControlId >= 0 && currentName.length > 0) {
+              controlNames.set(currentControlId, currentName.trim());
+              currentName = '';
+            }
+          }
+        }
+
+        // Save last name if exists
+        if (currentControlId >= 0 && currentName.length > 0) {
+          controlNames.set(currentControlId, currentName.trim());
+        }
+
+        // Apply names to controls
+        for (const control of controls) {
+          if (control.controlId !== undefined) {
+            const name = controlNames.get(control.controlId);
+            if (name) {
+              control.name = name;
+            }
+          }
+        }
+      }
+    }
+
     const result: { controls: ControlMapping[]; colors: ColorMapping[]; name?: string } = {
       controls,
       colors
diff --git a/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts b/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts
index 55633d2..27687da 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts
@@ -49,6 +49,7 @@ export interface ColorMapping {
 
 export interface ControlMapping {
   controlId?: number; // Optional - can use string keys in Record instead
+  name?: string; // User-configurable control name
   type?: ControlType; // Optional control type
   controlType?: ControlType; // Legacy compatibility
   midiChannel?: number; // Required OR use 'channel' alternative
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-control-names.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-control-names.ts
new file mode 100644
index 0000000..e6042b8
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-control-names.ts
@@ -0,0 +1,77 @@
+#!/usr/bin/env tsx
+/**
+ * Test script to verify control name extraction from device
+ */
+
+import { LaunchControlXL3 } from '../src/index.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+
+async function testControlNames() {
+  console.log('Launch Control XL 3 - Control Names Test');
+  console.log('========================================\n');
+
+  let device: LaunchControlXL3 | null = null;
+
+  try {
+    // Create backend
+    const backend = new EasyMidiBackend();
+    console.log('‚Üí Initializing MIDI backend...');
+    await backend.initialize();
+    console.log('‚úì Backend initialized\n');
+
+    // Create device instance with initialized backend
+    device = new LaunchControlXL3({ midiBackend: backend });
+
+    // Connect to device
+    console.log('‚Üí Connecting to device...');
+    await device.connect();
+    console.log('‚úì Connected successfully\n');
+
+    // Read custom modes and check for control names
+    console.log('‚Üí Reading custom modes to check control names...\n');
+
+    for (let slot = 1; slot <= 8; slot++) {
+      try {
+        console.log(`\nSlot ${slot}:`);
+        console.log('--------');
+        const mode = await device.readCustomMode(slot);
+
+        if (mode) {
+          console.log(`Mode Name: ${mode.name || '(unnamed)'}`);
+          console.log(`Controls: ${mode.controls?.length || 0}`);
+
+          // Check if any controls have names
+          const namedControls = mode.controls?.filter(c => c.name) || [];
+          console.log(`Named Controls: ${namedControls.length}`);
+
+          if (namedControls.length > 0) {
+            console.log('\nControl Names Found:');
+            namedControls.forEach(control => {
+              console.log(`  - Control ${control.controlId?.toString(16).padStart(2, '0')}: "${control.name}"`);
+            });
+          } else {
+            console.log('  (No control names found)');
+          }
+        }
+      } catch (error) {
+        console.log(`  Error reading slot ${slot}: ${error instanceof Error ? error.message : String(error)}`);
+      }
+    }
+
+    console.log('\n‚úì Control name test completed');
+
+  } catch (error) {
+    console.error('\n‚úó Test failed:', error instanceof Error ? error.message : String(error));
+    console.error('\nFull error:', error);
+  } finally {
+    // Cleanup
+    if (device) {
+      console.log('\n‚Üí Cleaning up...');
+      await device.cleanup();
+      console.log('‚úì Cleanup complete');
+    }
+  }
+}
+
+// Run the test
+testControlNames().catch(console.error);
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-fetch-custom-mode-node.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-fetch-custom-mode-node.ts
index 4e6f524..9f6b1d2 100755
--- a/modules/audio-control/modules/launch-control-xl3/utils/test-fetch-custom-mode-node.ts
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-fetch-custom-mode-node.ts
@@ -86,7 +86,8 @@ function displayCustomMode(slot: number, mode: CustomMode): void {
     console.log(chalk.yellow('  Faders:'));
     faders.forEach(control => {
       const id = control.controlId ?? 0;
-      log.data(`    Fader ${id + 1}`, formatControlMapping(control));
+      const label = control.name ? chalk.cyan(control.name) : chalk.gray(`Fader ${id + 1}`);
+      log.data(`    ${label}`, formatControlMapping(control));
     });
   }
 
@@ -94,7 +95,8 @@ function displayCustomMode(slot: number, mode: CustomMode): void {
     console.log(chalk.yellow('  Top Row Encoders:'));
     topEncoders.forEach(control => {
       const id = (control.controlId ?? 0) - 0x10 + 1;
-      log.data(`    Encoder ${id}`, formatControlMapping(control));
+      const label = control.name ? chalk.cyan(control.name) : chalk.gray(`Encoder ${id}`);
+      log.data(`    ${label}`, formatControlMapping(control));
     });
   }
 
@@ -102,7 +104,8 @@ function displayCustomMode(slot: number, mode: CustomMode): void {
     console.log(chalk.yellow('  Middle Row Encoders:'));
     midEncoders.forEach(control => {
       const id = (control.controlId ?? 0) - 0x18 + 1;
-      log.data(`    Encoder ${id}`, formatControlMapping(control));
+      const label = control.name ? chalk.cyan(control.name) : chalk.gray(`Encoder ${id}`);
+      log.data(`    ${label}`, formatControlMapping(control));
     });
   }
 
@@ -110,7 +113,8 @@ function displayCustomMode(slot: number, mode: CustomMode): void {
     console.log(chalk.yellow('  Bottom Row Encoders:'));
     botEncoders.forEach(control => {
       const id = (control.controlId ?? 0) - 0x20 + 1;
-      log.data(`    Encoder ${id}`, formatControlMapping(control));
+      const label = control.name ? chalk.cyan(control.name) : chalk.gray(`Encoder ${id}`);
+      log.data(`    ${label}`, formatControlMapping(control));
     });
   }
 
@@ -118,7 +122,8 @@ function displayCustomMode(slot: number, mode: CustomMode): void {
     console.log(chalk.yellow('  Buttons:'));
     buttons.forEach(control => {
       const id = (control.controlId ?? 0) - 0x28 + 1;
-      log.data(`    Button ${id}`, formatControlMapping(control));
+      const label = control.name ? chalk.cyan(control.name) : chalk.gray(`Button ${id}`);
+      log.data(`    ${label}`, formatControlMapping(control));
     });
   }
 
@@ -156,6 +161,8 @@ function displayCustomMode(slot: number, mode: CustomMode): void {
   // Statistics
   console.log(chalk.gray('  Statistics:'));
   log.data('    Total controls', controls.length);
+  const namedControls = controls.filter(c => c.name && c.name.length > 0);
+  log.data('    Named controls', `${namedControls.length}/${controls.length}`);
   log.data('    Colors defined', mode.colors?.size || 0);
   log.data('    Labels defined', mode.labels?.size || 0);
 }


---

_**Agent (claude-opus-4-1-20250805)**_

feat(launch-control-xl3): add control name extraction from device responses

