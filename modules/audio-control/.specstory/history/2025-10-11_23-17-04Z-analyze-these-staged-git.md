<!-- Generated by SpecStory -->

# 360 Feature: MIDI Controller Mapping Workflow Documentation (2025-10-11 23:17:04Z)

<!-- Claude Code Session 25e993b4-74df-4b90-b0bc-ebf6c5c71a40 (2025-10-11_23-17-04Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/controller-workflow/src/__tests__/integration/end-to-end.test.ts b/modules/audio-control/modules/controller-workflow/src/__tests__/integration/end-to-end.test.ts
index 1c96eb9..a0c12c9 100644
--- a/modules/audio-control/modules/controller-workflow/src/__tests__/integration/end-to-end.test.ts
+++ b/modules/audio-control/modules/controller-workflow/src/__tests__/integration/end-to-end.test.ts
@@ -78,6 +78,9 @@ describe('End-to-End Workflow', () => {
     } as unknown as jest.Mocked<LaunchControlXL3>;
 
     // Reset file system mocks
+    vi.mocked(fs.mkdir).mockClear();
+    vi.mocked(fs.writeFile).mockClear();
+    vi.mocked(fs.access).mockClear();
     vi.mocked(fs.mkdir).mockResolvedValue(undefined);
     vi.mocked(fs.writeFile).mockResolvedValue(undefined);
     vi.mocked(fs.access).mockResolvedValue(undefined);
@@ -346,6 +349,11 @@ describe('End-to-End Workflow', () => {
         deployers,
       });
 
+      // Add error listener to prevent unhandled error event
+      workflow.on('error', () => {
+        // Intentionally empty - we expect errors in this test
+      });
+
       const options: WorkflowOptions = {
         configSlot: 0,
         targets: ['ardour'],
@@ -371,6 +379,11 @@ describe('End-to-End Workflow', () => {
         deployers,
       });
 
+      // Add error listener to prevent unhandled error event
+      workflow.on('error', () => {
+        // Intentionally empty - we expect errors in this test
+      });
+
       const options: WorkflowOptions = {
         configSlot: 5,
         targets: ['ardour'],
@@ -383,6 +396,8 @@ describe('End-to-End Workflow', () => {
     });
 
     it('should handle file system errors during deployment', async () => {
+      // Reset to success first, then set rejection for this test
+      vi.mocked(fs.writeFile).mockClear();
       vi.mocked(fs.writeFile).mockRejectedValue(new Error('Disk full'));
 
       const adapter = new LaunchControlXL3Adapter(mockDevice);
@@ -396,6 +411,11 @@ describe('End-to-End Workflow', () => {
         deployers,
       });
 
+      // Add error listener to prevent unhandled error event
+      workflow.on('error', () => {
+        // Intentionally empty - we expect errors in this test
+      });
+
       const options: WorkflowOptions = {
         configSlot: 0,
         targets: ['ardour'],
diff --git a/modules/audio-control/modules/controller-workflow/src/__tests__/unit/ArdourDeployer.test.ts b/modules/audio-control/modules/controller-workflow/src/__tests__/unit/ArdourDeployer.test.ts
index 56dd9f2..2e731de 100644
--- a/modules/audio-control/modules/controller-workflow/src/__tests__/unit/ArdourDeployer.test.ts
+++ b/modules/audio-control/modules/controller-workflow/src/__tests__/unit/ArdourDeployer.test.ts
@@ -6,11 +6,10 @@
  */
 
 import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
-import { ArdourDeployer } from '@/adapters/daws/ArdourDeployer.js';
+import { ArdourDeployer, type PlatformProvider } from '@/adapters/daws/ArdourDeployer.js';
 import type { CanonicalMidiMap, ControlDefinition } from '@oletizi/canonical-midi-maps';
 import type { DeploymentOptions } from '@/types/daw-deployer.js';
 import * as fs from 'node:fs/promises';
-import * as os from 'node:os';
 
 // Mock file system operations
 vi.mock('node:fs/promises', () => ({
@@ -228,8 +227,11 @@ describe('ArdourDeployer', () => {
 
   describe('getConfigDirectory', () => {
     it('should return macOS path on darwin platform', async () => {
-      vi.spyOn(os, 'platform').mockReturnValue('darwin');
-      vi.spyOn(os, 'homedir').mockReturnValue('/Users/test');
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'darwin',
+        homedir: () => '/Users/test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
 
       const configDir = await deployer.getConfigDirectory();
 
@@ -237,8 +239,11 @@ describe('ArdourDeployer', () => {
     });
 
     it('should return Linux path on linux platform', async () => {
-      vi.spyOn(os, 'platform').mockReturnValue('linux');
-      vi.spyOn(os, 'homedir').mockReturnValue('/home/test');
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'linux',
+        homedir: () => '/home/test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
 
       const configDir = await deployer.getConfigDirectory();
 
@@ -246,27 +251,40 @@ describe('ArdourDeployer', () => {
     });
 
     it('should return Windows path on win32 platform', async () => {
-      vi.spyOn(os, 'platform').mockReturnValue('win32');
-      vi.spyOn(os, 'homedir').mockReturnValue('C:\\Users\\test');
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'win32',
+        homedir: () => 'C:\\Users\\test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
       process.env['APPDATA'] = 'C:\\Users\\test\\AppData\\Roaming';
 
       const configDir = await deployer.getConfigDirectory();
 
-      expect(configDir).toBe('C:\\Users\\test\\AppData\\Roaming\\Ardour8\\midi_maps');
+      // On non-Windows hosts, path.join uses forward slashes, so we normalize for comparison
+      expect(configDir.replace(/\//g, '\\')).toBe('C:\\Users\\test\\AppData\\Roaming\\Ardour8\\midi_maps');
     });
 
     it('should use fallback path when APPDATA not set on Windows', async () => {
-      vi.spyOn(os, 'platform').mockReturnValue('win32');
-      vi.spyOn(os, 'homedir').mockReturnValue('C:\\Users\\test');
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'win32',
+        homedir: () => 'C:\\Users\\test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
       delete process.env['APPDATA'];
 
       const configDir = await deployer.getConfigDirectory();
 
-      expect(configDir).toContain('AppData\\Roaming\\Ardour8\\midi_maps');
+      // Normalize path separators for cross-platform testing
+      const normalizedPath = configDir.replace(/\//g, '\\');
+      expect(normalizedPath).toContain('AppData\\Roaming\\Ardour8\\midi_maps');
     });
 
     it('should throw error for unsupported platform', async () => {
-      vi.spyOn(os, 'platform').mockReturnValue('aix' as NodeJS.Platform);
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'aix' as NodeJS.Platform,
+        homedir: () => '/home/test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
 
       await expect(deployer.getConfigDirectory()).rejects.toThrow('Unsupported platform');
     });
@@ -441,7 +459,7 @@ describe('ArdourDeployer', () => {
       await deployer.deploy(mapWithChannels, options);
 
       const [, content] = vi.mocked(fs.writeFile).mock.calls[0];
-      expect(content).toContain('chn="5"');
+      expect(content).toContain('channel="5"');
     });
 
     it('should use map-level channel when control channel not specified', async () => {
@@ -468,7 +486,7 @@ describe('ArdourDeployer', () => {
       await deployer.deploy(mapWithDefaultChannel, options);
 
       const [, content] = vi.mocked(fs.writeFile).mock.calls[0];
-      expect(content).toContain('chn="7"');
+      expect(content).toContain('channel="7"');
     });
 
     it('should group controls by channel', async () => {
@@ -496,8 +514,8 @@ describe('ArdourDeployer', () => {
       expect(content).toContain('Novation Launch Control XL 3');
 
       // All channels should be present
-      expect(content).toContain('chn="0"');
-      expect(content).toContain('chn="1"');
+      expect(content).toContain('channel="0"');
+      expect(content).toContain('channel="1"');
     });
   });
 
diff --git a/modules/audio-control/modules/controller-workflow/src/__tests__/unit/DeploymentWorkflow.test.ts b/modules/audio-control/modules/controller-workflow/src/__tests__/unit/DeploymentWorkflow.test.ts
index a146a04..a3781d8 100644
--- a/modules/audio-control/modules/controller-workflow/src/__tests__/unit/DeploymentWorkflow.test.ts
+++ b/modules/audio-control/modules/controller-workflow/src/__tests__/unit/DeploymentWorkflow.test.ts
@@ -5,7 +5,10 @@
  * Uses dependency injection for all components (no module stubbing).
  */
 
-import { describe, it, expect, beforeEach, vi } from 'vitest';
+import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
+import { tmpdir } from 'node:os';
+import { join } from 'node:path';
+import { mkdtemp, rm } from 'node:fs/promises';
 import { DeploymentWorkflow } from '@/orchestrator/DeploymentWorkflow.js';
 import type {
   ControllerAdapterInterface,
@@ -141,15 +144,29 @@ describe('DeploymentWorkflow', () => {
 
   describe('execute', () => {
     let workflow: DeploymentWorkflow;
+    let tempDir: string | undefined;
 
     beforeEach(async () => {
       workflow = await DeploymentWorkflow.create({
         controllerAdapter: mockAdapter,
+        converter: mockConverter,
         targets: ['ardour'],
         deployers,
       });
     });
 
+    afterEach(async () => {
+      // Clean up temporary directory if it was created
+      if (tempDir) {
+        try {
+          await rm(tempDir, { recursive: true, force: true });
+        } catch (error) {
+          // Ignore cleanup errors
+        }
+        tempDir = undefined;
+      }
+    });
+
     it('should execute complete workflow successfully', async () => {
       const options: WorkflowOptions = {
         configSlot: 0,
@@ -282,31 +299,24 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should save canonical YAML when output directory specified', async () => {
-      // Mock file operations via the parser
-      vi.mock('@oletizi/canonical-midi-maps', async () => {
-        const actual = await vi.importActual('@oletizi/canonical-midi-maps');
-        return {
-          ...actual,
-          CanonicalMapParser: {
-            serializeToYAML: vi.fn().mockReturnValue('yaml: content'),
-          },
-        };
-      });
+      tempDir = await mkdtemp(join(tmpdir(), 'workflow-test-'));
 
       const options: WorkflowOptions = {
         configSlot: 0,
         targets: ['ardour'],
-        outputDir: '/test/output',
+        outputDir: tempDir,
       };
 
       const result = await workflow.execute(options);
 
       expect(result.canonicalPath).toBeDefined();
-      expect(result.canonicalPath).toContain('/test/output');
+      expect(result.canonicalPath).toContain(tempDir);
       expect(result.canonicalPath).toMatch(/\.yaml$/);
     });
 
     it('should emit canonical-saved event when YAML saved', async () => {
+      tempDir = await mkdtemp(join(tmpdir(), 'workflow-test-'));
+
       let savedEvent: CanonicalSavedEvent | undefined;
       workflow.on('canonical-saved', (event: CanonicalSavedEvent) => {
         savedEvent = event;
@@ -315,7 +325,7 @@ describe('DeploymentWorkflow', () => {
       const options: WorkflowOptions = {
         configSlot: 0,
         targets: ['ardour'],
-        outputDir: '/test/output',
+        outputDir: tempDir,
       };
 
       await workflow.execute(options);
@@ -344,6 +354,7 @@ describe('DeploymentWorkflow', () => {
 
       workflow = await DeploymentWorkflow.create({
         controllerAdapter: mockAdapter,
+        converter: mockConverter,
         targets: ['ardour', 'live'],
         deployers,
       });
@@ -361,10 +372,12 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should pass deployment options to deployers', async () => {
+      tempDir = await mkdtemp(join(tmpdir(), 'workflow-test-'));
+
       const options: WorkflowOptions = {
         configSlot: 0,
         targets: ['ardour'],
-        outputDir: '/test/output',
+        outputDir: tempDir,
         autoInstall: true,
         dryRun: false,
       };
@@ -375,7 +388,7 @@ describe('DeploymentWorkflow', () => {
         mockCanonicalMap,
         expect.objectContaining({
           autoInstall: true,
-          outputPath: expect.stringContaining('/test/output/ardour'),
+          outputPath: expect.stringContaining('/ardour'),
           dryRun: false,
         }),
       );
@@ -414,6 +427,10 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should handle controller read errors', async () => {
+      // Add error listener to prevent unhandled error event
+      const errorHandler = vi.fn();
+      workflow.on('error', errorHandler);
+
       mockAdapter.readConfiguration.mockRejectedValue(new Error('SysEx timeout'));
 
       const options: WorkflowOptions = {
@@ -426,9 +443,14 @@ describe('DeploymentWorkflow', () => {
       expect(result.success).toBe(false);
       expect(result.errors).toContain('SysEx timeout');
       expect(result.controllerConfig).toBeUndefined();
+      expect(errorHandler).toHaveBeenCalled();
     });
 
     it('should handle empty configuration', async () => {
+      // Add error listener to prevent unhandled error event
+      const errorHandler = vi.fn();
+      workflow.on('error', errorHandler);
+
       mockAdapter.readConfiguration.mockResolvedValue({
         name: 'Empty',
         controls: [],
@@ -443,9 +465,14 @@ describe('DeploymentWorkflow', () => {
 
       expect(result.success).toBe(false);
       expect(result.errors.some(e => e.includes('No valid configuration'))).toBe(true);
+      expect(errorHandler).toHaveBeenCalled();
     });
 
     it('should handle conversion errors', async () => {
+      // Add error listener to prevent unhandled error event
+      const errorHandler = vi.fn();
+      workflow.on('error', errorHandler);
+
       mockConverter.canConvert.mockReturnValue(false);
 
       const options: WorkflowOptions = {
@@ -457,6 +484,7 @@ describe('DeploymentWorkflow', () => {
 
       expect(result.success).toBe(false);
       expect(result.errors.some(e => e.includes('cannot be converted'))).toBe(true);
+      expect(errorHandler).toHaveBeenCalled();
     });
 
     it('should emit error event on failure', async () => {
@@ -513,6 +541,7 @@ describe('DeploymentWorkflow', () => {
 
       workflow = await DeploymentWorkflow.create({
         controllerAdapter: mockAdapter,
+        converter: mockConverter,
         targets: ['ardour', 'live'],
         deployers,
       });
@@ -530,13 +559,15 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should sanitize canonical filename from map name', async () => {
+      tempDir = await mkdtemp(join(tmpdir(), 'workflow-test-'));
+
       mockCanonicalMap.metadata.name = 'Test Map (Special #1)';
       mockConverter.convert.mockReturnValue(mockCanonicalMap);
 
       const options: WorkflowOptions = {
         configSlot: 0,
         targets: ['ardour'],
-        outputDir: '/test/output',
+        outputDir: tempDir,
       };
 
       const result = await workflow.execute(options);
@@ -579,6 +610,7 @@ describe('DeploymentWorkflow', () => {
     beforeEach(async () => {
       workflow = await DeploymentWorkflow.create({
         controllerAdapter: mockAdapter,
+        converter: mockConverter,
         targets: ['ardour'],
         deployers,
       });
diff --git a/modules/audio-control/modules/controller-workflow/src/__tests__/unit/LaunchControlXL3Adapter.test.ts b/modules/audio-control/modules/controller-workflow/src/__tests__/unit/LaunchControlXL3Adapter.test.ts
index 23703de..238e8d2 100644
--- a/modules/audio-control/modules/controller-workflow/src/__tests__/unit/LaunchControlXL3Adapter.test.ts
+++ b/modules/audio-control/modules/controller-workflow/src/__tests__/unit/LaunchControlXL3Adapter.test.ts
@@ -309,11 +309,11 @@ describe('LaunchControlXL3Adapter', () => {
       const [slot, lcxl3Mode] = mockDevice.writeCustomMode.mock.calls[0];
 
       expect(slot).toBe(0);
-      expect(lcxl3Mode.name).toBe('Generic C'); // LCXL3 truncates to 8 chars
+      expect(lcxl3Mode.name).toBe('Generic '); // LCXL3 truncates to 8 chars
       expect(lcxl3Mode.controls.SEND_A1).toBeDefined();
-      expect(lcxl3Mode.controls.SEND_A1.type).toBe('encoder');
+      expect(lcxl3Mode.controls.SEND_A1.type).toBe('knob'); // LCXL3 uses 'knob' for encoders
       expect(lcxl3Mode.controls.FADER1).toBeDefined();
-      expect(lcxl3Mode.controls.FADER1.type).toBe('slider');
+      expect(lcxl3Mode.controls.FADER1.type).toBe('fader'); // LCXL3 uses 'fader' for sliders
     });
 
     it('should truncate mode name to 8 characters', async () => {
diff --git a/modules/audio-control/modules/controller-workflow/src/adapters/controllers/LaunchControlXL3Adapter.ts b/modules/audio-control/modules/controller-workflow/src/adapters/controllers/LaunchControlXL3Adapter.ts
index ae8fbbd..e2f201f 100644
--- a/modules/audio-control/modules/controller-workflow/src/adapters/controllers/LaunchControlXL3Adapter.ts
+++ b/modules/audio-control/modules/controller-workflow/src/adapters/controllers/LaunchControlXL3Adapter.ts
@@ -34,7 +34,7 @@ export class LaunchControlXL3Adapter implements ControllerAdapterInterface {
   readonly model = 'Launch Control XL 3';
   readonly capabilities: ControllerCapabilities = {
     supportsCustomModes: true,
-    maxConfigSlots: 15, // Slots 0-14 are user-programmable, slot 15 is factory
+    maxConfigSlots: 16, // Slots 0-15 (16 total: 0-14 user-programmable, 15 factory)
     supportsRead: true,
     supportsWrite: true,
     supportedControlTypes: ['encoder', 'slider', 'button'],
@@ -87,14 +87,15 @@ export class LaunchControlXL3Adapter implements ControllerAdapterInterface {
   /**
    * List all configuration slots
    *
-   * Reads slots 0-14 from the device (slot 15 is reserved for factory content).
+   * Reads all 16 slots (0-15) from the device.
+   * Slots 0-14 are user-programmable, slot 15 is factory preset.
    * Returns their status (empty or populated with mode name).
    */
   async listConfigurations(): Promise<ConfigurationSlot[]> {
     const slots: ConfigurationSlot[] = [];
 
-    // Only read slots 0-14; slot 15 is factory-only
-    for (let i = 0; i < 15; i++) {
+    // Read all 16 slots (0-15)
+    for (let i = 0; i < 16; i++) {
       const mode = await this.device.readCustomMode(i);
       const slot: ConfigurationSlot = {
         index: i,
@@ -127,7 +128,7 @@ export class LaunchControlXL3Adapter implements ControllerAdapterInterface {
       throw new Error(`No configuration found in slot ${slot}`);
     }
 
-    return this.convertFromLCXL3(customMode);
+    return this.convertFromLCXL3(customMode, slot);
   }
 
   /**
@@ -169,7 +170,7 @@ export class LaunchControlXL3Adapter implements ControllerAdapterInterface {
   /**
    * Convert LCXL3 CustomMode to generic ControllerConfiguration
    */
-  private convertFromLCXL3(mode: LCXL3CustomMode): ControllerConfiguration {
+  private convertFromLCXL3(mode: LCXL3CustomMode, slot?: number): ControllerConfiguration {
     const controls: ControlMapping[] = [];
 
     // Convert LCXL3 control mappings to generic format
@@ -178,14 +179,18 @@ export class LaunchControlXL3Adapter implements ControllerAdapterInterface {
       controls.push(mapping);
     }
 
+    // Check for labels and colors both at top level and in metadata
+    const labels = mode.labels ?? mode.metadata?.labels;
+    const colors = mode.colors ?? mode.metadata?.colors;
+
     return {
       name: mode.name,
       controls,
       metadata: {
         ...mode.metadata,
-        slot: mode.slot,
-        labels: mode.labels ? this.mapToObject(mode.labels) : undefined,
-        colors: mode.colors ? this.mapToObject(mode.colors) : undefined,
+        slot: mode.metadata?.slot ?? slot,
+        labels: labels ? this.mapToObject(labels) : undefined,
+        colors: colors ? this.mapToObject(colors) : undefined,
       },
     };
   }
@@ -256,15 +261,16 @@ export class LaunchControlXL3Adapter implements ControllerAdapterInterface {
   }
 
   /**
-   * Truncate name to specified length, ensuring clean truncation
+   * Truncate name to specified length
    * @param name - Name to truncate
    * @param maxLength - Maximum length
-   * @returns Truncated name
+   * @returns Truncated name (exactly maxLength characters)
    */
   private truncateName(name: string, maxLength: number): string {
     if (name.length <= maxLength) {
       return name;
     }
+
     return name.substring(0, maxLength);
   }
 
@@ -274,8 +280,24 @@ export class LaunchControlXL3Adapter implements ControllerAdapterInterface {
   private convertControlToLCXL3(control: ControlMapping): LCXL3ControlMapping {
     const [minValue, maxValue] = control.range ?? [0, 127];
 
+    // Map generic type to LCXL3 type (reverse of mapControlType)
+    let lcxl3Type: string;
+    switch (control.type) {
+      case 'encoder':
+        lcxl3Type = 'knob';
+        break;
+      case 'slider':
+        lcxl3Type = 'fader';
+        break;
+      case 'button':
+        lcxl3Type = 'button';
+        break;
+      default:
+        lcxl3Type = 'knob'; // Default fallback
+    }
+
     const lcxl3Control: LCXL3ControlMapping = {
-      type: this.mapControlType(control.type) as any,
+      type: lcxl3Type as any,
       minValue,
       maxValue,
       behavior: 'absolute', // Default behavior
diff --git a/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.test.ts b/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.test.ts
index d1d7fb9..7d2ad4c 100644
--- a/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.test.ts
+++ b/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.test.ts
@@ -3,7 +3,7 @@
  */
 
 import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
-import { ArdourDeployer } from './ArdourDeployer.js';
+import { ArdourDeployer, type PlatformProvider } from './ArdourDeployer.js';
 import type { CanonicalMidiMap } from '@oletizi/canonical-midi-maps';
 
 describe('ArdourDeployer', () => {
@@ -56,47 +56,58 @@ describe('ArdourDeployer', () => {
 
   describe('Platform detection', () => {
     it('should return correct path for macOS', async () => {
-      vi.stubGlobal('process', { ...process, platform: 'darwin' });
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'darwin',
+        homedir: () => '/Users/test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
 
       const path = await deployer.getConfigDirectory();
       expect(path).toContain('Library/Application Support/Ardour8/midi_maps');
-
-      vi.unstubAllGlobals();
     });
 
     it('should return correct path for Linux', async () => {
-      vi.stubGlobal('process', { ...process, platform: 'linux' });
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'linux',
+        homedir: () => '/home/test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
 
       const path = await deployer.getConfigDirectory();
       expect(path).toContain('.config/ardour8/midi_maps');
-
-      vi.unstubAllGlobals();
     });
 
     it('should return correct path for Windows', async () => {
-      vi.stubGlobal('process', { ...process, platform: 'win32', env: { APPDATA: 'C:\\Users\\Test\\AppData\\Roaming' } });
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'win32',
+        homedir: () => 'C:\\Users\\test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
+      process.env['APPDATA'] = 'C:\\Users\\Test\\AppData\\Roaming';
 
       const path = await deployer.getConfigDirectory();
       expect(path).toContain('Ardour8');
       expect(path).toContain('midi_maps');
-
-      vi.unstubAllGlobals();
     });
 
     it('should throw error for unsupported platform', async () => {
-      vi.stubGlobal('process', { ...process, platform: 'freebsd' });
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'freebsd' as NodeJS.Platform,
+        homedir: () => '/home/test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
 
       await expect(deployer.getConfigDirectory()).rejects.toThrow('Unsupported platform');
-
-      vi.unstubAllGlobals();
     });
 
     it('should throw error for unknown platform', async () => {
-      vi.stubGlobal('process', { ...process, platform: 'unknown' });
+      const mockPlatformProvider: PlatformProvider = {
+        platform: () => 'unknown' as NodeJS.Platform,
+        homedir: () => '/home/test',
+      };
+      const deployer = ArdourDeployer.create(mockPlatformProvider);
 
       await expect(deployer.getConfigDirectory()).rejects.toThrow('Unsupported platform');
-
-      vi.unstubAllGlobals();
     });
   });
 
diff --git a/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.ts b/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.ts
index a1b109a..1be8269 100644
--- a/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.ts
+++ b/modules/audio-control/modules/controller-workflow/src/adapters/daws/ArdourDeployer.ts
@@ -18,6 +18,27 @@ import type {
   DeploymentResult,
 } from '@/types/daw-deployer.js';
 
+/**
+ * Platform provider interface for dependency injection
+ */
+export interface PlatformProvider {
+  platform(): NodeJS.Platform;
+  homedir(): string;
+}
+
+/**
+ * Default platform provider using Node.js os module
+ */
+export class DefaultPlatformProvider implements PlatformProvider {
+  platform(): NodeJS.Platform {
+    return platform();
+  }
+
+  homedir(): string {
+    return homedir();
+  }
+}
+
 /**
  * Ardour DAW Deployer
  *
@@ -29,12 +50,22 @@ export class ArdourDeployer implements DAWDeployerInterface {
   readonly version = '8.x';
 
   private readonly serializer = new ArdourXMLSerializer();
+  private readonly platformProvider: PlatformProvider;
+
+  /**
+   * Constructor with dependency injection
+   *
+   * @param platformProvider - Provider for platform and homedir (optional, defaults to DefaultPlatformProvider)
+   */
+  constructor(platformProvider?: PlatformProvider) {
+    this.platformProvider = platformProvider ?? new DefaultPlatformProvider();
+  }
 
   /**
    * Factory method to create ArdourDeployer instance
    */
-  static create(): ArdourDeployer {
-    return new ArdourDeployer();
+  static create(platformProvider?: PlatformProvider): ArdourDeployer {
+    return new ArdourDeployer(platformProvider);
   }
 
   /**
@@ -128,8 +159,8 @@ export class ArdourDeployer implements DAWDeployerInterface {
    * @throws Error if platform is not supported
    */
   async getConfigDirectory(): Promise<string> {
-    const home = homedir();
-    const os = platform();
+    const home = this.platformProvider.homedir();
+    const os = this.platformProvider.platform();
 
     switch (os) {
       case 'darwin':
diff --git a/modules/audio-control/modules/controller-workflow/src/integration.test.ts b/modules/audio-control/modules/controller-workflow/src/integration.test.ts
index 667c6bf..8951bfe 100644
--- a/modules/audio-control/modules/controller-workflow/src/integration.test.ts
+++ b/modules/audio-control/modules/controller-workflow/src/integration.test.ts
@@ -279,7 +279,7 @@ describe('Integration Tests', () => {
     });
 
     it('should handle workflow errors gracefully', async () => {
-      vi.mocked(mockDevice.readCustomMode).mockRejectedValue(new Error('Device error'));
+      mockDevice.readCustomMode.mockRejectedValue(new Error('Device error'));
 
       const workflow = await DeploymentWorkflow.create({
         controllerAdapter: adapter,
@@ -287,6 +287,11 @@ describe('Integration Tests', () => {
         deployers: new Map([['ardour', deployer]]),
       });
 
+      // Add error listener to prevent unhandled error event
+      workflow.on('error', () => {
+        // Intentionally empty - we expect errors in this test
+      });
+
       const result = await workflow.execute({
         configSlot: 0,
         targets: ['ardour'],
diff --git a/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.test.ts b/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.test.ts
index 385ce1b..78e8524 100644
--- a/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.test.ts
+++ b/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.test.ts
@@ -112,13 +112,21 @@ describe('DeploymentWorkflow', () => {
     });
   });
 
+  const createWorkflow = async (options: Partial<{
+    targets: string[];
+    deployers: Map<string, DAWDeployerInterface>;
+  }> = {}) => {
+    return DeploymentWorkflow.create({
+      controllerAdapter: mockAdapter,
+      converter: mockConverter,
+      targets: options.targets ?? ['testdaw'],
+      deployers: options.deployers ?? new Map([['testdaw', mockDeployer]]),
+    });
+  };
+
   describe('Workflow execution', () => {
     it('should execute complete workflow successfully', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       const result = await workflow.execute({
         configSlot: 0,
@@ -134,11 +142,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should read configuration from correct slot', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.execute({
         configSlot: 5,
@@ -167,8 +171,7 @@ describe('DeploymentWorkflow', () => {
         installed: false,
       });
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
+      workflow = await createWorkflow({
         targets: ['daw1', 'daw2'],
         deployers: new Map([
           ['daw1', deployer1],
@@ -189,11 +192,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should not write files in dry-run mode', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       const result = await workflow.execute({
         configSlot: 0,
@@ -211,11 +210,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should handle missing deployer gracefully', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       const result = await workflow.execute({
         configSlot: 0,
@@ -232,13 +227,15 @@ describe('DeploymentWorkflow', () => {
 
   describe('Error handling', () => {
     it('should handle controller read errors', async () => {
-      vi.mocked(mockAdapter.readConfiguration).mockRejectedValue(new Error('Read failed'));
+      workflow = await createWorkflow();
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      // Add error listener to prevent unhandled error event
+      const errorHandler = vi.fn();
+      workflow.on('error', errorHandler);
+
+      // Override the mock after workflow is created
+      const readError = new Error('Read failed');
+      vi.mocked(mockAdapter.readConfiguration).mockRejectedValueOnce(readError);
 
       const result = await workflow.execute({
         configSlot: 0,
@@ -248,17 +245,20 @@ describe('DeploymentWorkflow', () => {
 
       expect(result.success).toBe(false);
       expect(result.errors).toContain('Read failed');
+      expect(errorHandler).toHaveBeenCalled();
     });
 
     it('should handle conversion errors', async () => {
-      vi.mocked(mockConverter.convert).mockImplementation(() => {
-        throw new Error('Conversion failed');
-      });
+      workflow = await createWorkflow();
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
+      // Add error listener to prevent unhandled error event
+      const errorHandler = vi.fn();
+      workflow.on('error', errorHandler);
+
+      // Override the mock after workflow is created
+      const conversionError = new Error('Conversion failed');
+      vi.mocked(mockConverter.convert).mockImplementationOnce(() => {
+        throw conversionError;
       });
 
       const result = await workflow.execute({
@@ -269,21 +269,19 @@ describe('DeploymentWorkflow', () => {
 
       expect(result.success).toBe(false);
       expect(result.errors).toContain('Conversion failed');
+      expect(errorHandler).toHaveBeenCalled();
     });
 
     it('should handle deployment errors', async () => {
-      vi.mocked(mockDeployer.deploy).mockResolvedValue({
+      workflow = await createWorkflow();
+
+      // Override the mock after workflow is created
+      vi.mocked(mockDeployer.deploy).mockResolvedValueOnce({
         success: false,
         dawName: 'TestDAW',
         errors: ['Deployment failed'],
       });
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
-
       const result = await workflow.execute({
         configSlot: 0,
         targets: ['testdaw'],
@@ -296,13 +294,10 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should emit error event on failure', async () => {
-      vi.mocked(mockAdapter.readConfiguration).mockRejectedValue(new Error('Read failed'));
+      workflow = await createWorkflow();
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      // Override the mock after workflow is created
+      vi.mocked(mockAdapter.readConfiguration).mockRejectedValueOnce(new Error('Read failed'));
 
       const errorHandler = vi.fn();
       workflow.on('error', errorHandler);
@@ -317,13 +312,10 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should handle deployment exception gracefully', async () => {
-      vi.mocked(mockDeployer.deploy).mockRejectedValue(new Error('Unexpected deployment error'));
+      workflow = await createWorkflow();
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      // Override the mock after workflow is created
+      vi.mocked(mockDeployer.deploy).mockRejectedValueOnce(new Error('Unexpected deployment error'));
 
       const result = await workflow.execute({
         configSlot: 0,
@@ -339,11 +331,7 @@ describe('DeploymentWorkflow', () => {
 
   describe('Event emission', () => {
     it('should emit progress events', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       const progressHandler = vi.fn();
       workflow.on('progress', progressHandler);
@@ -362,11 +350,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should emit canonical-saved event when saving YAML', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       const savedHandler = vi.fn();
       workflow.on('canonical-saved', savedHandler);
@@ -390,11 +374,7 @@ describe('DeploymentWorkflow', () => {
         type: 'vst3' as const,
       };
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.execute({
         configSlot: 0,
@@ -410,11 +390,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should pass MIDI channel to converter', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.execute({
         configSlot: 0,
@@ -430,11 +406,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should pass preserveLabels to converter', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.execute({
         configSlot: 0,
@@ -450,11 +422,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should pass autoInstall to deployer', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.execute({
         configSlot: 0,
@@ -470,11 +438,7 @@ describe('DeploymentWorkflow', () => {
     });
 
     it('should pass outputPath to deployer', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.execute({
         configSlot: 0,
@@ -492,11 +456,7 @@ describe('DeploymentWorkflow', () => {
 
   describe('Cleanup', () => {
     it('should disconnect adapter on cleanup', async () => {
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.cleanup();
 
@@ -506,11 +466,7 @@ describe('DeploymentWorkflow', () => {
     it('should not disconnect if not connected', async () => {
       vi.mocked(mockAdapter.isConnected).mockReturnValue(false);
 
-      workflow = await DeploymentWorkflow.create({
-        controllerAdapter: mockAdapter,
-        targets: ['testdaw'],
-        deployers: new Map([['testdaw', mockDeployer]]),
-      });
+      workflow = await createWorkflow();
 
       await workflow.cleanup();
 
@@ -523,6 +479,7 @@ describe('DeploymentWorkflow', () => {
       await expect(
         DeploymentWorkflow.create({
           controllerAdapter: mockAdapter,
+          converter: mockConverter,
           targets: ['ardour'],
         })
       ).rejects.toThrow('DAW deployers not yet implemented');
@@ -531,6 +488,7 @@ describe('DeploymentWorkflow', () => {
     it('should create workflow with empty targets', async () => {
       const newWorkflow = await DeploymentWorkflow.create({
         controllerAdapter: mockAdapter,
+        converter: mockConverter,
         targets: [],
         deployers: new Map(),
       });
diff --git a/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.ts b/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.ts
index 7dc50f7..69b1480 100644
--- a/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.ts
+++ b/modules/audio-control/modules/controller-workflow/src/orchestrator/DeploymentWorkflow.ts
@@ -73,6 +73,8 @@ export interface WorkflowResult {
 export interface CreateOptions {
   /** Optional pre-configured controller adapter */
   controllerAdapter?: ControllerAdapterInterface;
+  /** Optional pre-configured canonical converter */
+  converter?: CanonicalConverterInterface;
   /** Target DAW names */
   targets: string[];
   /** Optional pre-configured DAW deployers */
@@ -142,8 +144,8 @@ export class DeploymentWorkflow extends EventEmitter {
     // Use provided adapter or auto-detect controller
     const adapter = options.controllerAdapter ?? (await this.detectController());
 
-    // Select appropriate converter for detected controller
-    const converter = this.getConverterFor(adapter);
+    // Use provided converter or select appropriate one for detected controller
+    const converter = options.converter ?? this.getConverterFor(adapter);
 
     // Create DAW deployers for requested targets
     const deployers = options.deployers ?? (await this.createDeployers(options.targets));
@@ -275,7 +277,8 @@ export class DeploymentWorkflow extends EventEmitter {
     } catch (error) {
       const errorMsg = error instanceof Error ? error.message : 'Unknown workflow error';
       errors.push(errorMsg);
-      this.emit('error', new Error(errorMsg));
+      // Emit error event for listeners, but don't re-throw
+      this.emit('error', error instanceof Error ? error : new Error(errorMsg));
 
       const result: WorkflowResult = {
         success: false,


---

_**Agent (claude-sonnet-4-5-20250929)**_

test(controller-workflow): fix mock handling and error event listeners

