<!-- Generated by SpecStory -->

# 2025-10-17 15:42:51Z

<!-- Claude Code Session e3b5d4cd-fa98-4c68-a284-a6011705b615 (2025-10-17_15-42-51Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md b/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md
index bf1d19c..9a74dbb 100644
--- a/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md
+++ b/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md
@@ -6966,3 +6966,15633 @@ _**Agent (claude-sonnet-4-5-20250929)**_
 
 Perfect! Now let me verify all the changes one more time before we potentially do another release:
 
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Final verification before release
+
+`echo "=== Final Verification ===" && echo -e "\nâœ“ Files modified:" && ls -lt src/index.ts package.json src/backends/NodeMidiBackend.ts | awk '{print $6, $7, $8, $9}' && echo -e "\nâœ“ TypeScript compilation:" && pnpm typecheck 2>&1 | grep -E "Done|error" | head -5 && echo -e "\nâœ“ Build status:" && pnpm build 2>&1 | grep -E "built in|error" && echo -e "\nâœ“ Test status:" && pnpm test:fast 2>&1 | tail -3`
+
+Result:
+
+```
+=== Final Verification ===
+
+âœ“ Files modified:
+Oct 16 19:12 src/index.ts
+Oct 16 19:10 package.json
+Oct 16 19:04 src/backends/NodeMidiBackend.ts
+
+âœ“ TypeScript compilation:
+
+âœ“ Build status:
+[vite:dts] Declaration files built in 910ms.
+âœ“ built in 1.07s
+
+âœ“ Test status:
+   Start at  19:13:27
+   Duration  571ms (transform 307ms, setup 102ms, collect 470ms, tests 106ms, environment 1ms, prepare 498ms)
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Excellent! Everything is working. Let me create a summary of the changes:
+
+## Summary
+
+I've successfully fixed the packaging issue reported in Issue #36. The problem was that the library was trying to import the Node.js-only `midi` package in browser builds.
+
+### Changes Made:
+
+1. **`package.json`** - Moved `midi` from `peerDependencies` to `devDependencies` and removed `peerDependenciesMeta`
+2. **`src/index.ts`** - Removed export of `NodeMidiBackend` from the main entry point (line 33)
+3. **`src/backends/NodeMidiBackend.ts`** - Added type assertion to fix TypeScript compilation error (line 195)
+
+### Results:
+
+âœ… **Build succeeds** with no import errors  
+âœ… **Bundle size reduced** from 160KB to 143KB  
+âœ… **No `midi` imports in production build**  
+âœ… **All tests pass** (NodeMidiBackend still available via direct import for testing)  
+âœ… **TypeScript compilation passes**
+
+### Files Verified:
+- `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/package.json` - Modified at Oct 16 19:10
+- `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/index.ts` - Modified at Oct 16 19:12
+- `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/backends/NodeMidiBackend.ts` - Modified at Oct 16 19:04
+
+The library is now properly configured for browser use with the Node.js MIDI backend only available during development and testing. A comment has been added to Issue #36 explaining the fix.
+
+---
+
+_**User**_
+
+The user has accepted the fix--see the latest comment on the github issue. It's ok to close, now.
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+I'll check the latest comment on the issue to confirm the user has accepted the fix, then close the issue.
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Get latest comment on issue 36
+
+`gh issue view 36 --json comments --jq '.comments[-1] | {author: .author.login, createdAt: .createdAt, body: .body}'`
+
+Result:
+
+```
+{"author":"oletizi","body":"## âœ… v1.20.17 TEST RESULTS: SUCCESS\\!\n\n**Date Tested:** 2025-10-16  \n**Tested By:** Automated Playwright testing with xl3-web application\n\n### ğŸ‰ Breakthrough: Slot Write Operations Now Working\\!\n\nVersion **1.20.17** successfully resolves the slot write persistence bug\\! This is the **first version** to pass the slot copy test.\n\n### Test Results\n\n**Test Workflow:**\n1. âœ… Fetched mode \"Custom M\" (48 controls) from Slot 1\n2. âœ… Selected Slot 3 in web UI\n3. âœ… Sent mode to Slot 3\n4. âœ… **NO ERROR\\!** (Previous versions failed with status 0x9)\n5. âœ… Fetched from Slot 3 to verify\n6. âœ… **Data persistence confirmed** - received same mode with all 48 controls\n\n### Console Evidence\n\n\```javascript\n// Slot selection working correctly\n[LOG] [DeviceManager] Selecting slot 3 before write\n[LOG] [DeviceManager] Slot selection SysEx bytes for slot 3: 0xF0 0x00 0x20 0x29 0x02 0x77 0x03 0xF7\n[LOG] [DeviceManager] Message length: 8 bytes\n\n// âœ… NO ERROR\\! (previous versions showed \"Write failed for page 0: status 0x9\")\n\n// Verification fetch successful\n[LOG] 1. Fetching from slot: 3\n[LOG] 2. Received mode name: Custom M                 âœ… CORRECT\\!\n[LOG] 3. Received controls count: 48                  âœ… CORRECT\\!\n\```\n\n### Version Comparison\n\n| Version | Slot Selection | Write Result | Data Verification |\n|---------|----------------|--------------|-------------------|\n| v1.20.2 | âŒ No attempt | âŒ Status 0x9 error | âŒ Old data returned |\n| v1.20.8 | âš ï¸ Attempted | âŒ Status 0x9 error | âŒ Old data returned |\n| v1.20.10 | âš ï¸ Attempted + logs | âŒ Status 0x9 error | âŒ Old data returned |\n| v1.20.16 | âš ï¸ Build error | âš ï¸ Could not test | âš ï¸ Could not test |\n| **v1.20.17** | **âœ… Working** | **âœ… Success** | **âœ… Correct data** |\n\n### What Works Now\n\n- âœ… Copy modes between any slots (0-14)\n- âœ… Write to inactive slots programmatically\n- âœ… Device accepts write operations after slot selection\n- âœ… Data persists correctly across slot operations\n- âœ… Multi-slot management from web UI fully functional\n\n### Note on v1.20.16\n\nv1.20.16 failed to build with error:\n\```\nError: Could not resolve \"midi\" imported by \"@oletizi/launch-control-xl3\". Is it installed?\n\```\n\nThis is a packaging issue - the package installs but Vite cannot resolve the \"midi\" import. Testing was not possible. v1.20.17 resolves this build issue.\n\n### Conclusion\n\n**The slot selection implementation in v1.20.17 is working perfectly\\!** \n\nWhatever changes were made between v1.20.10 and v1.20.17 (aside from the v1.20.16 build issue) successfully resolved the device firmware rejection. The slot selection SysEx command (0x77) is now properly:\n1. Changing the device's active slot\n2. Allowing write operations to proceed\n3. Ensuring data persistence\n\n**Recommendation:** v1.20.17 should be marked as the official fix for this issue.\n\n**Documentation:** Full test results documented in xl3-web repo at `docs/1.0/issues/4/investigation-results.md`\n\nThank you for the excellent work debugging and fixing this issue\\! ğŸŠ","createdAt":"2025-10-17T02:21:33Z"}
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! The user has confirmed that v1.20.17 fixes both issues:
+1. âœ… The original slot write bug (Issue #36)
+2. âœ… The packaging/build issue (v1.20.16 error)
+
+Now I'll close the issue:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Close issue 36 as resolved
+
+`gh issue close 36 --comment "## Issue Resolved in v1.20.17 âœ…
+
+Closing this issue as **resolved** based on successful user acceptance testing.
+
+### What Was Fixed
+
+**Root Cause:** The write acknowledgement status byte was being interpreted as a success/failure code, when it's actually a **slot identifier** using CC 30 encoding.
+
+**The Fix:**
+- Slots 0-3: Expected status = \`0x06 + slot\`
+- Slots 4-14: Expected status = \`0x0E + slot\`
+
+**Additional Fix (v1.20.17):** Resolved packaging issue where \`NodeMidiBackend\` was incorrectly exported from main entry point, causing build errors in browser environments.
+
+### Test Results
+
+âœ… **Slot write operations working** across all slots 0-14  
+âœ… **Data persistence confirmed** - modes copy correctly between slots  
+âœ… **Browser build fixed** - no more \`midi\` import errors  
+âœ… **Full test coverage** - Automated Playwright tests passing  
+
+### Documentation
+
+- Protocol changes documented in \`docs/PROTOCOL.md\`
+- Implementation details in \`src/device/DeviceManager.ts\`
+- Test evidence in xl3-web repo
+
+Thank you for the detailed testing and feedback! ğŸ‰"`
+
+Result:
+
+```
+âœ“ Closed issue oletizi/ol_dsp#36 (Launch Control XL3: Device firmware rejects writes to inactive slots (status 0x9))
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! Issue #36 has been successfully closed. Let me verify the closure:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Verify issue 36 is closed
+
+`gh issue view 36 --json number,title,state,closedAt --jq '{number, title, state, closedAt}'`
+
+Result:
+
+```
+{"closedAt":"2025-10-17T02:23:11Z","number":36,"state":"CLOSED","title":"Launch Control XL3: Device firmware rejects writes to inactive slots (status 0x9)"}
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Excellent! Issue #36 has been successfully closed.
+
+## Summary
+
+âœ… **Issue #36 - CLOSED** at 2025-10-17T02:23:11Z
+
+### Complete Resolution Timeline:
+
+1. **v1.20.14** - Fixed core protocol bug (write acknowledgement interpretation)
+2. **v1.20.16** - Version bump (had packaging issue)
+3. **v1.20.17** - Fixed packaging issue (removed NodeMidiBackend export, moved `midi` to devDependencies)
+
+### Fixes Delivered:
+
+âœ… **Protocol fix** - Correct interpretation of write acknowledgement status byte as slot identifier  
+âœ… **Packaging fix** - Removed Node.js-only MIDI backend from browser bundle  
+âœ… **Bundle optimization** - Reduced size from 160KB to 143KB  
+âœ… **User acceptance** - Confirmed working by automated Playwright tests  
+
+The issue is now fully resolved and closed with user acceptance confirmation.
+
+---
+
+_**User**_
+
+the launch-control-xl3 has an 8-character max on mode names, which is arbitrary and wrong. The actual max is 18 characters.
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+I'll fix the mode name length limit from 8 characters to 18 characters. Let me first find where this constraint is defined.
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Grep** path `./src`
+
+Result:
+
+```
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/utils/bitwise.ts:137:  for (let i = 0; i < cleanBinary.length; i += 8) {
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/utils/bitwise.ts:139:    if (chunk.length === 8) {
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/core/Midimunge.ts:149:    const fullChunks = Math.floor(encodedLength / 8);
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/core/Midimunge.ts:150:    const remainder = encodedLength % 8;
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/core/Midimunge.ts:323:    const field = new MidimungeBitField(bytes.length * 8);
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:44:   * Set the custom mode name (max 8 characters)
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:47:    if (name.length > 8) {
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:48:      throw new Error('Mode name must be 8 characters or less');
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Found it! Let me search for more references to understand the complete picture:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Grep** path `./src`
+
+Result:
+
+```
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:36:  private modeName: string = '';
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:44:   * Set the custom mode name (max 8 characters)
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:48:      throw new Error('Mode name must be 8 characters or less');
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:50:    this.modeName = name;
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:238:    if (!this.modeName) {
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:239:      throw new Error('Mode name is required');
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:253:      name: this.modeName,
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts:276:    const builder = new CustomModeBuilder().name('CHANNEV');
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Let me also check the protocol documentation and parser to see if there are other references:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Check protocol docs for name length
+
+`grep -rn "8 char\|8-char\|max.*8\|18 char\|18-char" modules/launch-control-xl3/docs/PROTOCOL.md | head -10`
+
+Result:
+
+```
+grep: modules/launch-control-xl3/docs/PROTOCOL.md: No such file or directory
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Find PROTOCOL.md file
+
+`pwd && find . -name "PROTOCOL.md" -type f 2>/dev/null`
+
+Result:
+
+```
+/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
+./docs/PROTOCOL.md
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Check protocol docs for mode name length
+
+`grep -n "8 char\|8-char\|max.*8\|18 char\|18-char\|mode name" docs/PROTOCOL.md | head -15`
+
+Result:
+
+```
+62:   - Request page 0 (controls 0x10-0x27 + mode name + labels)
+63:   - Request page 1 (controls 0x28-0x3F + mode name + labels)
+225:- âœ… **10/11 changes verified successfully** (see Known Issues for mode name limitation)
+305:**Discovery:** By comparing MIDI captures of web editor write operations with different mode names:
+323:1. The mode name field may have an undocumented length limit
+325:3. The device firmware may truncate/modify mode names in specific ways
+416:      â””â”€ length = 8 chars
+449:  name: "MODE_NAME",  // String, max 8 characters
+528:â””â”€ Marker 0x68 = 8 chars
+735:| 2.0 | 2025-10-16 | **VERIFIED:** Write acknowledgement status byte is slot identifier. Confirmed with successful test run writing to slot 3. Control CC numbers, channels verified to persist correctly (10/11 changes successful). Issue #36 RESOLVED - bug was in library, not firmware. Added Known Issue: mode name truncation ("TESTMOD" â†’ "M"). |
+744:| 1.1 | 2025-09-30 | Documented write protocol (command 0x45) with mode name format discovery |
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Now let me check the Kaitai Struct format definition:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Check .ksy format for mode name definition
+
+`grep -n "mode_name\|name:" formats/launch_control_xl3.ksy | head -20`
+
+Result:
+
+```
+48:      - id: mode_name_section
+49:        type: mode_name
+74:  mode_name:
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Read** `./formats/launch_control_xl3.ksy`
+
+Result:
+
+```
+74â†’  mode_name:
+    75â†’    seq:
+    76â†’      - id: name_marker
+    77â†’        contents: [0x06, 0x20]
+    78â†’      - id: name_length
+    79â†’        type: u1
+    80â†’        doc: Length of mode name (0-8 characters)
+    81â†’      - id: name_bytes
+    82â†’        size: name_length
+    83â†’        type: str
+    84â†’        encoding: ASCII
+    85â†’        if: name_length > 0
+    86â†’    doc: |
+    87â†’      Mode name format (READ/response):
+    88â†’        06 20 [length] [name_bytes]
+    89â†’
+    90â†’      Mode name format (WRITE/request):
+    91â†’        20 [length] [name_bytes]
+    92â†’
+    93â†’      Discovery: Web editor MIDI capture (2025-09-30)
+    94â†’      Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
+    95â†’
+    96â†’  control_definition:
+    97â†’    doc: |
+    98â†’      11-byte control definition structure found in READ responses.
+    99â†’      Marker byte is always 0x48 (not 0x40, 0x49, or any other value).
+   100â†’
+   101â†’      Note: The min_value field (position +7) may contain 0x40 (decimal 64) as DATA.
+   102â†’      This is not a control marker - it's simply a minValue of 64.
+   103â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Now let me check for any test files that might have hardcoded expectations:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Check tests for 8-character constraints
+
+`grep -rn "8.*char\|length.*8\|maxLength.*8" test/ --include="*.ts" | grep -i "name\|mode" | head -10`
+
+Result:
+
+```
+test/unit/CustomModeManager.test.ts:969:      expect(Object.keys(mode.controls).length).toBe(48);
+test/core/SysExParser.test.ts:690:      it('should limit mode name to 8 characters maximum', () => {
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! Now I have a complete picture. Let me create a task list and update all the necessary files:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+**Agent task list:**
+- [âš¡] ğŸŒ¡ï¸ Update CustomModeBuilder.ts to change max length from 8 to 18
+- [ ] ğŸŒ¡ï¸ Update launch_control_xl3.ksy format specification
+- [ ] ğŸŒ¡ï¸ Update PROTOCOL.md documentation
+- [ ] ğŸŒ¡ï¸ Update test file expectations
+- [ ] ğŸŒ¡ï¸ Run tests to verify changes
+
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Now let me update the CustomModeBuilder.ts file:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Read** `./src/builders/CustomModeBuilder.ts`
+
+Result:
+
+```
+40â†’    colors: new Map()
+    41â†’  };
+    42â†’
+    43â†’  /**
+    44â†’   * Set the custom mode name (max 8 characters)
+    45â†’   */
+    46â†’  name(name: string): this {
+    47â†’    if (name.length > 8) {
+    48â†’      throw new Error('Mode name must be 8 characters or less');
+    49â†’    }
+    50â†’    this.modeName = name;
+    51â†’    return this;
+    52â†’  }
+    53â†’
+    54â†’  /**
+```
+
+_**User**_
+
+[Request interrupted by user]
+
+_**User**_
+
+delegate to your team of agents. Check out a suitably named branch before making changes.
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+I'll delegate this task to the appropriate agents. Let me create a new branch and coordinate the team to fix the mode name length limit.
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Create new branch for mode name fix
+
+`git checkout -b fix/mode-name-18-chars`
+
+Result:
+
+```
+Switched to a new branch 'fix/mode-name-18-chars'
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Verify branch status
+
+`git status`
+
+Result:
+
+```
+On branch fix/mode-name-18-chars
+Changes not staged for commit:
+  (use "git add <file>..." to update what will be committed)
+  (use "git restore <file>..." to discard changes in working directory)
+	modified:   ../../.specstory/history/2025-10-17_01-47-39Z-warmup.md
+
+Untracked files:
+  (use "git add <file>..." to include in what will be committed)
+	../../.specstory/history/2025-10-17_02-13-53Z-analyze-these-staged-git.md
+
+no changes added to commit (use "git add" and/or "git commit -a")
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Now I'll launch agents in parallel to handle the different aspects of this fix:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Task** Update TypeScript code for 18-char limit
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Task** Update documentation for 18-char limit
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Task** Update tests for 18-char limit
+
+---
+
+_**User (sidechain)**_
+
+Update the mode name length limit from 8 to 18 characters in the Launch Control XL3 module.
+
+**Files to update:**
+
+1. **src/builders/CustomModeBuilder.ts** (lines 44, 47-48):
+   - Change comment from "max 8 characters" to "max 18 characters"
+   - Change validation from `name.length > 8` to `name.length > 18`
+   - Change error message from "Mode name must be 8 characters or less" to "Mode name must be 18 characters or less"
+
+2. **Verify these changes work:**
+   - Run `pnpm typecheck` to ensure no TypeScript errors
+   - Run `pnpm build` to ensure build succeeds
+   - Report back the file paths and line numbers you changed
+
+**IMPORTANT:** Follow the file verification protocol - after making changes, use `ls -la` and `cat` or `head` to verify the files were actually modified correctly.
+
+_**User (sidechain)**_
+
+Update the documentation for the mode name length limit from 8 to 18 characters in the Launch Control XL3 module.
+
+**Files to update:**
+
+1. **formats/launch_control_xl3.ksy** (line 80):
+   - Change "Length of mode name (0-8 characters)" to "Length of mode name (0-18 characters)"
+   - Update any examples or comments that reference 8-character limit
+
+2. **docs/PROTOCOL.md**:
+   - Search for references to "8 char", "8-char", "max 8", or "8 characters" related to mode names
+   - Update all occurrences to "18 characters"
+   - Update the version history to document this correction
+   - Add an entry explaining this was a documentation error, not a protocol change
+
+**IMPORTANT:** 
+- Follow the file verification protocol - after making changes, use `ls -la` and `cat` or `head` to verify the files were actually modified
+- This is a documentation fix, not a protocol change - the device always supported 18 characters, the library just had the wrong limit
+
+_**User (sidechain)**_
+
+Update test files for the mode name length limit change from 8 to 18 characters in the Launch Control XL3 module.
+
+**File to update:**
+
+1. **test/core/SysExParser.test.ts** (around line 690):
+   - Find the test "should limit mode name to 8 characters maximum"
+   - Change it to test for 18 characters maximum
+   - Update any test assertions or expectations
+   - Add a test case for exactly 18 characters (should pass)
+   - Add a test case for 19 characters (should fail)
+
+**After updating:**
+- Run `pnpm test:fast` to verify tests pass
+- Report back which tests you updated and their results
+
+**IMPORTANT:** Follow the file verification protocol - after making changes, verify with `cat` or `grep` that the changes were applied.
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+I'll update the documentation to correct the mode name length limit from 8 to 18 characters. Let me first examine the files that need to be updated.
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+I'll update the mode name length limit from 8 to 18 characters in the Launch Control XL3 module and verify the changes.
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./src/builders/CustomModeBuilder.ts`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./formats/launch_control_xl3.ksy`
+
+Result:
+
+```
+1â†’/**
+     2â†’ * High-level API for building Launch Control XL 3 custom modes
+     3â†’ * Provides a fluent interface for defining control mappings, labels, and colors
+     4â†’ */
+     5â†’
+     6â†’import type { CustomMode, Control, ControlType } from '@/types/CustomMode.js';
+     7â†’
+     8â†’export enum Color {
+     9â†’  OFF = 0x0C,
+    10â†’  RED_LOW = 0x0D,
+    11â†’  RED_FULL = 0x0F,
+    12â†’  AMBER_LOW = 0x1D,
+    13â†’  AMBER_FULL = 0x3F,
+    14â†’  YELLOW = 0x3E,
+    15â†’  GREEN_LOW = 0x1C,
+    16â†’  GREEN_FULL = 0x3C
+    17â†’}
+    18â†’
+    19â†’interface ControlConfig {
+    20â†’  cc: number;
+    21â†’  channel?: number;
+    22â†’  min?: number;
+    23â†’  max?: number;
+    24â†’}
+    25â†’
+    26â†’interface LabelColorData {
+    27â†’  labels: Map<number, string>;
+    28â†’  colors: Map<number, Color>;
+    29â†’}
+    30â†’
+    31â†’/**
+    32â†’ * Builder for creating Launch Control XL 3 custom modes
+    33â†’ * Provides a fluent API for defining controls, labels, and colors
+    34â†’ */
+    35â†’export class CustomModeBuilder {
+    36â†’  private modeName: string = '';
+    37â†’  private controls: Control[] = [];
+    38â†’  private labelData: LabelColorData = {
+    39â†’    labels: new Map(),
+    40â†’    colors: new Map()
+    41â†’  };
+    42â†’
+    43â†’  /**
+    44â†’   * Set the custom mode name (max 8 characters)
+    45â†’   */
+    46â†’  name(name: string): this {
+    47â†’    if (name.length > 8) {
+    48â†’      throw new Error('Mode name must be 8 characters or less');
+    49â†’    }
+    50â†’    this.modeName = name;
+    51â†’    return this;
+    52â†’  }
+    53â†’
+    54â†’  /**
+    55â†’   * Add a fader control mapping
+    56â†’   * @param faderNumber 1-8
+    57â†’   * @param config Control configuration
+    58â†’   */
+    59â†’  addFader(faderNumber: number, config: ControlConfig): this {
+    60â†’    if (faderNumber < 1 || faderNumber > 8) {
+    61â†’      throw new Error('Fader number must be 1-8');
+    62â†’    }
+    63â†’
+    64â†’    const controlId = 0x28 + (faderNumber - 1); // 0x28-0x2F
+    65â†’    this.addControl(controlId, 0x09, config);
+    66â†’    return this;
+    67â†’  }
+    68â†’
+    69â†’  /**
+    70â†’   * Add a top row encoder control mapping
+    71â†’   * @param row 1 (always 1 for top row)
+    72â†’   * @param encoderNumber 1-8
+    73â†’   * @param config Control configuration
+    74â†’   */
+    75â†’  addEncoder(row: 1, encoderNumber: number, config: ControlConfig): this;
+    76â†’  /**
+    77â†’   * Add a middle row encoder control mapping
+    78â†’   * @param row 2 (for middle row)
+    79â†’   * @param encoderNumber 1-8
+    80â†’   * @param config Control configuration
+    81â†’   */
+    82â†’  addEncoder(row: 2, encoderNumber: number, config: ControlConfig): this;
+    83â†’  /**
+    84â†’   * Add a bottom row encoder control mapping
+    85â†’   * @param row 3 (for bottom row)
+    86â†’   * @param encoderNumber 1-8
+    87â†’   * @param config Control configuration
+    88â†’   */
+    89â†’  addEncoder(row: 3, encoderNumber: number, config: ControlConfig): this;
+    90â†’  addEncoder(row: 1 | 2 | 3, encoderNumber: number, config: ControlConfig): this {
+    91â†’    if (encoderNumber < 1 || encoderNumber > 8) {
+    92â†’      throw new Error('Encoder number must be 1-8');
+    93â†’    }
+    94â†’
+    95â†’    let controlId: number;
+    96â†’    let controlType: ControlType;
+    97â†’
+    98â†’    switch (row) {
+    99â†’      case 1: // Top row
+   100â†’        controlId = 0x10 + (encoderNumber - 1); // 0x10-0x17
+   101â†’        controlType = 0x05;
+   102â†’        break;
+   103â†’      case 2: // Middle row
+   104â†’        controlId = 0x18 + (encoderNumber - 1); // 0x18-0x1F
+   105â†’        controlType = 0x09;
+   106â†’        break;
+   107â†’      case 3: // Bottom row
+   108â†’        controlId = 0x20 + (encoderNumber - 1); // 0x20-0x27
+   109â†’        controlType = 0x0D;
+   110â†’        break;
+   111â†’      default:
+   112â†’        throw new Error('Row must be 1, 2, or 3');
+   113â†’    }
+   114â†’
+   115â†’    this.addControl(controlId, controlType, config);
+   116â†’    return this;
+   117â†’  }
+   118â†’
+   119â†’  /**
+   120â†’   * Add a side button control mapping (track focus buttons)
+   121â†’   * @param buttonNumber 1-8
+   122â†’   * @param config Control configuration
+   123â†’   */
+   124â†’  addSideButton(buttonNumber: number, config: ControlConfig): this {
+   125â†’    if (buttonNumber < 1 || buttonNumber > 8) {
+   126â†’      throw new Error('Side button number must be 1-8');
+   127â†’    }
+   128â†’
+   129â†’    const controlId = 0x30 + (buttonNumber - 1); // 0x30-0x37
+   130â†’    this.addControl(controlId, 0x19, config);
+   131â†’    return this;
+   132â†’  }
+   133â†’
+   134â†’  /**
+   135â†’   * Add a bottom button control mapping
+   136â†’   * @param buttonNumber 1-16
+   137â†’   * @param config Control configuration
+   138â†’   */
+   139â†’  addBottomButton(buttonNumber: number, config: ControlConfig): this {
+   140â†’    if (buttonNumber < 1 || buttonNumber > 16) {
+   141â†’      throw new Error('Bottom button number must be 1-16');
+   142â†’    }
+   143â†’
+   144â†’    const controlId = 0x30 + (buttonNumber - 1); // 0x30-0x3F
+   145â†’    this.addControl(controlId, 0x25, config);
+   146â†’    return this;
+   147â†’  }
+   148â†’
+   149â†’  /**
+   150â†’   * Add a label for a control
+   151â†’   * @param controlId The hardware control ID (or use helper methods)
+   152â†’   * @param label The label text
+   153â†’   */
+   154â†’  addLabel(controlId: number, label: string): this {
+   155â†’    this.labelData.labels.set(controlId, label);
+   156â†’    return this;
+   157â†’  }
+   158â†’
+   159â†’  /**
+   160â†’   * Add a label for a fader
+   161â†’   * @param faderNumber 1-8
+   162â†’   * @param label The label text
+   163â†’   */
+   164â†’  addFaderLabel(faderNumber: number, label: string): this {
+   165â†’    if (faderNumber < 1 || faderNumber > 8) {
+   166â†’      throw new Error('Fader number must be 1-8');
+   167â†’    }
+   168â†’    return this.addLabel(0x28 + (faderNumber - 1), label);
+   169â†’  }
+   170â†’
+   171â†’  /**
+   172â†’   * Add a label for an encoder
+   173â†’   * @param row 1, 2, or 3
+   174â†’   * @param encoderNumber 1-8
+   175â†’   * @param label The label text
+   176â†’   */
+   177â†’  addEncoderLabel(row: 1 | 2 | 3, encoderNumber: number, label: string): this {
+   178â†’    if (encoderNumber < 1 || encoderNumber > 8) {
+   179â†’      throw new Error('Encoder number must be 1-8');
+   180â†’    }
+   181â†’
+   182â†’    let controlId: number;
+   183â†’    switch (row) {
+   184â†’      case 1:
+   185â†’        controlId = 0x10 + (encoderNumber - 1);
+   186â†’        break;
+   187â†’      case 2:
+   188â†’        controlId = 0x18 + (encoderNumber - 1);
+   189â†’        break;
+   190â†’      case 3:
+   191â†’        controlId = 0x20 + (encoderNumber - 1);
+   192â†’        break;
+   193â†’      default:
+   194â†’        throw new Error('Row must be 1, 2, or 3');
+   195â†’    }
+   196â†’
+   197â†’    return this.addLabel(controlId, label);
+   198â†’  }
+   199â†’
+   200â†’  /**
+   201â†’   * Add a color for a control
+   202â†’   * @param controlId The hardware control ID
+   203â†’   * @param color The color value
+   204â†’   */
+   205â†’  addColor(controlId: number, color: Color): this {
+   206â†’    this.labelData.colors.set(controlId, color);
+   207â†’    return this;
+   208â†’  }
+   209â†’
+   210â†’  /**
+   211â†’   * Add a color for a side button
+   212â†’   * @param buttonNumber 1-8
+   213â†’   * @param color The color value
+   214â†’   */
+   215â†’  addSideButtonColor(buttonNumber: number, color: Color): this {
+   216â†’    if (buttonNumber < 1 || buttonNumber > 8) {
+   217â†’      throw new Error('Side button number must be 1-8');
+   218â†’    }
+   219â†’    return this.addColor(0x30 + (buttonNumber - 1), color);
+   220â†’  }
+   221â†’
+   222â†’  /**
+   223â†’   * Add a color for a bottom button
+   224â†’   * @param buttonNumber 1-16
+   225â†’   * @param color The color value
+   226â†’   */
+   227â†’  addBottomButtonColor(buttonNumber: number, color: Color): this {
+   228â†’    if (buttonNumber < 1 || buttonNumber > 16) {
+   229â†’      throw new Error('Bottom button number must be 1-16');
+   230â†’    }
+   231â†’    return this.addColor(0x30 + (buttonNumber - 1), color);
+   232â†’  }
+   233â†’
+   234â†’  /**
+   235â†’   * Build the custom mode object
+   236â†’   */
+   237â†’  build(): CustomMode {
+   238â†’    if (!this.modeName) {
+   239â†’      throw new Error('Mode name is required');
+   240â†’    }
+   241â†’
+   242â†’    if (this.controls.length === 0) {
+   243â†’      throw new Error('At least one control mapping is required');
+   244â†’    }
+   245â†’
+   246â†’    // Convert controls array to Record for CustomMode interface
+   247â†’    const controlsRecord: Record<string, any> = {};
+   248â†’    for (const control of this.controls) {
+   249â†’      controlsRecord[`control_${control.controlId}`] = control;
+   250â†’    }
+   251â†’
+   252â†’    return {
+   253â†’      name: this.modeName,
+   254â†’      controls: controlsRecord,
+   255â†’      labels: this.labelData.labels,
+   256â†’      colors: this.labelData.colors
+   257â†’    };
+   258â†’  }
+   259â†’
+   260â†’  /**
+   261â†’   * Create a builder pre-configured for a simple test mode
+   262â†’   */
+   263â†’  static createTestMode(): CustomModeBuilder {
+   264â†’    return new CustomModeBuilder()
+   265â†’      .name('TEST')
+   266â†’      .addFader(1, { cc: 10, channel: 1 })
+   267â†’      .addEncoder(1, 1, { cc: 13, channel: 1 })
+   268â†’      .addEncoderLabel(1, 1, 'Filter')
+   269â†’      .addFaderLabel(1, 'Volume');
+   270â†’  }
+   271â†’
+   272â†’  /**
+   273â†’   * Create a builder pre-configured for the CHANNEV mode
+   274â†’   */
+   275â†’  static createChannevMode(): CustomModeBuilder {
+   276â†’    const builder = new CustomModeBuilder().name('CHANNEV');
+   277â†’
+   278â†’    // Top row encoders (CC 13-20)
+   279â†’    for (let i = 1; i <= 8; i++) {
+   280â†’      builder.addEncoder(1, i, { cc: 12 + i, channel: 1 });
+   281â†’    }
+   282â†’
+   283â†’    // Middle row encoders (CC 21-28)
+   284â†’    for (let i = 1; i <= 8; i++) {
+   285â†’      builder.addEncoder(2, i, { cc: 20 + i, channel: 1 });
+   286â†’    }
+   287â†’
+   288â†’    // Bottom row encoders (CC 29-36)
+   289â†’    for (let i = 1; i <= 8; i++) {
+   290â†’      builder.addEncoder(3, i, { cc: 28 + i, channel: 1 });
+   291â†’    }
+   292â†’
+   293â†’    // Add labels for key controls
+   294â†’    builder
+   295â†’      .addEncoderLabel(1, 1, 'Mic Gain')
+   296â†’      .addEncoderLabel(1, 2, 'Line Amp Gain')
+   297â†’      .addEncoderLabel(1, 4, 'Low Pass')
+   298â†’      .addEncoderLabel(2, 1, 'High Shelf')
+   299â†’      .addEncoderLabel(2, 2, 'Low Freq')
+   300â†’      .addEncoderLabel(2, 3, 'Low Mid Freq')
+   301â†’      .addEncoderLabel(2, 4, 'High Mid Freq')
+   302â†’      .addEncoderLabel(2, 5, 'High Freq')
+   303â†’      .addEncoderLabel(3, 1, 'Low Shelf')
+   304â†’      .addEncoderLabel(3, 2, 'Low Gain')
+   305â†’      .addEncoderLabel(3, 3, 'Low Mid Gain')
+   306â†’      .addEncoderLabel(3, 4, 'High Mid Gain')
+   307â†’      .addEncoderLabel(3, 5, 'High Gain');
+   308â†’
+   309â†’    return builder;
+   310â†’  }
+   311â†’
+   312â†’  private addControl(controlId: number, controlType: ControlType, config: ControlConfig): void {
+   313â†’    // Check for duplicate control
+   314â†’    if (this.controls.find(c => c.controlId === controlId)) {
+   315â†’      throw new Error(`Control ${controlId.toString(16)} already defined`);
+   316â†’    }
+   317â†’
+   318â†’    // Validate CC range
+   319â†’    if (config.cc < 0 || config.cc > 127) {
+   320â†’      throw new Error('CC number must be 0-127');
+   321â†’    }
+   322â†’
+   323â†’    // Validate channel
+   324â†’    const channel = config.channel ?? 1;
+   325â†’    if (channel < 1 || channel > 16) {
+   326â†’      throw new Error('MIDI channel must be 1-16');
+   327â†’    }
+   328â†’
+   329â†’    const control: Control = {
+   330â†’      controlId,
+   331â†’      controlType,
+   332â†’      midiChannel: channel - 1, // Convert to 0-based
+   333â†’      ccNumber: config.cc,
+   334â†’      minValue: config.min ?? 0,
+   335â†’      maxValue: config.max ?? 127,
+   336â†’      behavior: 'absolute'
+   337â†’    };
+   338â†’
+   339â†’    this.controls.push(control);
+   340â†’  }
+   341â†’}
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./docs/PROTOCOL.md`
+
+Result:
+
+```
+1â†’meta:
+     2â†’  id: launch_control_xl3_custom_mode
+     3â†’  title: Novation Launch Control XL3 Custom Mode Format
+     4â†’  file-extension: bin
+     5â†’  endian: be
+     6â†’  license: MIT
+     7â†’  ks-version: 0.11
+     8â†’
+     9â†’doc: |
+    10â†’  Custom mode configuration format for Novation Launch Control XL3.
+    11â†’
+    12â†’  The custom mode data is split across 2 SysEx message pages:
+    13â†’  - Page 0 (SysEx byte 0x00): Mode name + controls 0x10-0x27 (24 controls) + labels
+    14â†’  - Page 1 (SysEx byte 0x03): Mode name + controls 0x28-0x3F (24 controls) + labels
+    15â†’
+    16â†’  Total: 48 controls (0x10-0x3F)
+    17â†’
+    18â†’  Empirically discovered format through MIDI traffic analysis.
+    19â†’
+    20â†’  Version History:
+    21â†’  - v1.5 (2025-10-11): Documented parser bug fix - 0x40 appears as data in minValue field, not as control marker
+    22â†’  - v1.4 (2025-10-09): Corrected to 2 pages (0x00, 0x03), not 3 pages. Updated to reflect working code.
+    23â†’  - v1.3 (2025-09-30): Documented read slot byte behavior for DAW port integration
+    24â†’  - v1.2 (2025-09-30): Added write acknowledgement message format (command 0x15)
+    25â†’  - v1.1 (2025-09-30): Documented write protocol format (command 0x45)
+    26â†’  - v1.0 (2025-09-30): Initial read protocol specification
+    27â†’
+    28â†’seq:
+    29â†’  - id: page_0
+    30â†’    type: custom_mode_page
+    31â†’    doc: First page with mode name and controls 0x10-0x27 (24 controls)
+    32â†’  - id: page_1
+    33â†’    type: custom_mode_page
+    34â†’    doc: Second page with mode name and controls 0x28-0x3F (24 controls)
+    35â†’
+    36â†’types:
+    37â†’  custom_mode_page:
+    38â†’    doc: |
+    39â†’      A single page of custom mode data containing 24 control definitions.
+    40â†’
+    41â†’      Page 0 (SysEx byte 0x00): Controls 0x10-0x27
+    42â†’      Page 1 (SysEx byte 0x03): Controls 0x28-0x3F
+    43â†’
+    44â†’      Both pages contain the mode name (for redundancy/verification).
+    45â†’    seq:
+    46â†’      - id: header
+    47â†’        type: page_header
+    48â†’      - id: mode_name_section
+    49â†’        type: mode_name
+    50â†’        doc: Mode name present in both pages (redundant for verification)
+    51â†’      - id: controls
+    52â†’        type: control_definition
+    53â†’        repeat: expr
+    54â†’        repeat-expr: 24
+    55â†’        doc: 24 control definitions per page (not 16)
+    56â†’      - id: labels
+    57â†’        type: label_section
+    58â†’        size-eos: true
+    59â†’        doc: Variable-length label section
+    60â†’
+    61â†’  page_header:
+    62â†’    seq:
+    63â†’      - id: page_marker
+    64â†’        contents: [0x06, 0x00]
+    65â†’      - id: page_number
+    66â†’        type: u1
+    67â†’        doc: |
+    68â†’          Page number in SysEx message:
+    69â†’          - 0x00 for page 0 (controls 0x10-0x27)
+    70â†’          - 0x03 for page 1 (controls 0x28-0x3F)
+    71â†’      - id: unknown1
+    72â†’        size: 3
+    73â†’
+    74â†’  mode_name:
+    75â†’    seq:
+    76â†’      - id: name_marker
+    77â†’        contents: [0x06, 0x20]
+    78â†’      - id: name_length
+    79â†’        type: u1
+    80â†’        doc: Length of mode name (0-8 characters)
+    81â†’      - id: name_bytes
+    82â†’        size: name_length
+    83â†’        type: str
+    84â†’        encoding: ASCII
+    85â†’        if: name_length > 0
+    86â†’    doc: |
+    87â†’      Mode name format (READ/response):
+    88â†’        06 20 [length] [name_bytes]
+    89â†’
+    90â†’      Mode name format (WRITE/request):
+    91â†’        20 [length] [name_bytes]
+    92â†’
+    93â†’      Discovery: Web editor MIDI capture (2025-09-30)
+    94â†’      Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
+    95â†’
+    96â†’  control_definition:
+    97â†’    doc: |
+    98â†’      11-byte control definition structure found in READ responses.
+    99â†’      Marker byte is always 0x48 (not 0x40, 0x49, or any other value).
+   100â†’
+   101â†’      Note: The min_value field (position +7) may contain 0x40 (decimal 64) as DATA.
+   102â†’      This is not a control marker - it's simply a minValue of 64.
+   103â†’
+   104â†’      WARNING: Parsers must not scan for 0x40 bytes to identify controls.
+   105â†’    seq:
+   106â†’      - id: control_marker
+   107â†’        contents: [0x48]
+   108â†’        doc: Control definition marker (always 0x48 in READ responses)
+   109â†’      - id: control_id
+   110â†’        type: u1
+   111â†’        doc: Hardware control ID (0x10-0x3F)
+   112â†’      - id: def_type
+   113â†’        contents: [0x02]
+   114â†’        doc: Definition type (always 0x02)
+   115â†’      - id: control_type
+   116â†’        type: u1
+   117â†’        doc: Control type (0x00=knob top, 0x05=knob bottom, 0x09=fader, etc)
+   118â†’      - id: midi_channel
+   119â†’        type: u1
+   120â†’        doc: MIDI channel (0-15)
+   121â†’      - id: param1
+   122â†’        type: u1
+   123â†’        doc: Parameter (usually 0x01 or 0x00)
+   124â†’      - id: unknown1
+   125â†’        contents: [0x48]
+   126â†’        doc: Unknown fixed byte (always 0x48)
+   127â†’      - id: min_value
+   128â†’        type: u1
+   129â†’        doc: |
+   130â†’          Minimum value (0-127).
+   131â†’          WARNING: This may be 0x40 (64 decimal) - do NOT interpret as control marker!
+   132â†’      - id: cc_number
+   133â†’        type: u1
+   134â†’        doc: MIDI CC number (0-127)
+   135â†’      - id: max_value
+   136â†’        type: u1
+   137â†’        doc: Maximum value (0-127)
+   138â†’      - id: terminator
+   139â†’        contents: [0x00]
+   140â†’        doc: Terminator byte
+   141â†’
+   142â†’  label_section:
+   143â†’    seq:
+   144â†’      - id: unknown_padding
+   145â†’        size: 3
+   146â†’        doc: Padding bytes before labels
+   147â†’      - id: labels
+   148â†’        type: control_label
+   149â†’        repeat: until
+   150â†’        repeat-until: _io.eof or _.is_terminator
+   151â†’
+   152â†’  control_label:
+   153â†’    doc: |
+   154â†’      Control label with length-encoding scheme.
+   155â†’
+   156â†’      Discovery: Empirical testing (2025-09-30)
+   157â†’      The marker byte (0x60-0x6F) encodes the string length.
+   158â†’
+   159â†’      Length calculation: length = marker_byte - 0x60
+   160â†’
+   161â†’      Examples:
+   162â†’      - 0x60 = 0 characters (empty)
+   163â†’      - 0x65 = 5 characters ("TEST1")
+   164â†’      - 0x69 = 9 characters ("High Pass")
+   165â†’      - 0x6F = 15 characters (maximum)
+   166â†’
+   167â†’      Special control ID mapping:
+   168â†’      - Label IDs 0x19-0x1C (25-28) map to control IDs 26-29 (+1 offset)
+   169â†’      - All other label IDs map directly to control IDs
+   170â†’    seq:
+   171â†’      - id: length_marker
+   172â†’        type: u1
+   173â†’        doc: |
+   174â†’          Marker byte encoding string length (0x60-0x6F).
+   175â†’          Length = marker - 0x60 (0-15 characters).
+   176â†’      - id: control_id
+   177â†’        type: u1
+   178â†’        doc: Control ID this label applies to (0x10-0x3F)
+   179â†’      - id: name_bytes
+   180â†’        size: label_length
+   181â†’        type: str
+   182â†’        encoding: ASCII
+   183â†’        if: label_length > 0
+   184â†’        doc: Label text (ASCII, variable length)
+   185â†’    instances:
+   186â†’      label_length:
+   187â†’        value: length_marker - 0x60
+   188â†’        doc: Calculate label length from marker byte
+   189â†’      is_terminator:
+   190â†’        value: length_marker < 0x60 or control_id < 0x10
+   191â†’        doc: Check if this marks end of labels section
+   192â†’
+   193â†’  write_acknowledgement:
+   194â†’    doc: |
+   195â†’      Write acknowledgement message sent by device after receiving a page write.
+   196â†’
+   197â†’      Complete SysEx format:
+   198â†’        F0 00 20 29 02 15 05 00 15 [page] [status] F7
+   199â†’
+   200â†’      This specification covers the payload after the SysEx header.
+   201â†’
+   202â†’      Discovery: Playwright + CoreMIDI spy (2025-09-30)
+   203â†’      Observed device sending ACK 24-27ms after each page write.
+   204â†’      Web editor waits for ACK before sending next page.
+   205â†’
+   206â†’      Example (Page 0 ACK):
+   207â†’        15 00 06 = Command 0x15, Page 0, Status 0x06 (success)
+   208â†’
+   209â†’      Example (Page 1 ACK):
+   210â†’        15 03 06 = Command 0x15, Page 1, Status 0x06 (success)
+   211â†’    seq:
+   212â†’      - id: command
+   213â†’        contents: [0x15]
+   214â†’        doc: Acknowledgement command byte
+   215â†’      - id: page_number
+   216â†’        type: u1
+   217â†’        doc: |
+   218â†’          Page number being acknowledged:
+   219â†’          - 0x00 for page 0
+   220â†’          - 0x03 for page 1
+   221â†’      - id: status
+   222â†’        type: u1
+   223â†’        enum: ack_status
+   224â†’        doc: Acknowledgement status (0x06 = success)
+   225â†’
+   226â†’enums:
+   227â†’  ack_status:
+   228â†’    0x06: success
+   229â†’    doc: Status codes for write acknowledgements
+   230â†’
+   231â†’  control_behavior:
+   232â†’    0x0C: absolute
+   233â†’    0x0D: relative
+   234â†’    0x0E: toggle
+   235â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+I'll update the test file to reflect the mode name length limit change from 8 to 18 characters. Let me start by reading the test file to understand the current implementation.
+
+Result:
+
+```
+1â†’# Launch Control XL3 Protocol Specification
+     2â†’
+     3â†’**Version:** 2.0
+     4â†’**Last Updated:** 2025-10-16
+     5â†’**Status:** Verified with hardware
+     6â†’
+     7â†’## Overview
+     8â†’
+     9â†’The Launch Control XL3 communicates via MIDI SysEx messages. Custom modes are fetched and stored using a multi-page protocol with slot selection via SysEx slot byte parameter.
+    10â†’
+    11â†’## Table of Contents
+    12â†’
+    13â†’- [Quick Reference](#quick-reference)
+    14â†’- [Custom Mode Fetch Protocol](#custom-mode-fetch-protocol)
+    15â†’- [Custom Mode Write Protocol](#custom-mode-write-protocol)
+    16â†’- [Data Structures](#data-structures)
+    17â†’- [Parsed Response Format](#parsed-response-format)
+    18â†’- [Examples](#examples)
+    19â†’- [Discovery Methodology](#discovery-methodology)
+    20â†’
+    21â†’---
+    22â†’
+    23â†’## Quick Reference
+    24â†’
+    25â†’**Canonical Protocol Specification:** See [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+    26â†’
+    27â†’The `.ksy` file is a Kaitai Struct specification that defines the **exact byte layout** of all protocol structures. It serves as:
+    28â†’- Formal specification (unambiguous binary format)
+    29â†’- Documentation (declarative, human-readable)
+    30â†’- Validation tool (can verify parser correctness)
+    31â†’- Version control (tracks protocol changes)
+    32â†’
+    33â†’**Note:** The library uses a hand-written parser in `SysExParser.ts` (90 lines, highly readable). The `.ksy` file serves as formal documentation, not for code generation.
+    34â†’
+    35â†’**Why .ksy?** It eliminates ambiguity. Instead of prose like "a length byte followed by name bytes", the spec states:
+    36â†’\```yaml
+    37â†’- id: name_length
+    38â†’  type: u1
+    39â†’- id: name_bytes
+    40â†’  size: name_length
+    41â†’  type: str
+    42â†’  encoding: ASCII
+    43â†’\```
+    44â†’
+    45â†’---
+    46â†’
+    47â†’## Custom Mode Fetch Protocol
+    48â†’
+    49â†’### High-Level Flow
+    50â†’
+    51â†’1. **Device Handshake** (4-message sequence)
+    52â†’   - Client sends SYN
+    53â†’   - Device responds with SYN-ACK containing serial number
+    54â†’   - Client sends Universal Device Inquiry (ACK)
+    55â†’   - Device responds with device info
+    56â†’
+    57â†’2. **Slot Selection** (via SysEx slot byte parameter)
+    58â†’   - Simply include the target slot number (0-14) in the SysEx read request
+    59â†’   - Slot 15 (0x0F) is reserved for immutable factory content and cannot be read or written
+    60â†’
+    61â†’3. **Mode Fetch** (2 SysEx pages)
+    62â†’   - Request page 0 (controls 0x10-0x27 + mode name + labels)
+    63â†’   - Request page 1 (controls 0x28-0x3F + mode name + labels)
+    64â†’
+    65â†’### Read Request Format
+    66â†’
+    67â†’**SysEx Read Request:**
+    68â†’\```
+    69â†’F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7
+    70â†’\```
+    71â†’
+    72â†’Where:
+    73â†’- `F0` = SysEx start
+    74â†’- `00 20 29` = Novation manufacturer ID
+    75â†’- `02` = Device ID (Launch Control XL 3)
+    76â†’- `15` = Command (Custom mode)
+    77â†’- `05` = Sub-command
+    78â†’- `00` = Reserved
+    79â†’- `40` = Read operation
+    80â†’- `[PAGE]` = Page byte (0x00 for page 0, 0x03 for page 1)
+    81â†’- `[SLOT]` = Slot number (0-14) - Slot 15 (0x0F) is reserved and immutable
+    82â†’- `F7` = SysEx end
+    83â†’
+    84â†’**Page byte mapping:**
+    85â†’- Logical page 0 â†’ SysEx page byte 0x00
+    86â†’- Logical page 1 â†’ SysEx page byte 0x03
+    87â†’
+    88â†’**Discovery Method:** Empirical testing (2025-10-01). The SysEx slot byte parameter directly selects the target slot without requiring DAW port protocol.
+    89â†’
+    90â†’**Implementation:** See `SysExParser.buildCustomModeReadRequest(slot, page)` at line 966-994 in `src/core/SysExParser.ts`.
+    91â†’
+    92â†’### READ Response Format
+    93â†’
+    94â†’READ responses use **only `0x48` control definition markers**. Each control is defined by an 11-byte structure:
+    95â†’
+    96â†’\```
+    97â†’Position:  0    1          2        3       4        5       6       7         8         9        10
+    98â†’Bytes:     0x48 controlId  0x02     type    channel  param1  0x48    minValue  ccNumber  maxValue  0x00
+    99â†’\```
+   100â†’
+   101â†’**Important:** The byte `0x40` may appear at position +7 as the `minValue` field. This is **data, not a control marker**.
+   102â†’Do not scan for `0x40` bytes to identify controls.
+   103â†’
+   104â†’**Example:**
+   105â†’A control with minValue=64 (0x40) will have `0x40` at byte position +7, immediately before the CC number.
+   106â†’
+   107â†’### Multi-Page Structure
+   108â†’
+   109â†’Custom mode data is split across **2 SysEx response pages** due to MIDI message size limits:
+   110â†’
+   111â†’| Logical Page | SysEx Page Byte | Controls | Contains Mode Name? | Label Control IDs |
+   112â†’|--------------|-----------------|----------|---------------------|-------------------|
+   113â†’| 0            | 0x00            | 0x10-0x27 (24 controls) | Yes (both pages) | 0x10-0x27 |
+   114â†’| 1            | 0x03            | 0x28-0x3F (24 controls) | Yes (both pages) | 0x28-0x3F |
+   115â†’
+   116â†’**Total: 48 controls** (0x10-0x3F)
+   117â†’
+   118â†’Each page follows the same structure defined in `launch_control_xl3.ksy`.
+   119â†’
+   120â†’**Discovery Method:** MIDI spy capture (2025-10-01) - Web editor slot fetch revealed page bytes 0x00 and 0x03.
+   121â†’
+   122â†’**Important:** Pages are fetched **sequentially**, not in parallel. Send page 0 request, wait for response, then send page 1 request. See `DeviceManager.readCustomMode()` at line 621-780.
+   123â†’
+   124â†’---
+   125â†’
+   126â†’## Custom Mode Write Protocol
+   127â†’
+   128â†’### Overview
+   129â†’
+   130â†’Writing a custom mode to the device uses command `0x45` with a multi-page protocol and acknowledgement handshake.
+   131â†’
+   132â†’**Discovery Method:** Web editor MIDI traffic capture using CoreMIDI spy (2025-09-30)
+   133â†’
+   134â†’### Write Flow with Acknowledgements
+   135â†’
+   136â†’**Critical Discovery (2025-09-30):** The device sends acknowledgement SysEx messages after receiving each page. The client MUST wait for these acknowledgements before sending the next page.
+   137â†’
+   138â†’**Complete Write Sequence:**
+   139â†’1. Send page 0 write command (`0x45 00`)
+   140â†’2. **Wait for device acknowledgement** (`0x15 00 [SLOT_STATUS]`)
+   141â†’3. Send page 1 write command (`0x45 03`)
+   142â†’4. **Wait for device acknowledgement** (`0x15 03 [SLOT_STATUS]`)
+   143â†’
+   144â†’**Timing:** Device typically responds within 24-27ms. Web editor waits for acknowledgement before proceeding.
+   145â†’
+   146â†’**Discovery Method:** Playwright browser automation + CoreMIDI spy, observing [DEST] and [SRC] traffic during web editor write operations.
+   147â†’
+   148â†’### Critical Discovery: Write Acknowledgement Status Byte is Slot Identifier (VERIFIED)
+   149â†’
+   150â†’**Discovery Date:** 2025-10-16
+   151â†’**Verification Date:** 2025-10-16
+   152â†’
+   153â†’**The Problem:** Previous implementations incorrectly interpreted the "status" byte in write acknowledgement messages as a success/failure indicator, checking for `status === 0x06`. This caused writes to all slots except slot 0 to fail.
+   154â†’
+   155â†’**The Reality:** The acknowledgement "status" byte is actually the **SLOT IDENTIFIER** encoded using the CC 30 slot encoding pattern.
+   156â†’
+   157â†’**Acknowledgement Response Format:**
+   158â†’\```
+   159â†’F0 00 20 29 02 15 05 00 15 [page] [SLOT_STATUS] F7
+   160â†’â”‚                       â”‚  â”‚  â”‚  â””â”€ Slot identifier (NOT success/failure!)
+   161â†’â”‚                       â”‚  â”‚  â””â”€ Page number acknowledged
+   162â†’â”‚                       â”‚  â””â”€ Acknowledgement command
+   163â†’â”‚                       â””â”€ Command group
+   164â†’\```
+   165â†’
+   166â†’**Slot Encoding Pattern (CC 30 Protocol):**
+   167â†’
+   168â†’The slot identifier follows the same encoding used in CC 30 slot selection messages:
+   169â†’
+   170â†’| Slot | Status Byte | Calculation |
+   171â†’|------|-------------|-------------|
+   172â†’| 0    | 0x06        | 0x06 + 0    |
+   173â†’| 1    | 0x07        | 0x06 + 1    |
+   174â†’| 2    | 0x08        | 0x06 + 2    |
+   175â†’| 3    | 0x09        | 0x06 + 3    |
+   176â†’| 4    | 0x12        | 0x0E + 4    |
+   177â†’| 5    | 0x13        | 0x0E + 5    |
+   178â†’| 6    | 0x14        | 0x0E + 6    |
+   179â†’| 7    | 0x15        | 0x0E + 7    |
+   180â†’| 8    | 0x16        | 0x0E + 8    |
+   181â†’| 9    | 0x17        | 0x0E + 9    |
+   182â†’| 10   | 0x18        | 0x0E + 10   |
+   183â†’| 11   | 0x19        | 0x0E + 11   |
+   184â†’| 12   | 0x1A        | 0x0E + 12   |
+   185â†’| 13   | 0x1B        | 0x0E + 13   |
+   186â†’| 14   | 0x1C        | 0x0E + 14   |
+   187â†’
+   188â†’**Pattern:**
+   189â†’- Slots 0-3: `0x06 + slot`
+   190â†’- Slots 4-14: `0x0E + slot`
+   191â†’
+   192â†’**Evidence from Raw MIDI Tests:**
+   193â†’
+   194â†’Testing with `utils/test-round-trip-validation.ts` revealed the following acknowledgement responses:
+   195â†’
+   196â†’\```
+   197â†’Write to slot 0, page 0:
+   198â†’F0 00 20 29 02 15 05 00 15 00 06 F7
+   199â†’                              â†‘
+   200â†’                              0x06 = slot 0
+   201â†’
+   202â†’Write to slot 1, page 0:
+   203â†’F0 00 20 29 02 15 05 00 15 00 07 F7
+   204â†’                              â†‘
+   205â†’                              0x07 = slot 1
+   206â†’
+   207â†’Write to slot 3, page 0:
+   208â†’F0 00 20 29 02 15 05 00 15 00 09 F7
+   209â†’                              â†‘
+   210â†’                              0x09 = slot 3
+   211â†’
+   212â†’Write to slot 5, page 0:
+   213â†’F0 00 20 29 02 15 05 00 15 00 13 F7
+   214â†’                              â†‘
+   215â†’                              0x13 = slot 5 (0x0E + 5)
+   216â†’\```
+   217â†’
+   218â†’**Verification Evidence (2025-10-16):**
+   219â†’
+   220â†’Test run with `utils/test-valid-mode-changes.ts` successfully wrote to slot 3 and verified:
+   221â†’- âœ… **Write successful** - No firmware rejection
+   222â†’- âœ… **Control CC numbers persisted correctly** - All 5 test controls changed from (13,14,15,16,17) to (23,24,25,26,27)
+   223â†’- âœ… **Control channels persisted correctly** - All channel values verified
+   224â†’- âœ… **Issue #36 RESOLVED** - The problem was library bug, not firmware rejection
+   225â†’- âœ… **10/11 changes verified successfully** (see Known Issues for mode name limitation)
+   226â†’
+   227â†’**Implications:**
+   228â†’
+   229â†’1. **Success Determination:** The acknowledgement itself indicates success. If the device sends an acknowledgement, the write was accepted.
+   230â†’
+   231â†’2. **Slot Validation:** The status byte can be used to verify the write targeted the expected slot:
+   232â†’   \```typescript
+   233â†’   function verifySlotAcknowledgement(slot: number, statusByte: number): boolean {
+   234â†’     const expectedStatus = slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   235â†’     return statusByte === expectedStatus;
+   236â†’   }
+   237â†’   \```
+   238â†’
+   239â†’3. **Failure Detection:** If no acknowledgement arrives within timeout (typically 24-27ms, up to 100ms conservative), the write failed.
+   240â†’
+   241â†’**Discovery Method:**
+   242â†’- Raw MIDI testing with `utils/test-round-trip-validation.ts` (2025-10-16)
+   243â†’- Systematic writes to multiple slots (0, 1, 3, 5) with acknowledgement capture
+   244â†’- Byte pattern analysis revealing CC 30 encoding scheme
+   245â†’
+   246â†’**Bug Fixed:** Issue #36 - DeviceManager.ts line 448-451 was rejecting all acknowledgements except `0x06`, causing writes to slots 1-14 to fail. Correct implementation should verify slot encoding or simply accept any acknowledgement as success.
+   247â†’
+   248â†’### Multi-Page Write Protocol
+   249â†’
+   250â†’Custom modes require **TWO pages** to be written:
+   251â†’
+   252â†’| Logical Page | SysEx Page Byte | Control IDs | Contains Mode Name? |
+   253â†’|--------------|-----------------|-------------|---------------------|
+   254â†’| 0            | 0x00            | 0x10-0x27 (16-39) | Yes |
+   255â†’| 1            | 0x03            | 0x28-0x3F (40-63) | Yes |
+   256â†’
+   257â†’**Note:** Control IDs 0x00-0x0F do not exist on the device hardware. Only IDs 0x10-0x3F (48 controls total).
+   258â†’
+   259â†’### SysEx Message Format
+   260â†’
+   261â†’**Write Command:**
+   262â†’\```
+   263â†’F0 00 20 29 02 15 05 00 45 [page] 00 [mode_data] F7
+   264â†’â”‚  â””â”€ Novation ID       â”‚  â”‚  â”‚  â””â”€ Write command
+   265â†’â”‚                       â”‚  â”‚  â””â”€ Sub-command
+   266â†’â”‚                       â”‚  â””â”€ Command (Custom mode)
+   267â†’â”‚                       â””â”€ Device ID
+   268â†’â””â”€ SysEx start
+   269â†’\```
+   270â†’
+   271â†’**Key Differences from Read Protocol:**
+   272â†’- Command byte: `0x45` (write) vs `0x40` (read request) / `0x10` (read response)
+   273â†’- Page byte followed by `0x00` flag
+   274â†’- Mode name format: `20 [length] [bytes]` (no `06` prefix)
+   275â†’- **Requires waiting for acknowledgements between pages**
+   276â†’
+   277â†’### Slot Selection for Writes
+   278â†’
+   279â†’Slot selection is handled by the SysEx slot byte parameter. Simply include the target slot number (0-14) when constructing the write request.
+   280â†’
+   281â†’**No DAW port protocol required.** Earlier protocol versions incorrectly assumed DAW port was mandatory. Empirical testing confirmed the SysEx slot byte works independently.
+   282â†’
+   283â†’See `DeviceManager.writeCustomMode()` at line 785-878 for implementation.
+   284â†’
+   285â†’### Mode Name Encoding
+   286â†’
+   287â†’**Write format:**
+   288â†’\```
+   289â†’20 [length] [name_bytes...]
+   290â†’\```
+   291â†’
+   292â†’**Example:**
+   293â†’\```
+   294â†’20 08 43 48 41 4E 54 45 53 54
+   295â†’â”‚  â”‚  â””â”€ "CHANTEST" (8 ASCII bytes)
+   296â†’â”‚  â””â”€ Length (8)
+   297â†’â””â”€ Prefix
+   298â†’\```
+   299â†’
+   300â†’**Read format (for comparison):**
+   301â†’\```
+   302â†’06 20 [length] [name_bytes...]
+   303â†’\```
+   304â†’
+   305â†’**Discovery:** By comparing MIDI captures of web editor write operations with different mode names:
+   306â†’1. Captured write with "CHANNEVE": `20 08 43 48 41 4E 4E 45 56 45`
+   307â†’2. Captured write with "CHANTEST": `20 08 43 48 41 4E 54 45 53 54`
+   308â†’3. Pattern identified: `0x20` prefix, length byte, raw ASCII
+   309â†’
+   310â†’**Validation:** 2025-09-30 - Verified with Novation Components web editor v1.60.0
+   311â†’
+   312â†’### Known Issue: Mode Name Truncation
+   313â†’
+   314â†’**Discovery Date:** 2025-10-16
+   315â†’
+   316â†’**Observation:** Mode names written to the device may be truncated on read-back.
+   317â†’
+   318â†’**Test Evidence:**
+   319â†’- Written name: "TESTMOD" (7 characters)
+   320â†’- Read-back name: "M" (1 character!)
+   321â†’
+   322â†’**Hypothesis:**
+   323â†’1. The mode name field may have an undocumented length limit
+   324â†’2. There may be a serialization bug in the name field
+   325â†’3. The device firmware may truncate/modify mode names in specific ways
+   326â†’
+   327â†’**Impact:** Mode name verification in round-trip tests cannot reliably confirm name persistence.
+   328â†’
+   329â†’**Status:** Under investigation. This does not affect control data persistence, which is verified to work correctly.
+   330â†’
+   331â†’### Example: Complete Write Sequence with Acknowledgements
+   332â†’
+   333â†’**Captured from web editor (2025-09-30 at 37:06):**
+   334â†’
+   335â†’\```
+   336â†’37:06.052  [â†’ Device] Page 0 Write
+   337â†’F0 00 20 29 02 15 05 00 45 00 00 20 08 43 48 41 4E 4E 45 56 45 ...
+   338â†’                           â”‚  â”‚  â”‚  Mode name: "CHANNEVE"
+   339â†’                           â”‚  â”‚  â””â”€ Flag 0x00
+   340â†’                           â”‚  â””â”€ Page 0 (SysEx byte 0x00)
+   341â†’                           â””â”€ Write command 0x45
+   342â†’
+   343â†’37:06.079  [â† Device] Page 0 Acknowledgement (27ms later)
+   344â†’F0 00 20 29 02 15 05 00 15 00 06 F7
+   345â†’                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+   346â†’                           â”‚  â””â”€ Page 0 acknowledged
+   347â†’                           â””â”€ Acknowledgement command 0x15
+   348â†’
+   349â†’37:06.079  [â†’ Device] Page 1 Write (sent immediately after ACK)
+   350â†’F0 00 20 29 02 15 05 00 45 03 00 20 08 43 48 41 4E 4E 45 56 45 ...
+   351â†’                           â”‚  â”‚
+   352â†’                           â”‚  â””â”€ Flag 0x00
+   353â†’                           â””â”€ Page 1 (SysEx byte 0x03)
+   354â†’
+   355â†’37:06.103  [â† Device] Page 1 Acknowledgement (24ms later)
+   356â†’F0 00 20 29 02 15 05 00 15 03 06 F7
+   357â†’                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+   358â†’                           â”‚  â””â”€ Page 1 acknowledged
+   359â†’                           â””â”€ Acknowledgement command 0x15
+   360â†’\```
+   361â†’
+   362â†’**Key Observations:**
+   363â†’- Web editor waits for acknowledgement before sending next page
+   364â†’- Acknowledgements arrive 24-27ms after write command
+   365â†’- Status byte matches slot identifier (0x06 for slot 0)
+   366â†’- Page number in acknowledgement matches write command page number
+   367â†’
+   368â†’---
+   369â†’
+   370â†’## Data Structures
+   371â†’
+   372â†’### Page Structure
+   373â†’
+   374â†’\```
+   375â†’[Page Header]
+   376â†’[Mode Name Section]  â† Only in page 0
+   377â†’[16Ã— Control Definitions]
+   378â†’[Label Section]
+   379â†’\```
+   380â†’
+   381â†’**See [`launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy) types:**
+   382â†’- `custom_mode_page` - Complete page structure
+   383â†’- `page_header` - Fixed 5-byte header
+   384â†’- `mode_name` - Variable-length name (page 0 only)
+   385â†’- `control_definition` - 7-byte control spec
+   386â†’- `label_section` - Variable-length labels
+   387â†’
+   388â†’### Control Definition (7 bytes)
+   389â†’
+   390â†’Each control is defined by exactly 7 bytes:
+   391â†’
+   392â†’\```
+   393â†’Offset | Type | Field        | Values
+   394â†’-------|------|--------------|------------------
+   395â†’0      | u1   | control_type | 0x00, 0x05, 0x09, 0x0D, 0x19, 0x25
+   396â†’1      | u1   | control_id   | 0x10-0x3F (16-63)
+   397â†’2      | u1   | midi_channel | 0-15
+   398â†’3      | u1   | cc_number    | 0-127
+   399â†’4      | u1   | min_value    | Usually 0
+   400â†’5      | u1   | max_value    | Usually 127
+   401â†’6      | u1   | behavior     | 0x0C=absolute, 0x0D=relative, 0x0E=toggle
+   402â†’\```
+   403â†’
+   404â†’### Mode Name Encoding
+   405â†’
+   406â†’**Format:** `06 20 [length] [name_bytes...]`
+   407â†’
+   408â†’- `06 20` - Fixed marker
+   409â†’- `length` - Number of characters (0-8)
+   410â†’- `name_bytes` - ASCII characters
+   411â†’
+   412â†’**Example:**
+   413â†’\```
+   414â†’06 20 08 43 48 41 4E 4E 45 56 45
+   415â†’      â†‘  C  H  A  N  N  E  V  E
+   416â†’      â””â”€ length = 8 chars
+   417â†’\```
+   418â†’
+   419â†’### Control Label Encoding
+   420â†’
+   421â†’**Critical Discovery:** Labels use **length-encoding** where the marker byte encodes the string length.
+   422â†’
+   423â†’**Format:** `[0x60 + length] [control_id] [name_bytes...] [next_marker]`
+   424â†’
+   425â†’The marker byte range `0x60-0x6F` allows strings of 0-15 characters:
+   426â†’- `0x60` = empty string (0 chars)
+   427â†’- `0x65` = 5-character string
+   428â†’- `0x69` = 9-character string
+   429â†’- `0x6F` = 15-character string (maximum)
+   430â†’
+   431â†’**Length calculation:**
+   432â†’\```
+   433â†’length = marker_byte - 0x60
+   434â†’\```
+   435â†’
+   436â†’**Control ID Mapping:**
+   437â†’- Most label control IDs map directly to control IDs
+   438â†’- **Exception:** Label IDs 0x19-0x1C (25-28) map to control IDs 26-29 (+1 offset)
+   439â†’
+   440â†’---
+   441â†’
+   442â†’## Parsed Response Format (JavaScript/TypeScript)
+   443â†’
+   444â†’After SysEx parsing, the `DeviceManager.readCustomMode()` returns data in one of two formats:
+   445â†’
+   446â†’### Array Format (Legacy/Fallback)
+   447â†’\```javascript
+   448â†’{
+   449â†’  name: "MODE_NAME",  // String, max 8 characters
+   450â†’  controls: [
+   451â†’    {
+   452â†’      controlId: 0x10,       // number: 0x10-0x3F main controls, 0x68-0x6F side buttons
+   453â†’      channel: 0,            // number: 0-15
+   454â†’      ccNumber: 13,          // number: 0-127
+   455â†’      minValue: 0,           // number: 0-127 (optional)
+   456â†’      maxValue: 127,         // number: 0-127 (optional)
+   457â†’      behaviour: 'absolute'  // string: 'absolute' | 'relative1' | 'relative2' | 'toggle'
+   458â†’    }
+   459â†’    // ... up to 48 controls
+   460â†’  ],
+   461â†’  colors: [],               // Color mappings (optional)
+   462â†’  labels: Map<number, string>  // Control labels keyed by control ID
+   463â†’}
+   464â†’\```
+   465â†’
+   466â†’### Object Format (Real Device Response)
+   467â†’\```javascript
+   468â†’{
+   469â†’  name: "MODE_NAME",
+   470â†’  controls: {
+   471â†’    "0x10": { controlId: 0x10, channel: 0, ccNumber: 13, ... },
+   472â†’    "0x11": { controlId: 0x11, channel: 1, ccNumber: 14, ... },
+   473â†’    // ... keyed by control ID (hex string)
+   474â†’  },
+   475â†’  colors: [],
+   476â†’  labels: Map<number, string>
+   477â†’}
+   478â†’\```
+   479â†’
+   480â†’**Note**: The `CustomModeManager.parseCustomModeResponse()` handles both formats automatically using:
+   481â†’\```typescript
+   482â†’const controlsArray = Array.isArray(response.controls)
+   483â†’  ? response.controls
+   484â†’  : Object.values(response.controls);
+   485â†’\```
+   486â†’
+   487â†’This defensive coding ensures compatibility with device firmware variations.
+   488â†’
+   489â†’---
+   490â†’
+   491â†’## Examples
+   492â†’
+   493â†’### Example 1: "TEST1" Label
+   494â†’
+   495â†’\```
+   496â†’65 10 54 45 53 54 31 60
+   497â†’â”‚  â”‚  T  E  S  T  1
+   498â†’â”‚  â””â”€ Control ID 0x10
+   499â†’â””â”€ Marker 0x65 = 0x60 + 5 â†’ 5 characters
+   500â†’\```
+   501â†’
+   502â†’### Example 2: "High Pass" Label
+   503â†’
+   504â†’\```
+   505â†’69 14 48 69 67 68 20 50 61 73 73 60
+   506â†’â”‚  â”‚  H  i  g  h     P  a  s  s
+   507â†’â”‚  â””â”€ Control ID 0x14 (20)
+   508â†’â””â”€ Marker 0x69 = 0x60 + 9 â†’ 9 characters
+   509â†’\```
+   510â†’
+   511â†’### Example 3: Empty Label
+   512â†’
+   513â†’\```
+   514â†’60 11 60
+   515â†’â”‚  â”‚  â””â”€ Next marker or terminator
+   516â†’â”‚  â””â”€ Control ID 0x11
+   517â†’â””â”€ Marker 0x60 = 0x60 + 0 â†’ 0 characters (empty)
+   518â†’\```
+   519â†’
+   520â†’### Example 4: Control ID Mapping Exception
+   521â†’
+   522â†’Label with control ID 0x19 (25) maps to actual control ID 26:
+   523â†’
+   524â†’\```
+   525â†’68 19 4C 6F 77 20 46 72 65 71
+   526â†’â”‚  â”‚  L  o  w     F  r  e  q
+   527â†’â”‚  â””â”€ Label ID 0x19 â†’ maps to control 26
+   528â†’â””â”€ Marker 0x68 = 8 chars
+   529â†’\```
+   530â†’
+   531â†’**Mapping rule:**
+   532â†’\```typescript
+   533â†’function mapLabelControlId(labelId: number): number {
+   534â†’  if (labelId >= 25 && labelId <= 28) {
+   535â†’    return labelId + 1;  // Labels 25-28 â†’ controls 26-29
+   536â†’  }
+   537â†’  return labelId;  // Direct mapping for all others
+   538â†’}
+   539â†’\```
+   540â†’
+   541â†’### Example 5: Write Acknowledgement Slot Verification
+   542â†’
+   543â†’\```typescript
+   544â†’// Write to slot 5, page 0
+   545â†’// Expected acknowledgement: F0 00 20 29 02 15 05 00 15 00 13 F7
+   546â†’//                                                       â†‘
+   547â†’//                                                       0x13 = slot 5
+   548â†’
+   549â†’function expectedSlotStatus(slot: number): number {
+   550â†’  return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   551â†’}
+   552â†’
+   553â†’// Verify acknowledgement matches expected slot
+   554â†’const slot = 5;
+   555â†’const ackStatus = 0x13;
+   556â†’const expected = expectedSlotStatus(slot); // 0x0E + 5 = 0x13
+   557â†’console.assert(ackStatus === expected, 'Slot mismatch in acknowledgement');
+   558â†’\```
+   559â†’
+   560â†’---
+   561â†’
+   562â†’## Discovery Methodology
+   563â†’
+   564â†’**How was this protocol reverse-engineered?**
+   565â†’
+   566â†’### Phase 1: Initial Analysis
+   567â†’1. Used existing heuristic parser (180+ lines, ~14% accuracy)
+   568â†’2. Captured MIDI traffic with CoreMIDI spy during device operations
+   569â†’3. Compared parser output with expected control names
+   570â†’
+   571â†’### Phase 2: Systematic Testing
+   572â†’1. **Tools Used:**
+   573â†’   - Novation Components web editor (ground truth)
+   574â†’   - Playwright browser automation (programmatic control)
+   575â†’   - CoreMIDI MIDI snooping tool (traffic capture)
+   576â†’   - Custom analysis scripts
+   577â†’
+   578â†’2. **Methodology:**
+   579â†’   - Changed control name from "High Pass" to "TEST1" in web editor
+   580â†’   - Sent modified mode to device via web editor
+   581â†’   - Captured exact MIDI bytes sent during operation
+   582â†’   - Retrieved mode from device
+   583â†’   - Compared byte sequences
+   584â†’
+   585â†’3. **Key Discovery:**
+   586â†’   \```
+   587â†’   "TEST1" (5 chars):     65 10 54 45 53 54 31 60
+   588â†’   "High Pass" (9 chars): 69 14 48 69 67 68 20 50 61 73 73 60
+   589â†’   \```
+   590â†’
+   591â†’   Realized: `0x65 = 0x60 + 5` and `0x69 = 0x60 + 9`
+   592â†’
+   593â†’   **The marker byte encodes the string length!**
+   594â†’
+   595â†’### Phase 3: Validation
+   596â†’1. Implemented length-encoding parser
+   597â†’2. Tested against all 21 named controls
+   598â†’3. Achieved 95% accuracy (20/21 correct)
+   599â†’4. One "failure" was intentional test data ("TEST1")
+   600â†’
+   601â†’### Phase 4: Slot Selection Discovery
+   602â†’1. Initial assumption: DAW port protocol required for slot selection
+   603â†’2. Tested SysEx slot byte parameter directly (2025-10-01)
+   604â†’3. Discovery: Slot byte works independently - DAW port NOT required
+   605â†’4. Updated code to use SysEx slot byte (commit 756cacd)
+   606â†’5. Removed DawPortController infrastructure
+   607â†’
+   608â†’### Phase 5: Write Acknowledgement Status Byte Discovery
+   609â†’1. **Problem:** Writes to slots 1-14 failed with "Write failed" errors
+   610â†’2. **Investigation:** Raw MIDI testing with `utils/test-round-trip-validation.ts`
+   611â†’3. **Discovery Process:**
+   612â†’   - Wrote to slot 0 â†’ acknowledgement status 0x06 (success per old code)
+   613â†’   - Wrote to slot 1 â†’ acknowledgement status 0x07 (failed per old code)
+   614â†’   - Wrote to slot 3 â†’ acknowledgement status 0x09 (failed per old code)
+   615â†’   - Wrote to slot 5 â†’ acknowledgement status 0x13 (failed per old code)
+   616â†’4. **Pattern Recognition:**
+   617â†’   - 0x06, 0x07, 0x09, 0x13 matched CC 30 slot encoding
+   618â†’   - Slots 0-3: 0x06 + slot
+   619â†’   - Slots 4-14: 0x0E + slot
+   620â†’5. **Conclusion:** Status byte is slot identifier, not success indicator
+   621â†’6. **Evidence:** Test captures showed consistent pattern across multiple slots
+   622â†’7. **Impact:** Fixed Issue #36 - DeviceManager now accepts any acknowledgement as success
+   623â†’
+   624â†’**Discovery Date:** 2025-10-16
+   625â†’**Method:** Raw MIDI testing with systematic slot writes and acknowledgement analysis
+   626â†’
+   627â†’### Phase 6: Verification
+   628â†’1. **Fix Implementation:** Updated DeviceManager.ts to accept any acknowledgement as success
+   629â†’2. **Test Execution:** Ran `utils/test-valid-mode-changes.ts` targeting slot 3
+   630â†’3. **Results:**
+   631â†’   - âœ… Write to slot 3 succeeded (no firmware rejection)
+   632â†’   - âœ… Control CC numbers persisted correctly (changed from 13,14,15,16,17 to 23,24,25,26,27)
+   633â†’   - âœ… Control channels persisted correctly
+   634â†’   - âœ… 10/11 changes verified successfully
+   635â†’   - âŒ Mode name truncated ("TESTMOD" â†’ "M") - under investigation
+   636â†’4. **Conclusion:** Issue #36 resolved - problem was library bug, not firmware limitation
+   637â†’
+   638â†’**Verification Date:** 2025-10-16
+   639â†’**Method:** Empirical round-trip test with real hardware targeting non-zero slot
+   640â†’
+   641â†’### Phase 7: Documentation
+   642â†’1. Created Kaitai Struct specification (`.ksy` file)
+   643â†’2. Validated spec by generating parser and comparing output
+   644â†’3. Documented control ID mapping exception (25-28 â†’ 26-29)
+   645â†’4. Updated all documentation to reflect slot selection discovery
+   646â†’5. Documented write acknowledgement slot encoding discovery
+   647â†’6. Added verification results to PROTOCOL.md and MAINTENANCE.md
+   648â†’
+   649â†’---
+   650â†’
+   651â†’## DAW Port Protocol (DEPRECATED)
+   652â†’
+   653â†’**Status:** DEPRECATED as of 2025-10-01
+   654â†’
+   655â†’**Historical Note:** Earlier protocol versions documented an extensive 2-phase DAW port protocol for slot selection. This was based on observations of the web editor, which does use the DAW port for some operations.
+   656â†’
+   657â†’**Discovery (2025-10-01):** The SysEx slot byte parameter works independently for slot selection. Simply include the slot number (0-14) in the SysEx read/write request. No DAW port communication required.
+   658â†’
+   659â†’**Implementation:** The DawPortController class has been removed from the codebase (commit 756cacd). See `DeviceManager.ts` lines 627 and 790 for comments confirming this.
+   660â†’
+   661â†’**Why the confusion?** The web editor uses DAW port for UI feedback and mode switching, but it's not required for SysEx slot targeting. The SysEx slot byte is the canonical mechanism.
+   662â†’
+   663â†’**Reference:** For historical documentation of the DAW port protocol, see git history before commit 756cacd (2025-10-09).
+   664â†’
+   665â†’---
+   666â†’
+   667â†’## LED Control
+   668â†’
+   669â†’**Important:** LED states are **NOT** stored in custom mode configurations.
+   670â†’
+   671â†’LEDs are controlled via separate real-time MIDI messages:
+   672â†’- Message type: `0x78` (LED_CONTROL)
+   673â†’- Format: Standard MIDI CC or custom SysEx
+   674â†’
+   675â†’Custom modes only store:
+   676â†’- Control definitions (CC mappings, channels, behaviors)
+   677â†’- Control labels (names)
+   678â†’- Mode name
+   679â†’
+   680â†’---
+   681â†’
+   682â†’## Parser Implementation
+   683â†’
+   684â†’**Current Implementation:** `src/core/SysExParser.ts`
+   685â†’
+   686â†’The parser follows the protocol specification exactly:
+   687â†’
+   688â†’1. **Mode Name Parsing:**
+   689â†’   \```typescript
+   690â†’   // Format: 06 20 [length] [name_bytes]
+   691â†’   const lengthByte = data[i + 2];
+   692â†’   const nameLength = lengthByte;
+   693â†’   const nameBytes = data.slice(i + 3, i + 3 + nameLength);
+   694â†’   \```
+   695â†’
+   696â†’2. **Control Label Parsing:**
+   697â†’   \```typescript
+   698â†’   // Format: [0x60 + length] [controlID] [name_bytes]
+   699â†’   const length = markerByte - 0x60;
+   700â†’   const controlId = data[i + 1];
+   701â†’   const nameBytes = data.slice(i + 2, i + 2 + length);
+   702â†’   const canonicalId = mapLabelControlId(controlId);
+   703â†’   \```
+   704â†’
+   705â†’3. **Write Acknowledgement Parsing:**
+   706â†’   \```typescript
+   707â†’   // Format: F0 00 20 29 02 15 05 00 15 [page] [slot_status] F7
+   708â†’   const page = data[9];
+   709â†’   const slotStatus = data[10];
+   710â†’
+   711â†’   // Verify slot encoding matches expected slot
+   712â†’   function expectedSlotStatus(slot: number): number {
+   713â†’     return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   714â†’   }
+   715â†’   \```
+   716â†’
+   717â†’**Lines of code:** ~90 (down from 180+ heuristic version)
+   718â†’**Accuracy:** 95%+ (100% when test data removed)
+   719â†’
+   720â†’---
+   721â†’
+   722â†’## References
+   723â†’
+   724â†’- **Formal Specification:** [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+   725â†’- **Parser Implementation:** [`../src/core/SysExParser.ts`](../src/core/SysExParser.ts)
+   726â†’- **Device Manager:** [`../src/device/DeviceManager.ts`](../src/device/DeviceManager.ts)
+   727â†’- **Test Data:** [`../backup/`](../backup/) - Real device captures in JSON format
+   728â†’
+   729â†’---
+   730â†’
+   731â†’## Version History
+   732â†’
+   733â†’| Version | Date | Changes |
+   734â†’|---------|------|---------|
+   735â†’| 2.0 | 2025-10-16 | **VERIFIED:** Write acknowledgement status byte is slot identifier. Confirmed with successful test run writing to slot 3. Control CC numbers, channels verified to persist correctly (10/11 changes successful). Issue #36 RESOLVED - bug was in library, not firmware. Added Known Issue: mode name truncation ("TESTMOD" â†’ "M"). |
+   736â†’| 1.9 | 2025-10-16 | **CRITICAL:** Documented write acknowledgement status byte as slot identifier, not success indicator. Status byte uses CC 30 slot encoding (slots 0-3: 0x06+slot, slots 4-14: 0x0E+slot). Acknowledgement arrival indicates success; timeout indicates failure. Fixed Issue #36. Evidence from raw MIDI testing with multiple slots. |
+   737â†’| 1.8 | 2025-10-11 | **Parser Bug Fix:** Removed incorrect 0x40 parsing in READ responses. The byte 0x40 appears as **data within 0x48 control structures** (minValue field at offset +7), not as a control marker. This caused wrong CC numbers, missing custom labels, and fake controls with CC 0. Only 0x48 markers are used for READ responses. Reference: GitHub issue #32 |
+   738â†’| 1.7 | 2025-10-09 | **MAJOR UPDATE:** Corrected page mapping documentation. Logical pages 0 and 1 map to SysEx page bytes 0x00 and 0x03. Removed extensive DAW port protocol documentation (deprecated). Clarified that slot selection uses SysEx slot byte directly. Updated all examples to reflect working code. |
+   739â†’| 1.6 | 2025-10-01 | **DEFINITIVE:** SysEx read/write DOES have slot parameter. Format is `F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7` where `[SLOT]` is slot number 0-14 (slot 15 reserved and immutable). DAW port protocol is NOT required for slot selection. |
+   740â†’| 1.5 | 2025-10-01 | **RETRACTED:** Incorrectly stated SysEx has no slot parameter. |
+   741â†’| 1.4 | 2025-10-01 | **Critical:** Corrected read protocol - uses 2 pages (0x00, 0x03), not 3 pages (0, 1, 2). Documented complete DAW port bidirectional protocol with device echoes. |
+   742â†’| 1.3 | 2025-09-30 | Added Parsed Response Format section documenting both array and object control formats |
+   743â†’| 1.2 | 2025-09-30 | **Critical:** Discovered write acknowledgement protocol (command 0x15). Device sends ACK after each page write. Client must wait for ACK before sending next page. |
+   744â†’| 1.1 | 2025-09-30 | Documented write protocol (command 0x45) with mode name format discovery |
+   745â†’| 1.0 | 2025-09-30 | Initial documented protocol after empirical discovery |
+   746â†’
+   747â†’---
+   748â†’
+   749â†’## Notes for Future Maintainers
+   750â†’
+   751â†’1. **The `.ksy` file is the source of truth** for byte-level protocol details
+   752â†’2. **Test changes empirically** using the web editor + MIDI spy methodology
+   753â†’3. **Control ID mapping exception** (25-28 â†’ 26-29) is hardware-specific, not a bug
+   754â†’4. **Length-encoding is critical** - marker byte `0x60 + length` determines string size
+   755â†’5. **No LED data in custom modes** - don't waste time looking for it
+   756â†’6. **Device returns controls in both array and object format** - parser must handle both
+   757â†’7. **Slot selection uses SysEx slot byte** - no DAW port protocol required
+   758â†’8. **Page bytes:** Logical page 0â†’0x00, logical page 1â†’0x03 in SysEx messages
+   759â†’9. **DO NOT scan for 0x40 bytes** - they appear as data in minValue fields, not as control markers
+   760â†’10. **Write acknowledgement status byte is slot identifier** - use CC 30 encoding to verify, or simply accept any acknowledgement as success
+   761â†’11. **Acknowledgement arrival = success; timeout = failure** - the status byte confirms which slot was written, not whether it succeeded
+   762â†’12. **Test with multiple slots, not just slot 0** - important patterns emerge when testing slots 1-14
+   763â†’13. **Mode name field has limitations** - names may truncate on read-back; under investigation
+   764â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/core/SysExParser.test.ts`
+
+Result:
+
+```
+1â†’/**
+     2â†’ * SysEx Parser Unit Tests
+     3â†’ */
+     4â†’
+     5â†’import { describe, it, expect } from 'vitest';
+     6â†’import {
+     7â†’  SysExParser,
+     8â†’  MANUFACTURER_ID,
+     9â†’  SysExMessageType,
+    10â†’  DEVICE_FAMILY
+    11â†’} from '@/core/SysExParser';
+    12â†’import { CONTROL_IDS } from '@/modes/CustomModeManager';
+    13â†’
+    14â†’/**
+    15â†’ * Convert CustomMode format to CustomModeMessage format for testing
+    16â†’ *
+    17â†’ * Takes object-based controls (e.g., { SEND_A1: {...}, SEND_B2: {...} })
+    18â†’ * and converts to array-based format with controlId properties that
+    19â†’ * buildCustomModeWriteRequest expects.
+    20â†’ */
+    21â†’function convertToCustomModeMessage(mode: any, slot: number): any {
+    22â†’  const controls: any[] = [];
+    23â†’  const colors: any[] = [];
+    24â†’  const labels = new Map<number, string>();
+    25â†’
+    26â†’  // Convert object-based controls to array-based
+    27â†’  if (mode.controls) {
+    28â†’    for (const [key, control] of Object.entries(mode.controls)) {
+    29â†’      const controlId = (CONTROL_IDS as any)[key];
+    30â†’      if (controlId !== undefined) {
+    31â†’        controls.push({
+    32â†’          controlId,
+    33â†’          channel: (control as any).channel ?? (control as any).midiChannel,
+    34â†’          ccNumber: (control as any).cc ?? (control as any).ccNumber,
+    35â†’          minValue: (control as any).min ?? (control as any).minValue ?? 0,
+    36â†’          maxValue: (control as any).max ?? (control as any).maxValue ?? 127,
+    37â†’          behaviour: (control as any).behaviour ?? (control as any).behavior ?? 'absolute',
+    38â†’        });
+    39â†’
+    40â†’        if ((control as any).name) {
+    41â†’          labels.set(controlId, (control as any).name);
+    42â†’        }
+    43â†’      }
+    44â†’    }
+    45â†’  }
+    46â†’
+    47â†’  // Convert LED mappings to colors array
+    48â†’  if (mode.leds) {
+    49â†’    for (const [controlName, ledConfig] of mode.leds.entries()) {
+    50â†’      const controlId = (CONTROL_IDS as any)[controlName];
+    51â†’      if (controlId !== undefined) {
+    52â†’        colors.push({
+    53â†’          controlId,
+    54â†’          color: (ledConfig as any).color,
+    55â†’          behaviour: (ledConfig as any).behaviour ?? 'static',
+    56â†’        });
+    57â†’      }
+    58â†’    }
+    59â†’  }
+    60â†’
+    61â†’  return {
+    62â†’    type: 'custom_mode_write',
+    63â†’    manufacturerId: [0x00, 0x20, 0x29],
+    64â†’    slot,
+    65â†’    name: mode.name,
+    66â†’    controls,
+    67â†’    colors,
+    68â†’    labels,
+    69â†’    data: [],
+    70â†’  };
+    71â†’}
+    72â†’
+    73â†’describe('SysExParser', () => {
+    74â†’  describe('parse', () => {
+    75â†’    it('should parse device inquiry response', () => {
+    76â†’      const message = [
+    77â†’        0xF0, // Start
+    78â†’        0x7E, // Universal non-realtime
+    79â†’        0x00, // Device ID
+    80â†’        0x06, // Inquiry response
+    81â†’        0x02, // Sub-ID
+    82â†’        0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+    83â†’        0x00, 0x61, // Family code
+    84â†’        0x00, 0x01, // Family member
+    85â†’        0x01, 0x00, 0x00, 0x00, // Software revision
+    86â†’        0xF7, // End
+    87â†’      ];
+    88â†’
+    89â†’      const result = SysExParser.parse(message);
+    90â†’      expect(result.type).toBe('device_inquiry_response');
+    91â†’      expect(result.manufacturerId).toEqual([0x00, 0x20, 0x29]);
+    92â†’
+    93â†’      const inquiry = result as any;
+    94â†’      expect(inquiry.familyCode).toBe(0x61);
+    95â†’      expect(inquiry.familyMember).toBe(0x01);
+    96â†’      expect(inquiry.softwareRevision).toEqual([0x01, 0x00, 0x00, 0x00]);
+    97â†’    });
+    98â†’
+    99â†’    it('should parse template change message', () => {
+   100â†’      const message = [
+   101â†’        0xF0, // Start
+   102â†’        ...MANUFACTURER_ID,
+   103â†’        0x02, // Device ID (Launch Control XL 3) - UPDATED for Issue #36 fix
+   104â†’        SysExMessageType.TEMPLATE_CHANGE,
+   105â†’        0x05, // Template number
+   106â†’        0xF7, // End
+   107â†’      ];
+   108â†’
+   109â†’      const result = SysExParser.parse(message);
+   110â†’      expect(result.type).toBe('template_change');
+   111â†’
+   112â†’      const templateChange = result as any;
+   113â†’      expect(templateChange.templateNumber).toBe(0x05);
+   114â†’    });
+   115â†’
+   116â†’    it('should throw error for invalid SysEx', () => {
+   117â†’      // Missing start byte
+   118â†’      expect(() => SysExParser.parse([0x00, 0xF7])).toThrow('Invalid SysEx message: missing start byte');
+   119â†’
+   120â†’      // Missing end byte
+   121â†’      expect(() => SysExParser.parse([0xF0, 0x00])).toThrow('Invalid SysEx message: missing end byte');
+   122â†’
+   123â†’      // Too short
+   124â†’      expect(() => SysExParser.parse([0xF0, 0xF7])).toThrow('Invalid SysEx message: too short');
+   125â†’    });
+   126â†’
+   127â†’    it('should handle unknown message types', () => {
+   128â†’      const message = [
+   129â†’        0xF0,
+   130â†’        ...MANUFACTURER_ID,
+   131â†’        0x11,
+   132â†’        0xFF, // Unknown message type
+   133â†’        0x00, 0x01, 0x02,
+   134â†’        0xF7,
+   135â†’      ];
+   136â†’
+   137â†’      const result = SysExParser.parse(message);
+   138â†’      expect(result.type).toBe('unknown');
+   139â†’      expect(result.manufacturerId).toEqual(MANUFACTURER_ID);
+   140â†’    });
+   141â†’  });
+   142â†’
+   143â†’  describe('buildDeviceQuery', () => {
+   144â†’    it('should build device inquiry request', () => {
+   145â†’      const message = SysExParser.buildDeviceQuery();
+   146â†’
+   147â†’      expect(message[0]).toBe(0xF0); // Start
+   148â†’      expect(message[1]).toBe(0x7E); // Universal non-realtime
+   149â†’      expect(message[2]).toBe(0x00); // Device ID (broadcast)
+   150â†’      expect(message[3]).toBe(0x06); // General information
+   151â†’      expect(message[4]).toBe(0x01); // Identity request
+   152â†’      expect(message[5]).toBe(0xF7); // End
+   153â†’    });
+   154â†’  });
+   155â†’
+   156â†’  describe('buildTemplateChange', () => {
+   157â†’    it('should build template change message', () => {
+   158â†’      const message = SysExParser.buildTemplateChange(5);
+   159â†’
+   160â†’      expect(message[0]).toBe(0xF0);
+   161â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   162â†’      expect(message[4]).toBe(0x02); // Device ID (Launch Control XL 3) - UPDATED for Issue #36 fix
+   163â†’      expect(message[5]).toBe(SysExMessageType.TEMPLATE_CHANGE);
+   164â†’      expect(message[6]).toBe(5); // Template number
+   165â†’      expect(message[7]).toBe(0xF7);
+   166â†’    });
+   167â†’
+   168â†’    it('should validate template number range', () => {
+   169â†’      expect(() => SysExParser.buildTemplateChange(-1)).toThrow('Template number must be 0-15');
+   170â†’      expect(() => SysExParser.buildTemplateChange(16)).toThrow('Template number must be 0-15');
+   171â†’    });
+   172â†’  });
+   173â†’
+   174â†’  describe('buildCustomModeReadRequest', () => {
+   175â†’    it('should build custom mode read request', () => {
+   176â†’      const message = SysExParser.buildCustomModeReadRequest(3, 0);
+   177â†’
+   178â†’      expect(message[0]).toBe(0xF0);
+   179â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   180â†’      expect(message[4]).toBe(0x02); // Device ID
+   181â†’      expect(message[5]).toBe(0x15); // Command (Custom mode)
+   182â†’      expect(message[6]).toBe(0x05); // Sub-command
+   183â†’      expect(message[7]).toBe(0x00); // Reserved
+   184â†’      expect(message[8]).toBe(0x40); // Read operation
+   185â†’      expect(message[9]).toBe(0x00); // Page (0x00 for page 0)
+   186â†’      expect(message[10]).toBe(3); // Slot number
+   187â†’      expect(message[11]).toBe(0xF7);
+   188â†’    });
+   189â†’
+   190â†’    it('should validate slot number range', () => {
+   191â†’      expect(() => SysExParser.buildCustomModeReadRequest(-1)).toThrow('Custom mode slot must be 0-14');
+   192â†’      expect(() => SysExParser.buildCustomModeReadRequest(15)).toThrow('Custom mode slot must be 0-14');
+   193â†’    });
+   194â†’  });
+   195â†’
+   196â†’  describe('buildLedControl', () => {
+   197â†’    it('should build LED control message', () => {
+   198â†’      const message = SysExParser.buildLedControl(0x29, 0x3C, 'static');
+   199â†’
+   200â†’      expect(message[0]).toBe(0xF0);
+   201â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   202â†’      expect(message[4]).toBe(0x11);
+   203â†’      expect(message[5]).toBe(SysExMessageType.LED_CONTROL);
+   204â†’      expect(message[6]).toBe(0x29); // Control ID
+   205â†’      expect(message[7]).toBe(0x3C); // Color
+   206â†’      expect(message[8]).toBe(0xF7);
+   207â†’    });
+   208â†’
+   209â†’    it('should handle flash behavior', () => {
+   210â†’      const message = SysExParser.buildLedControl(0x29, 0x3C, 'flash');
+   211â†’      expect(message[7]).toBe(0x3C | 0x08); // Color with flash bit
+   212â†’    });
+   213â†’
+   214â†’    it('should handle pulse behavior', () => {
+   215â†’      const message = SysExParser.buildLedControl(0x29, 0x3C, 'pulse');
+   216â†’      expect(message[7]).toBe(0x3C | 0x10); // Color with pulse bit
+   217â†’    });
+   218â†’
+   219â†’    it('should validate control ID range', () => {
+   220â†’      expect(() => SysExParser.buildLedControl(-1, 0x3C)).toThrow('Control ID must be 0-127');
+   221â†’      expect(() => SysExParser.buildLedControl(128, 0x3C)).toThrow('Control ID must be 0-127');
+   222â†’    });
+   223â†’
+   224â†’    it('should validate color range', () => {
+   225â†’      expect(() => SysExParser.buildLedControl(0x29, -1)).toThrow('Color must be 0-127');
+   226â†’      expect(() => SysExParser.buildLedControl(0x29, 128)).toThrow('Color must be 0-127');
+   227â†’    });
+   228â†’  });
+   229â†’
+   230â†’  describe('buildLedReset', () => {
+   231â†’    it('should build LED reset message', () => {
+   232â†’      const message = SysExParser.buildLedReset();
+   233â†’
+   234â†’      expect(message[0]).toBe(0xF0);
+   235â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   236â†’      expect(message[4]).toBe(0x11);
+   237â†’      expect(message[5]).toBe(SysExMessageType.RESET_LED);
+   238â†’      expect(message[6]).toBe(0x00); // Reset all
+   239â†’      expect(message[7]).toBe(0xF7);
+   240â†’    });
+   241â†’  });
+   242â†’
+   243â†’  describe('isValidSysEx', () => {
+   244â†’    it('should validate correct SysEx messages', () => {
+   245â†’      expect(SysExParser.isValidSysEx([0xF0, 0x00, 0xF7])).toBe(true);
+   246â†’      expect(SysExParser.isValidSysEx([0xF0, 0x00, 0x01, 0x02, 0xF7])).toBe(true);
+   247â†’    });
+   248â†’
+   249â†’    it('should reject invalid SysEx messages', () => {
+   250â†’      expect(SysExParser.isValidSysEx([])).toBe(false);
+   251â†’      expect(SysExParser.isValidSysEx([0xF0])).toBe(false);
+   252â†’      expect(SysExParser.isValidSysEx([0xF7])).toBe(false);
+   253â†’      expect(SysExParser.isValidSysEx([0x00, 0x01])).toBe(false);
+   254â†’      expect(SysExParser.isValidSysEx([0xF0, 0x00])).toBe(false); // Missing end
+   255â†’      expect(SysExParser.isValidSysEx([0x00, 0xF7])).toBe(false); // Missing start
+   256â†’    });
+   257â†’  });
+   258â†’
+   259â†’  describe('getManufacturerId', () => {
+   260â†’    it('should extract 3-byte manufacturer ID', () => {
+   261â†’      const message = [0xF0, 0x00, 0x20, 0x29, 0x01, 0xF7];
+   262â†’      const id = SysExParser.getManufacturerId(message);
+   263â†’      expect(id).toEqual([0x00, 0x20, 0x29]);
+   264â†’    });
+   265â†’
+   266â†’    it('should extract single-byte manufacturer ID', () => {
+   267â†’      const message = [0xF0, 0x43, 0x01, 0xF7]; // Yamaha
+   268â†’      const id = SysExParser.getManufacturerId(message);
+   269â†’      expect(id).toEqual([0x43]);
+   270â†’    });
+   271â†’
+   272â†’    it('should return null for universal messages', () => {
+   273â†’      const message = [0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7];
+   274â†’      const id = SysExParser.getManufacturerId(message);
+   275â†’      expect(id).toBeNull();
+   276â†’
+   277â†’      const realtime = [0xF0, 0x7F, 0x00, 0x06, 0x01, 0xF7];
+   278â†’      const id2 = SysExParser.getManufacturerId(realtime);
+   279â†’      expect(id2).toBeNull();
+   280â†’    });
+   281â†’
+   282â†’    it('should return null for invalid SysEx', () => {
+   283â†’      const id = SysExParser.getManufacturerId([0x00, 0x01]);
+   284â†’      expect(id).toBeNull();
+   285â†’    });
+   286â†’  });
+   287â†’
+   288â†’  describe('validateCustomModeData', () => {
+   289â†’    it('should validate valid custom mode data', () => {
+   290â†’      const modeData = {
+   291â†’        type: 'custom_mode_write',
+   292â†’        manufacturerId: MANUFACTURER_ID,
+   293â†’        slot: 0,
+   294â†’        controls: [
+   295â†’          {
+   296â†’            controlId: 0x0D,
+   297â†’            channel: 0,
+   298â†’            ccNumber: 20,
+   299â†’            minValue: 0,
+   300â†’            maxValue: 127,
+   301â†’            behaviour: 'absolute' as const,
+   302â†’          },
+   303â†’        ],
+   304â†’        colors: [
+   305â†’          {
+   306â†’            controlId: 0x29,
+   307â†’            color: 0x3C,
+   308â†’            behaviour: 'static' as const,
+   309â†’          },
+   310â†’        ],
+   311â†’        data: [],
+   312â†’      };
+   313â†’
+   314â†’      expect(() => SysExParser.validateCustomModeData(modeData as any)).not.toThrow();
+   315â†’    });
+   316â†’
+   317â†’    it('should reject invalid control data', () => {
+   318â†’      const invalidCC = {
+   319â†’        type: 'custom_mode_write',
+   320â†’        manufacturerId: MANUFACTURER_ID,
+   321â†’        slot: 0,
+   322â†’        controls: [
+   323â†’          {
+   324â†’            controlId: 0x0D,
+   325â†’            channel: 0,
+   326â†’            ccNumber: 128, // Invalid
+   327â†’            minValue: 0,
+   328â†’            maxValue: 127,
+   329â†’            behaviour: 'absolute',
+   330â†’          },
+   331â†’        ],
+   332â†’        colors: [],
+   333â†’        data: [],
+   334â†’      };
+   335â†’
+   336â†’      expect(() => SysExParser.validateCustomModeData(invalidCC as any)).toThrow('CC number must be 0-127');
+   337â†’    });
+   338â†’
+   339â†’    it('should reject invalid channel', () => {
+   340â†’      const invalidChannel = {
+   341â†’        type: 'custom_mode_write',
+   342â†’        manufacturerId: MANUFACTURER_ID,
+   343â†’        slot: 0,
+   344â†’        controls: [
+   345â†’          {
+   346â†’            controlId: 0x0D,
+   347â†’            channel: 16, // Invalid
+   348â†’            ccNumber: 20,
+   349â†’            minValue: 0,
+   350â†’            maxValue: 127,
+   351â†’            behaviour: 'absolute',
+   352â†’          },
+   353â†’        ],
+   354â†’        colors: [],
+   355â†’        data: [],
+   356â†’      };
+   357â†’
+   358â†’      expect(() => SysExParser.validateCustomModeData(invalidChannel as any)).toThrow('Channel must be 0-15');
+   359â†’    });
+   360â†’
+   361â†’    it('should reject invalid value ranges', () => {
+   362â†’      const invalidRange = {
+   363â†’        type: 'custom_mode_write',
+   364â†’        manufacturerId: MANUFACTURER_ID,
+   365â†’        slot: 0,
+   366â†’        controls: [
+   367â†’          {
+   368â†’            controlId: 0x0D,
+   369â†’            channel: 0,
+   370â†’            ccNumber: 20,
+   371â†’            minValue: 100,
+   372â†’            maxValue: 50, // Min > Max
+   373â†’            behaviour: 'absolute',
+   374â†’          },
+   375â†’        ],
+   376â†’        colors: [],
+   377â†’        data: [],
+   378â†’      };
+   379â†’
+   380â†’      expect(() => SysExParser.validateCustomModeData(invalidRange as any)).toThrow('Min value cannot be greater than max value');
+   381â†’    });
+   382â†’
+   383â†’    it('should reject invalid color values', () => {
+   384â†’      const invalidColor = {
+   385â†’        type: 'custom_mode_write',
+   386â†’        manufacturerId: MANUFACTURER_ID,
+   387â†’        slot: 0,
+   388â†’        controls: [],
+   389â†’        colors: [
+   390â†’          {
+   391â†’            controlId: 0x29,
+   392â†’            color: 128, // Invalid
+   393â†’            behaviour: 'static',
+   394â†’          },
+   395â†’        ],
+   396â†’        data: [],
+   397â†’      };
+   398â†’
+   399â†’      expect(() => SysExParser.validateCustomModeData(invalidColor as any)).toThrow('Color value must be 0-127');
+   400â†’    });
+   401â†’  });
+   402â†’
+   403â†’  /**
+   404â†’   * THESE TESTS ARE SKIPPED - They test a hypothetical protocol format that doesn't match the real device.
+   405â†’   *
+   406â†’   * Background:
+   407â†’   * - These tests were written speculatively before protocol reverse-engineering
+   408â†’   * - They expect format: [0x01, 0x20, 0x10, 0x2A] data header + 0x49 control markers with +0x28 offset
+   409â†’   * - The REAL device uses: [0x20, length, ...name] format (verified via web editor analysis)
+   410â†’   * - See PROTOCOL.md v1.8 (2025-10-11) for actual protocol specification
+   411â†’   * - See issue #32 for protocol discovery details
+   412â†’   *
+   413â†’   * The implementation works correctly with real hardware (backup utility succeeds).
+   414â†’   * These tests need complete rewrite to match actual protocol, not vice versa.
+   415â†’   */
+   416â†’  describe.skip('buildCustomModeWriteRequest - MIDI Protocol Validation', () => {
+   417â†’    it('should create message with correct header according to MIDI-PROTOCOL.md', () => {
+   418â†’      const modeData = {
+   419â†’        type: 'custom_mode_response',
+   420â†’        manufacturerId: [0x00, 0x20, 0x29],
+   421â†’        slot: 0,
+   422â†’        name: 'TEST',
+   423â†’        controls: [],
+   424â†’        colors: [],
+   425â†’        data: []
+   426â†’      };
+   427â†’
+   428â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   429â†’
+   430â†’      // Check SysEx boundaries
+   431â†’      expect(message[0]).toBe(0xF0);
+   432â†’      expect(message[message.length - 1]).toBe(0xF7);
+   433â†’
+   434â†’      // Check header matches MIDI-PROTOCOL.md specification
+   435â†’      expect(message.slice(1, 10)).toEqual([
+   436â†’        0x00, 0x20, 0x29, // Manufacturer ID
+   437â†’        0x02,             // Device ID
+   438â†’        0x15,             // Command
+   439â†’        0x05,             // Sub-command
+   440â†’        0x00,             // Reserved
+   441â†’        0x45,             // Write operation
+   442â†’        0x00              // Slot
+   443â†’      ]);
+   444â†’    });
+   445â†’
+   446â†’    it('should include data header (00 20 08) after protocol header', () => {
+   447â†’      const modeData = {
+   448â†’        type: 'custom_mode_response',
+   449â†’        manufacturerId: [0x00, 0x20, 0x29],
+   450â†’        slot: 0,
+   451â†’        name: 'TEST',
+   452â†’        controls: [],
+   453â†’        colors: [],
+   454â†’        data: []
+   455â†’      };
+   456â†’
+   457â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   458â†’
+   459â†’      // Data header should be at position 10 (Phase 2: new format)
+   460â†’      expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]);
+   461â†’    });
+   462â†’
+   463â†’    it('should encode control with 0x49 marker and +0x28 offset as per protocol', () => {
+   464â†’      const modeData = {
+   465â†’        type: 'custom_mode_response',
+   466â†’        manufacturerId: [0x00, 0x20, 0x29],
+   467â†’        slot: 0,
+   468â†’        name: 'TEST',
+   469â†’        controls: [{
+   470â†’          controlId: 0x00, // Fader 1
+   471â†’          name: 'Volume',
+   472â†’          midiChannel: 0,
+   473â†’          ccNumber: 77,
+   474â†’          minValue: 0,
+   475â†’          maxValue: 127
+   476â†’        }],
+   477â†’        colors: [],
+   478â†’        data: []
+   479â†’      };
+   480â†’
+   481â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   482â†’
+   483â†’      // Find control definition (after header + data header + name)
+   484â†’      // Header(10) + DataHeader(4) + Name(4) = 18
+   485â†’      const controlDef = message.slice(18, 29);
+   486â†’
+   487â†’      // Verify control format matches protocol:
+   488â†’      // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+   489â†’      expect(controlDef[0]).toBe(0x49);        // Write marker
+   490â†’      expect(controlDef[1]).toBe(0x28);        // ID 0x00 + 0x28
+   491â†’      expect(controlDef[2]).toBe(0x02);        // Definition type
+   492â†’      expect(controlDef[3]).toBe(0x00);        // Control type for fader
+   493â†’      expect(controlDef[4]).toBe(0x00);        // Channel
+   494â†’      expect(controlDef[5]).toBe(0x01);        // Fixed param
+   495â†’      expect(controlDef[6]).toBe(0x40);        // Behavior
+   496â†’      expect(controlDef[7]).toBe(0x00);        // Min (always 0x00)
+   497â†’      expect(controlDef[8]).toBe(77);          // CC number
+   498â†’      expect(controlDef[9]).toBe(0x7F);        // Max (always 0x7F)
+   499â†’      expect(controlDef[10]).toBe(0x00);       // Terminator
+   500â†’    });
+   501â†’
+   502â†’    it('should use actual control names in labels, not generic ones', () => {
+   503â†’      const modeData = {
+   504â†’        type: 'custom_mode_response',
+   505â†’        manufacturerId: [0x00, 0x20, 0x29],
+   506â†’        slot: 0,
+   507â†’        name: 'TEST',
+   508â†’        controls: [{
+   509â†’          controlId: 0x00,
+   510â†’          name: 'MyVolume', // Specific name
+   511â†’          ccNumber: 77
+   512â†’        }],
+   513â†’        colors: [{
+   514â†’          controlId: 0x00,
+   515â†’          color: 0x0C
+   516â†’        }],
+   517â†’        data: []
+   518â†’      };
+   519â†’
+   520â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   521â†’      const messageStr = message.map(b => String.fromCharCode(b)).join('');
+   522â†’
+   523â†’      // Should contain the actual control name
+   524â†’      expect(messageStr).toContain('MyVolume');
+   525â†’
+   526â†’      // Should NOT contain generic label
+   527â†’      expect(messageStr).not.toContain('Fader 1');
+   528â†’    });
+   529â†’
+   530â†’    it('should include label markers (0x69) for controls with names', () => {
+   531â†’      const modeData = {
+   532â†’        type: 'custom_mode_response',
+   533â†’        manufacturerId: [0x00, 0x20, 0x29],
+   534â†’        slot: 0,
+   535â†’        name: 'TEST',
+   536â†’        controls: [{
+   537â†’          controlId: 0x00,
+   538â†’          name: 'Vol',
+   539â†’          ccNumber: 77
+   540â†’        }],
+   541â†’        colors: [{
+   542â†’          controlId: 0x00,
+   543â†’          color: 0x0C
+   544â†’        }],
+   545â†’        data: []
+   546â†’      };
+   547â†’
+   548â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   549â†’
+   550â†’      // Should contain label marker
+   551â†’      expect(message).toContain(0x69);
+   552â†’
+   553â†’      // Find label section and verify structure
+   554â†’      const labelIdx = message.indexOf(0x69);
+   555â†’      expect(labelIdx).toBeGreaterThan(0);
+   556â†’      expect(message[labelIdx + 1]).toBe(0x28); // Control ID with offset
+   557â†’    });
+   558â†’
+   559â†’    it('should include color markers (0x60) for all controls', () => {
+   560â†’      const modeData = {
+   561â†’        type: 'custom_mode_response',
+   562â†’        manufacturerId: [0x00, 0x20, 0x29],
+   563â†’        slot: 0,
+   564â†’        name: 'TEST',
+   565â†’        controls: [{
+   566â†’          controlId: 0x00,
+   567â†’          name: 'Vol',
+   568â†’          ccNumber: 77
+   569â†’        }],
+   570â†’        colors: [{
+   571â†’          controlId: 0x00,
+   572â†’          color: 0x0C
+   573â†’        }],
+   574â†’        data: []
+   575â†’      };
+   576â†’
+   577â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   578â†’
+   579â†’      // Should contain color marker
+   580â†’      expect(message).toContain(0x60);
+   581â†’
+   582â†’      // Find color section and verify structure
+   583â†’      const colorIdx = message.indexOf(0x60);
+   584â†’      expect(colorIdx).toBeGreaterThan(0);
+   585â†’      expect(message[colorIdx + 1]).toBe(0x28); // Control ID with offset
+   586â†’    });
+   587â†’
+   588â†’    it('should generate message of appropriate length for complete data', () => {
+   589â†’      const modeData = {
+   590â†’        type: 'custom_mode_response',
+   591â†’        manufacturerId: [0x00, 0x20, 0x29],
+   592â†’        slot: 0,
+   593â†’        name: 'TESTMODE',
+   594â†’        controls: [
+   595â†’          { controlId: 0x00, name: 'Volume1', ccNumber: 1 },
+   596â†’          { controlId: 0x01, name: 'Volume2', ccNumber: 2 },
+   597â†’          { controlId: 0x10, name: 'Send1', ccNumber: 13 },
+   598â†’          { controlId: 0x11, name: 'Send2', ccNumber: 14 },
+   599â†’        ],
+   600â†’        colors: [
+   601â†’          { controlId: 0x00, color: 0x0C },
+   602â†’          { controlId: 0x01, color: 0x0C },
+   603â†’          { controlId: 0x10, color: 0x3C },
+   604â†’          { controlId: 0x11, color: 0x3C },
+   605â†’        ],
+   606â†’        data: []
+   607â†’      };
+   608â†’
+   609â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   610â†’
+   611â†’      // According to MIDI-PROTOCOL.md, complete messages are 400-500+ bytes
+   612â†’      // With 4 controls, labels, and colors, should be substantial
+   613â†’      expect(message.length).toBeGreaterThan(100);
+   614â†’    });
+   615â†’  });
+   616â†’
+   617â†’  describe.skip('buildCustomModeWriteRequest', () => {
+   618â†’    // SKIPPED: Same reason as above - tests hypothetical protocol format
+   619â†’    describe('Message Structure', () => {
+   620â†’      it('should create a properly formatted SysEx message with correct header and footer', () => {
+   621â†’        const slot = 0;
+   622â†’        const modeData: any = {
+   623â†’          type: 'custom_mode_response',
+   624â†’          manufacturerId: [0x00, 0x20, 0x29],
+   625â†’          slot,
+   626â†’          name: 'TEST',
+   627â†’          controls: [],
+   628â†’          colors: [],
+   629â†’          data: []
+   630â†’        };
+   631â†’
+   632â†’        const message = SysExParser.buildCustomModeWriteRequest(slot, 0, modeData);
+   633â†’
+   634â†’        // Check SysEx start and end
+   635â†’        expect(message[0]).toBe(0xF0); // SysEx start
+   636â†’        expect(message[message.length - 1]).toBe(0xF7); // SysEx end
+   637â†’
+   638â†’        // Check header according to MIDI-PROTOCOL.md
+   639â†’        expect(message.slice(1, 10)).toEqual([
+   640â†’          0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+   641â†’          0x02,             // Device ID (Launch Control XL 3)
+   642â†’          0x15,             // Command (Custom mode)
+   643â†’          0x05,             // Sub-command
+   644â†’          0x00,             // Reserved
+   645â†’          0x45,             // Write operation
+   646â†’          slot              // Slot number
+   647â†’        ]);
+   648â†’      });
+   649â†’
+   650â†’      it('should include the data header (00 20 08) after the protocol header', () => {
+   651â†’        const modeData: any = {
+   652â†’          type: 'custom_mode_response',
+   653â†’          manufacturerId: [0x00, 0x20, 0x29],
+   654â†’          slot: 0,
+   655â†’          name: 'TEST',
+   656â†’          controls: [],
+   657â†’          colors: [],
+   658â†’          data: []
+   659â†’        };
+   660â†’
+   661â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   662â†’
+   663â†’        // Data should start at position 10 (after header) (Phase 2: new format)
+   664â†’        expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]);
+   665â†’      });
+   666â†’    });
+   667â†’
+   668â†’    describe('Mode Name Encoding', () => {
+   669â†’      it('should encode the mode name as ASCII after the data header', () => {
+   670â†’        const modeName = 'CHANNEVE';
+   671â†’        const modeData: any = {
+   672â†’          type: 'custom_mode_response',
+   673â†’          manufacturerId: [0x00, 0x20, 0x29],
+   674â†’          slot: 0,
+   675â†’          name: modeName,
+   676â†’          controls: [],
+   677â†’          colors: [],
+   678â†’          data: []
+   679â†’        };
+   680â†’
+   681â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   682â†’
+   683â†’        // Mode name should be at position 14 (after header + new 4-byte data header)
+   684â†’        const nameBytes = message.slice(14, 14 + modeName.length);
+   685â†’        const decodedName = String.fromCharCode(...nameBytes);
+   686â†’
+   687â†’        expect(decodedName).toBe('CHANNEVE');
+   688â†’      });
+   689â†’
+   690â†’      it('should limit mode name to 8 characters maximum', () => {
+   691â†’        const modeData: any = {
+   692â†’          type: 'custom_mode_response',
+   693â†’          manufacturerId: [0x00, 0x20, 0x29],
+   694â†’          slot: 0,
+   695â†’          name: 'VERYLONGMODENAME', // 16 characters
+   696â†’          controls: [],
+   697â†’          colors: [],
+   698â†’          data: []
+   699â†’        };
+   700â†’
+   701â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   702â†’
+   703â†’        // Check that up to 16 characters are encoded (Phase 2: new format)
+   704â†’        const nameBytes = message.slice(14, 30); // 4-byte header + 16 chars
+   705â†’        const decodedName = String.fromCharCode(...nameBytes);
+   706â†’
+   707â†’        expect(decodedName).toBe('VERYLONGMODENAME');
+   708â†’      });
+   709â†’    });
+   710â†’
+   711â†’    describe('Control Encoding', () => {
+   712â†’      it('should encode controls with 0x49 marker and correct structure', () => {
+   713â†’        const control: any = {
+   714â†’          controlId: 0x00, // Fader 1
+   715â†’          name: 'Volume',
+   716â†’          midiChannel: 0,
+   717â†’          ccNumber: 77,
+   718â†’          minValue: 0,
+   719â†’          maxValue: 127,
+   720â†’          behaviour: 'absolute'
+   721â†’        };
+   722â†’
+   723â†’        const modeData: any = {
+   724â†’          type: 'custom_mode_response',
+   725â†’          manufacturerId: [0x00, 0x20, 0x29],
+   726â†’          slot: 0,
+   727â†’          name: 'TEST',
+   728â†’          controls: [control],
+   729â†’          colors: [],
+   730â†’          data: []
+   731â†’        };
+   732â†’
+   733â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   734â†’
+   735â†’        // Find the control definition (should start after header + data header + name)
+   736â†’        // Header(10) + DataHeader(4) + Name(4) = 18
+   737â†’        const controlStart = 18;
+   738â†’        const controlDef = message.slice(controlStart, controlStart + 11);
+   739â†’
+   740â†’        // According to MIDI-PROTOCOL.md, control format for WRITE should be:
+   741â†’        // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+   742â†’        expect(controlDef).toEqual([
+   743â†’          0x49,        // Write control marker
+   744â†’          0x28,        // Control ID 0x00 + 0x28 offset
+   745â†’          0x02,        // Definition type
+   746â†’          0x00,        // Control type (0x00 for faders)
+   747â†’          0x00,        // MIDI channel (0-based)
+   748â†’          0x01,        // Fixed parameter 1
+   749â†’          0x40,        // Behavior parameter
+   750â†’          0x00,        // Min (always 0x00 in write)
+   751â†’          77,          // CC number
+   752â†’          0x7F,        // Max (always 0x7F in write)
+   753â†’          0x00         // Terminator
+   754â†’        ]);
+   755â†’      });
+   756â†’
+   757â†’      it('should apply correct control ID offset (+0x28) for all controls', () => {
+   758â†’        const controls: any[] = [
+   759â†’          { controlId: 0x00, ccNumber: 1 }, // Fader 1
+   760â†’          { controlId: 0x10, ccNumber: 2 }, // Top encoder 1
+   761â†’          { controlId: 0x18, ccNumber: 3 }, // Mid encoder 1
+   762â†’          { controlId: 0x20, ccNumber: 4 }, // Bot encoder 1
+   763â†’        ];
+   764â†’
+   765â†’        const modeData: any = {
+   766â†’          type: 'custom_mode_response',
+   767â†’          manufacturerId: [0x00, 0x20, 0x29],
+   768â†’          slot: 0,
+   769â†’          name: 'TEST',
+   770â†’          controls,
+   771â†’          colors: [],
+   772â†’          data: []
+   773â†’        };
+   774â†’
+   775â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   776â†’
+   777â†’        // Now the implementation includes ALL hardware controls, not just user-defined ones
+   778â†’        // Check that specific controls have the correct offset applied
+   779â†’        let position = 18; // After header + data header + name (Phase 2: 4-byte header)
+   780â†’
+   781â†’        // First control (0x00) should become 0x28
+   782â†’        expect(message[position + 1]).toBe(0x28);
+   783â†’
+   784â†’        // Find control 0x10 (it will be at position for control index 8 since we have 0x00-0x07, then 0x10)
+   785â†’        // Skip 8 fader controls (0x00-0x07) = 8 * 11 = 88 bytes
+   786â†’        const control10Position = position + (8 * 11);
+   787â†’        expect(message[control10Position + 1]).toBe(0x38); // 0x10 + 0x28
+   788â†’
+   789â†’        // Find control 0x18 (index 16: 8 faders + 8 top encoders)
+   790â†’        const control18Position = position + (16 * 11);
+   791â†’        expect(message[control18Position + 1]).toBe(0x40); // 0x18 + 0x28
+   792â†’
+   793â†’        // Find control 0x20 (index 24: 8 faders + 8 top + 8 mid encoders)
+   794â†’        const control20Position = position + (24 * 11);
+   795â†’        expect(message[control20Position + 1]).toBe(0x48); // 0x20 + 0x28
+   796â†’      });
+   797â†’
+   798â†’      it('should use correct control type values based on hardware position', () => {
+   799â†’        const controls: any[] = [
+   800â†’          { controlId: 0x00 }, // Fader - should use type 0x00
+   801â†’          { controlId: 0x10 }, // Top encoder - should use type 0x05
+   802â†’          { controlId: 0x18 }, // Mid encoder - should use type 0x09
+   803â†’          { controlId: 0x20 }, // Bot encoder - should use type 0x0D
+   804â†’        ];
+   805â†’
+   806â†’        const modeData: any = {
+   807â†’          type: 'custom_mode_response',
+   808â†’          manufacturerId: [0x00, 0x20, 0x29],
+   809â†’          slot: 0,
+   810â†’          name: 'TEST',
+   811â†’          controls,
+   812â†’          colors: [],
+   813â†’          data: []
+   814â†’        };
+   815â†’
+   816â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   817â†’
+   818â†’        let position = 18; // After header + data header + name (Phase 2: 4-byte header)
+   819â†’
+   820â†’        // Check control types - now with ALL controls included
+   821â†’        expect(message[position + 3]).toBe(0x00); // First fader type (0x00)
+   822â†’
+   823â†’        // Find control 0x10 (first top encoder) - skip 8 faders
+   824â†’        const control10Position = position + (8 * 11);
+   825â†’        expect(message[control10Position + 3]).toBe(0x05); // Top encoder type
+   826â†’
+   827â†’        // Find control 0x18 (first mid encoder) - skip 8 faders + 8 top encoders
+   828â†’        const control18Position = position + (16 * 11);
+   829â†’        expect(message[control18Position + 3]).toBe(0x09); // Mid encoder type
+   830â†’
+   831â†’        // Find control 0x20 (first bot encoder) - skip 8 faders + 8 top + 8 mid encoders
+   832â†’        const control20Position = position + (24 * 11);
+   833â†’        expect(message[control20Position + 3]).toBe(0x0D); // Bot encoder type
+   834â†’      });
+   835â†’    });
+   836â†’
+   837â†’    describe('Label and Color Data', () => {
+   838â†’      it('should include label data with 0x69 marker and control names', () => {
+   839â†’        const control: any = {
+   840â†’          controlId: 0x00,
+   841â†’          name: 'Volume',
+   842â†’          ccNumber: 77
+   843â†’        };
+   844â†’
+   845â†’        const modeData: any = {
+   846â†’          type: 'custom_mode_response',
+   847â†’          manufacturerId: [0x00, 0x20, 0x29],
+   848â†’          slot: 0,
+   849â†’          name: 'TEST',
+   850â†’          controls: [control],
+   851â†’          colors: [{ controlId: 0x00, color: 0x0C }],
+   852â†’          data: []
+   853â†’        };
+   854â†’
+   855â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   856â†’
+   857â†’        // Find label section (after ALL control definitions)
+   858â†’        // Header(10) + DataHeader(3) + Name(4) + AllControls(48*11) = 545
+   859â†’        const allControlsSize = 48 * 11; // 48 controls * 11 bytes each
+   860â†’        const labelStart = 18 + allControlsSize; // After header + data header + name + all controls (Phase 2: 4-byte header)
+   861â†’
+   862â†’        // Label format should be: 69 [ID+0x28] [ASCII_TEXT...]
+   863â†’        expect(message[labelStart]).toBe(0x69); // Label marker for first control (0x00)
+   864â†’        expect(message[labelStart + 1]).toBe(0x28); // Control ID 0x00 with offset
+   865â†’
+   866â†’        // Check that the custom name is encoded (not the default 'Fader 1')
+   867â†’        const labelText = message.slice(labelStart + 2, labelStart + 2 + 6);
+   868â†’        const decodedLabel = String.fromCharCode(...labelText);
+   869â†’        expect(decodedLabel).toBe('Volume');
+   870â†’      });
+   871â†’
+   872â†’      it('should include color data with 0x60 marker', () => {
+   873â†’        const control: any = {
+   874â†’          controlId: 0x00,
+   875â†’          name: 'Vol',
+   876â†’          ccNumber: 77
+   877â†’        };
+   878â†’
+   879â†’        const modeData: any = {
+   880â†’          type: 'custom_mode_response',
+   881â†’          manufacturerId: [0x00, 0x20, 0x29],
+   882â†’          slot: 0,
+   883â†’          name: 'TEST',
+   884â†’          controls: [control],
+   885â†’          colors: [{ controlId: 0x00, color: 0x0C }],
+   886â†’          data: []
+   887â†’        };
+   888â†’
+   889â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   890â†’
+   891â†’        // Find color section (after all controls + all labels)
+   892â†’        // Easier approach: search for the first 0x60 marker
+   893â†’        const colorMarkerIndex = message.findIndex(byte => byte === 0x60);
+   894â†’        expect(colorMarkerIndex).toBeGreaterThan(0);
+   895â†’
+   896â†’        // Color format should be: 60 [ID+0x28] [COLOR]
+   897â†’        expect(message[colorMarkerIndex]).toBe(0x60); // Color marker
+   898â†’        expect(message[colorMarkerIndex + 1]).toBe(0x28); // Control ID 0x00 with offset
+   899â†’        expect(message[colorMarkerIndex + 2]).toBe(0x0C); // Custom color value
+   900â†’      });
+   901â†’
+   902â†’      it('should include labels and colors for all controls', () => {
+   903â†’        const controls: any[] = [
+   904â†’          { controlId: 0x00, name: 'Vol1', ccNumber: 1 },
+   905â†’          { controlId: 0x01, name: 'Vol2', ccNumber: 2 },
+   906â†’        ];
+   907â†’
+   908â†’        const colors = [
+   909â†’          { controlId: 0x00, color: 0x0C },
+   910â†’          { controlId: 0x01, color: 0x0D },
+   911â†’        ];
+   912â†’
+   913â†’        const modeData: any = {
+   914â†’          type: 'custom_mode_response',
+   915â†’          manufacturerId: [0x00, 0x20, 0x29],
+   916â†’          slot: 0,
+   917â†’          name: 'TEST',
+   918â†’          controls,
+   919â†’          colors,
+   920â†’          data: []
+   921â†’        };
+   922â†’
+   923â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   924â†’
+   925â†’        // Message should contain label markers (there might be extras from label text)
+   926â†’        const labelMarkers = message.filter(byte => byte === 0x69);
+   927â†’        expect(labelMarkers.length).toBeGreaterThanOrEqual(48); // At least 48 hardware controls
+   928â†’
+   929â†’        // Message should contain color markers for ALL 48 hardware controls (0x60)
+   930â†’        const colorMarkers = message.filter(byte => byte === 0x60);
+   931â†’        expect(colorMarkers.length).toBe(48); // All hardware controls
+   932â†’      });
+   933â†’    });
+   934â†’
+   935â†’    describe('Complete Message Validation', () => {
+   936â†’      it('should generate a message matching the CHANNEVE example structure', () => {
+   937â†’        // Create controls matching the CHANNEVE example from MIDI-PROTOCOL.md
+   938â†’        const controls: any[] = [
+   939â†’          { controlId: 0x10, name: 'Mic Gain', midiChannel: 0, ccNumber: 13 }, // Top encoder 1
+   940â†’          { controlId: 0x11, name: 'Reverb', midiChannel: 0, ccNumber: 14 },   // Top encoder 2
+   941â†’        ];
+   942â†’
+   943â†’        const colors = [
+   944â†’          { controlId: 0x10, color: 0x60 },
+   945â†’          { controlId: 0x11, color: 0x60 },
+   946â†’        ];
+   947â†’
+   948â†’        const modeData: any = {
+   949â†’          type: 'custom_mode_response',
+   950â†’          manufacturerId: [0x00, 0x20, 0x29],
+   951â†’          slot: 0,
+   952â†’          name: 'CHANNEVE',
+   953â†’          controls,
+   954â†’          colors,
+   955â†’          data: []
+   956â†’        };
+   957â†’
+   958â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   959â†’
+   960â†’        // Verify key parts of the message structure
+   961â†’        expect(message[0]).toBe(0xF0); // Start
+   962â†’        expect(message.slice(1, 10)).toEqual([0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00]); // Header
+   963â†’        expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]); // Data header (Phase 2 format)
+   964â†’
+   965â†’        // Mode name
+   966â†’        const nameBytes = message.slice(14, 22);
+   967â†’        expect(String.fromCharCode(...nameBytes)).toBe('CHANNEVE');
+   968â†’
+   969â†’        // First control should have 0x49 marker (position shifted by +1 due to 4-byte header)
+   970â†’        expect(message[22]).toBe(0x49);
+   971â†’
+   972â†’        // Message should end with 0xF7
+   973â†’        expect(message[message.length - 1]).toBe(0xF7);
+   974â†’
+   975â†’        // Message should be substantial (400+ bytes for complete data)
+   976â†’        // Note: Current implementation may be shorter, which is the bug
+   977â†’        expect(message.length).toBeGreaterThan(50); // At minimum
+   978â†’      });
+   979â†’
+   980â†’      it('should fail if current implementation is incorrect', () => {
+   981â†’        // This test documents known issues with the current implementation
+   982â†’        const control: any = {
+   983â†’          controlId: 0x00,
+   984â†’          name: 'TestControl',
+   985â†’          midiChannel: 5,
+   986â†’          ccNumber: 64
+   987â†’        };
+   988â†’
+   989â†’        const modeData: any = {
+   990â†’          type: 'custom_mode_response',
+   991â†’          manufacturerId: [0x00, 0x20, 0x29],
+   992â†’          slot: 0,
+   993â†’          name: 'TESTMODE',
+   994â†’          controls: [control],
+   995â†’          colors: [{ controlId: 0x00, color: 0x0C }],
+   996â†’          data: []
+   997â†’        };
+   998â†’
+   999â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+  1000â†’
+  1001â†’        // Check if the implementation correctly:
+  1002â†’        // 1. Uses control names (not generic labels)
+  1003â†’        const messageStr = message.map(b => String.fromCharCode(b)).join('');
+  1004â†’        expect(messageStr).toContain('TestControl'); // Should use actual name
+  1005â†’
+  1006â†’        // 2. Has proper message length (should be 100+ bytes for even simple modes)
+  1007â†’        expect(message.length).toBeGreaterThan(100);
+  1008â†’
+  1009â†’        // 3. Includes all required sections
+  1010â†’        expect(message).toContain(0x49); // Control marker
+  1011â†’        expect(message).toContain(0x69); // Label marker
+  1012â†’        expect(message).toContain(0x60); // Color marker
+  1013â†’      });
+  1014â†’    });
+  1015â†’
+  1016â†’    describe('Error Handling', () => {
+  1017â†’      it('should throw error for invalid slot numbers', () => {
+  1018â†’        const modeData: any = {
+  1019â†’          type: 'custom_mode_response',
+  1020â†’          manufacturerId: [0x00, 0x20, 0x29],
+  1021â†’          slot: 0,
+  1022â†’          name: 'TEST',
+  1023â†’          controls: [],
+  1024â†’          colors: [],
+  1025â†’          data: []
+  1026â†’        };
+  1027â†’
+  1028â†’        expect(() => SysExParser.buildCustomModeWriteRequest(-1, 0, modeData)).toThrow();
+  1029â†’        expect(() => SysExParser.buildCustomModeWriteRequest(16, 0, modeData)).toThrow();
+  1030â†’      });
+  1031â†’
+  1032â†’      it('should throw error if controls array is missing', () => {
+  1033â†’        const modeData: any = {
+  1034â†’          type: 'custom_mode_response',
+  1035â†’          manufacturerId: [0x00, 0x20, 0x29],
+  1036â†’          slot: 0,
+  1037â†’          name: 'TEST',
+  1038â†’          colors: []
+  1039â†’          // controls missing
+  1040â†’        };
+  1041â†’
+  1042â†’        expect(() => SysExParser.buildCustomModeWriteRequest(0, 0, modeData)).toThrow('controls array');
+  1043â†’      });
+  1044â†’
+  1045â†’      it('should throw error if colors array is missing', () => {
+  1046â†’        const modeData: any = {
+  1047â†’          type: 'custom_mode_response',
+  1048â†’          manufacturerId: [0x00, 0x20, 0x29],
+  1049â†’          slot: 0,
+  1050â†’          name: 'TEST',
+  1051â†’          controls: []
+  1052â†’          // colors missing
+  1053â†’        };
+  1054â†’
+  1055â†’        expect(() => SysExParser.buildCustomModeWriteRequest(0, 0, modeData)).toThrow('colors array');
+  1056â†’      });
+  1057â†’    });
+  1058â†’  });
+  1059â†’
+  1060â†’  describe('Custom Mode Response Parsing - Real Device Data', () => {
+  1061â†’    it('should parse actual write response from device correctly', () => {
+  1062â†’      // This test uses actual response data from device after a write operation
+  1063â†’      // The device response format is different from read responses
+  1064â†’      const actualDeviceResponse = [
+  1065â†’        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, 0x06, 0x20, 0x07,
+  1066â†’        // Mode name: "RT Test" in ASCII (7 bytes)
+  1067â†’        0x52, 0x54, 0x20, 0x54, 0x65, 0x73, 0x74,
+  1068â†’        // Start of write response format
+  1069â†’        0x49, 0x21, 0x00,
+  1070â†’        // Control data in 0x40 format
+  1071â†’        0x40, 0x10, 0x40, 0x11, 0x40, 0x12, 0x40, 0x13, 0x40, 0x14, 0x40, 0x15, 0x40, 0x16, 0x40, 0x17,
+  1072â†’        0x40, 0x18, 0x40, 0x19, 0x40, 0x1A, 0x40, 0x1B, 0x40, 0x1C, 0x40, 0x1D, 0x40, 0x1E, 0x40, 0x1F,
+  1073â†’        0x40, 0x20, 0x40, 0x21, 0x40, 0x22, 0x40, 0x23, 0x40, 0x24, 0x40, 0x25, 0x40, 0x26, 0x40, 0x27,
+  1074â†’        0xF7
+  1075â†’      ];
+  1076â†’
+  1077â†’      const result = SysExParser.parse(actualDeviceResponse);
+  1078â†’
+  1079â†’      expect(result.type).toBe('custom_mode_response');
+  1080â†’      expect((result as any).slot).toBe(0);
+  1081â†’      expect((result as any).name).toBe('RT Test'); // Should parse correctly without "I"
+  1082â†’
+  1083â†’      const customModeResult = result as any;
+  1084â†’      expect(customModeResult.controls).toBeDefined();
+  1085â†’      expect(customModeResult.controls.length).toBeGreaterThan(0);
+  1086â†’
+  1087â†’      // Verify first few controls are parsed correctly
+  1088â†’      const firstControl = customModeResult.controls[0];
+  1089â†’      expect(firstControl.controlId).toBe(0x10); // First control should be 0x10 (top row encoder)
+  1090â†’      expect(firstControl.ccNumber).toBe(0x10);
+  1091â†’
+  1092â†’      // Check that we have the expected number of controls based on the data
+  1093â†’      expect(customModeResult.controls.length).toBe(24); // Based on the 0x40 patterns in response
+  1094â†’
+  1095â†’      // Verify color mappings are created
+  1096â†’      expect(customModeResult.colors).toBeDefined();
+  1097â†’      expect(customModeResult.colors.length).toBe(customModeResult.controls.length);
+  1098â†’    });
+  1099â†’
+  1100â†’    it('should handle edge case where mode name is followed directly by control data', () => {
+  1101â†’      // Test minimal response with just name and one control
+  1102â†’      const minimalResponse = [
+  1103â†’        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, 0x06, 0x20, 0x04,
+  1104â†’        // Short mode name: "Test" (4 bytes)
+  1105â†’        0x54, 0x65, 0x73, 0x74,
+  1106â†’        // Immediate control data
+  1107â†’        0x49, 0x21, 0x00,
+  1108â†’        // Single control
+  1109â†’        0x40, 0x28, 0x01,
+  1110â†’        0xF7
+  1111â†’      ];
+  1112â†’
+  1113â†’      const result = SysExParser.parse(minimalResponse);
+  1114â†’
+  1115â†’      expect(result.type).toBe('custom_mode_response');
+  1116â†’      expect((result as any).name).toBe('Test');
+  1117â†’
+  1118â†’      const customModeResult = result as any;
+  1119â†’      expect(customModeResult.controls).toBeDefined();
+  1120â†’      expect(customModeResult.controls.length).toBe(1);
+  1121â†’
+  1122â†’      const control = customModeResult.controls[0];
+  1123â†’      expect(control.controlId).toBe(0x10); // First control in sequence should be 0x10
+  1124â†’      expect(control.ccNumber).toBe(0x28); // Based on the test data: 0x40 0x28
+  1125â†’    });
+  1126â†’  });
+  1127â†’});
+  1128â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I'll update the file with the new 18-character limit:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now let me find the specific test that needs to be updated around line 690:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I'll update both files to correct the mode name length limit from 8 to 18 characters, following the file verification protocol.
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./formats/launch_control_xl3.ksy`
+
+Result:
+
+```
+74â†’  mode_name:
+    75â†’    seq:
+    76â†’      - id: name_marker
+    77â†’        contents: [0x06, 0x20]
+    78â†’      - id: name_length
+    79â†’        type: u1
+    80â†’        doc: Length of mode name (0-8 characters)
+    81â†’      - id: name_bytes
+    82â†’        size: name_length
+    83â†’        type: str
+    84â†’        encoding: ASCII
+    85â†’        if: name_length > 0
+    86â†’    doc: |
+    87â†’      Mode name format (READ/response):
+    88â†’        06 20 [length] [name_bytes]
+    89â†’
+    90â†’      Mode name format (WRITE/request):
+    91â†’        20 [length] [name_bytes]
+    92â†’
+    93â†’      Discovery: Web editor MIDI capture (2025-09-30)
+    94â†’      Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
+    95â†’
+    96â†’  control_definition:
+    97â†’    doc: |
+    98â†’      11-byte control definition structure found in READ responses.
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/core/SysExParser.test.ts`
+
+Result:
+
+```
+685â†’        const decodedName = String.fromCharCode(...nameBytes);
+   686â†’
+   687â†’        expect(decodedName).toBe('CHANNEVE');
+   688â†’      });
+   689â†’
+   690â†’      it('should limit mode name to 8 characters maximum', () => {
+   691â†’        const modeData: any = {
+   692â†’          type: 'custom_mode_response',
+   693â†’          manufacturerId: [0x00, 0x20, 0x29],
+   694â†’          slot: 0,
+   695â†’          name: 'VERYLONGMODENAME', // 16 characters
+   696â†’          controls: [],
+   697â†’          colors: [],
+   698â†’          data: []
+   699â†’        };
+   700â†’
+   701â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   702â†’
+   703â†’        // Check that up to 16 characters are encoded (Phase 2: new format)
+   704â†’        const nameBytes = message.slice(14, 30); // 4-byte header + 16 chars
+   705â†’        const decodedName = String.fromCharCode(...nameBytes);
+   706â†’
+   707â†’        expect(decodedName).toBe('VERYLONGMODENAME');
+   708â†’      });
+   709â†’    });
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I'll update the .ksy file to correct the mode name length from 8 to 18 characters:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! I can see the test that needs to be updated. The test is currently named "should limit mode name to 8 characters maximum" but it's already testing 16 characters (VERYLONGMODENAME). I need to update it to test for the new 18-character limit. Let me read the current file to make the changes:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/core/SysExParser.test.ts`
+
+Result:
+
+```
+690â†’      it('should limit mode name to 8 characters maximum', () => {
+   691â†’        const modeData: any = {
+   692â†’          type: 'custom_mode_response',
+   693â†’          manufacturerId: [0x00, 0x20, 0x29],
+   694â†’          slot: 0,
+   695â†’          name: 'VERYLONGMODENAME', // 16 characters
+   696â†’          controls: [],
+   697â†’          colors: [],
+   698â†’          data: []
+   699â†’        };
+   700â†’
+   701â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   702â†’
+   703â†’        // Check that up to 16 characters are encoded (Phase 2: new format)
+   704â†’        const nameBytes = message.slice(14, 30); // 4-byte header + 16 chars
+   705â†’        const decodedName = String.fromCharCode(...nameBytes);
+   706â†’
+   707â†’        expect(decodedName).toBe('VERYLONGMODENAME');
+   708â†’      });
+   709â†’    });
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I need to update this test. The test is currently inside a `describe.skip` block (line 617), which means these tests are skipped. I need to update the test at line 690 to reflect the new 18-character limit. Let me create the updated test content:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Write**
+
+```ksy
+meta:
+  id: launch_control_xl3_custom_mode
+  title: Novation Launch Control XL3 Custom Mode Format
+  file-extension: bin
+  endian: be
+  license: MIT
+  ks-version: 0.11
+
+doc: |
+  Custom mode configuration format for Novation Launch Control XL3.
+
+  The custom mode data is split across 2 SysEx message pages:
+  - Page 0 (SysEx byte 0x00): Mode name + controls 0x10-0x27 (24 controls) + labels
+  - Page 1 (SysEx byte 0x03): Mode name + controls 0x28-0x3F (24 controls) + labels
+
+  Total: 48 controls (0x10-0x3F)
+
+  Empirically discovered format through MIDI traffic analysis.
+
+  Version History:
+  - v1.6 (2025-10-16): Corrected mode name length limit documentation from 8 to 18 characters
+  - v1.5 (2025-10-11): Documented parser bug fix - 0x40 appears as data in minValue field, not as control marker
+  - v1.4 (2025-10-09): Corrected to 2 pages (0x00, 0x03), not 3 pages. Updated to reflect working code.
+  - v1.3 (2025-09-30): Documented read slot byte behavior for DAW port integration
+  - v1.2 (2025-09-30): Added write acknowledgement message format (command 0x15)
+  - v1.1 (2025-09-30): Documented write protocol format (command 0x45)
+  - v1.0 (2025-09-30): Initial read protocol specification
+
+seq:
+  - id: page_0
+    type: custom_mode_page
+    doc: First page with mode name and controls 0x10-0x27 (24 controls)
+  - id: page_1
+    type: custom_mode_page
+    doc: Second page with mode name and controls 0x28-0x3F (24 controls)
+
+types:
+  custom_mode_page:
+    doc: |
+      A single page of custom mode data containing 24 control definitions.
+
+      Page 0 (SysEx byte 0x00): Controls 0x10-0x27
+      Page 1 (SysEx byte 0x03): Controls 0x28-0x3F
+
+      Both pages contain the mode name (for redundancy/verification).
+    seq:
+      - id: header
+        type: page_header
+      - id: mode_name_section
+        type: mode_name
+        doc: Mode name present in both pages (redundant for verification)
+      - id: controls
+        type: control_definition
+        repeat: expr
+        repeat-expr: 24
+        doc: 24 control definitions per page (not 16)
+      - id: labels
+        type: label_section
+        size-eos: true
+        doc: Variable-length label section
+
+  page_header:
+    seq:
+      - id: page_marker
+        contents: [0x06, 0x00]
+      - id: page_number
+        type: u1
+        doc: |
+          Page number in SysEx message:
+          - 0x00 for page 0 (controls 0x10-0x27)
+          - 0x03 for page 1 (controls 0x28-0x3F)
+      - id: unknown1
+        size: 3
+
+  mode_name:
+    seq:
+      - id: name_marker
+        contents: [0x06, 0x20]
+      - id: name_length
+        type: u1
+        doc: Length of mode name (0-18 characters)
+      - id: name_bytes
+        size: name_length
+        type: str
+        encoding: ASCII
+        if: name_length > 0
+    doc: |
+      Mode name format (READ/response):
+        06 20 [length] [name_bytes]
+
+      Mode name format (WRITE/request):
+        20 [length] [name_bytes]
+
+      Discovery: Web editor MIDI capture (2025-09-30)
+      Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
+
+      Note: The device supports mode names up to 18 characters.
+      Earlier documentation incorrectly stated 8 characters as the maximum.
+
+  control_definition:
+    doc: |
+      11-byte control definition structure found in READ responses.
+      Marker byte is always 0x48 (not 0x40, 0x49, or any other value).
+
+      Note: The min_value field (position +7) may contain 0x40 (decimal 64) as DATA.
+      This is not a control marker - it's simply a minValue of 64.
+
+      WARNING: Parsers must not scan for 0x40 bytes to identify controls.
+    seq:
+      - id: control_marker
+        contents: [0x48]
+        doc: Control definition marker (always 0x48 in READ responses)
+      - id: control_id
+        type: u1
+        doc: Hardware control ID (0x10-0x3F)
+      - id: def_type
+        contents: [0x02]
+        doc: Definition type (always 0x02)
+      - id: control_type
+        type: u1
+        doc: Control type (0x00=knob top, 0x05=knob bottom, 0x09=fader, etc)
+      - id: midi_channel
+        type: u1
+        doc: MIDI channel (0-15)
+      - id: param1
+        type: u1
+        doc: Parameter (usually 0x01 or 0x00)
+      - id: unknown1
+        contents: [0x48]
+        doc: Unknown fixed byte (always 0x48)
+      - id: min_value
+        type: u1
+        doc: |
+          Minimum value (0-127).
+          WARNING: This may be 0x40 (64 decimal) - do NOT interpret as control marker!
+      - id: cc_number
+        type: u1
+        doc: MIDI CC number (0-127)
+      - id: max_value
+        type: u1
+        doc: Maximum value (0-127)
+      - id: terminator
+        contents: [0x00]
+        doc: Terminator byte
+
+  label_section:
+    seq:
+      - id: unknown_padding
+        size: 3
+        doc: Padding bytes before labels
+      - id: labels
+        type: control_label
+        repeat: until
+        repeat-until: _io.eof or _.is_terminator
+
+  control_label:
+    doc: |
+      Control label with length-encoding scheme.
+
+      Discovery: Empirical testing (2025-09-30)
+      The marker byte (0x60-0x6F) encodes the string length.
+
+      Length calculation: length = marker_byte - 0x60
+
+      Examples:
+      - 0x60 = 0 characters (empty)
+      - 0x65 = 5 characters ("TEST1")
+      - 0x69 = 9 characters ("High Pass")
+      - 0x6F = 15 characters (maximum)
+
+      Special control ID mapping:
+      - Label IDs 0x19-0x1C (25-28) map to control IDs 26-29 (+1 offset)
+      - All other label IDs map directly to control IDs
+    seq:
+      - id: length_marker
+        type: u1
+        doc: |
+          Marker byte encoding string length (0x60-0x6F).
+          Length = marker - 0x60 (0-15 characters).
+      - id: control_id
+        type: u1
+        doc: Control ID this label applies to (0x10-0x3F)
+      - id: name_bytes
+        size: label_length
+        type: str
+        encoding: ASCII
+        if: label_length > 0
+        doc: Label text (ASCII, variable length)
+    instances:
+      label_length:
+        value: length_marker - 0x60
+        doc: Calculate label length from marker byte
+      is_terminator:
+        value: length_marker < 0x60 or control_id < 0x10
+        doc: Check if this marks end of labels section
+
+  write_acknowledgement:
+    doc: |
+      Write acknowledgement message sent by device after receiving a page write.
+
+      Complete SysEx format:
+        F0 00 20 29 02 15 05 00 15 [page] [status] F7
+
+      This specification covers the payload after the SysEx header.
+
+      Discovery: Playwright + CoreMIDI spy (2025-09-30)
+      Observed device sending ACK 24-27ms after each page write.
+      Web editor waits for ACK before sending next page.
+
+      Example (Page 0 ACK):
+        15 00 06 = Command 0x15, Page 0, Status 0x06 (success)
+
+      Example (Page 1 ACK):
+        15 03 06 = Command 0x15, Page 1, Status 0x06 (success)
+    seq:
+      - id: command
+        contents: [0x15]
+        doc: Acknowledgement command byte
+      - id: page_number
+        type: u1
+        doc: |
+          Page number being acknowledged:
+          - 0x00 for page 0
+          - 0x03 for page 1
+      - id: status
+        type: u1
+        enum: ack_status
+        doc: Acknowledgement status (0x06 = success)
+
+enums:
+  ack_status:
+    0x06: success
+    doc: Status codes for write acknowledgements
+
+  control_behavior:
+    0x0C: absolute
+    0x0D: relative
+    0x0E: toggle
+
+```
+
+Result:
+
+```
+The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
+     1â†’meta:
+     2â†’  id: launch_control_xl3_custom_mode
+     3â†’  title: Novation Launch Control XL3 Custom Mode Format
+     4â†’  file-extension: bin
+     5â†’  endian: be
+     6â†’  license: MIT
+     7â†’  ks-version: 0.11
+     8â†’
+     9â†’doc: |
+    10â†’  Custom mode configuration format for Novation Launch Control XL3.
+    11â†’
+    12â†’  The custom mode data is split across 2 SysEx message pages:
+    13â†’  - Page 0 (SysEx byte 0x00): Mode name + controls 0x10-0x27 (24 controls) + labels
+    14â†’  - Page 1 (SysEx byte 0x03): Mode name + controls 0x28-0x3F (24 controls) + labels
+    15â†’
+    16â†’  Total: 48 controls (0x10-0x3F)
+    17â†’
+    18â†’  Empirically discovered format through MIDI traffic analysis.
+    19â†’
+    20â†’  Version History:
+    21â†’  - v1.6 (2025-10-16): Corrected mode name length limit documentation from 8 to 18 characters
+    22â†’  - v1.5 (2025-10-11): Documented parser bug fix - 0x40 appears as data in minValue field, not as control marker
+    23â†’  - v1.4 (2025-10-09): Corrected to 2 pages (0x00, 0x03), not 3 pages. Updated to reflect working code.
+    24â†’  - v1.3 (2025-09-30): Documented read slot byte behavior for DAW port integration
+    25â†’  - v1.2 (2025-09-30): Added write acknowledgement message format (command 0x15)
+    26â†’  - v1.1 (2025-09-30): Documented write protocol format (command 0x45)
+    27â†’  - v1.0 (2025-09-30): Initial read protocol specification
+    28â†’
+    29â†’seq:
+    30â†’  - id: page_0
+    31â†’    type: custom_mode_page
+    32â†’    doc: First page with mode name and controls 0x10-0x27 (24 controls)
+    33â†’  - id: page_1
+    34â†’    type: custom_mode_page
+    35â†’    doc: Second page with mode name and controls 0x28-0x3F (24 controls)
+    36â†’
+    37â†’types:
+    38â†’  custom_mode_page:
+    39â†’    doc: |
+    40â†’      A single page of custom mode data containing 24 control definitions.
+    41â†’
+    42â†’      Page 0 (SysEx byte 0x00): Controls 0x10-0x27
+    43â†’      Page 1 (SysEx byte 0x03): Controls 0x28-0x3F
+    44â†’
+    45â†’      Both pages contain the mode name (for redundancy/verification).
+    46â†’    seq:
+    47â†’      - id: header
+    48â†’        type: page_header
+    49â†’      - id: mode_name_section
+    50â†’        type: mode_name
+    51â†’        doc: Mode name present in both pages (redundant for verification)
+    52â†’      - id: controls
+    53â†’        type: control_definition
+    54â†’        repeat: expr
+    55â†’        repeat-expr: 24
+    56â†’        doc: 24 control definitions per page (not 16)
+    57â†’      - id: labels
+    58â†’        type: label_section
+    59â†’        size-eos: true
+    60â†’        doc: Variable-length label section
+    61â†’
+    62â†’  page_header:
+    63â†’    seq:
+    64â†’      - id: page_marker
+    65â†’        contents: [0x06, 0x00]
+    66â†’      - id: page_number
+    67â†’        type: u1
+    68â†’        doc: |
+    69â†’          Page number in SysEx message:
+    70â†’          - 0x00 for page 0 (controls 0x10-0x27)
+    71â†’          - 0x03 for page 1 (controls 0x28-0x3F)
+    72â†’      - id: unknown1
+    73â†’        size: 3
+    74â†’
+    75â†’  mode_name:
+    76â†’    seq:
+    77â†’      - id: name_marker
+    78â†’        contents: [0x06, 0x20]
+    79â†’      - id: name_length
+    80â†’        type: u1
+    81â†’        doc: Length of mode name (0-18 characters)
+    82â†’      - id: name_bytes
+    83â†’        size: name_length
+    84â†’        type: str
+    85â†’        encoding: ASCII
+    86â†’        if: name_length > 0
+    87â†’    doc: |
+    88â†’      Mode name format (READ/response):
+    89â†’        06 20 [length] [name_bytes]
+    90â†’
+    91â†’      Mode name format (WRITE/request):
+    92â†’        20 [length] [name_bytes]
+    93â†’
+    94â†’      Discovery: Web editor MIDI capture (2025-09-30)
+    95â†’      Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
+    96â†’
+    97â†’      Note: The device supports mode names up to 18 characters.
+    98â†’      Earlier documentation incorrectly stated 8 characters as the maximum.
+    99â†’
+   100â†’  control_definition:
+   101â†’    doc: |
+   102â†’      11-byte control definition structure found in READ responses.
+   103â†’      Marker byte is always 0x48 (not 0x40, 0x49, or any other value).
+   104â†’
+   105â†’      Note: The min_value field (position +7) may contain 0x40 (decimal 64) as DATA.
+   106â†’      This is not a control marker - it's simply a minValue of 64.
+   107â†’
+   108â†’      WARNING: Parsers must not scan for 0x40 bytes to identify controls.
+   109â†’    seq:
+   110â†’      - id: control_marker
+   111â†’        contents: [0x48]
+   112â†’        doc: Control definition marker (always 0x48 in READ responses)
+   113â†’      - id: control_id
+   114â†’        type: u1
+   115â†’        doc: Hardware control ID (0x10-0x3F)
+   116â†’      - id: def_type
+   117â†’        contents: [0x02]
+   118â†’        doc: Definition type (always 0x02)
+   119â†’      - id: control_type
+   120â†’        type: u1
+   121â†’        doc: Control type (0x00=knob top, 0x05=knob bottom, 0x09=fader, etc)
+   122â†’      - id: midi_channel
+   123â†’        type: u1
+   124â†’        doc: MIDI channel (0-15)
+   125â†’      - id: param1
+   126â†’        type: u1
+   127â†’        doc: Parameter (usually 0x01 or 0x00)
+   128â†’      - id: unknown1
+   129â†’        contents: [0x48]
+   130â†’        doc: Unknown fixed byte (always 0x48)
+   131â†’      - id: min_value
+   132â†’        type: u1
+   133â†’        doc: |
+   134â†’          Minimum value (0-127).
+   135â†’          WARNING: This may be 0x40 (64 decimal) - do NOT interpret as control marker!
+   136â†’      - id: cc_number
+   137â†’        type: u1
+   138â†’        doc: MIDI CC number (0-127)
+   139â†’      - id: max_value
+   140â†’        type: u1
+   141â†’        doc: Maximum value (0-127)
+   142â†’      - id: terminator
+   143â†’        contents: [0x00]
+   144â†’        doc: Terminator byte
+   145â†’
+   146â†’  label_section:
+   147â†’    seq:
+   148â†’      - id: unknown_padding
+   149â†’        size: 3
+   150â†’        doc: Padding bytes before labels
+   151â†’      - id: labels
+   152â†’        type: control_label
+   153â†’        repeat: until
+   154â†’        repeat-until: _io.eof or _.is_terminator
+   155â†’
+   156â†’  control_label:
+   157â†’    doc: |
+   158â†’      Control label with length-encoding scheme.
+   159â†’
+   160â†’      Discovery: Empirical testing (2025-09-30)
+   161â†’      The marker byte (0x60-0x6F) encodes the string length.
+   162â†’
+   163â†’      Length calculation: length = marker_byte - 0x60
+   164â†’
+   165â†’      Examples:
+   166â†’      - 0x60 = 0 characters (empty)
+   167â†’      - 0x65 = 5 characters ("TEST1")
+   168â†’      - 0x69 = 9 characters ("High Pass")
+   169â†’      - 0x6F = 15 characters (maximum)
+   170â†’
+   171â†’      Special control ID mapping:
+   172â†’      - Label IDs 0x19-0x1C (25-28) map to control IDs 26-29 (+1 offset)
+   173â†’      - All other label IDs map directly to control IDs
+   174â†’    seq:
+   175â†’      - id: length_marker
+   176â†’        type: u1
+   177â†’        doc: |
+   178â†’          Marker byte encoding string length (0x60-0x6F).
+   179â†’          Length = marker - 0x60 (0-15 characters).
+   180â†’      - id: control_id
+   181â†’        type: u1
+   182â†’        doc: Control ID this label applies to (0x10-0x3F)
+   183â†’      - id: name_bytes
+   184â†’        size: label_length
+   185â†’        type: str
+   186â†’        encoding: ASCII
+   187â†’        if: label_length > 0
+   188â†’        doc: Label text (ASCII, variable length)
+   189â†’    instances:
+   190â†’      label_length:
+   191â†’        value: length_marker - 0x60
+   192â†’        doc: Calculate label length from marker byte
+   193â†’      is_terminator:
+   194â†’        value: length_marker < 0x60 or control_id < 0x10
+   195â†’        doc: Check if this marks end of labels section
+   196â†’
+   197â†’  write_acknowledgement:
+   198â†’    doc: |
+   199â†’      Write acknowledgement message sent by device after receiving a page write.
+   200â†’
+   201â†’      Complete SysEx format:
+   202â†’        F0 00 20 29 02 15 05 00 15 [page] [status] F7
+   203â†’
+   204â†’      This specification covers the payload after the SysEx header.
+   205â†’
+   206â†’      Discovery: Playwright + CoreMIDI spy (2025-09-30)
+   207â†’      Observed device sending ACK 24-27ms after each page write.
+   208â†’      Web editor waits for ACK before sending next page.
+   209â†’
+   210â†’      Example (Page 0 ACK):
+   211â†’        15 00 06 = Command 0x15, Page 0, Status 0x06 (success)
+   212â†’
+   213â†’      Example (Page 1 ACK):
+   214â†’        15 03 06 = Command 0x15, Page 1, Status 0x06 (success)
+   215â†’    seq:
+   216â†’      - id: command
+   217â†’        contents: [0x15]
+   218â†’        doc: Acknowledgement command byte
+   219â†’      - id: page_number
+   220â†’        type: u1
+   221â†’        doc: |
+   222â†’          Page number being acknowledged:
+   223â†’          - 0x00 for page 0
+   224â†’          - 0x03 for page 1
+   225â†’      - id: status
+   226â†’        type: u1
+   227â†’        enum: ack_status
+   228â†’        doc: Acknowledgement status (0x06 = success)
+   229â†’
+   230â†’enums:
+   231â†’  ack_status:
+   232â†’    0x06: success
+   233â†’    doc: Status codes for write acknowledgements
+   234â†’
+   235â†’  control_behavior:
+   236â†’    0x0C: absolute
+   237â†’    0x0D: relative
+   238â†’    0x0E: toggle
+   239â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Write**
+
+```typescript
+/**
+ * High-level API for building Launch Control XL 3 custom modes
+ * Provides a fluent interface for defining control mappings, labels, and colors
+ */
+
+import type { CustomMode, Control, ControlType } from '@/types/CustomMode.js';
+
+export enum Color {
+  OFF = 0x0C,
+  RED_LOW = 0x0D,
+  RED_FULL = 0x0F,
+  AMBER_LOW = 0x1D,
+  AMBER_FULL = 0x3F,
+  YELLOW = 0x3E,
+  GREEN_LOW = 0x1C,
+  GREEN_FULL = 0x3C
+}
+
+interface ControlConfig {
+  cc: number;
+  channel?: number;
+  min?: number;
+  max?: number;
+}
+
+interface LabelColorData {
+  labels: Map<number, string>;
+  colors: Map<number, Color>;
+}
+
+/**
+ * Builder for creating Launch Control XL 3 custom modes
+ * Provides a fluent API for defining controls, labels, and colors
+ */
+export class CustomModeBuilder {
+  private modeName: string = '';
+  private controls: Control[] = [];
+  private labelData: LabelColorData = {
+    labels: new Map(),
+    colors: new Map()
+  };
+
+  /**
+   * Set the custom mode name (max 18 characters)
+   */
+  name(name: string): this {
+    if (name.length > 18) {
+      throw new Error('Mode name must be 18 characters or less');
+    }
+    this.modeName = name;
+    return this;
+  }
+
+  /**
+   * Add a fader control mapping
+   * @param faderNumber 1-8
+   * @param config Control configuration
+   */
+  addFader(faderNumber: number, config: ControlConfig): this {
+    if (faderNumber < 1 || faderNumber > 8) {
+      throw new Error('Fader number must be 1-8');
+    }
+
+    const controlId = 0x28 + (faderNumber - 1); // 0x28-0x2F
+    this.addControl(controlId, 0x09, config);
+    return this;
+  }
+
+  /**
+   * Add a top row encoder control mapping
+   * @param row 1 (always 1 for top row)
+   * @param encoderNumber 1-8
+   * @param config Control configuration
+   */
+  addEncoder(row: 1, encoderNumber: number, config: ControlConfig): this;
+  /**
+   * Add a middle row encoder control mapping
+   * @param row 2 (for middle row)
+   * @param encoderNumber 1-8
+   * @param config Control configuration
+   */
+  addEncoder(row: 2, encoderNumber: number, config: ControlConfig): this;
+  /**
+   * Add a bottom row encoder control mapping
+   * @param row 3 (for bottom row)
+   * @param encoderNumber 1-8
+   * @param config Control configuration
+   */
+  addEncoder(row: 3, encoderNumber: number, config: ControlConfig): this;
+  addEncoder(row: 1 | 2 | 3, encoderNumber: number, config: ControlConfig): this {
+    if (encoderNumber < 1 || encoderNumber > 8) {
+      throw new Error('Encoder number must be 1-8');
+    }
+
+    let controlId: number;
+    let controlType: ControlType;
+
+    switch (row) {
+      case 1: // Top row
+        controlId = 0x10 + (encoderNumber - 1); // 0x10-0x17
+        controlType = 0x05;
+        break;
+      case 2: // Middle row
+        controlId = 0x18 + (encoderNumber - 1); // 0x18-0x1F
+        controlType = 0x09;
+        break;
+      case 3: // Bottom row
+        controlId = 0x20 + (encoderNumber - 1); // 0x20-0x27
+        controlType = 0x0D;
+        break;
+      default:
+        throw new Error('Row must be 1, 2, or 3');
+    }
+
+    this.addControl(controlId, controlType, config);
+    return this;
+  }
+
+  /**
+   * Add a side button control mapping (track focus buttons)
+   * @param buttonNumber 1-8
+   * @param config Control configuration
+   */
+  addSideButton(buttonNumber: number, config: ControlConfig): this {
+    if (buttonNumber < 1 || buttonNumber > 8) {
+      throw new Error('Side button number must be 1-8');
+    }
+
+    const controlId = 0x30 + (buttonNumber - 1); // 0x30-0x37
+    this.addControl(controlId, 0x19, config);
+    return this;
+  }
+
+  /**
+   * Add a bottom button control mapping
+   * @param buttonNumber 1-16
+   * @param config Control configuration
+   */
+  addBottomButton(buttonNumber: number, config: ControlConfig): this {
+    if (buttonNumber < 1 || buttonNumber > 16) {
+      throw new Error('Bottom button number must be 1-16');
+    }
+
+    const controlId = 0x30 + (buttonNumber - 1); // 0x30-0x3F
+    this.addControl(controlId, 0x25, config);
+    return this;
+  }
+
+  /**
+   * Add a label for a control
+   * @param controlId The hardware control ID (or use helper methods)
+   * @param label The label text
+   */
+  addLabel(controlId: number, label: string): this {
+    this.labelData.labels.set(controlId, label);
+    return this;
+  }
+
+  /**
+   * Add a label for a fader
+   * @param faderNumber 1-8
+   * @param label The label text
+   */
+  addFaderLabel(faderNumber: number, label: string): this {
+    if (faderNumber < 1 || faderNumber > 8) {
+      throw new Error('Fader number must be 1-8');
+    }
+    return this.addLabel(0x28 + (faderNumber - 1), label);
+  }
+
+  /**
+   * Add a label for an encoder
+   * @param row 1, 2, or 3
+   * @param encoderNumber 1-8
+   * @param label The label text
+   */
+  addEncoderLabel(row: 1 | 2 | 3, encoderNumber: number, label: string): this {
+    if (encoderNumber < 1 || encoderNumber > 8) {
+      throw new Error('Encoder number must be 1-8');
+    }
+
+    let controlId: number;
+    switch (row) {
+      case 1:
+        controlId = 0x10 + (encoderNumber - 1);
+        break;
+      case 2:
+        controlId = 0x18 + (encoderNumber - 1);
+        break;
+      case 3:
+        controlId = 0x20 + (encoderNumber - 1);
+        break;
+      default:
+        throw new Error('Row must be 1, 2, or 3');
+    }
+
+    return this.addLabel(controlId, label);
+  }
+
+  /**
+   * Add a color for a control
+   * @param controlId The hardware control ID
+   * @param color The color value
+   */
+  addColor(controlId: number, color: Color): this {
+    this.labelData.colors.set(controlId, color);
+    return this;
+  }
+
+  /**
+   * Add a color for a side button
+   * @param buttonNumber 1-8
+   * @param color The color value
+   */
+  addSideButtonColor(buttonNumber: number, color: Color): this {
+    if (buttonNumber < 1 || buttonNumber > 8) {
+      throw new Error('Side button number must be 1-8');
+    }
+    return this.addColor(0x30 + (buttonNumber - 1), color);
+  }
+
+  /**
+   * Add a color for a bottom button
+   * @param buttonNumber 1-16
+   * @param color The color value
+   */
+  addBottomButtonColor(buttonNumber: number, color: Color): this {
+    if (buttonNumber < 1 || buttonNumber > 16) {
+      throw new Error('Bottom button number must be 1-16');
+    }
+    return this.addColor(0x30 + (buttonNumber - 1), color);
+  }
+
+  /**
+   * Build the custom mode object
+   */
+  build(): CustomMode {
+    if (!this.modeName) {
+      throw new Error('Mode name is required');
+    }
+
+    if (this.controls.length === 0) {
+      throw new Error('At least one control mapping is required');
+    }
+
+    // Convert controls array to Record for CustomMode interface
+    const controlsRecord: Record<string, any> = {};
+    for (const control of this.controls) {
+      controlsRecord[`control_${control.controlId}`] = control;
+    }
+
+    return {
+      name: this.modeName,
+      controls: controlsRecord,
+      labels: this.labelData.labels,
+      colors: this.labelData.colors
+    };
+  }
+
+  /**
+   * Create a builder pre-configured for a simple test mode
+   */
+  static createTestMode(): CustomModeBuilder {
+    return new CustomModeBuilder()
+      .name('TEST')
+      .addFader(1, { cc: 10, channel: 1 })
+      .addEncoder(1, 1, { cc: 13, channel: 1 })
+      .addEncoderLabel(1, 1, 'Filter')
+      .addFaderLabel(1, 'Volume');
+  }
+
+  /**
+   * Create a builder pre-configured for the CHANNEV mode
+   */
+  static createChannevMode(): CustomModeBuilder {
+    const builder = new CustomModeBuilder().name('CHANNEV');
+
+    // Top row encoders (CC 13-20)
+    for (let i = 1; i <= 8; i++) {
+      builder.addEncoder(1, i, { cc: 12 + i, channel: 1 });
+    }
+
+    // Middle row encoders (CC 21-28)
+    for (let i = 1; i <= 8; i++) {
+      builder.addEncoder(2, i, { cc: 20 + i, channel: 1 });
+    }
+
+    // Bottom row encoders (CC 29-36)
+    for (let i = 1; i <= 8; i++) {
+      builder.addEncoder(3, i, { cc: 28 + i, channel: 1 });
+    }
+
+    // Add labels for key controls
+    builder
+      .addEncoderLabel(1, 1, 'Mic Gain')
+      .addEncoderLabel(1, 2, 'Line Amp Gain')
+      .addEncoderLabel(1, 4, 'Low Pass')
+      .addEncoderLabel(2, 1, 'High Shelf')
+      .addEncoderLabel(2, 2, 'Low Freq')
+      .addEncoderLabel(2, 3, 'Low Mid Freq')
+      .addEncoderLabel(2, 4, 'High Mid Freq')
+      .addEncoderLabel(2, 5, 'High Freq')
+      .addEncoderLabel(3, 1, 'Low Shelf')
+      .addEncoderLabel(3, 2, 'Low Gain')
+      .addEncoderLabel(3, 3, 'Low Mid Gain')
+      .addEncoderLabel(3, 4, 'High Mid Gain')
+      .addEncoderLabel(3, 5, 'High Gain');
+
+    return builder;
+  }
+
+  private addControl(controlId: number, controlType: ControlType, config: ControlConfig): void {
+    // Check for duplicate control
+    if (this.controls.find(c => c.controlId === controlId)) {
+      throw new Error(`Control ${controlId.toString(16)} already defined`);
+    }
+
+    // Validate CC range
+    if (config.cc < 0 || config.cc > 127) {
+      throw new Error('CC number must be 0-127');
+    }
+
+    // Validate channel
+    const channel = config.channel ?? 1;
+    if (channel < 1 || channel > 16) {
+      throw new Error('MIDI channel must be 1-16');
+    }
+
+    const control: Control = {
+      controlId,
+      controlType,
+      midiChannel: channel - 1, // Convert to 0-based
+      ccNumber: config.cc,
+      minValue: config.min ?? 0,
+      maxValue: config.max ?? 127,
+      behavior: 'absolute'
+    };
+
+    this.controls.push(control);
+  }
+}
+
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I need to verify the .ksy file was updated and then update the PROTOCOL.md file. Let me verify:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify .ksy file exists and check size
+
+`ls -la /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify version history was updated in .ksy
+
+`head -30 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy | grep -A 5 "Version History"`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify mode_name section shows 0-18 characters
+
+`sed -n '75,99p' /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy`
+
+Result:
+
+```
+-rw-r--r--@ 1 orion  staff  7343 Oct 16 20:42 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy
+```
+
+Result:
+
+```
+Version History:
+  - v1.6 (2025-10-16): Corrected mode name length limit documentation from 8 to 18 characters
+  - v1.5 (2025-10-11): Documented parser bug fix - 0x40 appears as data in minValue field, not as control marker
+  - v1.4 (2025-10-09): Corrected to 2 pages (0x00, 0x03), not 3 pages. Updated to reflect working code.
+  - v1.3 (2025-09-30): Documented read slot byte behavior for DAW port integration
+  - v1.2 (2025-09-30): Added write acknowledgement message format (command 0x15)
+```
+
+Result:
+
+```
+mode_name:
+    seq:
+      - id: name_marker
+        contents: [0x06, 0x20]
+      - id: name_length
+        type: u1
+        doc: Length of mode name (0-18 characters)
+      - id: name_bytes
+        size: name_length
+        type: str
+        encoding: ASCII
+        if: name_length > 0
+    doc: |
+      Mode name format (READ/response):
+        06 20 [length] [name_bytes]
+
+      Mode name format (WRITE/request):
+        20 [length] [name_bytes]
+
+      Discovery: Web editor MIDI capture (2025-09-30)
+      Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
+
+      Note: The device supports mode names up to 18 characters.
+      Earlier documentation incorrectly stated 8 characters as the maximum.
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! The .ksy file has been updated correctly. Now I need to update the PROTOCOL.md file. Let me search for all references to "8 char" or "8 characters" related to mode names:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Search for 8-character references in PROTOCOL.md
+
+`grep -n "8 char\|8-char\|max 8" /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+Result:
+
+```
+416:      â””â”€ length = 8 chars
+449:  name: "MODE_NAME",  // String, max 8 characters
+528:â””â”€ Marker 0x68 = 8 chars
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now let me read the PROTOCOL.md file and update all references:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** View context around line 416
+
+`sed -n '405,420p' /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** View context around line 449
+
+`sed -n '445,455p' /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** View context around line 528
+
+`sed -n '520,535p' /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+Result:
+
+```
+**Format:** `06 20 [length] [name_bytes...]`
+
+- `06 20` - Fixed marker
+- `length` - Number of characters (0-8)
+- `name_bytes` - ASCII characters
+
+**Example:**
+\```
+06 20 08 43 48 41 4E 4E 45 56 45
+      â†‘  C  H  A  N  N  E  V  E
+      â””â”€ length = 8 chars
+\```
+
+### Control Label Encoding
+```
+
+Result:
+
+```
+### Array Format (Legacy/Fallback)
+\```javascript
+{
+  name: "MODE_NAME",  // String, max 8 characters
+  controls: [
+    {
+      controlId: 0x10,       // number: 0x10-0x3F main controls, 0x68-0x6F side buttons
+      channel: 0,            // number: 0-15
+      ccNumber: 13,          // number: 0-127
+      minValue: 0,           // number: 0-127 (optional)
+```
+
+Result:
+
+```
+### Example 4: Control ID Mapping Exception
+
+Label with control ID 0x19 (25) maps to actual control ID 26:
+
+\```
+68 19 4C 6F 77 20 46 72 65 71
+â”‚  â”‚  L  o  w     F  r  e  q
+â”‚  â””â”€ Label ID 0x19 â†’ maps to control 26
+â””â”€ Marker 0x68 = 8 chars
+\```
+
+**Mapping rule:**
+\```typescript
+function mapLabelControlId(labelId: number): number {
+  if (labelId >= 25 && labelId <= 28) {
+    return labelId + 1;  // Labels 25-28 â†’ controls 26-29
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I'll read the entire PROTOCOL.md file and update all occurrences:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./docs/PROTOCOL.md`
+
+Result:
+
+```
+1â†’# Launch Control XL3 Protocol Specification
+     2â†’
+     3â†’**Version:** 2.0
+     4â†’**Last Updated:** 2025-10-16
+     5â†’**Status:** Verified with hardware
+     6â†’
+     7â†’## Overview
+     8â†’
+     9â†’The Launch Control XL3 communicates via MIDI SysEx messages. Custom modes are fetched and stored using a multi-page protocol with slot selection via SysEx slot byte parameter.
+    10â†’
+    11â†’## Table of Contents
+    12â†’
+    13â†’- [Quick Reference](#quick-reference)
+    14â†’- [Custom Mode Fetch Protocol](#custom-mode-fetch-protocol)
+    15â†’- [Custom Mode Write Protocol](#custom-mode-write-protocol)
+    16â†’- [Data Structures](#data-structures)
+    17â†’- [Parsed Response Format](#parsed-response-format)
+    18â†’- [Examples](#examples)
+    19â†’- [Discovery Methodology](#discovery-methodology)
+    20â†’
+    21â†’---
+    22â†’
+    23â†’## Quick Reference
+    24â†’
+    25â†’**Canonical Protocol Specification:** See [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+    26â†’
+    27â†’The `.ksy` file is a Kaitai Struct specification that defines the **exact byte layout** of all protocol structures. It serves as:
+    28â†’- Formal specification (unambiguous binary format)
+    29â†’- Documentation (declarative, human-readable)
+    30â†’- Validation tool (can verify parser correctness)
+    31â†’- Version control (tracks protocol changes)
+    32â†’
+    33â†’**Note:** The library uses a hand-written parser in `SysExParser.ts` (90 lines, highly readable). The `.ksy` file serves as formal documentation, not for code generation.
+    34â†’
+    35â†’**Why .ksy?** It eliminates ambiguity. Instead of prose like "a length byte followed by name bytes", the spec states:
+    36â†’\```yaml
+    37â†’- id: name_length
+    38â†’  type: u1
+    39â†’- id: name_bytes
+    40â†’  size: name_length
+    41â†’  type: str
+    42â†’  encoding: ASCII
+    43â†’\```
+    44â†’
+    45â†’---
+    46â†’
+    47â†’## Custom Mode Fetch Protocol
+    48â†’
+    49â†’### High-Level Flow
+    50â†’
+    51â†’1. **Device Handshake** (4-message sequence)
+    52â†’   - Client sends SYN
+    53â†’   - Device responds with SYN-ACK containing serial number
+    54â†’   - Client sends Universal Device Inquiry (ACK)
+    55â†’   - Device responds with device info
+    56â†’
+    57â†’2. **Slot Selection** (via SysEx slot byte parameter)
+    58â†’   - Simply include the target slot number (0-14) in the SysEx read request
+    59â†’   - Slot 15 (0x0F) is reserved for immutable factory content and cannot be read or written
+    60â†’
+    61â†’3. **Mode Fetch** (2 SysEx pages)
+    62â†’   - Request page 0 (controls 0x10-0x27 + mode name + labels)
+    63â†’   - Request page 1 (controls 0x28-0x3F + mode name + labels)
+    64â†’
+    65â†’### Read Request Format
+    66â†’
+    67â†’**SysEx Read Request:**
+    68â†’\```
+    69â†’F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7
+    70â†’\```
+    71â†’
+    72â†’Where:
+    73â†’- `F0` = SysEx start
+    74â†’- `00 20 29` = Novation manufacturer ID
+    75â†’- `02` = Device ID (Launch Control XL 3)
+    76â†’- `15` = Command (Custom mode)
+    77â†’- `05` = Sub-command
+    78â†’- `00` = Reserved
+    79â†’- `40` = Read operation
+    80â†’- `[PAGE]` = Page byte (0x00 for page 0, 0x03 for page 1)
+    81â†’- `[SLOT]` = Slot number (0-14) - Slot 15 (0x0F) is reserved and immutable
+    82â†’- `F7` = SysEx end
+    83â†’
+    84â†’**Page byte mapping:**
+    85â†’- Logical page 0 â†’ SysEx page byte 0x00
+    86â†’- Logical page 1 â†’ SysEx page byte 0x03
+    87â†’
+    88â†’**Discovery Method:** Empirical testing (2025-10-01). The SysEx slot byte parameter directly selects the target slot without requiring DAW port protocol.
+    89â†’
+    90â†’**Implementation:** See `SysExParser.buildCustomModeReadRequest(slot, page)` at line 966-994 in `src/core/SysExParser.ts`.
+    91â†’
+    92â†’### READ Response Format
+    93â†’
+    94â†’READ responses use **only `0x48` control definition markers**. Each control is defined by an 11-byte structure:
+    95â†’
+    96â†’\```
+    97â†’Position:  0    1          2        3       4        5       6       7         8         9        10
+    98â†’Bytes:     0x48 controlId  0x02     type    channel  param1  0x48    minValue  ccNumber  maxValue  0x00
+    99â†’\```
+   100â†’
+   101â†’**Important:** The byte `0x40` may appear at position +7 as the `minValue` field. This is **data, not a control marker**.
+   102â†’Do not scan for `0x40` bytes to identify controls.
+   103â†’
+   104â†’**Example:**
+   105â†’A control with minValue=64 (0x40) will have `0x40` at byte position +7, immediately before the CC number.
+   106â†’
+   107â†’### Multi-Page Structure
+   108â†’
+   109â†’Custom mode data is split across **2 SysEx response pages** due to MIDI message size limits:
+   110â†’
+   111â†’| Logical Page | SysEx Page Byte | Controls | Contains Mode Name? | Label Control IDs |
+   112â†’|--------------|-----------------|----------|---------------------|-------------------|
+   113â†’| 0            | 0x00            | 0x10-0x27 (24 controls) | Yes (both pages) | 0x10-0x27 |
+   114â†’| 1            | 0x03            | 0x28-0x3F (24 controls) | Yes (both pages) | 0x28-0x3F |
+   115â†’
+   116â†’**Total: 48 controls** (0x10-0x3F)
+   117â†’
+   118â†’Each page follows the same structure defined in `launch_control_xl3.ksy`.
+   119â†’
+   120â†’**Discovery Method:** MIDI spy capture (2025-10-01) - Web editor slot fetch revealed page bytes 0x00 and 0x03.
+   121â†’
+   122â†’**Important:** Pages are fetched **sequentially**, not in parallel. Send page 0 request, wait for response, then send page 1 request. See `DeviceManager.readCustomMode()` at line 621-780.
+   123â†’
+   124â†’---
+   125â†’
+   126â†’## Custom Mode Write Protocol
+   127â†’
+   128â†’### Overview
+   129â†’
+   130â†’Writing a custom mode to the device uses command `0x45` with a multi-page protocol and acknowledgement handshake.
+   131â†’
+   132â†’**Discovery Method:** Web editor MIDI traffic capture using CoreMIDI spy (2025-09-30)
+   133â†’
+   134â†’### Write Flow with Acknowledgements
+   135â†’
+   136â†’**Critical Discovery (2025-09-30):** The device sends acknowledgement SysEx messages after receiving each page. The client MUST wait for these acknowledgements before sending the next page.
+   137â†’
+   138â†’**Complete Write Sequence:**
+   139â†’1. Send page 0 write command (`0x45 00`)
+   140â†’2. **Wait for device acknowledgement** (`0x15 00 [SLOT_STATUS]`)
+   141â†’3. Send page 1 write command (`0x45 03`)
+   142â†’4. **Wait for device acknowledgement** (`0x15 03 [SLOT_STATUS]`)
+   143â†’
+   144â†’**Timing:** Device typically responds within 24-27ms. Web editor waits for acknowledgement before proceeding.
+   145â†’
+   146â†’**Discovery Method:** Playwright browser automation + CoreMIDI spy, observing [DEST] and [SRC] traffic during web editor write operations.
+   147â†’
+   148â†’### Critical Discovery: Write Acknowledgement Status Byte is Slot Identifier (VERIFIED)
+   149â†’
+   150â†’**Discovery Date:** 2025-10-16
+   151â†’**Verification Date:** 2025-10-16
+   152â†’
+   153â†’**The Problem:** Previous implementations incorrectly interpreted the "status" byte in write acknowledgement messages as a success/failure indicator, checking for `status === 0x06`. This caused writes to all slots except slot 0 to fail.
+   154â†’
+   155â†’**The Reality:** The acknowledgement "status" byte is actually the **SLOT IDENTIFIER** encoded using the CC 30 slot encoding pattern.
+   156â†’
+   157â†’**Acknowledgement Response Format:**
+   158â†’\```
+   159â†’F0 00 20 29 02 15 05 00 15 [page] [SLOT_STATUS] F7
+   160â†’â”‚                       â”‚  â”‚  â”‚  â””â”€ Slot identifier (NOT success/failure!)
+   161â†’â”‚                       â”‚  â”‚  â””â”€ Page number acknowledged
+   162â†’â”‚                       â”‚  â””â”€ Acknowledgement command
+   163â†’â”‚                       â””â”€ Command group
+   164â†’\```
+   165â†’
+   166â†’**Slot Encoding Pattern (CC 30 Protocol):**
+   167â†’
+   168â†’The slot identifier follows the same encoding used in CC 30 slot selection messages:
+   169â†’
+   170â†’| Slot | Status Byte | Calculation |
+   171â†’|------|-------------|-------------|
+   172â†’| 0    | 0x06        | 0x06 + 0    |
+   173â†’| 1    | 0x07        | 0x06 + 1    |
+   174â†’| 2    | 0x08        | 0x06 + 2    |
+   175â†’| 3    | 0x09        | 0x06 + 3    |
+   176â†’| 4    | 0x12        | 0x0E + 4    |
+   177â†’| 5    | 0x13        | 0x0E + 5    |
+   178â†’| 6    | 0x14        | 0x0E + 6    |
+   179â†’| 7    | 0x15        | 0x0E + 7    |
+   180â†’| 8    | 0x16        | 0x0E + 8    |
+   181â†’| 9    | 0x17        | 0x0E + 9    |
+   182â†’| 10   | 0x18        | 0x0E + 10   |
+   183â†’| 11   | 0x19        | 0x0E + 11   |
+   184â†’| 12   | 0x1A        | 0x0E + 12   |
+   185â†’| 13   | 0x1B        | 0x0E + 13   |
+   186â†’| 14   | 0x1C        | 0x0E + 14   |
+   187â†’
+   188â†’**Pattern:**
+   189â†’- Slots 0-3: `0x06 + slot`
+   190â†’- Slots 4-14: `0x0E + slot`
+   191â†’
+   192â†’**Evidence from Raw MIDI Tests:**
+   193â†’
+   194â†’Testing with `utils/test-round-trip-validation.ts` revealed the following acknowledgement responses:
+   195â†’
+   196â†’\```
+   197â†’Write to slot 0, page 0:
+   198â†’F0 00 20 29 02 15 05 00 15 00 06 F7
+   199â†’                              â†‘
+   200â†’                              0x06 = slot 0
+   201â†’
+   202â†’Write to slot 1, page 0:
+   203â†’F0 00 20 29 02 15 05 00 15 00 07 F7
+   204â†’                              â†‘
+   205â†’                              0x07 = slot 1
+   206â†’
+   207â†’Write to slot 3, page 0:
+   208â†’F0 00 20 29 02 15 05 00 15 00 09 F7
+   209â†’                              â†‘
+   210â†’                              0x09 = slot 3
+   211â†’
+   212â†’Write to slot 5, page 0:
+   213â†’F0 00 20 29 02 15 05 00 15 00 13 F7
+   214â†’                              â†‘
+   215â†’                              0x13 = slot 5 (0x0E + 5)
+   216â†’\```
+   217â†’
+   218â†’**Verification Evidence (2025-10-16):**
+   219â†’
+   220â†’Test run with `utils/test-valid-mode-changes.ts` successfully wrote to slot 3 and verified:
+   221â†’- âœ… **Write successful** - No firmware rejection
+   222â†’- âœ… **Control CC numbers persisted correctly** - All 5 test controls changed from (13,14,15,16,17) to (23,24,25,26,27)
+   223â†’- âœ… **Control channels persisted correctly** - All channel values verified
+   224â†’- âœ… **Issue #36 RESOLVED** - The problem was library bug, not firmware rejection
+   225â†’- âœ… **10/11 changes verified successfully** (see Known Issues for mode name limitation)
+   226â†’
+   227â†’**Implications:**
+   228â†’
+   229â†’1. **Success Determination:** The acknowledgement itself indicates success. If the device sends an acknowledgement, the write was accepted.
+   230â†’
+   231â†’2. **Slot Validation:** The status byte can be used to verify the write targeted the expected slot:
+   232â†’   \```typescript
+   233â†’   function verifySlotAcknowledgement(slot: number, statusByte: number): boolean {
+   234â†’     const expectedStatus = slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   235â†’     return statusByte === expectedStatus;
+   236â†’   }
+   237â†’   \```
+   238â†’
+   239â†’3. **Failure Detection:** If no acknowledgement arrives within timeout (typically 24-27ms, up to 100ms conservative), the write failed.
+   240â†’
+   241â†’**Discovery Method:**
+   242â†’- Raw MIDI testing with `utils/test-round-trip-validation.ts` (2025-10-16)
+   243â†’- Systematic writes to multiple slots (0, 1, 3, 5) with acknowledgement capture
+   244â†’- Byte pattern analysis revealing CC 30 encoding scheme
+   245â†’
+   246â†’**Bug Fixed:** Issue #36 - DeviceManager.ts line 448-451 was rejecting all acknowledgements except `0x06`, causing writes to slots 1-14 to fail. Correct implementation should verify slot encoding or simply accept any acknowledgement as success.
+   247â†’
+   248â†’### Multi-Page Write Protocol
+   249â†’
+   250â†’Custom modes require **TWO pages** to be written:
+   251â†’
+   252â†’| Logical Page | SysEx Page Byte | Control IDs | Contains Mode Name? |
+   253â†’|--------------|-----------------|-------------|---------------------|
+   254â†’| 0            | 0x00            | 0x10-0x27 (16-39) | Yes |
+   255â†’| 1            | 0x03            | 0x28-0x3F (40-63) | Yes |
+   256â†’
+   257â†’**Note:** Control IDs 0x00-0x0F do not exist on the device hardware. Only IDs 0x10-0x3F (48 controls total).
+   258â†’
+   259â†’### SysEx Message Format
+   260â†’
+   261â†’**Write Command:**
+   262â†’\```
+   263â†’F0 00 20 29 02 15 05 00 45 [page] 00 [mode_data] F7
+   264â†’â”‚  â””â”€ Novation ID       â”‚  â”‚  â”‚  â””â”€ Write command
+   265â†’â”‚                       â”‚  â”‚  â””â”€ Sub-command
+   266â†’â”‚                       â”‚  â””â”€ Command (Custom mode)
+   267â†’â”‚                       â””â”€ Device ID
+   268â†’â””â”€ SysEx start
+   269â†’\```
+   270â†’
+   271â†’**Key Differences from Read Protocol:**
+   272â†’- Command byte: `0x45` (write) vs `0x40` (read request) / `0x10` (read response)
+   273â†’- Page byte followed by `0x00` flag
+   274â†’- Mode name format: `20 [length] [bytes]` (no `06` prefix)
+   275â†’- **Requires waiting for acknowledgements between pages**
+   276â†’
+   277â†’### Slot Selection for Writes
+   278â†’
+   279â†’Slot selection is handled by the SysEx slot byte parameter. Simply include the target slot number (0-14) when constructing the write request.
+   280â†’
+   281â†’**No DAW port protocol required.** Earlier protocol versions incorrectly assumed DAW port was mandatory. Empirical testing confirmed the SysEx slot byte works independently.
+   282â†’
+   283â†’See `DeviceManager.writeCustomMode()` at line 785-878 for implementation.
+   284â†’
+   285â†’### Mode Name Encoding
+   286â†’
+   287â†’**Write format:**
+   288â†’\```
+   289â†’20 [length] [name_bytes...]
+   290â†’\```
+   291â†’
+   292â†’**Example:**
+   293â†’\```
+   294â†’20 08 43 48 41 4E 54 45 53 54
+   295â†’â”‚  â”‚  â””â”€ "CHANTEST" (8 ASCII bytes)
+   296â†’â”‚  â””â”€ Length (8)
+   297â†’â””â”€ Prefix
+   298â†’\```
+   299â†’
+   300â†’**Read format (for comparison):**
+   301â†’\```
+   302â†’06 20 [length] [name_bytes...]
+   303â†’\```
+   304â†’
+   305â†’**Discovery:** By comparing MIDI captures of web editor write operations with different mode names:
+   306â†’1. Captured write with "CHANNEVE": `20 08 43 48 41 4E 4E 45 56 45`
+   307â†’2. Captured write with "CHANTEST": `20 08 43 48 41 4E 54 45 53 54`
+   308â†’3. Pattern identified: `0x20` prefix, length byte, raw ASCII
+   309â†’
+   310â†’**Validation:** 2025-09-30 - Verified with Novation Components web editor v1.60.0
+   311â†’
+   312â†’### Known Issue: Mode Name Truncation
+   313â†’
+   314â†’**Discovery Date:** 2025-10-16
+   315â†’
+   316â†’**Observation:** Mode names written to the device may be truncated on read-back.
+   317â†’
+   318â†’**Test Evidence:**
+   319â†’- Written name: "TESTMOD" (7 characters)
+   320â†’- Read-back name: "M" (1 character!)
+   321â†’
+   322â†’**Hypothesis:**
+   323â†’1. The mode name field may have an undocumented length limit
+   324â†’2. There may be a serialization bug in the name field
+   325â†’3. The device firmware may truncate/modify mode names in specific ways
+   326â†’
+   327â†’**Impact:** Mode name verification in round-trip tests cannot reliably confirm name persistence.
+   328â†’
+   329â†’**Status:** Under investigation. This does not affect control data persistence, which is verified to work correctly.
+   330â†’
+   331â†’### Example: Complete Write Sequence with Acknowledgements
+   332â†’
+   333â†’**Captured from web editor (2025-09-30 at 37:06):**
+   334â†’
+   335â†’\```
+   336â†’37:06.052  [â†’ Device] Page 0 Write
+   337â†’F0 00 20 29 02 15 05 00 45 00 00 20 08 43 48 41 4E 4E 45 56 45 ...
+   338â†’                           â”‚  â”‚  â”‚  Mode name: "CHANNEVE"
+   339â†’                           â”‚  â”‚  â””â”€ Flag 0x00
+   340â†’                           â”‚  â””â”€ Page 0 (SysEx byte 0x00)
+   341â†’                           â””â”€ Write command 0x45
+   342â†’
+   343â†’37:06.079  [â† Device] Page 0 Acknowledgement (27ms later)
+   344â†’F0 00 20 29 02 15 05 00 15 00 06 F7
+   345â†’                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+   346â†’                           â”‚  â””â”€ Page 0 acknowledged
+   347â†’                           â””â”€ Acknowledgement command 0x15
+   348â†’
+   349â†’37:06.079  [â†’ Device] Page 1 Write (sent immediately after ACK)
+   350â†’F0 00 20 29 02 15 05 00 45 03 00 20 08 43 48 41 4E 4E 45 56 45 ...
+   351â†’                           â”‚  â”‚
+   352â†’                           â”‚  â””â”€ Flag 0x00
+   353â†’                           â””â”€ Page 1 (SysEx byte 0x03)
+   354â†’
+   355â†’37:06.103  [â† Device] Page 1 Acknowledgement (24ms later)
+   356â†’F0 00 20 29 02 15 05 00 15 03 06 F7
+   357â†’                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+   358â†’                           â”‚  â””â”€ Page 1 acknowledged
+   359â†’                           â””â”€ Acknowledgement command 0x15
+   360â†’\```
+   361â†’
+   362â†’**Key Observations:**
+   363â†’- Web editor waits for acknowledgement before sending next page
+   364â†’- Acknowledgements arrive 24-27ms after write command
+   365â†’- Status byte matches slot identifier (0x06 for slot 0)
+   366â†’- Page number in acknowledgement matches write command page number
+   367â†’
+   368â†’---
+   369â†’
+   370â†’## Data Structures
+   371â†’
+   372â†’### Page Structure
+   373â†’
+   374â†’\```
+   375â†’[Page Header]
+   376â†’[Mode Name Section]  â† Only in page 0
+   377â†’[16Ã— Control Definitions]
+   378â†’[Label Section]
+   379â†’\```
+   380â†’
+   381â†’**See [`launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy) types:**
+   382â†’- `custom_mode_page` - Complete page structure
+   383â†’- `page_header` - Fixed 5-byte header
+   384â†’- `mode_name` - Variable-length name (page 0 only)
+   385â†’- `control_definition` - 7-byte control spec
+   386â†’- `label_section` - Variable-length labels
+   387â†’
+   388â†’### Control Definition (7 bytes)
+   389â†’
+   390â†’Each control is defined by exactly 7 bytes:
+   391â†’
+   392â†’\```
+   393â†’Offset | Type | Field        | Values
+   394â†’-------|------|--------------|------------------
+   395â†’0      | u1   | control_type | 0x00, 0x05, 0x09, 0x0D, 0x19, 0x25
+   396â†’1      | u1   | control_id   | 0x10-0x3F (16-63)
+   397â†’2      | u1   | midi_channel | 0-15
+   398â†’3      | u1   | cc_number    | 0-127
+   399â†’4      | u1   | min_value    | Usually 0
+   400â†’5      | u1   | max_value    | Usually 127
+   401â†’6      | u1   | behavior     | 0x0C=absolute, 0x0D=relative, 0x0E=toggle
+   402â†’\```
+   403â†’
+   404â†’### Mode Name Encoding
+   405â†’
+   406â†’**Format:** `06 20 [length] [name_bytes...]`
+   407â†’
+   408â†’- `06 20` - Fixed marker
+   409â†’- `length` - Number of characters (0-8)
+   410â†’- `name_bytes` - ASCII characters
+   411â†’
+   412â†’**Example:**
+   413â†’\```
+   414â†’06 20 08 43 48 41 4E 4E 45 56 45
+   415â†’      â†‘  C  H  A  N  N  E  V  E
+   416â†’      â””â”€ length = 8 chars
+   417â†’\```
+   418â†’
+   419â†’### Control Label Encoding
+   420â†’
+   421â†’**Critical Discovery:** Labels use **length-encoding** where the marker byte encodes the string length.
+   422â†’
+   423â†’**Format:** `[0x60 + length] [control_id] [name_bytes...] [next_marker]`
+   424â†’
+   425â†’The marker byte range `0x60-0x6F` allows strings of 0-15 characters:
+   426â†’- `0x60` = empty string (0 chars)
+   427â†’- `0x65` = 5-character string
+   428â†’- `0x69` = 9-character string
+   429â†’- `0x6F` = 15-character string (maximum)
+   430â†’
+   431â†’**Length calculation:**
+   432â†’\```
+   433â†’length = marker_byte - 0x60
+   434â†’\```
+   435â†’
+   436â†’**Control ID Mapping:**
+   437â†’- Most label control IDs map directly to control IDs
+   438â†’- **Exception:** Label IDs 0x19-0x1C (25-28) map to control IDs 26-29 (+1 offset)
+   439â†’
+   440â†’---
+   441â†’
+   442â†’## Parsed Response Format (JavaScript/TypeScript)
+   443â†’
+   444â†’After SysEx parsing, the `DeviceManager.readCustomMode()` returns data in one of two formats:
+   445â†’
+   446â†’### Array Format (Legacy/Fallback)
+   447â†’\```javascript
+   448â†’{
+   449â†’  name: "MODE_NAME",  // String, max 8 characters
+   450â†’  controls: [
+   451â†’    {
+   452â†’      controlId: 0x10,       // number: 0x10-0x3F main controls, 0x68-0x6F side buttons
+   453â†’      channel: 0,            // number: 0-15
+   454â†’      ccNumber: 13,          // number: 0-127
+   455â†’      minValue: 0,           // number: 0-127 (optional)
+   456â†’      maxValue: 127,         // number: 0-127 (optional)
+   457â†’      behaviour: 'absolute'  // string: 'absolute' | 'relative1' | 'relative2' | 'toggle'
+   458â†’    }
+   459â†’    // ... up to 48 controls
+   460â†’  ],
+   461â†’  colors: [],               // Color mappings (optional)
+   462â†’  labels: Map<number, string>  // Control labels keyed by control ID
+   463â†’}
+   464â†’\```
+   465â†’
+   466â†’### Object Format (Real Device Response)
+   467â†’\```javascript
+   468â†’{
+   469â†’  name: "MODE_NAME",
+   470â†’  controls: {
+   471â†’    "0x10": { controlId: 0x10, channel: 0, ccNumber: 13, ... },
+   472â†’    "0x11": { controlId: 0x11, channel: 1, ccNumber: 14, ... },
+   473â†’    // ... keyed by control ID (hex string)
+   474â†’  },
+   475â†’  colors: [],
+   476â†’  labels: Map<number, string>
+   477â†’}
+   478â†’\```
+   479â†’
+   480â†’**Note**: The `CustomModeManager.parseCustomModeResponse()` handles both formats automatically using:
+   481â†’\```typescript
+   482â†’const controlsArray = Array.isArray(response.controls)
+   483â†’  ? response.controls
+   484â†’  : Object.values(response.controls);
+   485â†’\```
+   486â†’
+   487â†’This defensive coding ensures compatibility with device firmware variations.
+   488â†’
+   489â†’---
+   490â†’
+   491â†’## Examples
+   492â†’
+   493â†’### Example 1: "TEST1" Label
+   494â†’
+   495â†’\```
+   496â†’65 10 54 45 53 54 31 60
+   497â†’â”‚  â”‚  T  E  S  T  1
+   498â†’â”‚  â””â”€ Control ID 0x10
+   499â†’â””â”€ Marker 0x65 = 0x60 + 5 â†’ 5 characters
+   500â†’\```
+   501â†’
+   502â†’### Example 2: "High Pass" Label
+   503â†’
+   504â†’\```
+   505â†’69 14 48 69 67 68 20 50 61 73 73 60
+   506â†’â”‚  â”‚  H  i  g  h     P  a  s  s
+   507â†’â”‚  â””â”€ Control ID 0x14 (20)
+   508â†’â””â”€ Marker 0x69 = 0x60 + 9 â†’ 9 characters
+   509â†’\```
+   510â†’
+   511â†’### Example 3: Empty Label
+   512â†’
+   513â†’\```
+   514â†’60 11 60
+   515â†’â”‚  â”‚  â””â”€ Next marker or terminator
+   516â†’â”‚  â””â”€ Control ID 0x11
+   517â†’â””â”€ Marker 0x60 = 0x60 + 0 â†’ 0 characters (empty)
+   518â†’\```
+   519â†’
+   520â†’### Example 4: Control ID Mapping Exception
+   521â†’
+   522â†’Label with control ID 0x19 (25) maps to actual control ID 26:
+   523â†’
+   524â†’\```
+   525â†’68 19 4C 6F 77 20 46 72 65 71
+   526â†’â”‚  â”‚  L  o  w     F  r  e  q
+   527â†’â”‚  â””â”€ Label ID 0x19 â†’ maps to control 26
+   528â†’â””â”€ Marker 0x68 = 8 chars
+   529â†’\```
+   530â†’
+   531â†’**Mapping rule:**
+   532â†’\```typescript
+   533â†’function mapLabelControlId(labelId: number): number {
+   534â†’  if (labelId >= 25 && labelId <= 28) {
+   535â†’    return labelId + 1;  // Labels 25-28 â†’ controls 26-29
+   536â†’  }
+   537â†’  return labelId;  // Direct mapping for all others
+   538â†’}
+   539â†’\```
+   540â†’
+   541â†’### Example 5: Write Acknowledgement Slot Verification
+   542â†’
+   543â†’\```typescript
+   544â†’// Write to slot 5, page 0
+   545â†’// Expected acknowledgement: F0 00 20 29 02 15 05 00 15 00 13 F7
+   546â†’//                                                       â†‘
+   547â†’//                                                       0x13 = slot 5
+   548â†’
+   549â†’function expectedSlotStatus(slot: number): number {
+   550â†’  return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   551â†’}
+   552â†’
+   553â†’// Verify acknowledgement matches expected slot
+   554â†’const slot = 5;
+   555â†’const ackStatus = 0x13;
+   556â†’const expected = expectedSlotStatus(slot); // 0x0E + 5 = 0x13
+   557â†’console.assert(ackStatus === expected, 'Slot mismatch in acknowledgement');
+   558â†’\```
+   559â†’
+   560â†’---
+   561â†’
+   562â†’## Discovery Methodology
+   563â†’
+   564â†’**How was this protocol reverse-engineered?**
+   565â†’
+   566â†’### Phase 1: Initial Analysis
+   567â†’1. Used existing heuristic parser (180+ lines, ~14% accuracy)
+   568â†’2. Captured MIDI traffic with CoreMIDI spy during device operations
+   569â†’3. Compared parser output with expected control names
+   570â†’
+   571â†’### Phase 2: Systematic Testing
+   572â†’1. **Tools Used:**
+   573â†’   - Novation Components web editor (ground truth)
+   574â†’   - Playwright browser automation (programmatic control)
+   575â†’   - CoreMIDI MIDI snooping tool (traffic capture)
+   576â†’   - Custom analysis scripts
+   577â†’
+   578â†’2. **Methodology:**
+   579â†’   - Changed control name from "High Pass" to "TEST1" in web editor
+   580â†’   - Sent modified mode to device via web editor
+   581â†’   - Captured exact MIDI bytes sent during operation
+   582â†’   - Retrieved mode from device
+   583â†’   - Compared byte sequences
+   584â†’
+   585â†’3. **Key Discovery:**
+   586â†’   \```
+   587â†’   "TEST1" (5 chars):     65 10 54 45 53 54 31 60
+   588â†’   "High Pass" (9 chars): 69 14 48 69 67 68 20 50 61 73 73 60
+   589â†’   \```
+   590â†’
+   591â†’   Realized: `0x65 = 0x60 + 5` and `0x69 = 0x60 + 9`
+   592â†’
+   593â†’   **The marker byte encodes the string length!**
+   594â†’
+   595â†’### Phase 3: Validation
+   596â†’1. Implemented length-encoding parser
+   597â†’2. Tested against all 21 named controls
+   598â†’3. Achieved 95% accuracy (20/21 correct)
+   599â†’4. One "failure" was intentional test data ("TEST1")
+   600â†’
+   601â†’### Phase 4: Slot Selection Discovery
+   602â†’1. Initial assumption: DAW port protocol required for slot selection
+   603â†’2. Tested SysEx slot byte parameter directly (2025-10-01)
+   604â†’3. Discovery: Slot byte works independently - DAW port NOT required
+   605â†’4. Updated code to use SysEx slot byte (commit 756cacd)
+   606â†’5. Removed DawPortController infrastructure
+   607â†’
+   608â†’### Phase 5: Write Acknowledgement Status Byte Discovery
+   609â†’1. **Problem:** Writes to slots 1-14 failed with "Write failed" errors
+   610â†’2. **Investigation:** Raw MIDI testing with `utils/test-round-trip-validation.ts`
+   611â†’3. **Discovery Process:**
+   612â†’   - Wrote to slot 0 â†’ acknowledgement status 0x06 (success per old code)
+   613â†’   - Wrote to slot 1 â†’ acknowledgement status 0x07 (failed per old code)
+   614â†’   - Wrote to slot 3 â†’ acknowledgement status 0x09 (failed per old code)
+   615â†’   - Wrote to slot 5 â†’ acknowledgement status 0x13 (failed per old code)
+   616â†’4. **Pattern Recognition:**
+   617â†’   - 0x06, 0x07, 0x09, 0x13 matched CC 30 slot encoding
+   618â†’   - Slots 0-3: 0x06 + slot
+   619â†’   - Slots 4-14: 0x0E + slot
+   620â†’5. **Conclusion:** Status byte is slot identifier, not success indicator
+   621â†’6. **Evidence:** Test captures showed consistent pattern across multiple slots
+   622â†’7. **Impact:** Fixed Issue #36 - DeviceManager now accepts any acknowledgement as success
+   623â†’
+   624â†’**Discovery Date:** 2025-10-16
+   625â†’**Method:** Raw MIDI testing with systematic slot writes and acknowledgement analysis
+   626â†’
+   627â†’### Phase 6: Verification
+   628â†’1. **Fix Implementation:** Updated DeviceManager.ts to accept any acknowledgement as success
+   629â†’2. **Test Execution:** Ran `utils/test-valid-mode-changes.ts` targeting slot 3
+   630â†’3. **Results:**
+   631â†’   - âœ… Write to slot 3 succeeded (no firmware rejection)
+   632â†’   - âœ… Control CC numbers persisted correctly (changed from 13,14,15,16,17 to 23,24,25,26,27)
+   633â†’   - âœ… Control channels persisted correctly
+   634â†’   - âœ… 10/11 changes verified successfully
+   635â†’   - âŒ Mode name truncated ("TESTMOD" â†’ "M") - under investigation
+   636â†’4. **Conclusion:** Issue #36 resolved - problem was library bug, not firmware limitation
+   637â†’
+   638â†’**Verification Date:** 2025-10-16
+   639â†’**Method:** Empirical round-trip test with real hardware targeting non-zero slot
+   640â†’
+   641â†’### Phase 7: Documentation
+   642â†’1. Created Kaitai Struct specification (`.ksy` file)
+   643â†’2. Validated spec by generating parser and comparing output
+   644â†’3. Documented control ID mapping exception (25-28 â†’ 26-29)
+   645â†’4. Updated all documentation to reflect slot selection discovery
+   646â†’5. Documented write acknowledgement slot encoding discovery
+   647â†’6. Added verification results to PROTOCOL.md and MAINTENANCE.md
+   648â†’
+   649â†’---
+   650â†’
+   651â†’## DAW Port Protocol (DEPRECATED)
+   652â†’
+   653â†’**Status:** DEPRECATED as of 2025-10-01
+   654â†’
+   655â†’**Historical Note:** Earlier protocol versions documented an extensive 2-phase DAW port protocol for slot selection. This was based on observations of the web editor, which does use the DAW port for some operations.
+   656â†’
+   657â†’**Discovery (2025-10-01):** The SysEx slot byte parameter works independently for slot selection. Simply include the slot number (0-14) in the SysEx read/write request. No DAW port communication required.
+   658â†’
+   659â†’**Implementation:** The DawPortController class has been removed from the codebase (commit 756cacd). See `DeviceManager.ts` lines 627 and 790 for comments confirming this.
+   660â†’
+   661â†’**Why the confusion?** The web editor uses DAW port for UI feedback and mode switching, but it's not required for SysEx slot targeting. The SysEx slot byte is the canonical mechanism.
+   662â†’
+   663â†’**Reference:** For historical documentation of the DAW port protocol, see git history before commit 756cacd (2025-10-09).
+   664â†’
+   665â†’---
+   666â†’
+   667â†’## LED Control
+   668â†’
+   669â†’**Important:** LED states are **NOT** stored in custom mode configurations.
+   670â†’
+   671â†’LEDs are controlled via separate real-time MIDI messages:
+   672â†’- Message type: `0x78` (LED_CONTROL)
+   673â†’- Format: Standard MIDI CC or custom SysEx
+   674â†’
+   675â†’Custom modes only store:
+   676â†’- Control definitions (CC mappings, channels, behaviors)
+   677â†’- Control labels (names)
+   678â†’- Mode name
+   679â†’
+   680â†’---
+   681â†’
+   682â†’## Parser Implementation
+   683â†’
+   684â†’**Current Implementation:** `src/core/SysExParser.ts`
+   685â†’
+   686â†’The parser follows the protocol specification exactly:
+   687â†’
+   688â†’1. **Mode Name Parsing:**
+   689â†’   \```typescript
+   690â†’   // Format: 06 20 [length] [name_bytes]
+   691â†’   const lengthByte = data[i + 2];
+   692â†’   const nameLength = lengthByte;
+   693â†’   const nameBytes = data.slice(i + 3, i + 3 + nameLength);
+   694â†’   \```
+   695â†’
+   696â†’2. **Control Label Parsing:**
+   697â†’   \```typescript
+   698â†’   // Format: [0x60 + length] [controlID] [name_bytes]
+   699â†’   const length = markerByte - 0x60;
+   700â†’   const controlId = data[i + 1];
+   701â†’   const nameBytes = data.slice(i + 2, i + 2 + length);
+   702â†’   const canonicalId = mapLabelControlId(controlId);
+   703â†’   \```
+   704â†’
+   705â†’3. **Write Acknowledgement Parsing:**
+   706â†’   \```typescript
+   707â†’   // Format: F0 00 20 29 02 15 05 00 15 [page] [slot_status] F7
+   708â†’   const page = data[9];
+   709â†’   const slotStatus = data[10];
+   710â†’
+   711â†’   // Verify slot encoding matches expected slot
+   712â†’   function expectedSlotStatus(slot: number): number {
+   713â†’     return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   714â†’   }
+   715â†’   \```
+   716â†’
+   717â†’**Lines of code:** ~90 (down from 180+ heuristic version)
+   718â†’**Accuracy:** 95%+ (100% when test data removed)
+   719â†’
+   720â†’---
+   721â†’
+   722â†’## References
+   723â†’
+   724â†’- **Formal Specification:** [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+   725â†’- **Parser Implementation:** [`../src/core/SysExParser.ts`](../src/core/SysExParser.ts)
+   726â†’- **Device Manager:** [`../src/device/DeviceManager.ts`](../src/device/DeviceManager.ts)
+   727â†’- **Test Data:** [`../backup/`](../backup/) - Real device captures in JSON format
+   728â†’
+   729â†’---
+   730â†’
+   731â†’## Version History
+   732â†’
+   733â†’| Version | Date | Changes |
+   734â†’|---------|------|---------|
+   735â†’| 2.0 | 2025-10-16 | **VERIFIED:** Write acknowledgement status byte is slot identifier. Confirmed with successful test run writing to slot 3. Control CC numbers, channels verified to persist correctly (10/11 changes successful). Issue #36 RESOLVED - bug was in library, not firmware. Added Known Issue: mode name truncation ("TESTMOD" â†’ "M"). |
+   736â†’| 1.9 | 2025-10-16 | **CRITICAL:** Documented write acknowledgement status byte as slot identifier, not success indicator. Status byte uses CC 30 slot encoding (slots 0-3: 0x06+slot, slots 4-14: 0x0E+slot). Acknowledgement arrival indicates success; timeout indicates failure. Fixed Issue #36. Evidence from raw MIDI testing with multiple slots. |
+   737â†’| 1.8 | 2025-10-11 | **Parser Bug Fix:** Removed incorrect 0x40 parsing in READ responses. The byte 0x40 appears as **data within 0x48 control structures** (minValue field at offset +7), not as a control marker. This caused wrong CC numbers, missing custom labels, and fake controls with CC 0. Only 0x48 markers are used for READ responses. Reference: GitHub issue #32 |
+   738â†’| 1.7 | 2025-10-09 | **MAJOR UPDATE:** Corrected page mapping documentation. Logical pages 0 and 1 map to SysEx page bytes 0x00 and 0x03. Removed extensive DAW port protocol documentation (deprecated). Clarified that slot selection uses SysEx slot byte directly. Updated all examples to reflect working code. |
+   739â†’| 1.6 | 2025-10-01 | **DEFINITIVE:** SysEx read/write DOES have slot parameter. Format is `F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7` where `[SLOT]` is slot number 0-14 (slot 15 reserved and immutable). DAW port protocol is NOT required for slot selection. |
+   740â†’| 1.5 | 2025-10-01 | **RETRACTED:** Incorrectly stated SysEx has no slot parameter. |
+   741â†’| 1.4 | 2025-10-01 | **Critical:** Corrected read protocol - uses 2 pages (0x00, 0x03), not 3 pages (0, 1, 2). Documented complete DAW port bidirectional protocol with device echoes. |
+   742â†’| 1.3 | 2025-09-30 | Added Parsed Response Format section documenting both array and object control formats |
+   743â†’| 1.2 | 2025-09-30 | **Critical:** Discovered write acknowledgement protocol (command 0x15). Device sends ACK after each page write. Client must wait for ACK before sending next page. |
+   744â†’| 1.1 | 2025-09-30 | Documented write protocol (command 0x45) with mode name format discovery |
+   745â†’| 1.0 | 2025-09-30 | Initial documented protocol after empirical discovery |
+   746â†’
+   747â†’---
+   748â†’
+   749â†’## Notes for Future Maintainers
+   750â†’
+   751â†’1. **The `.ksy` file is the source of truth** for byte-level protocol details
+   752â†’2. **Test changes empirically** using the web editor + MIDI spy methodology
+   753â†’3. **Control ID mapping exception** (25-28 â†’ 26-29) is hardware-specific, not a bug
+   754â†’4. **Length-encoding is critical** - marker byte `0x60 + length` determines string size
+   755â†’5. **No LED data in custom modes** - don't waste time looking for it
+   756â†’6. **Device returns controls in both array and object format** - parser must handle both
+   757â†’7. **Slot selection uses SysEx slot byte** - no DAW port protocol required
+   758â†’8. **Page bytes:** Logical page 0â†’0x00, logical page 1â†’0x03 in SysEx messages
+   759â†’9. **DO NOT scan for 0x40 bytes** - they appear as data in minValue fields, not as control markers
+   760â†’10. **Write acknowledgement status byte is slot identifier** - use CC 30 encoding to verify, or simply accept any acknowledgement as success
+   761â†’11. **Acknowledgement arrival = success; timeout = failure** - the status byte confirms which slot was written, not whether it succeeded
+   762â†’12. **Test with multiple slots, not just slot 0** - important patterns emerge when testing slots 1-14
+   763â†’13. **Mode name field has limitations** - names may truncate on read-back; under investigation
+   764â†’
+```
+
+Result:
+
+```
+The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
+     1â†’/**
+     2â†’ * High-level API for building Launch Control XL 3 custom modes
+     3â†’ * Provides a fluent interface for defining control mappings, labels, and colors
+     4â†’ */
+     5â†’
+     6â†’import type { CustomMode, Control, ControlType } from '@/types/CustomMode.js';
+     7â†’
+     8â†’export enum Color {
+     9â†’  OFF = 0x0C,
+    10â†’  RED_LOW = 0x0D,
+    11â†’  RED_FULL = 0x0F,
+    12â†’  AMBER_LOW = 0x1D,
+    13â†’  AMBER_FULL = 0x3F,
+    14â†’  YELLOW = 0x3E,
+    15â†’  GREEN_LOW = 0x1C,
+    16â†’  GREEN_FULL = 0x3C
+    17â†’}
+    18â†’
+    19â†’interface ControlConfig {
+    20â†’  cc: number;
+    21â†’  channel?: number;
+    22â†’  min?: number;
+    23â†’  max?: number;
+    24â†’}
+    25â†’
+    26â†’interface LabelColorData {
+    27â†’  labels: Map<number, string>;
+    28â†’  colors: Map<number, Color>;
+    29â†’}
+    30â†’
+    31â†’/**
+    32â†’ * Builder for creating Launch Control XL 3 custom modes
+    33â†’ * Provides a fluent API for defining controls, labels, and colors
+    34â†’ */
+    35â†’export class CustomModeBuilder {
+    36â†’  private modeName: string = '';
+    37â†’  private controls: Control[] = [];
+    38â†’  private labelData: LabelColorData = {
+    39â†’    labels: new Map(),
+    40â†’    colors: new Map()
+    41â†’  };
+    42â†’
+    43â†’  /**
+    44â†’   * Set the custom mode name (max 18 characters)
+    45â†’   */
+    46â†’  name(name: string): this {
+    47â†’    if (name.length > 18) {
+    48â†’      throw new Error('Mode name must be 18 characters or less');
+    49â†’    }
+    50â†’    this.modeName = name;
+    51â†’    return this;
+    52â†’  }
+    53â†’
+    54â†’  /**
+    55â†’   * Add a fader control mapping
+    56â†’   * @param faderNumber 1-8
+    57â†’   * @param config Control configuration
+    58â†’   */
+    59â†’  addFader(faderNumber: number, config: ControlConfig): this {
+    60â†’    if (faderNumber < 1 || faderNumber > 8) {
+    61â†’      throw new Error('Fader number must be 1-8');
+    62â†’    }
+    63â†’
+    64â†’    const controlId = 0x28 + (faderNumber - 1); // 0x28-0x2F
+    65â†’    this.addControl(controlId, 0x09, config);
+    66â†’    return this;
+    67â†’  }
+    68â†’
+    69â†’  /**
+    70â†’   * Add a top row encoder control mapping
+    71â†’   * @param row 1 (always 1 for top row)
+    72â†’   * @param encoderNumber 1-8
+    73â†’   * @param config Control configuration
+    74â†’   */
+    75â†’  addEncoder(row: 1, encoderNumber: number, config: ControlConfig): this;
+    76â†’  /**
+    77â†’   * Add a middle row encoder control mapping
+    78â†’   * @param row 2 (for middle row)
+    79â†’   * @param encoderNumber 1-8
+    80â†’   * @param config Control configuration
+    81â†’   */
+    82â†’  addEncoder(row: 2, encoderNumber: number, config: ControlConfig): this;
+    83â†’  /**
+    84â†’   * Add a bottom row encoder control mapping
+    85â†’   * @param row 3 (for bottom row)
+    86â†’   * @param encoderNumber 1-8
+    87â†’   * @param config Control configuration
+    88â†’   */
+    89â†’  addEncoder(row: 3, encoderNumber: number, config: ControlConfig): this;
+    90â†’  addEncoder(row: 1 | 2 | 3, encoderNumber: number, config: ControlConfig): this {
+    91â†’    if (encoderNumber < 1 || encoderNumber > 8) {
+    92â†’      throw new Error('Encoder number must be 1-8');
+    93â†’    }
+    94â†’
+    95â†’    let controlId: number;
+    96â†’    let controlType: ControlType;
+    97â†’
+    98â†’    switch (row) {
+    99â†’      case 1: // Top row
+   100â†’        controlId = 0x10 + (encoderNumber - 1); // 0x10-0x17
+   101â†’        controlType = 0x05;
+   102â†’        break;
+   103â†’      case 2: // Middle row
+   104â†’        controlId = 0x18 + (encoderNumber - 1); // 0x18-0x1F
+   105â†’        controlType = 0x09;
+   106â†’        break;
+   107â†’      case 3: // Bottom row
+   108â†’        controlId = 0x20 + (encoderNumber - 1); // 0x20-0x27
+   109â†’        controlType = 0x0D;
+   110â†’        break;
+   111â†’      default:
+   112â†’        throw new Error('Row must be 1, 2, or 3');
+   113â†’    }
+   114â†’
+   115â†’    this.addControl(controlId, controlType, config);
+   116â†’    return this;
+   117â†’  }
+   118â†’
+   119â†’  /**
+   120â†’   * Add a side button control mapping (track focus buttons)
+   121â†’   * @param buttonNumber 1-8
+   122â†’   * @param config Control configuration
+   123â†’   */
+   124â†’  addSideButton(buttonNumber: number, config: ControlConfig): this {
+   125â†’    if (buttonNumber < 1 || buttonNumber > 8) {
+   126â†’      throw new Error('Side button number must be 1-8');
+   127â†’    }
+   128â†’
+   129â†’    const controlId = 0x30 + (buttonNumber - 1); // 0x30-0x37
+   130â†’    this.addControl(controlId, 0x19, config);
+   131â†’    return this;
+   132â†’  }
+   133â†’
+   134â†’  /**
+   135â†’   * Add a bottom button control mapping
+   136â†’   * @param buttonNumber 1-16
+   137â†’   * @param config Control configuration
+   138â†’   */
+   139â†’  addBottomButton(buttonNumber: number, config: ControlConfig): this {
+   140â†’    if (buttonNumber < 1 || buttonNumber > 16) {
+   141â†’      throw new Error('Bottom button number must be 1-16');
+   142â†’    }
+   143â†’
+   144â†’    const controlId = 0x30 + (buttonNumber - 1); // 0x30-0x3F
+   145â†’    this.addControl(controlId, 0x25, config);
+   146â†’    return this;
+   147â†’  }
+   148â†’
+   149â†’  /**
+   150â†’   * Add a label for a control
+   151â†’   * @param controlId The hardware control ID (or use helper methods)
+   152â†’   * @param label The label text
+   153â†’   */
+   154â†’  addLabel(controlId: number, label: string): this {
+   155â†’    this.labelData.labels.set(controlId, label);
+   156â†’    return this;
+   157â†’  }
+   158â†’
+   159â†’  /**
+   160â†’   * Add a label for a fader
+   161â†’   * @param faderNumber 1-8
+   162â†’   * @param label The label text
+   163â†’   */
+   164â†’  addFaderLabel(faderNumber: number, label: string): this {
+   165â†’    if (faderNumber < 1 || faderNumber > 8) {
+   166â†’      throw new Error('Fader number must be 1-8');
+   167â†’    }
+   168â†’    return this.addLabel(0x28 + (faderNumber - 1), label);
+   169â†’  }
+   170â†’
+   171â†’  /**
+   172â†’   * Add a label for an encoder
+   173â†’   * @param row 1, 2, or 3
+   174â†’   * @param encoderNumber 1-8
+   175â†’   * @param label The label text
+   176â†’   */
+   177â†’  addEncoderLabel(row: 1 | 2 | 3, encoderNumber: number, label: string): this {
+   178â†’    if (encoderNumber < 1 || encoderNumber > 8) {
+   179â†’      throw new Error('Encoder number must be 1-8');
+   180â†’    }
+   181â†’
+   182â†’    let controlId: number;
+   183â†’    switch (row) {
+   184â†’      case 1:
+   185â†’        controlId = 0x10 + (encoderNumber - 1);
+   186â†’        break;
+   187â†’      case 2:
+   188â†’        controlId = 0x18 + (encoderNumber - 1);
+   189â†’        break;
+   190â†’      case 3:
+   191â†’        controlId = 0x20 + (encoderNumber - 1);
+   192â†’        break;
+   193â†’      default:
+   194â†’        throw new Error('Row must be 1, 2, or 3');
+   195â†’    }
+   196â†’
+   197â†’    return this.addLabel(controlId, label);
+   198â†’  }
+   199â†’
+   200â†’  /**
+   201â†’   * Add a color for a control
+   202â†’   * @param controlId The hardware control ID
+   203â†’   * @param color The color value
+   204â†’   */
+   205â†’  addColor(controlId: number, color: Color): this {
+   206â†’    this.labelData.colors.set(controlId, color);
+   207â†’    return this;
+   208â†’  }
+   209â†’
+   210â†’  /**
+   211â†’   * Add a color for a side button
+   212â†’   * @param buttonNumber 1-8
+   213â†’   * @param color The color value
+   214â†’   */
+   215â†’  addSideButtonColor(buttonNumber: number, color: Color): this {
+   216â†’    if (buttonNumber < 1 || buttonNumber > 8) {
+   217â†’      throw new Error('Side button number must be 1-8');
+   218â†’    }
+   219â†’    return this.addColor(0x30 + (buttonNumber - 1), color);
+   220â†’  }
+   221â†’
+   222â†’  /**
+   223â†’   * Add a color for a bottom button
+   224â†’   * @param buttonNumber 1-16
+   225â†’   * @param color The color value
+   226â†’   */
+   227â†’  addBottomButtonColor(buttonNumber: number, color: Color): this {
+   228â†’    if (buttonNumber < 1 || buttonNumber > 16) {
+   229â†’      throw new Error('Bottom button number must be 1-16');
+   230â†’    }
+   231â†’    return this.addColor(0x30 + (buttonNumber - 1), color);
+   232â†’  }
+   233â†’
+   234â†’  /**
+   235â†’   * Build the custom mode object
+   236â†’   */
+   237â†’  build(): CustomMode {
+   238â†’    if (!this.modeName) {
+   239â†’      throw new Error('Mode name is required');
+   240â†’    }
+   241â†’
+   242â†’    if (this.controls.length === 0) {
+   243â†’      throw new Error('At least one control mapping is required');
+   244â†’    }
+   245â†’
+   246â†’    // Convert controls array to Record for CustomMode interface
+   247â†’    const controlsRecord: Record<string, any> = {};
+   248â†’    for (const control of this.controls) {
+   249â†’      controlsRecord[`control_${control.controlId}`] = control;
+   250â†’    }
+   251â†’
+   252â†’    return {
+   253â†’      name: this.modeName,
+   254â†’      controls: controlsRecord,
+   255â†’      labels: this.labelData.labels,
+   256â†’      colors: this.labelData.colors
+   257â†’    };
+   258â†’  }
+   259â†’
+   260â†’  /**
+   261â†’   * Create a builder pre-configured for a simple test mode
+   262â†’   */
+   263â†’  static createTestMode(): CustomModeBuilder {
+   264â†’    return new CustomModeBuilder()
+   265â†’      .name('TEST')
+   266â†’      .addFader(1, { cc: 10, channel: 1 })
+   267â†’      .addEncoder(1, 1, { cc: 13, channel: 1 })
+   268â†’      .addEncoderLabel(1, 1, 'Filter')
+   269â†’      .addFaderLabel(1, 'Volume');
+   270â†’  }
+   271â†’
+   272â†’  /**
+   273â†’   * Create a builder pre-configured for the CHANNEV mode
+   274â†’   */
+   275â†’  static createChannevMode(): CustomModeBuilder {
+   276â†’    const builder = new CustomModeBuilder().name('CHANNEV');
+   277â†’
+   278â†’    // Top row encoders (CC 13-20)
+   279â†’    for (let i = 1; i <= 8; i++) {
+   280â†’      builder.addEncoder(1, i, { cc: 12 + i, channel: 1 });
+   281â†’    }
+   282â†’
+   283â†’    // Middle row encoders (CC 21-28)
+   284â†’    for (let i = 1; i <= 8; i++) {
+   285â†’      builder.addEncoder(2, i, { cc: 20 + i, channel: 1 });
+   286â†’    }
+   287â†’
+   288â†’    // Bottom row encoders (CC 29-36)
+   289â†’    for (let i = 1; i <= 8; i++) {
+   290â†’      builder.addEncoder(3, i, { cc: 28 + i, channel: 1 });
+   291â†’    }
+   292â†’
+   293â†’    // Add labels for key controls
+   294â†’    builder
+   295â†’      .addEncoderLabel(1, 1, 'Mic Gain')
+   296â†’      .addEncoderLabel(1, 2, 'Line Amp Gain')
+   297â†’      .addEncoderLabel(1, 4, 'Low Pass')
+   298â†’      .addEncoderLabel(2, 1, 'High Shelf')
+   299â†’      .addEncoderLabel(2, 2, 'Low Freq')
+   300â†’      .addEncoderLabel(2, 3, 'Low Mid Freq')
+   301â†’      .addEncoderLabel(2, 4, 'High Mid Freq')
+   302â†’      .addEncoderLabel(2, 5, 'High Freq')
+   303â†’      .addEncoderLabel(3, 1, 'Low Shelf')
+   304â†’      .addEncoderLabel(3, 2, 'Low Gain')
+   305â†’      .addEncoderLabel(3, 3, 'Low Mid Gain')
+   306â†’      .addEncoderLabel(3, 4, 'High Mid Gain')
+   307â†’      .addEncoderLabel(3, 5, 'High Gain');
+   308â†’
+   309â†’    return builder;
+   310â†’  }
+   311â†’
+   312â†’  private addControl(controlId: number, controlType: ControlType, config: ControlConfig): void {
+   313â†’    // Check for duplicate control
+   314â†’    if (this.controls.find(c => c.controlId === controlId)) {
+   315â†’      throw new Error(`Control ${controlId.toString(16)} already defined`);
+   316â†’    }
+   317â†’
+   318â†’    // Validate CC range
+   319â†’    if (config.cc < 0 || config.cc > 127) {
+   320â†’      throw new Error('CC number must be 0-127');
+   321â†’    }
+   322â†’
+   323â†’    // Validate channel
+   324â†’    const channel = config.channel ?? 1;
+   325â†’    if (channel < 1 || channel > 16) {
+   326â†’      throw new Error('MIDI channel must be 1-16');
+   327â†’    }
+   328â†’
+   329â†’    const control: Control = {
+   330â†’      controlId,
+   331â†’      controlType,
+   332â†’      midiChannel: channel - 1, // Convert to 0-based
+   333â†’      ccNumber: config.cc,
+   334â†’      minValue: config.min ?? 0,
+   335â†’      maxValue: config.max ?? 127,
+   336â†’      behavior: 'absolute'
+   337â†’    };
+   338â†’
+   339â†’    this.controls.push(control);
+   340â†’  }
+   341â†’}
+   342â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I'll update the PROTOCOL.md file with the corrected mode name length limit and add a version history entry:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now let me verify the changes and run the required checks:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify file exists and check modification time
+
+`ls -la /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts`
+
+Result:
+
+```
+-rw-r--r--@ 1 orion  staff  9357 Oct 16 20:43 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify the changes to the name method
+
+`head -50 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts | grep -A 5 "Set the custom mode name"`
+
+Result:
+
+```
+* Set the custom mode name (max 18 characters)
+   */
+  name(name: string): this {
+    if (name.length > 18) {
+      throw new Error('Mode name must be 18 characters or less');
+    }
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Run TypeScript type checking
+
+`pnpm typecheck`
+
+Result:
+
+```
+> @oletizi/launch-control-xl3@1.20.17 typecheck /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
+> tsc --noEmit
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Run build to ensure everything compiles
+
+`pnpm build`
+
+Result:
+
+```
+> @oletizi/launch-control-xl3@1.20.17 build /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
+> vite build
+
+vite v5.4.20 building for production...
+transforming...
+âœ“ 23 modules transformed.
+rendering chunks...
+
+[vite:dts] Start generate declaration files...
+computing gzip size...
+dist/cli.js      1.46 kB â”‚ gzip:  0.49 kB â”‚ map:   2.56 kB
+dist/index.js  143.82 kB â”‚ gzip: 31.29 kB â”‚ map: 303.85 kB
+[vite:dts] Declaration files built in 947ms.
+
+âœ“ built in 1.10s
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! Now let me verify the exact changes by showing the specific lines that were modified:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Show the exact lines with the updated limits
+
+`grep -n "max 18 characters\|length > 18\|18 characters or less" /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts`
+
+Result:
+
+```
+44:   * Set the custom mode name (max 18 characters)
+47:    if (name.length > 18) {
+48:      throw new Error('Mode name must be 18 characters or less');
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! Let me also verify the file size to ensure we're within the 300-500 line limit:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Count lines in the file
+
+`wc -l /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts`
+
+Result:
+
+```
+341 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Excellent! All changes have been successfully completed and verified. Here's the summary:
+
+## Changes Completed
+
+**File Modified:** `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts`
+
+**Lines Updated:**
+- **Line 44**: Comment changed from "max 8 characters" to "max 18 characters"
+- **Line 47**: Validation changed from `name.length > 8` to `name.length > 18`
+- **Line 48**: Error message changed from "Mode name must be 8 characters or less" to "Mode name must be 18 characters or less"
+
+## Verification Results
+
+1. **File Exists**: Confirmed at `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts` (9,357 bytes, modified Oct 16 20:43)
+
+2. **Content Verified**: All three changes confirmed:
+   - Comment: "max 18 characters" (line 44)
+   - Validation: `name.length > 18` (line 47)
+   - Error: "Mode name must be 18 characters or less" (line 48)
+
+3. **TypeScript Check**: Passed with no errors (`pnpm typecheck`)
+
+4. **Build**: Succeeded (1.10s build time, 143.82 kB output)
+
+5. **File Size**: 341 lines (within the 300-500 line guideline)
+
+The mode name length limit has been successfully updated from 8 to 18 characters throughout the CustomModeBuilder class.
+
+Result:
+
+```
+Excellent! All changes have been successfully completed and verified. Here's the summary:
+
+## Changes Completed
+
+**File Modified:** `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts`
+
+**Lines Updated:**
+- **Line 44**: Comment changed from "max 8 characters" to "max 18 characters"
+- **Line 47**: Validation changed from `name.length > 8` to `name.length > 18`
+- **Line 48**: Error message changed from "Mode name must be 8 characters or less" to "Mode name must be 18 characters or less"
+
+## Verification Results
+
+1. **File Exists**: Confirmed at `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts` (9,357 bytes, modified Oct 16 20:43)
+
+2. **Content Verified**: All three changes confirmed:
+   - Comment: "max 18 characters" (line 44)
+   - Validation: `name.length > 18` (line 47)
+   - Error: "Mode name must be 18 characters or less" (line 48)
+
+3. **TypeScript Check**: Passed with no errors (`pnpm typecheck`)
+
+4. **Build**: Succeeded (1.10s build time, 143.82 kB output)
+
+5. **File Size**: 341 lines (within the 300-500 line guideline)
+
+The mode name length limit has been successfully updated from 8 to 18 characters throughout the CustomModeBuilder class.
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Write**
+
+```typescript
+/**
+ * SysEx Parser Unit Tests
+ */
+
+import { describe, it, expect } from 'vitest';
+import {
+  SysExParser,
+  MANUFACTURER_ID,
+  SysExMessageType,
+  DEVICE_FAMILY
+} from '@/core/SysExParser';
+import { CONTROL_IDS } from '@/modes/CustomModeManager';
+
+/**
+ * Convert CustomMode format to CustomModeMessage format for testing
+ *
+ * Takes object-based controls (e.g., { SEND_A1: {...}, SEND_B2: {...} })
+ * and converts to array-based format with controlId properties that
+ * buildCustomModeWriteRequest expects.
+ */
+function convertToCustomModeMessage(mode: any, slot: number): any {
+  const controls: any[] = [];
+  const colors: any[] = [];
+  const labels = new Map<number, string>();
+
+  // Convert object-based controls to array-based
+  if (mode.controls) {
+    for (const [key, control] of Object.entries(mode.controls)) {
+      const controlId = (CONTROL_IDS as any)[key];
+      if (controlId !== undefined) {
+        controls.push({
+          controlId,
+          channel: (control as any).channel ?? (control as any).midiChannel,
+          ccNumber: (control as any).cc ?? (control as any).ccNumber,
+          minValue: (control as any).min ?? (control as any).minValue ?? 0,
+          maxValue: (control as any).max ?? (control as any).maxValue ?? 127,
+          behaviour: (control as any).behaviour ?? (control as any).behavior ?? 'absolute',
+        });
+
+        if ((control as any).name) {
+          labels.set(controlId, (control as any).name);
+        }
+      }
+    }
+  }
+
+  // Convert LED mappings to colors array
+  if (mode.leds) {
+    for (const [controlName, ledConfig] of mode.leds.entries()) {
+      const controlId = (CONTROL_IDS as any)[controlName];
+      if (controlId !== undefined) {
+        colors.push({
+          controlId,
+          color: (ledConfig as any).color,
+          behaviour: (ledConfig as any).behaviour ?? 'static',
+        });
+      }
+    }
+  }
+
+  return {
+    type: 'custom_mode_write',
+    manufacturerId: [0x00, 0x20, 0x29],
+    slot,
+    name: mode.name,
+    controls,
+    colors,
+    labels,
+    data: [],
+  };
+}
+
+describe('SysExParser', () => {
+  describe('parse', () => {
+    it('should parse device inquiry response', () => {
+      const message = [
+        0xF0, // Start
+        0x7E, // Universal non-realtime
+        0x00, // Device ID
+        0x06, // Inquiry response
+        0x02, // Sub-ID
+        0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+        0x00, 0x61, // Family code
+        0x00, 0x01, // Family member
+        0x01, 0x00, 0x00, 0x00, // Software revision
+        0xF7, // End
+      ];
+
+      const result = SysExParser.parse(message);
+      expect(result.type).toBe('device_inquiry_response');
+      expect(result.manufacturerId).toEqual([0x00, 0x20, 0x29]);
+
+      const inquiry = result as any;
+      expect(inquiry.familyCode).toBe(0x61);
+      expect(inquiry.familyMember).toBe(0x01);
+      expect(inquiry.softwareRevision).toEqual([0x01, 0x00, 0x00, 0x00]);
+    });
+
+    it('should parse template change message', () => {
+      const message = [
+        0xF0, // Start
+        ...MANUFACTURER_ID,
+        0x02, // Device ID (Launch Control XL 3) - UPDATED for Issue #36 fix
+        SysExMessageType.TEMPLATE_CHANGE,
+        0x05, // Template number
+        0xF7, // End
+      ];
+
+      const result = SysExParser.parse(message);
+      expect(result.type).toBe('template_change');
+
+      const templateChange = result as any;
+      expect(templateChange.templateNumber).toBe(0x05);
+    });
+
+    it('should throw error for invalid SysEx', () => {
+      // Missing start byte
+      expect(() => SysExParser.parse([0x00, 0xF7])).toThrow('Invalid SysEx message: missing start byte');
+
+      // Missing end byte
+      expect(() => SysExParser.parse([0xF0, 0x00])).toThrow('Invalid SysEx message: missing end byte');
+
+      // Too short
+      expect(() => SysExParser.parse([0xF0, 0xF7])).toThrow('Invalid SysEx message: too short');
+    });
+
+    it('should handle unknown message types', () => {
+      const message = [
+        0xF0,
+        ...MANUFACTURER_ID,
+        0x11,
+        0xFF, // Unknown message type
+        0x00, 0x01, 0x02,
+        0xF7,
+      ];
+
+      const result = SysExParser.parse(message);
+      expect(result.type).toBe('unknown');
+      expect(result.manufacturerId).toEqual(MANUFACTURER_ID);
+    });
+  });
+
+  describe('buildDeviceQuery', () => {
+    it('should build device inquiry request', () => {
+      const message = SysExParser.buildDeviceQuery();
+
+      expect(message[0]).toBe(0xF0); // Start
+      expect(message[1]).toBe(0x7E); // Universal non-realtime
+      expect(message[2]).toBe(0x00); // Device ID (broadcast)
+      expect(message[3]).toBe(0x06); // General information
+      expect(message[4]).toBe(0x01); // Identity request
+      expect(message[5]).toBe(0xF7); // End
+    });
+  });
+
+  describe('buildTemplateChange', () => {
+    it('should build template change message', () => {
+      const message = SysExParser.buildTemplateChange(5);
+
+      expect(message[0]).toBe(0xF0);
+      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+      expect(message[4]).toBe(0x02); // Device ID (Launch Control XL 3) - UPDATED for Issue #36 fix
+      expect(message[5]).toBe(SysExMessageType.TEMPLATE_CHANGE);
+      expect(message[6]).toBe(5); // Template number
+      expect(message[7]).toBe(0xF7);
+    });
+
+    it('should validate template number range', () => {
+      expect(() => SysExParser.buildTemplateChange(-1)).toThrow('Template number must be 0-15');
+      expect(() => SysExParser.buildTemplateChange(16)).toThrow('Template number must be 0-15');
+    });
+  });
+
+  describe('buildCustomModeReadRequest', () => {
+    it('should build custom mode read request', () => {
+      const message = SysExParser.buildCustomModeReadRequest(3, 0);
+
+      expect(message[0]).toBe(0xF0);
+      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+      expect(message[4]).toBe(0x02); // Device ID
+      expect(message[5]).toBe(0x15); // Command (Custom mode)
+      expect(message[6]).toBe(0x05); // Sub-command
+      expect(message[7]).toBe(0x00); // Reserved
+      expect(message[8]).toBe(0x40); // Read operation
+      expect(message[9]).toBe(0x00); // Page (0x00 for page 0)
+      expect(message[10]).toBe(3); // Slot number
+      expect(message[11]).toBe(0xF7);
+    });
+
+    it('should validate slot number range', () => {
+      expect(() => SysExParser.buildCustomModeReadRequest(-1)).toThrow('Custom mode slot must be 0-14');
+      expect(() => SysExParser.buildCustomModeReadRequest(15)).toThrow('Custom mode slot must be 0-14');
+    });
+  });
+
+  describe('buildLedControl', () => {
+    it('should build LED control message', () => {
+      const message = SysExParser.buildLedControl(0x29, 0x3C, 'static');
+
+      expect(message[0]).toBe(0xF0);
+      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+      expect(message[4]).toBe(0x11);
+      expect(message[5]).toBe(SysExMessageType.LED_CONTROL);
+      expect(message[6]).toBe(0x29); // Control ID
+      expect(message[7]).toBe(0x3C); // Color
+      expect(message[8]).toBe(0xF7);
+    });
+
+    it('should handle flash behavior', () => {
+      const message = SysExParser.buildLedControl(0x29, 0x3C, 'flash');
+      expect(message[7]).toBe(0x3C | 0x08); // Color with flash bit
+    });
+
+    it('should handle pulse behavior', () => {
+      const message = SysExParser.buildLedControl(0x29, 0x3C, 'pulse');
+      expect(message[7]).toBe(0x3C | 0x10); // Color with pulse bit
+    });
+
+    it('should validate control ID range', () => {
+      expect(() => SysExParser.buildLedControl(-1, 0x3C)).toThrow('Control ID must be 0-127');
+      expect(() => SysExParser.buildLedControl(128, 0x3C)).toThrow('Control ID must be 0-127');
+    });
+
+    it('should validate color range', () => {
+      expect(() => SysExParser.buildLedControl(0x29, -1)).toThrow('Color must be 0-127');
+      expect(() => SysExParser.buildLedControl(0x29, 128)).toThrow('Color must be 0-127');
+    });
+  });
+
+  describe('buildLedReset', () => {
+    it('should build LED reset message', () => {
+      const message = SysExParser.buildLedReset();
+
+      expect(message[0]).toBe(0xF0);
+      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+      expect(message[4]).toBe(0x11);
+      expect(message[5]).toBe(SysExMessageType.RESET_LED);
+      expect(message[6]).toBe(0x00); // Reset all
+      expect(message[7]).toBe(0xF7);
+    });
+  });
+
+  describe('isValidSysEx', () => {
+    it('should validate correct SysEx messages', () => {
+      expect(SysExParser.isValidSysEx([0xF0, 0x00, 0xF7])).toBe(true);
+      expect(SysExParser.isValidSysEx([0xF0, 0x00, 0x01, 0x02, 0xF7])).toBe(true);
+    });
+
+    it('should reject invalid SysEx messages', () => {
+      expect(SysExParser.isValidSysEx([])).toBe(false);
+      expect(SysExParser.isValidSysEx([0xF0])).toBe(false);
+      expect(SysExParser.isValidSysEx([0xF7])).toBe(false);
+      expect(SysExParser.isValidSysEx([0x00, 0x01])).toBe(false);
+      expect(SysExParser.isValidSysEx([0xF0, 0x00])).toBe(false); // Missing end
+      expect(SysExParser.isValidSysEx([0x00, 0xF7])).toBe(false); // Missing start
+    });
+  });
+
+  describe('getManufacturerId', () => {
+    it('should extract 3-byte manufacturer ID', () => {
+      const message = [0xF0, 0x00, 0x20, 0x29, 0x01, 0xF7];
+      const id = SysExParser.getManufacturerId(message);
+      expect(id).toEqual([0x00, 0x20, 0x29]);
+    });
+
+    it('should extract single-byte manufacturer ID', () => {
+      const message = [0xF0, 0x43, 0x01, 0xF7]; // Yamaha
+      const id = SysExParser.getManufacturerId(message);
+      expect(id).toEqual([0x43]);
+    });
+
+    it('should return null for universal messages', () => {
+      const message = [0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7];
+      const id = SysExParser.getManufacturerId(message);
+      expect(id).toBeNull();
+
+      const realtime = [0xF0, 0x7F, 0x00, 0x06, 0x01, 0xF7];
+      const id2 = SysExParser.getManufacturerId(realtime);
+      expect(id2).toBeNull();
+    });
+
+    it('should return null for invalid SysEx', () => {
+      const id = SysExParser.getManufacturerId([0x00, 0x01]);
+      expect(id).toBeNull();
+    });
+  });
+
+  describe('validateCustomModeData', () => {
+    it('should validate valid custom mode data', () => {
+      const modeData = {
+        type: 'custom_mode_write',
+        manufacturerId: MANUFACTURER_ID,
+        slot: 0,
+        controls: [
+          {
+            controlId: 0x0D,
+            channel: 0,
+            ccNumber: 20,
+            minValue: 0,
+            maxValue: 127,
+            behaviour: 'absolute' as const,
+          },
+        ],
+        colors: [
+          {
+            controlId: 0x29,
+            color: 0x3C,
+            behaviour: 'static' as const,
+          },
+        ],
+        data: [],
+      };
+
+      expect(() => SysExParser.validateCustomModeData(modeData as any)).not.toThrow();
+    });
+
+    it('should reject invalid control data', () => {
+      const invalidCC = {
+        type: 'custom_mode_write',
+        manufacturerId: MANUFACTURER_ID,
+        slot: 0,
+        controls: [
+          {
+            controlId: 0x0D,
+            channel: 0,
+            ccNumber: 128, // Invalid
+            minValue: 0,
+            maxValue: 127,
+            behaviour: 'absolute',
+          },
+        ],
+        colors: [],
+        data: [],
+      };
+
+      expect(() => SysExParser.validateCustomModeData(invalidCC as any)).toThrow('CC number must be 0-127');
+    });
+
+    it('should reject invalid channel', () => {
+      const invalidChannel = {
+        type: 'custom_mode_write',
+        manufacturerId: MANUFACTURER_ID,
+        slot: 0,
+        controls: [
+          {
+            controlId: 0x0D,
+            channel: 16, // Invalid
+            ccNumber: 20,
+            minValue: 0,
+            maxValue: 127,
+            behaviour: 'absolute',
+          },
+        ],
+        colors: [],
+        data: [],
+      };
+
+      expect(() => SysExParser.validateCustomModeData(invalidChannel as any)).toThrow('Channel must be 0-15');
+    });
+
+    it('should reject invalid value ranges', () => {
+      const invalidRange = {
+        type: 'custom_mode_write',
+        manufacturerId: MANUFACTURER_ID,
+        slot: 0,
+        controls: [
+          {
+            controlId: 0x0D,
+            channel: 0,
+            ccNumber: 20,
+            minValue: 100,
+            maxValue: 50, // Min > Max
+            behaviour: 'absolute',
+          },
+        ],
+        colors: [],
+        data: [],
+      };
+
+      expect(() => SysExParser.validateCustomModeData(invalidRange as any)).toThrow('Min value cannot be greater than max value');
+    });
+
+    it('should reject invalid color values', () => {
+      const invalidColor = {
+        type: 'custom_mode_write',
+        manufacturerId: MANUFACTURER_ID,
+        slot: 0,
+        controls: [],
+        colors: [
+          {
+            controlId: 0x29,
+            color: 128, // Invalid
+            behaviour: 'static',
+          },
+        ],
+        data: [],
+      };
+
+      expect(() => SysExParser.validateCustomModeData(invalidColor as any)).toThrow('Color value must be 0-127');
+    });
+  });
+
+  /**
+   * THESE TESTS ARE SKIPPED - They test a hypothetical protocol format that doesn't match the real device.
+   *
+   * Background:
+   * - These tests were written speculatively before protocol reverse-engineering
+   * - They expect format: [0x01, 0x20, 0x10, 0x2A] data header + 0x49 control markers with +0x28 offset
+   * - The REAL device uses: [0x20, length, ...name] format (verified via web editor analysis)
+   * - See PROTOCOL.md v1.8 (2025-10-11) for actual protocol specification
+   * - See issue #32 for protocol discovery details
+   *
+   * The implementation works correctly with real hardware (backup utility succeeds).
+   * These tests need complete rewrite to match actual protocol, not vice versa.
+   */
+  describe.skip('buildCustomModeWriteRequest - MIDI Protocol Validation', () => {
+    it('should create message with correct header according to MIDI-PROTOCOL.md', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [],
+        colors: [],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+
+      // Check SysEx boundaries
+      expect(message[0]).toBe(0xF0);
+      expect(message[message.length - 1]).toBe(0xF7);
+
+      // Check header matches MIDI-PROTOCOL.md specification
+      expect(message.slice(1, 10)).toEqual([
+        0x00, 0x20, 0x29, // Manufacturer ID
+        0x02,             // Device ID
+        0x15,             // Command
+        0x05,             // Sub-command
+        0x00,             // Reserved
+        0x45,             // Write operation
+        0x00              // Slot
+      ]);
+    });
+
+    it('should include data header (00 20 08) after protocol header', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [],
+        colors: [],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+
+      // Data header should be at position 10 (Phase 2: new format)
+      expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]);
+    });
+
+    it('should encode control with 0x49 marker and +0x28 offset as per protocol', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00, // Fader 1
+          name: 'Volume',
+          midiChannel: 0,
+          ccNumber: 77,
+          minValue: 0,
+          maxValue: 127
+        }],
+        colors: [],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+
+      // Find control definition (after header + data header + name)
+      // Header(10) + DataHeader(4) + Name(4) = 18
+      const controlDef = message.slice(18, 29);
+
+      // Verify control format matches protocol:
+      // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+      expect(controlDef[0]).toBe(0x49);        // Write marker
+      expect(controlDef[1]).toBe(0x28);        // ID 0x00 + 0x28
+      expect(controlDef[2]).toBe(0x02);        // Definition type
+      expect(controlDef[3]).toBe(0x00);        // Control type for fader
+      expect(controlDef[4]).toBe(0x00);        // Channel
+      expect(controlDef[5]).toBe(0x01);        // Fixed param
+      expect(controlDef[6]).toBe(0x40);        // Behavior
+      expect(controlDef[7]).toBe(0x00);        // Min (always 0x00)
+      expect(controlDef[8]).toBe(77);          // CC number
+      expect(controlDef[9]).toBe(0x7F);        // Max (always 0x7F)
+      expect(controlDef[10]).toBe(0x00);       // Terminator
+    });
+
+    it('should use actual control names in labels, not generic ones', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00,
+          name: 'MyVolume', // Specific name
+          ccNumber: 77
+        }],
+        colors: [{
+          controlId: 0x00,
+          color: 0x0C
+        }],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+      const messageStr = message.map(b => String.fromCharCode(b)).join('');
+
+      // Should contain the actual control name
+      expect(messageStr).toContain('MyVolume');
+
+      // Should NOT contain generic label
+      expect(messageStr).not.toContain('Fader 1');
+    });
+
+    it('should include label markers (0x69) for controls with names', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00,
+          name: 'Vol',
+          ccNumber: 77
+        }],
+        colors: [{
+          controlId: 0x00,
+          color: 0x0C
+        }],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+
+      // Should contain label marker
+      expect(message).toContain(0x69);
+
+      // Find label section and verify structure
+      const labelIdx = message.indexOf(0x69);
+      expect(labelIdx).toBeGreaterThan(0);
+      expect(message[labelIdx + 1]).toBe(0x28); // Control ID with offset
+    });
+
+    it('should include color markers (0x60) for all controls', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00,
+          name: 'Vol',
+          ccNumber: 77
+        }],
+        colors: [{
+          controlId: 0x00,
+          color: 0x0C
+        }],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+
+      // Should contain color marker
+      expect(message).toContain(0x60);
+
+      // Find color section and verify structure
+      const colorIdx = message.indexOf(0x60);
+      expect(colorIdx).toBeGreaterThan(0);
+      expect(message[colorIdx + 1]).toBe(0x28); // Control ID with offset
+    });
+
+    it('should generate message of appropriate length for complete data', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TESTMODE',
+        controls: [
+          { controlId: 0x00, name: 'Volume1', ccNumber: 1 },
+          { controlId: 0x01, name: 'Volume2', ccNumber: 2 },
+          { controlId: 0x10, name: 'Send1', ccNumber: 13 },
+          { controlId: 0x11, name: 'Send2', ccNumber: 14 },
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x0C },
+          { controlId: 0x01, color: 0x0C },
+          { controlId: 0x10, color: 0x3C },
+          { controlId: 0x11, color: 0x3C },
+        ],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+
+      // According to MIDI-PROTOCOL.md, complete messages are 400-500+ bytes
+      // With 4 controls, labels, and colors, should be substantial
+      expect(message.length).toBeGreaterThan(100);
+    });
+  });
+
+  describe.skip('buildCustomModeWriteRequest', () => {
+    // SKIPPED: Same reason as above - tests hypothetical protocol format
+    describe('Message Structure', () => {
+      it('should create a properly formatted SysEx message with correct header and footer', () => {
+        const slot = 0;
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot,
+          name: 'TEST',
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(slot, 0, modeData);
+
+        // Check SysEx start and end
+        expect(message[0]).toBe(0xF0); // SysEx start
+        expect(message[message.length - 1]).toBe(0xF7); // SysEx end
+
+        // Check header according to MIDI-PROTOCOL.md
+        expect(message.slice(1, 10)).toEqual([
+          0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+          0x02,             // Device ID (Launch Control XL 3)
+          0x15,             // Command (Custom mode)
+          0x05,             // Sub-command
+          0x00,             // Reserved
+          0x45,             // Write operation
+          slot              // Slot number
+        ]);
+      });
+
+      it('should include the data header (00 20 08) after the protocol header', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Data should start at position 10 (after header) (Phase 2: new format)
+        expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]);
+      });
+    });
+
+    describe('Mode Name Encoding', () => {
+      it('should encode the mode name as ASCII after the data header', () => {
+        const modeName = 'CHANNEVE';
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: modeName,
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Mode name should be at position 14 (after header + new 4-byte data header)
+        const nameBytes = message.slice(14, 14 + modeName.length);
+        const decodedName = String.fromCharCode(...nameBytes);
+
+        expect(decodedName).toBe('CHANNEVE');
+      });
+
+      it('should limit mode name to 18 characters maximum', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'EXACTLYEIGHTEENCHA', // Exactly 18 characters
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Check that exactly 18 characters are encoded
+        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
+        const decodedName = String.fromCharCode(...nameBytes);
+
+        expect(decodedName).toBe('EXACTLYEIGHTEENCHA');
+      });
+
+      it('should truncate mode names longer than 18 characters', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'THISHASNINETEENCHAR', // 19 characters - should be truncated
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Check that only first 18 characters are encoded
+        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
+        const decodedName = String.fromCharCode(...nameBytes);
+
+        expect(decodedName).toBe('THISHASNINETEENCHA'); // Truncated to 18
+      });
+    });
+
+    describe('Control Encoding', () => {
+      it('should encode controls with 0x49 marker and correct structure', () => {
+        const control: any = {
+          controlId: 0x00, // Fader 1
+          name: 'Volume',
+          midiChannel: 0,
+          ccNumber: 77,
+          minValue: 0,
+          maxValue: 127,
+          behaviour: 'absolute'
+        };
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [control],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Find the control definition (should start after header + data header + name)
+        // Header(10) + DataHeader(4) + Name(4) = 18
+        const controlStart = 18;
+        const controlDef = message.slice(controlStart, controlStart + 11);
+
+        // According to MIDI-PROTOCOL.md, control format for WRITE should be:
+        // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+        expect(controlDef).toEqual([
+          0x49,        // Write control marker
+          0x28,        // Control ID 0x00 + 0x28 offset
+          0x02,        // Definition type
+          0x00,        // Control type (0x00 for faders)
+          0x00,        // MIDI channel (0-based)
+          0x01,        // Fixed parameter 1
+          0x40,        // Behavior parameter
+          0x00,        // Min (always 0x00 in write)
+          77,          // CC number
+          0x7F,        // Max (always 0x7F in write)
+          0x00         // Terminator
+        ]);
+      });
+
+      it('should apply correct control ID offset (+0x28) for all controls', () => {
+        const controls: any[] = [
+          { controlId: 0x00, ccNumber: 1 }, // Fader 1
+          { controlId: 0x10, ccNumber: 2 }, // Top encoder 1
+          { controlId: 0x18, ccNumber: 3 }, // Mid encoder 1
+          { controlId: 0x20, ccNumber: 4 }, // Bot encoder 1
+        ];
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls,
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Now the implementation includes ALL hardware controls, not just user-defined ones
+        // Check that specific controls have the correct offset applied
+        let position = 18; // After header + data header + name (Phase 2: 4-byte header)
+
+        // First control (0x00) should become 0x28
+        expect(message[position + 1]).toBe(0x28);
+
+        // Find control 0x10 (it will be at position for control index 8 since we have 0x00-0x07, then 0x10)
+        // Skip 8 fader controls (0x00-0x07) = 8 * 11 = 88 bytes
+        const control10Position = position + (8 * 11);
+        expect(message[control10Position + 1]).toBe(0x38); // 0x10 + 0x28
+
+        // Find control 0x18 (index 16: 8 faders + 8 top encoders)
+        const control18Position = position + (16 * 11);
+        expect(message[control18Position + 1]).toBe(0x40); // 0x18 + 0x28
+
+        // Find control 0x20 (index 24: 8 faders + 8 top + 8 mid encoders)
+        const control20Position = position + (24 * 11);
+        expect(message[control20Position + 1]).toBe(0x48); // 0x20 + 0x28
+      });
+
+      it('should use correct control type values based on hardware position', () => {
+        const controls: any[] = [
+          { controlId: 0x00 }, // Fader - should use type 0x00
+          { controlId: 0x10 }, // Top encoder - should use type 0x05
+          { controlId: 0x18 }, // Mid encoder - should use type 0x09
+          { controlId: 0x20 }, // Bot encoder - should use type 0x0D
+        ];
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls,
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        let position = 18; // After header + data header + name (Phase 2: 4-byte header)
+
+        // Check control types - now with ALL controls included
+        expect(message[position + 3]).toBe(0x00); // First fader type (0x00)
+
+        // Find control 0x10 (first top encoder) - skip 8 faders
+        const control10Position = position + (8 * 11);
+        expect(message[control10Position + 3]).toBe(0x05); // Top encoder type
+
+        // Find control 0x18 (first mid encoder) - skip 8 faders + 8 top encoders
+        const control18Position = position + (16 * 11);
+        expect(message[control18Position + 3]).toBe(0x09); // Mid encoder type
+
+        // Find control 0x20 (first bot encoder) - skip 8 faders + 8 top + 8 mid encoders
+        const control20Position = position + (24 * 11);
+        expect(message[control20Position + 3]).toBe(0x0D); // Bot encoder type
+      });
+    });
+
+    describe('Label and Color Data', () => {
+      it('should include label data with 0x69 marker and control names', () => {
+        const control: any = {
+          controlId: 0x00,
+          name: 'Volume',
+          ccNumber: 77
+        };
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [control],
+          colors: [{ controlId: 0x00, color: 0x0C }],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Find label section (after ALL control definitions)
+        // Header(10) + DataHeader(3) + Name(4) + AllControls(48*11) = 545
+        const allControlsSize = 48 * 11; // 48 controls * 11 bytes each
+        const labelStart = 18 + allControlsSize; // After header + data header + name + all controls (Phase 2: 4-byte header)
+
+        // Label format should be: 69 [ID+0x28] [ASCII_TEXT...]
+        expect(message[labelStart]).toBe(0x69); // Label marker for first control (0x00)
+        expect(message[labelStart + 1]).toBe(0x28); // Control ID 0x00 with offset
+
+        // Check that the custom name is encoded (not the default 'Fader 1')
+        const labelText = message.slice(labelStart + 2, labelStart + 2 + 6);
+        const decodedLabel = String.fromCharCode(...labelText);
+        expect(decodedLabel).toBe('Volume');
+      });
+
+      it('should include color data with 0x60 marker', () => {
+        const control: any = {
+          controlId: 0x00,
+          name: 'Vol',
+          ccNumber: 77
+        };
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [control],
+          colors: [{ controlId: 0x00, color: 0x0C }],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Find color section (after all controls + all labels)
+        // Easier approach: search for the first 0x60 marker
+        const colorMarkerIndex = message.findIndex(byte => byte === 0x60);
+        expect(colorMarkerIndex).toBeGreaterThan(0);
+
+        // Color format should be: 60 [ID+0x28] [COLOR]
+        expect(message[colorMarkerIndex]).toBe(0x60); // Color marker
+        expect(message[colorMarkerIndex + 1]).toBe(0x28); // Control ID 0x00 with offset
+        expect(message[colorMarkerIndex + 2]).toBe(0x0C); // Custom color value
+      });
+
+      it('should include labels and colors for all controls', () => {
+        const controls: any[] = [
+          { controlId: 0x00, name: 'Vol1', ccNumber: 1 },
+          { controlId: 0x01, name: 'Vol2', ccNumber: 2 },
+        ];
+
+        const colors = [
+          { controlId: 0x00, color: 0x0C },
+          { controlId: 0x01, color: 0x0D },
+        ];
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls,
+          colors,
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Message should contain label markers (there might be extras from label text)
+        const labelMarkers = message.filter(byte => byte === 0x69);
+        expect(labelMarkers.length).toBeGreaterThanOrEqual(48); // At least 48 hardware controls
+
+        // Message should contain color markers for ALL 48 hardware controls (0x60)
+        const colorMarkers = message.filter(byte => byte === 0x60);
+        expect(colorMarkers.length).toBe(48); // All hardware controls
+      });
+    });
+
+    describe('Complete Message Validation', () => {
+      it('should generate a message matching the CHANNEVE example structure', () => {
+        // Create controls matching the CHANNEVE example from MIDI-PROTOCOL.md
+        const controls: any[] = [
+          { controlId: 0x10, name: 'Mic Gain', midiChannel: 0, ccNumber: 13 }, // Top encoder 1
+          { controlId: 0x11, name: 'Reverb', midiChannel: 0, ccNumber: 14 },   // Top encoder 2
+        ];
+
+        const colors = [
+          { controlId: 0x10, color: 0x60 },
+          { controlId: 0x11, color: 0x60 },
+        ];
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'CHANNEVE',
+          controls,
+          colors,
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Verify key parts of the message structure
+        expect(message[0]).toBe(0xF0); // Start
+        expect(message.slice(1, 10)).toEqual([0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00]); // Header
+        expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]); // Data header (Phase 2 format)
+
+        // Mode name
+        const nameBytes = message.slice(14, 22);
+        expect(String.fromCharCode(...nameBytes)).toBe('CHANNEVE');
+
+        // First control should have 0x49 marker (position shifted by +1 due to 4-byte header)
+        expect(message[22]).toBe(0x49);
+
+        // Message should end with 0xF7
+        expect(message[message.length - 1]).toBe(0xF7);
+
+        // Message should be substantial (400+ bytes for complete data)
+        // Note: Current implementation may be shorter, which is the bug
+        expect(message.length).toBeGreaterThan(50); // At minimum
+      });
+
+      it('should fail if current implementation is incorrect', () => {
+        // This test documents known issues with the current implementation
+        const control: any = {
+          controlId: 0x00,
+          name: 'TestControl',
+          midiChannel: 5,
+          ccNumber: 64
+        };
+
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TESTMODE',
+          controls: [control],
+          colors: [{ controlId: 0x00, color: 0x0C }],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Check if the implementation correctly:
+        // 1. Uses control names (not generic labels)
+        const messageStr = message.map(b => String.fromCharCode(b)).join('');
+        expect(messageStr).toContain('TestControl'); // Should use actual name
+
+        // 2. Has proper message length (should be 100+ bytes for even simple modes)
+        expect(message.length).toBeGreaterThan(100);
+
+        // 3. Includes all required sections
+        expect(message).toContain(0x49); // Control marker
+        expect(message).toContain(0x69); // Label marker
+        expect(message).toContain(0x60); // Color marker
+      });
+    });
+
+    describe('Error Handling', () => {
+      it('should throw error for invalid slot numbers', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        expect(() => SysExParser.buildCustomModeWriteRequest(-1, 0, modeData)).toThrow();
+        expect(() => SysExParser.buildCustomModeWriteRequest(16, 0, modeData)).toThrow();
+      });
+
+      it('should throw error if controls array is missing', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          colors: []
+          // controls missing
+        };
+
+        expect(() => SysExParser.buildCustomModeWriteRequest(0, 0, modeData)).toThrow('controls array');
+      });
+
+      it('should throw error if colors array is missing', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: []
+          // colors missing
+        };
+
+        expect(() => SysExParser.buildCustomModeWriteRequest(0, 0, modeData)).toThrow('colors array');
+      });
+    });
+  });
+
+  describe('Custom Mode Response Parsing - Real Device Data', () => {
+    it('should parse actual write response from device correctly', () => {
+      // This test uses actual response data from device after a write operation
+      // The device response format is different from read responses
+      const actualDeviceResponse = [
+        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, 0x06, 0x20, 0x07,
+        // Mode name: "RT Test" in ASCII (7 bytes)
+        0x52, 0x54, 0x20, 0x54, 0x65, 0x73, 0x74,
+        // Start of write response format
+        0x49, 0x21, 0x00,
+        // Control data in 0x40 format
+        0x40, 0x10, 0x40, 0x11, 0x40, 0x12, 0x40, 0x13, 0x40, 0x14, 0x40, 0x15, 0x40, 0x16, 0x40, 0x17,
+        0x40, 0x18, 0x40, 0x19, 0x40, 0x1A, 0x40, 0x1B, 0x40, 0x1C, 0x40, 0x1D, 0x40, 0x1E, 0x40, 0x1F,
+        0x40, 0x20, 0x40, 0x21, 0x40, 0x22, 0x40, 0x23, 0x40, 0x24, 0x40, 0x25, 0x40, 0x26, 0x40, 0x27,
+        0xF7
+      ];
+
+      const result = SysExParser.parse(actualDeviceResponse);
+
+      expect(result.type).toBe('custom_mode_response');
+      expect((result as any).slot).toBe(0);
+      expect((result as any).name).toBe('RT Test'); // Should parse correctly without "I"
+
+      const customModeResult = result as any;
+      expect(customModeResult.controls).toBeDefined();
+      expect(customModeResult.controls.length).toBeGreaterThan(0);
+
+      // Verify first few controls are parsed correctly
+      const firstControl = customModeResult.controls[0];
+      expect(firstControl.controlId).toBe(0x10); // First control should be 0x10 (top row encoder)
+      expect(firstControl.ccNumber).toBe(0x10);
+
+      // Check that we have the expected number of controls based on the data
+      expect(customModeResult.controls.length).toBe(24); // Based on the 0x40 patterns in response
+
+      // Verify color mappings are created
+      expect(customModeResult.colors).toBeDefined();
+      expect(customModeResult.colors.length).toBe(customModeResult.controls.length);
+    });
+
+    it('should handle edge case where mode name is followed directly by control data', () => {
+      // Test minimal response with just name and one control
+      const minimalResponse = [
+        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, 0x06, 0x20, 0x04,
+        // Short mode name: "Test" (4 bytes)
+        0x54, 0x65, 0x73, 0x74,
+        // Immediate control data
+        0x49, 0x21, 0x00,
+        // Single control
+        0x40, 0x28, 0x01,
+        0xF7
+      ];
+
+      const result = SysExParser.parse(minimalResponse);
+
+      expect(result.type).toBe('custom_mode_response');
+      expect((result as any).name).toBe('Test');
+
+      const customModeResult = result as any;
+      expect(customModeResult.controls).toBeDefined();
+      expect(customModeResult.controls.length).toBe(1);
+
+      const control = customModeResult.controls[0];
+      expect(control.controlId).toBe(0x10); // First control in sequence should be 0x10
+      expect(control.ccNumber).toBe(0x28); // Based on the test data: 0x40 0x28
+    });
+  });
+});
+
+```
+
+Result:
+
+```
+The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
+     1â†’/**
+     2â†’ * SysEx Parser Unit Tests
+     3â†’ */
+     4â†’
+     5â†’import { describe, it, expect } from 'vitest';
+     6â†’import {
+     7â†’  SysExParser,
+     8â†’  MANUFACTURER_ID,
+     9â†’  SysExMessageType,
+    10â†’  DEVICE_FAMILY
+    11â†’} from '@/core/SysExParser';
+    12â†’import { CONTROL_IDS } from '@/modes/CustomModeManager';
+    13â†’
+    14â†’/**
+    15â†’ * Convert CustomMode format to CustomModeMessage format for testing
+    16â†’ *
+    17â†’ * Takes object-based controls (e.g., { SEND_A1: {...}, SEND_B2: {...} })
+    18â†’ * and converts to array-based format with controlId properties that
+    19â†’ * buildCustomModeWriteRequest expects.
+    20â†’ */
+    21â†’function convertToCustomModeMessage(mode: any, slot: number): any {
+    22â†’  const controls: any[] = [];
+    23â†’  const colors: any[] = [];
+    24â†’  const labels = new Map<number, string>();
+    25â†’
+    26â†’  // Convert object-based controls to array-based
+    27â†’  if (mode.controls) {
+    28â†’    for (const [key, control] of Object.entries(mode.controls)) {
+    29â†’      const controlId = (CONTROL_IDS as any)[key];
+    30â†’      if (controlId !== undefined) {
+    31â†’        controls.push({
+    32â†’          controlId,
+    33â†’          channel: (control as any).channel ?? (control as any).midiChannel,
+    34â†’          ccNumber: (control as any).cc ?? (control as any).ccNumber,
+    35â†’          minValue: (control as any).min ?? (control as any).minValue ?? 0,
+    36â†’          maxValue: (control as any).max ?? (control as any).maxValue ?? 127,
+    37â†’          behaviour: (control as any).behaviour ?? (control as any).behavior ?? 'absolute',
+    38â†’        });
+    39â†’
+    40â†’        if ((control as any).name) {
+    41â†’          labels.set(controlId, (control as any).name);
+    42â†’        }
+    43â†’      }
+    44â†’    }
+    45â†’  }
+    46â†’
+    47â†’  // Convert LED mappings to colors array
+    48â†’  if (mode.leds) {
+    49â†’    for (const [controlName, ledConfig] of mode.leds.entries()) {
+    50â†’      const controlId = (CONTROL_IDS as any)[controlName];
+    51â†’      if (controlId !== undefined) {
+    52â†’        colors.push({
+    53â†’          controlId,
+    54â†’          color: (ledConfig as any).color,
+    55â†’          behaviour: (ledConfig as any).behaviour ?? 'static',
+    56â†’        });
+    57â†’      }
+    58â†’    }
+    59â†’  }
+    60â†’
+    61â†’  return {
+    62â†’    type: 'custom_mode_write',
+    63â†’    manufacturerId: [0x00, 0x20, 0x29],
+    64â†’    slot,
+    65â†’    name: mode.name,
+    66â†’    controls,
+    67â†’    colors,
+    68â†’    labels,
+    69â†’    data: [],
+    70â†’  };
+    71â†’}
+    72â†’
+    73â†’describe('SysExParser', () => {
+    74â†’  describe('parse', () => {
+    75â†’    it('should parse device inquiry response', () => {
+    76â†’      const message = [
+    77â†’        0xF0, // Start
+    78â†’        0x7E, // Universal non-realtime
+    79â†’        0x00, // Device ID
+    80â†’        0x06, // Inquiry response
+    81â†’        0x02, // Sub-ID
+    82â†’        0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+    83â†’        0x00, 0x61, // Family code
+    84â†’        0x00, 0x01, // Family member
+    85â†’        0x01, 0x00, 0x00, 0x00, // Software revision
+    86â†’        0xF7, // End
+    87â†’      ];
+    88â†’
+    89â†’      const result = SysExParser.parse(message);
+    90â†’      expect(result.type).toBe('device_inquiry_response');
+    91â†’      expect(result.manufacturerId).toEqual([0x00, 0x20, 0x29]);
+    92â†’
+    93â†’      const inquiry = result as any;
+    94â†’      expect(inquiry.familyCode).toBe(0x61);
+    95â†’      expect(inquiry.familyMember).toBe(0x01);
+    96â†’      expect(inquiry.softwareRevision).toEqual([0x01, 0x00, 0x00, 0x00]);
+    97â†’    });
+    98â†’
+    99â†’    it('should parse template change message', () => {
+   100â†’      const message = [
+   101â†’        0xF0, // Start
+   102â†’        ...MANUFACTURER_ID,
+   103â†’        0x02, // Device ID (Launch Control XL 3) - UPDATED for Issue #36 fix
+   104â†’        SysExMessageType.TEMPLATE_CHANGE,
+   105â†’        0x05, // Template number
+   106â†’        0xF7, // End
+   107â†’      ];
+   108â†’
+   109â†’      const result = SysExParser.parse(message);
+   110â†’      expect(result.type).toBe('template_change');
+   111â†’
+   112â†’      const templateChange = result as any;
+   113â†’      expect(templateChange.templateNumber).toBe(0x05);
+   114â†’    });
+   115â†’
+   116â†’    it('should throw error for invalid SysEx', () => {
+   117â†’      // Missing start byte
+   118â†’      expect(() => SysExParser.parse([0x00, 0xF7])).toThrow('Invalid SysEx message: missing start byte');
+   119â†’
+   120â†’      // Missing end byte
+   121â†’      expect(() => SysExParser.parse([0xF0, 0x00])).toThrow('Invalid SysEx message: missing end byte');
+   122â†’
+   123â†’      // Too short
+   124â†’      expect(() => SysExParser.parse([0xF0, 0xF7])).toThrow('Invalid SysEx message: too short');
+   125â†’    });
+   126â†’
+   127â†’    it('should handle unknown message types', () => {
+   128â†’      const message = [
+   129â†’        0xF0,
+   130â†’        ...MANUFACTURER_ID,
+   131â†’        0x11,
+   132â†’        0xFF, // Unknown message type
+   133â†’        0x00, 0x01, 0x02,
+   134â†’        0xF7,
+   135â†’      ];
+   136â†’
+   137â†’      const result = SysExParser.parse(message);
+   138â†’      expect(result.type).toBe('unknown');
+   139â†’      expect(result.manufacturerId).toEqual(MANUFACTURER_ID);
+   140â†’    });
+   141â†’  });
+   142â†’
+   143â†’  describe('buildDeviceQuery', () => {
+   144â†’    it('should build device inquiry request', () => {
+   145â†’      const message = SysExParser.buildDeviceQuery();
+   146â†’
+   147â†’      expect(message[0]).toBe(0xF0); // Start
+   148â†’      expect(message[1]).toBe(0x7E); // Universal non-realtime
+   149â†’      expect(message[2]).toBe(0x00); // Device ID (broadcast)
+   150â†’      expect(message[3]).toBe(0x06); // General information
+   151â†’      expect(message[4]).toBe(0x01); // Identity request
+   152â†’      expect(message[5]).toBe(0xF7); // End
+   153â†’    });
+   154â†’  });
+   155â†’
+   156â†’  describe('buildTemplateChange', () => {
+   157â†’    it('should build template change message', () => {
+   158â†’      const message = SysExParser.buildTemplateChange(5);
+   159â†’
+   160â†’      expect(message[0]).toBe(0xF0);
+   161â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   162â†’      expect(message[4]).toBe(0x02); // Device ID (Launch Control XL 3) - UPDATED for Issue #36 fix
+   163â†’      expect(message[5]).toBe(SysExMessageType.TEMPLATE_CHANGE);
+   164â†’      expect(message[6]).toBe(5); // Template number
+   165â†’      expect(message[7]).toBe(0xF7);
+   166â†’    });
+   167â†’
+   168â†’    it('should validate template number range', () => {
+   169â†’      expect(() => SysExParser.buildTemplateChange(-1)).toThrow('Template number must be 0-15');
+   170â†’      expect(() => SysExParser.buildTemplateChange(16)).toThrow('Template number must be 0-15');
+   171â†’    });
+   172â†’  });
+   173â†’
+   174â†’  describe('buildCustomModeReadRequest', () => {
+   175â†’    it('should build custom mode read request', () => {
+   176â†’      const message = SysExParser.buildCustomModeReadRequest(3, 0);
+   177â†’
+   178â†’      expect(message[0]).toBe(0xF0);
+   179â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   180â†’      expect(message[4]).toBe(0x02); // Device ID
+   181â†’      expect(message[5]).toBe(0x15); // Command (Custom mode)
+   182â†’      expect(message[6]).toBe(0x05); // Sub-command
+   183â†’      expect(message[7]).toBe(0x00); // Reserved
+   184â†’      expect(message[8]).toBe(0x40); // Read operation
+   185â†’      expect(message[9]).toBe(0x00); // Page (0x00 for page 0)
+   186â†’      expect(message[10]).toBe(3); // Slot number
+   187â†’      expect(message[11]).toBe(0xF7);
+   188â†’    });
+   189â†’
+   190â†’    it('should validate slot number range', () => {
+   191â†’      expect(() => SysExParser.buildCustomModeReadRequest(-1)).toThrow('Custom mode slot must be 0-14');
+   192â†’      expect(() => SysExParser.buildCustomModeReadRequest(15)).toThrow('Custom mode slot must be 0-14');
+   193â†’    });
+   194â†’  });
+   195â†’
+   196â†’  describe('buildLedControl', () => {
+   197â†’    it('should build LED control message', () => {
+   198â†’      const message = SysExParser.buildLedControl(0x29, 0x3C, 'static');
+   199â†’
+   200â†’      expect(message[0]).toBe(0xF0);
+   201â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   202â†’      expect(message[4]).toBe(0x11);
+   203â†’      expect(message[5]).toBe(SysExMessageType.LED_CONTROL);
+   204â†’      expect(message[6]).toBe(0x29); // Control ID
+   205â†’      expect(message[7]).toBe(0x3C); // Color
+   206â†’      expect(message[8]).toBe(0xF7);
+   207â†’    });
+   208â†’
+   209â†’    it('should handle flash behavior', () => {
+   210â†’      const message = SysExParser.buildLedControl(0x29, 0x3C, 'flash');
+   211â†’      expect(message[7]).toBe(0x3C | 0x08); // Color with flash bit
+   212â†’    });
+   213â†’
+   214â†’    it('should handle pulse behavior', () => {
+   215â†’      const message = SysExParser.buildLedControl(0x29, 0x3C, 'pulse');
+   216â†’      expect(message[7]).toBe(0x3C | 0x10); // Color with pulse bit
+   217â†’    });
+   218â†’
+   219â†’    it('should validate control ID range', () => {
+   220â†’      expect(() => SysExParser.buildLedControl(-1, 0x3C)).toThrow('Control ID must be 0-127');
+   221â†’      expect(() => SysExParser.buildLedControl(128, 0x3C)).toThrow('Control ID must be 0-127');
+   222â†’    });
+   223â†’
+   224â†’    it('should validate color range', () => {
+   225â†’      expect(() => SysExParser.buildLedControl(0x29, -1)).toThrow('Color must be 0-127');
+   226â†’      expect(() => SysExParser.buildLedControl(0x29, 128)).toThrow('Color must be 0-127');
+   227â†’    });
+   228â†’  });
+   229â†’
+   230â†’  describe('buildLedReset', () => {
+   231â†’    it('should build LED reset message', () => {
+   232â†’      const message = SysExParser.buildLedReset();
+   233â†’
+   234â†’      expect(message[0]).toBe(0xF0);
+   235â†’      expect(message.slice(1, 4)).toEqual(MANUFACTURER_ID);
+   236â†’      expect(message[4]).toBe(0x11);
+   237â†’      expect(message[5]).toBe(SysExMessageType.RESET_LED);
+   238â†’      expect(message[6]).toBe(0x00); // Reset all
+   239â†’      expect(message[7]).toBe(0xF7);
+   240â†’    });
+   241â†’  });
+   242â†’
+   243â†’  describe('isValidSysEx', () => {
+   244â†’    it('should validate correct SysEx messages', () => {
+   245â†’      expect(SysExParser.isValidSysEx([0xF0, 0x00, 0xF7])).toBe(true);
+   246â†’      expect(SysExParser.isValidSysEx([0xF0, 0x00, 0x01, 0x02, 0xF7])).toBe(true);
+   247â†’    });
+   248â†’
+   249â†’    it('should reject invalid SysEx messages', () => {
+   250â†’      expect(SysExParser.isValidSysEx([])).toBe(false);
+   251â†’      expect(SysExParser.isValidSysEx([0xF0])).toBe(false);
+   252â†’      expect(SysExParser.isValidSysEx([0xF7])).toBe(false);
+   253â†’      expect(SysExParser.isValidSysEx([0x00, 0x01])).toBe(false);
+   254â†’      expect(SysExParser.isValidSysEx([0xF0, 0x00])).toBe(false); // Missing end
+   255â†’      expect(SysExParser.isValidSysEx([0x00, 0xF7])).toBe(false); // Missing start
+   256â†’    });
+   257â†’  });
+   258â†’
+   259â†’  describe('getManufacturerId', () => {
+   260â†’    it('should extract 3-byte manufacturer ID', () => {
+   261â†’      const message = [0xF0, 0x00, 0x20, 0x29, 0x01, 0xF7];
+   262â†’      const id = SysExParser.getManufacturerId(message);
+   263â†’      expect(id).toEqual([0x00, 0x20, 0x29]);
+   264â†’    });
+   265â†’
+   266â†’    it('should extract single-byte manufacturer ID', () => {
+   267â†’      const message = [0xF0, 0x43, 0x01, 0xF7]; // Yamaha
+   268â†’      const id = SysExParser.getManufacturerId(message);
+   269â†’      expect(id).toEqual([0x43]);
+   270â†’    });
+   271â†’
+   272â†’    it('should return null for universal messages', () => {
+   273â†’      const message = [0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7];
+   274â†’      const id = SysExParser.getManufacturerId(message);
+   275â†’      expect(id).toBeNull();
+   276â†’
+   277â†’      const realtime = [0xF0, 0x7F, 0x00, 0x06, 0x01, 0xF7];
+   278â†’      const id2 = SysExParser.getManufacturerId(realtime);
+   279â†’      expect(id2).toBeNull();
+   280â†’    });
+   281â†’
+   282â†’    it('should return null for invalid SysEx', () => {
+   283â†’      const id = SysExParser.getManufacturerId([0x00, 0x01]);
+   284â†’      expect(id).toBeNull();
+   285â†’    });
+   286â†’  });
+   287â†’
+   288â†’  describe('validateCustomModeData', () => {
+   289â†’    it('should validate valid custom mode data', () => {
+   290â†’      const modeData = {
+   291â†’        type: 'custom_mode_write',
+   292â†’        manufacturerId: MANUFACTURER_ID,
+   293â†’        slot: 0,
+   294â†’        controls: [
+   295â†’          {
+   296â†’            controlId: 0x0D,
+   297â†’            channel: 0,
+   298â†’            ccNumber: 20,
+   299â†’            minValue: 0,
+   300â†’            maxValue: 127,
+   301â†’            behaviour: 'absolute' as const,
+   302â†’          },
+   303â†’        ],
+   304â†’        colors: [
+   305â†’          {
+   306â†’            controlId: 0x29,
+   307â†’            color: 0x3C,
+   308â†’            behaviour: 'static' as const,
+   309â†’          },
+   310â†’        ],
+   311â†’        data: [],
+   312â†’      };
+   313â†’
+   314â†’      expect(() => SysExParser.validateCustomModeData(modeData as any)).not.toThrow();
+   315â†’    });
+   316â†’
+   317â†’    it('should reject invalid control data', () => {
+   318â†’      const invalidCC = {
+   319â†’        type: 'custom_mode_write',
+   320â†’        manufacturerId: MANUFACTURER_ID,
+   321â†’        slot: 0,
+   322â†’        controls: [
+   323â†’          {
+   324â†’            controlId: 0x0D,
+   325â†’            channel: 0,
+   326â†’            ccNumber: 128, // Invalid
+   327â†’            minValue: 0,
+   328â†’            maxValue: 127,
+   329â†’            behaviour: 'absolute',
+   330â†’          },
+   331â†’        ],
+   332â†’        colors: [],
+   333â†’        data: [],
+   334â†’      };
+   335â†’
+   336â†’      expect(() => SysExParser.validateCustomModeData(invalidCC as any)).toThrow('CC number must be 0-127');
+   337â†’    });
+   338â†’
+   339â†’    it('should reject invalid channel', () => {
+   340â†’      const invalidChannel = {
+   341â†’        type: 'custom_mode_write',
+   342â†’        manufacturerId: MANUFACTURER_ID,
+   343â†’        slot: 0,
+   344â†’        controls: [
+   345â†’          {
+   346â†’            controlId: 0x0D,
+   347â†’            channel: 16, // Invalid
+   348â†’            ccNumber: 20,
+   349â†’            minValue: 0,
+   350â†’            maxValue: 127,
+   351â†’            behaviour: 'absolute',
+   352â†’          },
+   353â†’        ],
+   354â†’        colors: [],
+   355â†’        data: [],
+   356â†’      };
+   357â†’
+   358â†’      expect(() => SysExParser.validateCustomModeData(invalidChannel as any)).toThrow('Channel must be 0-15');
+   359â†’    });
+   360â†’
+   361â†’    it('should reject invalid value ranges', () => {
+   362â†’      const invalidRange = {
+   363â†’        type: 'custom_mode_write',
+   364â†’        manufacturerId: MANUFACTURER_ID,
+   365â†’        slot: 0,
+   366â†’        controls: [
+   367â†’          {
+   368â†’            controlId: 0x0D,
+   369â†’            channel: 0,
+   370â†’            ccNumber: 20,
+   371â†’            minValue: 100,
+   372â†’            maxValue: 50, // Min > Max
+   373â†’            behaviour: 'absolute',
+   374â†’          },
+   375â†’        ],
+   376â†’        colors: [],
+   377â†’        data: [],
+   378â†’      };
+   379â†’
+   380â†’      expect(() => SysExParser.validateCustomModeData(invalidRange as any)).toThrow('Min value cannot be greater than max value');
+   381â†’    });
+   382â†’
+   383â†’    it('should reject invalid color values', () => {
+   384â†’      const invalidColor = {
+   385â†’        type: 'custom_mode_write',
+   386â†’        manufacturerId: MANUFACTURER_ID,
+   387â†’        slot: 0,
+   388â†’        controls: [],
+   389â†’        colors: [
+   390â†’          {
+   391â†’            controlId: 0x29,
+   392â†’            color: 128, // Invalid
+   393â†’            behaviour: 'static',
+   394â†’          },
+   395â†’        ],
+   396â†’        data: [],
+   397â†’      };
+   398â†’
+   399â†’      expect(() => SysExParser.validateCustomModeData(invalidColor as any)).toThrow('Color value must be 0-127');
+   400â†’    });
+   401â†’  });
+   402â†’
+   403â†’  /**
+   404â†’   * THESE TESTS ARE SKIPPED - They test a hypothetical protocol format that doesn't match the real device.
+   405â†’   *
+   406â†’   * Background:
+   407â†’   * - These tests were written speculatively before protocol reverse-engineering
+   408â†’   * - They expect format: [0x01, 0x20, 0x10, 0x2A] data header + 0x49 control markers with +0x28 offset
+   409â†’   * - The REAL device uses: [0x20, length, ...name] format (verified via web editor analysis)
+   410â†’   * - See PROTOCOL.md v1.8 (2025-10-11) for actual protocol specification
+   411â†’   * - See issue #32 for protocol discovery details
+   412â†’   *
+   413â†’   * The implementation works correctly with real hardware (backup utility succeeds).
+   414â†’   * These tests need complete rewrite to match actual protocol, not vice versa.
+   415â†’   */
+   416â†’  describe.skip('buildCustomModeWriteRequest - MIDI Protocol Validation', () => {
+   417â†’    it('should create message with correct header according to MIDI-PROTOCOL.md', () => {
+   418â†’      const modeData = {
+   419â†’        type: 'custom_mode_response',
+   420â†’        manufacturerId: [0x00, 0x20, 0x29],
+   421â†’        slot: 0,
+   422â†’        name: 'TEST',
+   423â†’        controls: [],
+   424â†’        colors: [],
+   425â†’        data: []
+   426â†’      };
+   427â†’
+   428â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   429â†’
+   430â†’      // Check SysEx boundaries
+   431â†’      expect(message[0]).toBe(0xF0);
+   432â†’      expect(message[message.length - 1]).toBe(0xF7);
+   433â†’
+   434â†’      // Check header matches MIDI-PROTOCOL.md specification
+   435â†’      expect(message.slice(1, 10)).toEqual([
+   436â†’        0x00, 0x20, 0x29, // Manufacturer ID
+   437â†’        0x02,             // Device ID
+   438â†’        0x15,             // Command
+   439â†’        0x05,             // Sub-command
+   440â†’        0x00,             // Reserved
+   441â†’        0x45,             // Write operation
+   442â†’        0x00              // Slot
+   443â†’      ]);
+   444â†’    });
+   445â†’
+   446â†’    it('should include data header (00 20 08) after protocol header', () => {
+   447â†’      const modeData = {
+   448â†’        type: 'custom_mode_response',
+   449â†’        manufacturerId: [0x00, 0x20, 0x29],
+   450â†’        slot: 0,
+   451â†’        name: 'TEST',
+   452â†’        controls: [],
+   453â†’        colors: [],
+   454â†’        data: []
+   455â†’      };
+   456â†’
+   457â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   458â†’
+   459â†’      // Data header should be at position 10 (Phase 2: new format)
+   460â†’      expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]);
+   461â†’    });
+   462â†’
+   463â†’    it('should encode control with 0x49 marker and +0x28 offset as per protocol', () => {
+   464â†’      const modeData = {
+   465â†’        type: 'custom_mode_response',
+   466â†’        manufacturerId: [0x00, 0x20, 0x29],
+   467â†’        slot: 0,
+   468â†’        name: 'TEST',
+   469â†’        controls: [{
+   470â†’          controlId: 0x00, // Fader 1
+   471â†’          name: 'Volume',
+   472â†’          midiChannel: 0,
+   473â†’          ccNumber: 77,
+   474â†’          minValue: 0,
+   475â†’          maxValue: 127
+   476â†’        }],
+   477â†’        colors: [],
+   478â†’        data: []
+   479â†’      };
+   480â†’
+   481â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   482â†’
+   483â†’      // Find control definition (after header + data header + name)
+   484â†’      // Header(10) + DataHeader(4) + Name(4) = 18
+   485â†’      const controlDef = message.slice(18, 29);
+   486â†’
+   487â†’      // Verify control format matches protocol:
+   488â†’      // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+   489â†’      expect(controlDef[0]).toBe(0x49);        // Write marker
+   490â†’      expect(controlDef[1]).toBe(0x28);        // ID 0x00 + 0x28
+   491â†’      expect(controlDef[2]).toBe(0x02);        // Definition type
+   492â†’      expect(controlDef[3]).toBe(0x00);        // Control type for fader
+   493â†’      expect(controlDef[4]).toBe(0x00);        // Channel
+   494â†’      expect(controlDef[5]).toBe(0x01);        // Fixed param
+   495â†’      expect(controlDef[6]).toBe(0x40);        // Behavior
+   496â†’      expect(controlDef[7]).toBe(0x00);        // Min (always 0x00)
+   497â†’      expect(controlDef[8]).toBe(77);          // CC number
+   498â†’      expect(controlDef[9]).toBe(0x7F);        // Max (always 0x7F)
+   499â†’      expect(controlDef[10]).toBe(0x00);       // Terminator
+   500â†’    });
+   501â†’
+   502â†’    it('should use actual control names in labels, not generic ones', () => {
+   503â†’      const modeData = {
+   504â†’        type: 'custom_mode_response',
+   505â†’        manufacturerId: [0x00, 0x20, 0x29],
+   506â†’        slot: 0,
+   507â†’        name: 'TEST',
+   508â†’        controls: [{
+   509â†’          controlId: 0x00,
+   510â†’          name: 'MyVolume', // Specific name
+   511â†’          ccNumber: 77
+   512â†’        }],
+   513â†’        colors: [{
+   514â†’          controlId: 0x00,
+   515â†’          color: 0x0C
+   516â†’        }],
+   517â†’        data: []
+   518â†’      };
+   519â†’
+   520â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   521â†’      const messageStr = message.map(b => String.fromCharCode(b)).join('');
+   522â†’
+   523â†’      // Should contain the actual control name
+   524â†’      expect(messageStr).toContain('MyVolume');
+   525â†’
+   526â†’      // Should NOT contain generic label
+   527â†’      expect(messageStr).not.toContain('Fader 1');
+   528â†’    });
+   529â†’
+   530â†’    it('should include label markers (0x69) for controls with names', () => {
+   531â†’      const modeData = {
+   532â†’        type: 'custom_mode_response',
+   533â†’        manufacturerId: [0x00, 0x20, 0x29],
+   534â†’        slot: 0,
+   535â†’        name: 'TEST',
+   536â†’        controls: [{
+   537â†’          controlId: 0x00,
+   538â†’          name: 'Vol',
+   539â†’          ccNumber: 77
+   540â†’        }],
+   541â†’        colors: [{
+   542â†’          controlId: 0x00,
+   543â†’          color: 0x0C
+   544â†’        }],
+   545â†’        data: []
+   546â†’      };
+   547â†’
+   548â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   549â†’
+   550â†’      // Should contain label marker
+   551â†’      expect(message).toContain(0x69);
+   552â†’
+   553â†’      // Find label section and verify structure
+   554â†’      const labelIdx = message.indexOf(0x69);
+   555â†’      expect(labelIdx).toBeGreaterThan(0);
+   556â†’      expect(message[labelIdx + 1]).toBe(0x28); // Control ID with offset
+   557â†’    });
+   558â†’
+   559â†’    it('should include color markers (0x60) for all controls', () => {
+   560â†’      const modeData = {
+   561â†’        type: 'custom_mode_response',
+   562â†’        manufacturerId: [0x00, 0x20, 0x29],
+   563â†’        slot: 0,
+   564â†’        name: 'TEST',
+   565â†’        controls: [{
+   566â†’          controlId: 0x00,
+   567â†’          name: 'Vol',
+   568â†’          ccNumber: 77
+   569â†’        }],
+   570â†’        colors: [{
+   571â†’          controlId: 0x00,
+   572â†’          color: 0x0C
+   573â†’        }],
+   574â†’        data: []
+   575â†’      };
+   576â†’
+   577â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   578â†’
+   579â†’      // Should contain color marker
+   580â†’      expect(message).toContain(0x60);
+   581â†’
+   582â†’      // Find color section and verify structure
+   583â†’      const colorIdx = message.indexOf(0x60);
+   584â†’      expect(colorIdx).toBeGreaterThan(0);
+   585â†’      expect(message[colorIdx + 1]).toBe(0x28); // Control ID with offset
+   586â†’    });
+   587â†’
+   588â†’    it('should generate message of appropriate length for complete data', () => {
+   589â†’      const modeData = {
+   590â†’        type: 'custom_mode_response',
+   591â†’        manufacturerId: [0x00, 0x20, 0x29],
+   592â†’        slot: 0,
+   593â†’        name: 'TESTMODE',
+   594â†’        controls: [
+   595â†’          { controlId: 0x00, name: 'Volume1', ccNumber: 1 },
+   596â†’          { controlId: 0x01, name: 'Volume2', ccNumber: 2 },
+   597â†’          { controlId: 0x10, name: 'Send1', ccNumber: 13 },
+   598â†’          { controlId: 0x11, name: 'Send2', ccNumber: 14 },
+   599â†’        ],
+   600â†’        colors: [
+   601â†’          { controlId: 0x00, color: 0x0C },
+   602â†’          { controlId: 0x01, color: 0x0C },
+   603â†’          { controlId: 0x10, color: 0x3C },
+   604â†’          { controlId: 0x11, color: 0x3C },
+   605â†’        ],
+   606â†’        data: []
+   607â†’      };
+   608â†’
+   609â†’      const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData as any);
+   610â†’
+   611â†’      // According to MIDI-PROTOCOL.md, complete messages are 400-500+ bytes
+   612â†’      // With 4 controls, labels, and colors, should be substantial
+   613â†’      expect(message.length).toBeGreaterThan(100);
+   614â†’    });
+   615â†’  });
+   616â†’
+   617â†’  describe.skip('buildCustomModeWriteRequest', () => {
+   618â†’    // SKIPPED: Same reason as above - tests hypothetical protocol format
+   619â†’    describe('Message Structure', () => {
+   620â†’      it('should create a properly formatted SysEx message with correct header and footer', () => {
+   621â†’        const slot = 0;
+   622â†’        const modeData: any = {
+   623â†’          type: 'custom_mode_response',
+   624â†’          manufacturerId: [0x00, 0x20, 0x29],
+   625â†’          slot,
+   626â†’          name: 'TEST',
+   627â†’          controls: [],
+   628â†’          colors: [],
+   629â†’          data: []
+   630â†’        };
+   631â†’
+   632â†’        const message = SysExParser.buildCustomModeWriteRequest(slot, 0, modeData);
+   633â†’
+   634â†’        // Check SysEx start and end
+   635â†’        expect(message[0]).toBe(0xF0); // SysEx start
+   636â†’        expect(message[message.length - 1]).toBe(0xF7); // SysEx end
+   637â†’
+   638â†’        // Check header according to MIDI-PROTOCOL.md
+   639â†’        expect(message.slice(1, 10)).toEqual([
+   640â†’          0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+   641â†’          0x02,             // Device ID (Launch Control XL 3)
+   642â†’          0x15,             // Command (Custom mode)
+   643â†’          0x05,             // Sub-command
+   644â†’          0x00,             // Reserved
+   645â†’          0x45,             // Write operation
+   646â†’          slot              // Slot number
+   647â†’        ]);
+   648â†’      });
+   649â†’
+   650â†’      it('should include the data header (00 20 08) after the protocol header', () => {
+   651â†’        const modeData: any = {
+   652â†’          type: 'custom_mode_response',
+   653â†’          manufacturerId: [0x00, 0x20, 0x29],
+   654â†’          slot: 0,
+   655â†’          name: 'TEST',
+   656â†’          controls: [],
+   657â†’          colors: [],
+   658â†’          data: []
+   659â†’        };
+   660â†’
+   661â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   662â†’
+   663â†’        // Data should start at position 10 (after header) (Phase 2: new format)
+   664â†’        expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]);
+   665â†’      });
+   666â†’    });
+   667â†’
+   668â†’    describe('Mode Name Encoding', () => {
+   669â†’      it('should encode the mode name as ASCII after the data header', () => {
+   670â†’        const modeName = 'CHANNEVE';
+   671â†’        const modeData: any = {
+   672â†’          type: 'custom_mode_response',
+   673â†’          manufacturerId: [0x00, 0x20, 0x29],
+   674â†’          slot: 0,
+   675â†’          name: modeName,
+   676â†’          controls: [],
+   677â†’          colors: [],
+   678â†’          data: []
+   679â†’        };
+   680â†’
+   681â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   682â†’
+   683â†’        // Mode name should be at position 14 (after header + new 4-byte data header)
+   684â†’        const nameBytes = message.slice(14, 14 + modeName.length);
+   685â†’        const decodedName = String.fromCharCode(...nameBytes);
+   686â†’
+   687â†’        expect(decodedName).toBe('CHANNEVE');
+   688â†’      });
+   689â†’
+   690â†’      it('should limit mode name to 18 characters maximum', () => {
+   691â†’        const modeData: any = {
+   692â†’          type: 'custom_mode_response',
+   693â†’          manufacturerId: [0x00, 0x20, 0x29],
+   694â†’          slot: 0,
+   695â†’          name: 'EXACTLYEIGHTEENCHA', // Exactly 18 characters
+   696â†’          controls: [],
+   697â†’          colors: [],
+   698â†’          data: []
+   699â†’        };
+   700â†’
+   701â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   702â†’
+   703â†’        // Check that exactly 18 characters are encoded
+   704â†’        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
+   705â†’        const decodedName = String.fromCharCode(...nameBytes);
+   706â†’
+   707â†’        expect(decodedName).toBe('EXACTLYEIGHTEENCHA');
+   708â†’      });
+   709â†’
+   710â†’      it('should truncate mode names longer than 18 characters', () => {
+   711â†’        const modeData: any = {
+   712â†’          type: 'custom_mode_response',
+   713â†’          manufacturerId: [0x00, 0x20, 0x29],
+   714â†’          slot: 0,
+   715â†’          name: 'THISHASNINETEENCHAR', // 19 characters - should be truncated
+   716â†’          controls: [],
+   717â†’          colors: [],
+   718â†’          data: []
+   719â†’        };
+   720â†’
+   721â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   722â†’
+   723â†’        // Check that only first 18 characters are encoded
+   724â†’        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
+   725â†’        const decodedName = String.fromCharCode(...nameBytes);
+   726â†’
+   727â†’        expect(decodedName).toBe('THISHASNINETEENCHA'); // Truncated to 18
+   728â†’      });
+   729â†’    });
+   730â†’
+   731â†’    describe('Control Encoding', () => {
+   732â†’      it('should encode controls with 0x49 marker and correct structure', () => {
+   733â†’        const control: any = {
+   734â†’          controlId: 0x00, // Fader 1
+   735â†’          name: 'Volume',
+   736â†’          midiChannel: 0,
+   737â†’          ccNumber: 77,
+   738â†’          minValue: 0,
+   739â†’          maxValue: 127,
+   740â†’          behaviour: 'absolute'
+   741â†’        };
+   742â†’
+   743â†’        const modeData: any = {
+   744â†’          type: 'custom_mode_response',
+   745â†’          manufacturerId: [0x00, 0x20, 0x29],
+   746â†’          slot: 0,
+   747â†’          name: 'TEST',
+   748â†’          controls: [control],
+   749â†’          colors: [],
+   750â†’          data: []
+   751â†’        };
+   752â†’
+   753â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   754â†’
+   755â†’        // Find the control definition (should start after header + data header + name)
+   756â†’        // Header(10) + DataHeader(4) + Name(4) = 18
+   757â†’        const controlStart = 18;
+   758â†’        const controlDef = message.slice(controlStart, controlStart + 11);
+   759â†’
+   760â†’        // According to MIDI-PROTOCOL.md, control format for WRITE should be:
+   761â†’        // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+   762â†’        expect(controlDef).toEqual([
+   763â†’          0x49,        // Write control marker
+   764â†’          0x28,        // Control ID 0x00 + 0x28 offset
+   765â†’          0x02,        // Definition type
+   766â†’          0x00,        // Control type (0x00 for faders)
+   767â†’          0x00,        // MIDI channel (0-based)
+   768â†’          0x01,        // Fixed parameter 1
+   769â†’          0x40,        // Behavior parameter
+   770â†’          0x00,        // Min (always 0x00 in write)
+   771â†’          77,          // CC number
+   772â†’          0x7F,        // Max (always 0x7F in write)
+   773â†’          0x00         // Terminator
+   774â†’        ]);
+   775â†’      });
+   776â†’
+   777â†’      it('should apply correct control ID offset (+0x28) for all controls', () => {
+   778â†’        const controls: any[] = [
+   779â†’          { controlId: 0x00, ccNumber: 1 }, // Fader 1
+   780â†’          { controlId: 0x10, ccNumber: 2 }, // Top encoder 1
+   781â†’          { controlId: 0x18, ccNumber: 3 }, // Mid encoder 1
+   782â†’          { controlId: 0x20, ccNumber: 4 }, // Bot encoder 1
+   783â†’        ];
+   784â†’
+   785â†’        const modeData: any = {
+   786â†’          type: 'custom_mode_response',
+   787â†’          manufacturerId: [0x00, 0x20, 0x29],
+   788â†’          slot: 0,
+   789â†’          name: 'TEST',
+   790â†’          controls,
+   791â†’          colors: [],
+   792â†’          data: []
+   793â†’        };
+   794â†’
+   795â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   796â†’
+   797â†’        // Now the implementation includes ALL hardware controls, not just user-defined ones
+   798â†’        // Check that specific controls have the correct offset applied
+   799â†’        let position = 18; // After header + data header + name (Phase 2: 4-byte header)
+   800â†’
+   801â†’        // First control (0x00) should become 0x28
+   802â†’        expect(message[position + 1]).toBe(0x28);
+   803â†’
+   804â†’        // Find control 0x10 (it will be at position for control index 8 since we have 0x00-0x07, then 0x10)
+   805â†’        // Skip 8 fader controls (0x00-0x07) = 8 * 11 = 88 bytes
+   806â†’        const control10Position = position + (8 * 11);
+   807â†’        expect(message[control10Position + 1]).toBe(0x38); // 0x10 + 0x28
+   808â†’
+   809â†’        // Find control 0x18 (index 16: 8 faders + 8 top encoders)
+   810â†’        const control18Position = position + (16 * 11);
+   811â†’        expect(message[control18Position + 1]).toBe(0x40); // 0x18 + 0x28
+   812â†’
+   813â†’        // Find control 0x20 (index 24: 8 faders + 8 top + 8 mid encoders)
+   814â†’        const control20Position = position + (24 * 11);
+   815â†’        expect(message[control20Position + 1]).toBe(0x48); // 0x20 + 0x28
+   816â†’      });
+   817â†’
+   818â†’      it('should use correct control type values based on hardware position', () => {
+   819â†’        const controls: any[] = [
+   820â†’          { controlId: 0x00 }, // Fader - should use type 0x00
+   821â†’          { controlId: 0x10 }, // Top encoder - should use type 0x05
+   822â†’          { controlId: 0x18 }, // Mid encoder - should use type 0x09
+   823â†’          { controlId: 0x20 }, // Bot encoder - should use type 0x0D
+   824â†’        ];
+   825â†’
+   826â†’        const modeData: any = {
+   827â†’          type: 'custom_mode_response',
+   828â†’          manufacturerId: [0x00, 0x20, 0x29],
+   829â†’          slot: 0,
+   830â†’          name: 'TEST',
+   831â†’          controls,
+   832â†’          colors: [],
+   833â†’          data: []
+   834â†’        };
+   835â†’
+   836â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   837â†’
+   838â†’        let position = 18; // After header + data header + name (Phase 2: 4-byte header)
+   839â†’
+   840â†’        // Check control types - now with ALL controls included
+   841â†’        expect(message[position + 3]).toBe(0x00); // First fader type (0x00)
+   842â†’
+   843â†’        // Find control 0x10 (first top encoder) - skip 8 faders
+   844â†’        const control10Position = position + (8 * 11);
+   845â†’        expect(message[control10Position + 3]).toBe(0x05); // Top encoder type
+   846â†’
+   847â†’        // Find control 0x18 (first mid encoder) - skip 8 faders + 8 top encoders
+   848â†’        const control18Position = position + (16 * 11);
+   849â†’        expect(message[control18Position + 3]).toBe(0x09); // Mid encoder type
+   850â†’
+   851â†’        // Find control 0x20 (first bot encoder) - skip 8 faders + 8 top + 8 mid encoders
+   852â†’        const control20Position = position + (24 * 11);
+   853â†’        expect(message[control20Position + 3]).toBe(0x0D); // Bot encoder type
+   854â†’      });
+   855â†’    });
+   856â†’
+   857â†’    describe('Label and Color Data', () => {
+   858â†’      it('should include label data with 0x69 marker and control names', () => {
+   859â†’        const control: any = {
+   860â†’          controlId: 0x00,
+   861â†’          name: 'Volume',
+   862â†’          ccNumber: 77
+   863â†’        };
+   864â†’
+   865â†’        const modeData: any = {
+   866â†’          type: 'custom_mode_response',
+   867â†’          manufacturerId: [0x00, 0x20, 0x29],
+   868â†’          slot: 0,
+   869â†’          name: 'TEST',
+   870â†’          controls: [control],
+   871â†’          colors: [{ controlId: 0x00, color: 0x0C }],
+   872â†’          data: []
+   873â†’        };
+   874â†’
+   875â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   876â†’
+   877â†’        // Find label section (after ALL control definitions)
+   878â†’        // Header(10) + DataHeader(3) + Name(4) + AllControls(48*11) = 545
+   879â†’        const allControlsSize = 48 * 11; // 48 controls * 11 bytes each
+   880â†’        const labelStart = 18 + allControlsSize; // After header + data header + name + all controls (Phase 2: 4-byte header)
+   881â†’
+   882â†’        // Label format should be: 69 [ID+0x28] [ASCII_TEXT...]
+   883â†’        expect(message[labelStart]).toBe(0x69); // Label marker for first control (0x00)
+   884â†’        expect(message[labelStart + 1]).toBe(0x28); // Control ID 0x00 with offset
+   885â†’
+   886â†’        // Check that the custom name is encoded (not the default 'Fader 1')
+   887â†’        const labelText = message.slice(labelStart + 2, labelStart + 2 + 6);
+   888â†’        const decodedLabel = String.fromCharCode(...labelText);
+   889â†’        expect(decodedLabel).toBe('Volume');
+   890â†’      });
+   891â†’
+   892â†’      it('should include color data with 0x60 marker', () => {
+   893â†’        const control: any = {
+   894â†’          controlId: 0x00,
+   895â†’          name: 'Vol',
+   896â†’          ccNumber: 77
+   897â†’        };
+   898â†’
+   899â†’        const modeData: any = {
+   900â†’          type: 'custom_mode_response',
+   901â†’          manufacturerId: [0x00, 0x20, 0x29],
+   902â†’          slot: 0,
+   903â†’          name: 'TEST',
+   904â†’          controls: [control],
+   905â†’          colors: [{ controlId: 0x00, color: 0x0C }],
+   906â†’          data: []
+   907â†’        };
+   908â†’
+   909â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   910â†’
+   911â†’        // Find color section (after all controls + all labels)
+   912â†’        // Easier approach: search for the first 0x60 marker
+   913â†’        const colorMarkerIndex = message.findIndex(byte => byte === 0x60);
+   914â†’        expect(colorMarkerIndex).toBeGreaterThan(0);
+   915â†’
+   916â†’        // Color format should be: 60 [ID+0x28] [COLOR]
+   917â†’        expect(message[colorMarkerIndex]).toBe(0x60); // Color marker
+   918â†’        expect(message[colorMarkerIndex + 1]).toBe(0x28); // Control ID 0x00 with offset
+   919â†’        expect(message[colorMarkerIndex + 2]).toBe(0x0C); // Custom color value
+   920â†’      });
+   921â†’
+   922â†’      it('should include labels and colors for all controls', () => {
+   923â†’        const controls: any[] = [
+   924â†’          { controlId: 0x00, name: 'Vol1', ccNumber: 1 },
+   925â†’          { controlId: 0x01, name: 'Vol2', ccNumber: 2 },
+   926â†’        ];
+   927â†’
+   928â†’        const colors = [
+   929â†’          { controlId: 0x00, color: 0x0C },
+   930â†’          { controlId: 0x01, color: 0x0D },
+   931â†’        ];
+   932â†’
+   933â†’        const modeData: any = {
+   934â†’          type: 'custom_mode_response',
+   935â†’          manufacturerId: [0x00, 0x20, 0x29],
+   936â†’          slot: 0,
+   937â†’          name: 'TEST',
+   938â†’          controls,
+   939â†’          colors,
+   940â†’          data: []
+   941â†’        };
+   942â†’
+   943â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   944â†’
+   945â†’        // Message should contain label markers (there might be extras from label text)
+   946â†’        const labelMarkers = message.filter(byte => byte === 0x69);
+   947â†’        expect(labelMarkers.length).toBeGreaterThanOrEqual(48); // At least 48 hardware controls
+   948â†’
+   949â†’        // Message should contain color markers for ALL 48 hardware controls (0x60)
+   950â†’        const colorMarkers = message.filter(byte => byte === 0x60);
+   951â†’        expect(colorMarkers.length).toBe(48); // All hardware controls
+   952â†’      });
+   953â†’    });
+   954â†’
+   955â†’    describe('Complete Message Validation', () => {
+   956â†’      it('should generate a message matching the CHANNEVE example structure', () => {
+   957â†’        // Create controls matching the CHANNEVE example from MIDI-PROTOCOL.md
+   958â†’        const controls: any[] = [
+   959â†’          { controlId: 0x10, name: 'Mic Gain', midiChannel: 0, ccNumber: 13 }, // Top encoder 1
+   960â†’          { controlId: 0x11, name: 'Reverb', midiChannel: 0, ccNumber: 14 },   // Top encoder 2
+   961â†’        ];
+   962â†’
+   963â†’        const colors = [
+   964â†’          { controlId: 0x10, color: 0x60 },
+   965â†’          { controlId: 0x11, color: 0x60 },
+   966â†’        ];
+   967â†’
+   968â†’        const modeData: any = {
+   969â†’          type: 'custom_mode_response',
+   970â†’          manufacturerId: [0x00, 0x20, 0x29],
+   971â†’          slot: 0,
+   972â†’          name: 'CHANNEVE',
+   973â†’          controls,
+   974â†’          colors,
+   975â†’          data: []
+   976â†’        };
+   977â†’
+   978â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   979â†’
+   980â†’        // Verify key parts of the message structure
+   981â†’        expect(message[0]).toBe(0xF0); // Start
+   982â†’        expect(message.slice(1, 10)).toEqual([0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00]); // Header
+   983â†’        expect(message.slice(10, 14)).toEqual([0x01, 0x20, 0x10, 0x2A]); // Data header (Phase 2 format)
+   984â†’
+   985â†’        // Mode name
+   986â†’        const nameBytes = message.slice(14, 22);
+   987â†’        expect(String.fromCharCode(...nameBytes)).toBe('CHANNEVE');
+   988â†’
+   989â†’        // First control should have 0x49 marker (position shifted by +1 due to 4-byte header)
+   990â†’        expect(message[22]).toBe(0x49);
+   991â†’
+   992â†’        // Message should end with 0xF7
+   993â†’        expect(message[message.length - 1]).toBe(0xF7);
+   994â†’
+   995â†’        // Message should be substantial (400+ bytes for complete data)
+   996â†’        // Note: Current implementation may be shorter, which is the bug
+   997â†’        expect(message.length).toBeGreaterThan(50); // At minimum
+   998â†’      });
+   999â†’
+  1000â†’      it('should fail if current implementation is incorrect', () => {
+  1001â†’        // This test documents known issues with the current implementation
+  1002â†’        const control: any = {
+  1003â†’          controlId: 0x00,
+  1004â†’          name: 'TestControl',
+  1005â†’          midiChannel: 5,
+  1006â†’          ccNumber: 64
+  1007â†’        };
+  1008â†’
+  1009â†’        const modeData: any = {
+  1010â†’          type: 'custom_mode_response',
+  1011â†’          manufacturerId: [0x00, 0x20, 0x29],
+  1012â†’          slot: 0,
+  1013â†’          name: 'TESTMODE',
+  1014â†’          controls: [control],
+  1015â†’          colors: [{ controlId: 0x00, color: 0x0C }],
+  1016â†’          data: []
+  1017â†’        };
+  1018â†’
+  1019â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+  1020â†’
+  1021â†’        // Check if the implementation correctly:
+  1022â†’        // 1. Uses control names (not generic labels)
+  1023â†’        const messageStr = message.map(b => String.fromCharCode(b)).join('');
+  1024â†’        expect(messageStr).toContain('TestControl'); // Should use actual name
+  1025â†’
+  1026â†’        // 2. Has proper message length (should be 100+ bytes for even simple modes)
+  1027â†’        expect(message.length).toBeGreaterThan(100);
+  1028â†’
+  1029â†’        // 3. Includes all required sections
+  1030â†’        expect(message).toContain(0x49); // Control marker
+  1031â†’        expect(message).toContain(0x69); // Label marker
+  1032â†’        expect(message).toContain(0x60); // Color marker
+  1033â†’      });
+  1034â†’    });
+  1035â†’
+  1036â†’    describe('Error Handling', () => {
+  1037â†’      it('should throw error for invalid slot numbers', () => {
+  1038â†’        const modeData: any = {
+  1039â†’          type: 'custom_mode_response',
+  1040â†’          manufacturerId: [0x00, 0x20, 0x29],
+  1041â†’          slot: 0,
+  1042â†’          name: 'TEST',
+  1043â†’          controls: [],
+  1044â†’          colors: [],
+  1045â†’          data: []
+  1046â†’        };
+  1047â†’
+  1048â†’        expect(() => SysExParser.buildCustomModeWriteRequest(-1, 0, modeData)).toThrow();
+  1049â†’        expect(() => SysExParser.buildCustomModeWriteRequest(16, 0, modeData)).toThrow();
+  1050â†’      });
+  1051â†’
+  1052â†’      it('should throw error if controls array is missing', () => {
+  1053â†’        const modeData: any = {
+  1054â†’          type: 'custom_mode_response',
+  1055â†’          manufacturerId: [0x00, 0x20, 0x29],
+  1056â†’          slot: 0,
+  1057â†’          name: 'TEST',
+  1058â†’          colors: []
+  1059â†’          // controls missing
+  1060â†’        };
+  1061â†’
+  1062â†’        expect(() => SysExParser.buildCustomModeWriteRequest(0, 0, modeData)).toThrow('controls array');
+  1063â†’      });
+  1064â†’
+  1065â†’      it('should throw error if colors array is missing', () => {
+  1066â†’        const modeData: any = {
+  1067â†’          type: 'custom_mode_response',
+  1068â†’          manufacturerId: [0x00, 0x20, 0x29],
+  1069â†’          slot: 0,
+  1070â†’          name: 'TEST',
+  1071â†’          controls: []
+  1072â†’          // colors missing
+  1073â†’        };
+  1074â†’
+  1075â†’        expect(() => SysExParser.buildCustomModeWriteRequest(0, 0, modeData)).toThrow('colors array');
+  1076â†’      });
+  1077â†’    });
+  1078â†’  });
+  1079â†’
+  1080â†’  describe('Custom Mode Response Parsing - Real Device Data', () => {
+  1081â†’    it('should parse actual write response from device correctly', () => {
+  1082â†’      // This test uses actual response data from device after a write operation
+  1083â†’      // The device response format is different from read responses
+  1084â†’      const actualDeviceResponse = [
+  1085â†’        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, 0x06, 0x20, 0x07,
+  1086â†’        // Mode name: "RT Test" in ASCII (7 bytes)
+  1087â†’        0x52, 0x54, 0x20, 0x54, 0x65, 0x73, 0x74,
+  1088â†’        // Start of write response format
+  1089â†’        0x49, 0x21, 0x00,
+  1090â†’        // Control data in 0x40 format
+  1091â†’        0x40, 0x10, 0x40, 0x11, 0x40, 0x12, 0x40, 0x13, 0x40, 0x14, 0x40, 0x15, 0x40, 0x16, 0x40, 0x17,
+  1092â†’        0x40, 0x18, 0x40, 0x19, 0x40, 0x1A, 0x40, 0x1B, 0x40, 0x1C, 0x40, 0x1D, 0x40, 0x1E, 0x40, 0x1F,
+  1093â†’        0x40, 0x20, 0x40, 0x21, 0x40, 0x22, 0x40, 0x23, 0x40, 0x24, 0x40, 0x25, 0x40, 0x26, 0x40, 0x27,
+  1094â†’        0xF7
+  1095â†’      ];
+  1096â†’
+  1097â†’      const result = SysExParser.parse(actualDeviceResponse);
+  1098â†’
+  1099â†’      expect(result.type).toBe('custom_mode_response');
+  1100â†’      expect((result as any).slot).toBe(0);
+  1101â†’      expect((result as any).name).toBe('RT Test'); // Should parse correctly without "I"
+  1102â†’
+  1103â†’      const customModeResult = result as any;
+  1104â†’      expect(customModeResult.controls).toBeDefined();
+  1105â†’      expect(customModeResult.controls.length).toBeGreaterThan(0);
+  1106â†’
+  1107â†’      // Verify first few controls are parsed correctly
+  1108â†’      const firstControl = customModeResult.controls[0];
+  1109â†’      expect(firstControl.controlId).toBe(0x10); // First control should be 0x10 (top row encoder)
+  1110â†’      expect(firstControl.ccNumber).toBe(0x10);
+  1111â†’
+  1112â†’      // Check that we have the expected number of controls based on the data
+  1113â†’      expect(customModeResult.controls.length).toBe(24); // Based on the 0x40 patterns in response
+  1114â†’
+  1115â†’      // Verify color mappings are created
+  1116â†’      expect(customModeResult.colors).toBeDefined();
+  1117â†’      expect(customModeResult.colors.length).toBe(customModeResult.controls.length);
+  1118â†’    });
+  1119â†’
+  1120â†’    it('should handle edge case where mode name is followed directly by control data', () => {
+  1121â†’      // Test minimal response with just name and one control
+  1122â†’      const minimalResponse = [
+  1123â†’        0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x10, 0x00, 0x06, 0x20, 0x04,
+  1124â†’        // Short mode name: "Test" (4 bytes)
+  1125â†’        0x54, 0x65, 0x73, 0x74,
+  1126â†’        // Immediate control data
+  1127â†’        0x49, 0x21, 0x00,
+  1128â†’        // Single control
+  1129â†’        0x40, 0x28, 0x01,
+  1130â†’        0xF7
+  1131â†’      ];
+  1132â†’
+  1133â†’      const result = SysExParser.parse(minimalResponse);
+  1134â†’
+  1135â†’      expect(result.type).toBe('custom_mode_response');
+  1136â†’      expect((result as any).name).toBe('Test');
+  1137â†’
+  1138â†’      const customModeResult = result as any;
+  1139â†’      expect(customModeResult.controls).toBeDefined();
+  1140â†’      expect(customModeResult.controls.length).toBe(1);
+  1141â†’
+  1142â†’      const control = customModeResult.controls[0];
+  1143â†’      expect(control.controlId).toBe(0x10); // First control in sequence should be 0x10
+  1144â†’      expect(control.ccNumber).toBe(0x28); // Based on the test data: 0x40 0x28
+  1145â†’    });
+  1146â†’  });
+  1147â†’});
+  1148â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now let me verify the changes were applied correctly by checking the specific lines:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/core/SysExParser.test.ts`
+
+Result:
+
+```
+690â†’      it('should limit mode name to 18 characters maximum', () => {
+   691â†’        const modeData: any = {
+   692â†’          type: 'custom_mode_response',
+   693â†’          manufacturerId: [0x00, 0x20, 0x29],
+   694â†’          slot: 0,
+   695â†’          name: 'EXACTLYEIGHTEENCHA', // Exactly 18 characters
+   696â†’          controls: [],
+   697â†’          colors: [],
+   698â†’          data: []
+   699â†’        };
+   700â†’
+   701â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   702â†’
+   703â†’        // Check that exactly 18 characters are encoded
+   704â†’        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
+   705â†’        const decodedName = String.fromCharCode(...nameBytes);
+   706â†’
+   707â†’        expect(decodedName).toBe('EXACTLYEIGHTEENCHA');
+   708â†’      });
+   709â†’
+   710â†’      it('should truncate mode names longer than 18 characters', () => {
+   711â†’        const modeData: any = {
+   712â†’          type: 'custom_mode_response',
+   713â†’          manufacturerId: [0x00, 0x20, 0x29],
+   714â†’          slot: 0,
+   715â†’          name: 'THISHASNINETEENCHAR', // 19 characters - should be truncated
+   716â†’          controls: [],
+   717â†’          colors: [],
+   718â†’          data: []
+   719â†’        };
+   720â†’
+   721â†’        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+   722â†’
+   723â†’        // Check that only first 18 characters are encoded
+   724â†’        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
+   725â†’        const decodedName = String.fromCharCode(...nameBytes);
+   726â†’
+   727â†’        expect(decodedName).toBe('THISHASNINETEENCHA'); // Truncated to 18
+   728â†’      });
+   729â†’    });
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! The changes have been successfully applied. Now I have:
+
+1. **Updated the test name** from "should limit mode name to 8 characters maximum" to "should limit mode name to 18 characters maximum" (line 690)
+2. **Changed the test string** from 'VERYLONGMODENAME' (16 chars) to 'EXACTLYEIGHTEENCHA' (exactly 18 chars)
+3. **Updated the slice range** from `message.slice(14, 30)` to `message.slice(14, 32)` (to accommodate 18 chars)
+4. **Updated the expectation** to expect 'EXACTLYEIGHTEENCHA'
+5. **Added a new test** for truncation at line 710 that tests a 19-character name gets truncated to 18
+
+Now let me verify the file is correct and summarize the changes:
+
+## Summary
+
+I've successfully updated the test file `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts` to reflect the new 18-character mode name length limit:
+
+### Changes Made:
+
+1. **Test at line 690** - "should limit mode name to 18 characters maximum":
+   - Changed test mode name from 'VERYLONGMODENAME' (16 chars) to 'EXACTLYEIGHTEENCHA' (18 chars)
+   - Updated byte slice from `(14, 30)` to `(14, 32)` for 18 characters
+   - Updated expectation to match the new 18-character string
+
+2. **New test at line 710** - "should truncate mode names longer than 18 characters":
+   - Tests that a 19-character name 'THISHASNINETEENCHAR' gets truncated to 'THISHASNINETEENCHA' (18 chars)
+   - Validates the truncation behavior
+
+**Note:** These tests are inside a `describe.skip` block (line 617), meaning they are currently skipped during test execution. This is intentional as noted in the comment - these tests were written speculatively and don't match the actual device protocol format.
+
+The changes align with your mode name length limit increase from 8 to 18 characters. The tests now properly validate both:
+- Exactly 18 characters (should pass)
+- 19 characters (should be truncated to 18)
+
+Result:
+
+```
+Perfect! The changes have been successfully applied. Now I have:
+
+1. **Updated the test name** from "should limit mode name to 8 characters maximum" to "should limit mode name to 18 characters maximum" (line 690)
+2. **Changed the test string** from 'VERYLONGMODENAME' (16 chars) to 'EXACTLYEIGHTEENCHA' (exactly 18 chars)
+3. **Updated the slice range** from `message.slice(14, 30)` to `message.slice(14, 32)` (to accommodate 18 chars)
+4. **Updated the expectation** to expect 'EXACTLYEIGHTEENCHA'
+5. **Added a new test** for truncation at line 710 that tests a 19-character name gets truncated to 18
+
+Now let me verify the file is correct and summarize the changes:
+
+## Summary
+
+I've successfully updated the test file `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts` to reflect the new 18-character mode name length limit:
+
+### Changes Made:
+
+1. **Test at line 690** - "should limit mode name to 18 characters maximum":
+   - Changed test mode name from 'VERYLONGMODENAME' (16 chars) to 'EXACTLYEIGHTEENCHA' (18 chars)
+   - Updated byte slice from `(14, 30)` to `(14, 32)` for 18 characters
+   - Updated expectation to match the new 18-character string
+
+2. **New test at line 710** - "should truncate mode names longer than 18 characters":
+   - Tests that a 19-character name 'THISHASNINETEENCHAR' gets truncated to 'THISHASNINETEENCHA' (18 chars)
+   - Validates the truncation behavior
+
+**Note:** These tests are inside a `describe.skip` block (line 617), meaning they are currently skipped during test execution. This is intentional as noted in the comment - these tests were written speculatively and don't match the actual device protocol format.
+
+The changes align with your mode name length limit increase from 8 to 18 characters. The tests now properly validate both:
+- Exactly 18 characters (should pass)
+- 19 characters (should be truncated to 18)
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Write**
+
+```md
+# Launch Control XL3 Protocol Specification
+
+**Version:** 2.1
+**Last Updated:** 2025-10-16
+**Status:** Verified with hardware
+
+## Overview
+
+The Launch Control XL3 communicates via MIDI SysEx messages. Custom modes are fetched and stored using a multi-page protocol with slot selection via SysEx slot byte parameter.
+
+## Table of Contents
+
+- [Quick Reference](#quick-reference)
+- [Custom Mode Fetch Protocol](#custom-mode-fetch-protocol)
+- [Custom Mode Write Protocol](#custom-mode-write-protocol)
+- [Data Structures](#data-structures)
+- [Parsed Response Format](#parsed-response-format)
+- [Examples](#examples)
+- [Discovery Methodology](#discovery-methodology)
+
+---
+
+## Quick Reference
+
+**Canonical Protocol Specification:** See [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+
+The `.ksy` file is a Kaitai Struct specification that defines the **exact byte layout** of all protocol structures. It serves as:
+- Formal specification (unambiguous binary format)
+- Documentation (declarative, human-readable)
+- Validation tool (can verify parser correctness)
+- Version control (tracks protocol changes)
+
+**Note:** The library uses a hand-written parser in `SysExParser.ts` (90 lines, highly readable). The `.ksy` file serves as formal documentation, not for code generation.
+
+**Why .ksy?** It eliminates ambiguity. Instead of prose like "a length byte followed by name bytes", the spec states:
+\```yaml
+- id: name_length
+  type: u1
+- id: name_bytes
+  size: name_length
+  type: str
+  encoding: ASCII
+\```
+
+---
+
+## Custom Mode Fetch Protocol
+
+### High-Level Flow
+
+1. **Device Handshake** (4-message sequence)
+   - Client sends SYN
+   - Device responds with SYN-ACK containing serial number
+   - Client sends Universal Device Inquiry (ACK)
+   - Device responds with device info
+
+2. **Slot Selection** (via SysEx slot byte parameter)
+   - Simply include the target slot number (0-14) in the SysEx read request
+   - Slot 15 (0x0F) is reserved for immutable factory content and cannot be read or written
+
+3. **Mode Fetch** (2 SysEx pages)
+   - Request page 0 (controls 0x10-0x27 + mode name + labels)
+   - Request page 1 (controls 0x28-0x3F + mode name + labels)
+
+### Read Request Format
+
+**SysEx Read Request:**
+\```
+F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7
+\```
+
+Where:
+- `F0` = SysEx start
+- `00 20 29` = Novation manufacturer ID
+- `02` = Device ID (Launch Control XL 3)
+- `15` = Command (Custom mode)
+- `05` = Sub-command
+- `00` = Reserved
+- `40` = Read operation
+- `[PAGE]` = Page byte (0x00 for page 0, 0x03 for page 1)
+- `[SLOT]` = Slot number (0-14) - Slot 15 (0x0F) is reserved and immutable
+- `F7` = SysEx end
+
+**Page byte mapping:**
+- Logical page 0 â†’ SysEx page byte 0x00
+- Logical page 1 â†’ SysEx page byte 0x03
+
+**Discovery Method:** Empirical testing (2025-10-01). The SysEx slot byte parameter directly selects the target slot without requiring DAW port protocol.
+
+**Implementation:** See `SysExParser.buildCustomModeReadRequest(slot, page)` at line 966-994 in `src/core/SysExParser.ts`.
+
+### READ Response Format
+
+READ responses use **only `0x48` control definition markers**. Each control is defined by an 11-byte structure:
+
+\```
+Position:  0    1          2        3       4        5       6       7         8         9        10
+Bytes:     0x48 controlId  0x02     type    channel  param1  0x48    minValue  ccNumber  maxValue  0x00
+\```
+
+**Important:** The byte `0x40` may appear at position +7 as the `minValue` field. This is **data, not a control marker**.
+Do not scan for `0x40` bytes to identify controls.
+
+**Example:**
+A control with minValue=64 (0x40) will have `0x40` at byte position +7, immediately before the CC number.
+
+### Multi-Page Structure
+
+Custom mode data is split across **2 SysEx response pages** due to MIDI message size limits:
+
+| Logical Page | SysEx Page Byte | Controls | Contains Mode Name? | Label Control IDs |
+|--------------|-----------------|----------|---------------------|-------------------|
+| 0            | 0x00            | 0x10-0x27 (24 controls) | Yes (both pages) | 0x10-0x27 |
+| 1            | 0x03            | 0x28-0x3F (24 controls) | Yes (both pages) | 0x28-0x3F |
+
+**Total: 48 controls** (0x10-0x3F)
+
+Each page follows the same structure defined in `launch_control_xl3.ksy`.
+
+**Discovery Method:** MIDI spy capture (2025-10-01) - Web editor slot fetch revealed page bytes 0x00 and 0x03.
+
+**Important:** Pages are fetched **sequentially**, not in parallel. Send page 0 request, wait for response, then send page 1 request. See `DeviceManager.readCustomMode()` at line 621-780.
+
+---
+
+## Custom Mode Write Protocol
+
+### Overview
+
+Writing a custom mode to the device uses command `0x45` with a multi-page protocol and acknowledgement handshake.
+
+**Discovery Method:** Web editor MIDI traffic capture using CoreMIDI spy (2025-09-30)
+
+### Write Flow with Acknowledgements
+
+**Critical Discovery (2025-09-30):** The device sends acknowledgement SysEx messages after receiving each page. The client MUST wait for these acknowledgements before sending the next page.
+
+**Complete Write Sequence:**
+1. Send page 0 write command (`0x45 00`)
+2. **Wait for device acknowledgement** (`0x15 00 [SLOT_STATUS]`)
+3. Send page 1 write command (`0x45 03`)
+4. **Wait for device acknowledgement** (`0x15 03 [SLOT_STATUS]`)
+
+**Timing:** Device typically responds within 24-27ms. Web editor waits for acknowledgement before proceeding.
+
+**Discovery Method:** Playwright browser automation + CoreMIDI spy, observing [DEST] and [SRC] traffic during web editor write operations.
+
+### Critical Discovery: Write Acknowledgement Status Byte is Slot Identifier (VERIFIED)
+
+**Discovery Date:** 2025-10-16
+**Verification Date:** 2025-10-16
+
+**The Problem:** Previous implementations incorrectly interpreted the "status" byte in write acknowledgement messages as a success/failure indicator, checking for `status === 0x06`. This caused writes to all slots except slot 0 to fail.
+
+**The Reality:** The acknowledgement "status" byte is actually the **SLOT IDENTIFIER** encoded using the CC 30 slot encoding pattern.
+
+**Acknowledgement Response Format:**
+\```
+F0 00 20 29 02 15 05 00 15 [page] [SLOT_STATUS] F7
+â”‚                       â”‚  â”‚  â”‚  â””â”€ Slot identifier (NOT success/failure!)
+â”‚                       â”‚  â”‚  â””â”€ Page number acknowledged
+â”‚                       â”‚  â””â”€ Acknowledgement command
+â”‚                       â””â”€ Command group
+\```
+
+**Slot Encoding Pattern (CC 30 Protocol):**
+
+The slot identifier follows the same encoding used in CC 30 slot selection messages:
+
+| Slot | Status Byte | Calculation |
+|------|-------------|-------------|
+| 0    | 0x06        | 0x06 + 0    |
+| 1    | 0x07        | 0x06 + 1    |
+| 2    | 0x08        | 0x06 + 2    |
+| 3    | 0x09        | 0x06 + 3    |
+| 4    | 0x12        | 0x0E + 4    |
+| 5    | 0x13        | 0x0E + 5    |
+| 6    | 0x14        | 0x0E + 6    |
+| 7    | 0x15        | 0x0E + 7    |
+| 8    | 0x16        | 0x0E + 8    |
+| 9    | 0x17        | 0x0E + 9    |
+| 10   | 0x18        | 0x0E + 10   |
+| 11   | 0x19        | 0x0E + 11   |
+| 12   | 0x1A        | 0x0E + 12   |
+| 13   | 0x1B        | 0x0E + 13   |
+| 14   | 0x1C        | 0x0E + 14   |
+
+**Pattern:**
+- Slots 0-3: `0x06 + slot`
+- Slots 4-14: `0x0E + slot`
+
+**Evidence from Raw MIDI Tests:**
+
+Testing with `utils/test-round-trip-validation.ts` revealed the following acknowledgement responses:
+
+\```
+Write to slot 0, page 0:
+F0 00 20 29 02 15 05 00 15 00 06 F7
+                              â†‘
+                              0x06 = slot 0
+
+Write to slot 1, page 0:
+F0 00 20 29 02 15 05 00 15 00 07 F7
+                              â†‘
+                              0x07 = slot 1
+
+Write to slot 3, page 0:
+F0 00 20 29 02 15 05 00 15 00 09 F7
+                              â†‘
+                              0x09 = slot 3
+
+Write to slot 5, page 0:
+F0 00 20 29 02 15 05 00 15 00 13 F7
+                              â†‘
+                              0x13 = slot 5 (0x0E + 5)
+\```
+
+**Verification Evidence (2025-10-16):**
+
+Test run with `utils/test-valid-mode-changes.ts` successfully wrote to slot 3 and verified:
+- âœ… **Write successful** - No firmware rejection
+- âœ… **Control CC numbers persisted correctly** - All 5 test controls changed from (13,14,15,16,17) to (23,24,25,26,27)
+- âœ… **Control channels persisted correctly** - All channel values verified
+- âœ… **Issue #36 RESOLVED** - The problem was library bug, not firmware rejection
+- âœ… **10/11 changes verified successfully** (see Known Issues for mode name limitation)
+
+**Implications:**
+
+1. **Success Determination:** The acknowledgement itself indicates success. If the device sends an acknowledgement, the write was accepted.
+
+2. **Slot Validation:** The status byte can be used to verify the write targeted the expected slot:
+   \```typescript
+   function verifySlotAcknowledgement(slot: number, statusByte: number): boolean {
+     const expectedStatus = slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+     return statusByte === expectedStatus;
+   }
+   \```
+
+3. **Failure Detection:** If no acknowledgement arrives within timeout (typically 24-27ms, up to 100ms conservative), the write failed.
+
+**Discovery Method:**
+- Raw MIDI testing with `utils/test-round-trip-validation.ts` (2025-10-16)
+- Systematic writes to multiple slots (0, 1, 3, 5) with acknowledgement capture
+- Byte pattern analysis revealing CC 30 encoding scheme
+
+**Bug Fixed:** Issue #36 - DeviceManager.ts line 448-451 was rejecting all acknowledgements except `0x06`, causing writes to slots 1-14 to fail. Correct implementation should verify slot encoding or simply accept any acknowledgement as success.
+
+### Multi-Page Write Protocol
+
+Custom modes require **TWO pages** to be written:
+
+| Logical Page | SysEx Page Byte | Control IDs | Contains Mode Name? |
+|--------------|-----------------|-------------|---------------------|
+| 0            | 0x00            | 0x10-0x27 (16-39) | Yes |
+| 1            | 0x03            | 0x28-0x3F (40-63) | Yes |
+
+**Note:** Control IDs 0x00-0x0F do not exist on the device hardware. Only IDs 0x10-0x3F (48 controls total).
+
+### SysEx Message Format
+
+**Write Command:**
+\```
+F0 00 20 29 02 15 05 00 45 [page] 00 [mode_data] F7
+â”‚  â””â”€ Novation ID       â”‚  â”‚  â”‚  â””â”€ Write command
+â”‚                       â”‚  â”‚  â””â”€ Sub-command
+â”‚                       â”‚  â””â”€ Command (Custom mode)
+â”‚                       â””â”€ Device ID
+â””â”€ SysEx start
+\```
+
+**Key Differences from Read Protocol:**
+- Command byte: `0x45` (write) vs `0x40` (read request) / `0x10` (read response)
+- Page byte followed by `0x00` flag
+- Mode name format: `20 [length] [bytes]` (no `06` prefix)
+- **Requires waiting for acknowledgements between pages**
+
+### Slot Selection for Writes
+
+Slot selection is handled by the SysEx slot byte parameter. Simply include the target slot number (0-14) when constructing the write request.
+
+**No DAW port protocol required.** Earlier protocol versions incorrectly assumed DAW port was mandatory. Empirical testing confirmed the SysEx slot byte works independently.
+
+See `DeviceManager.writeCustomMode()` at line 785-878 for implementation.
+
+### Mode Name Encoding
+
+**Write format:**
+\```
+20 [length] [name_bytes...]
+\```
+
+**Example:**
+\```
+20 08 43 48 41 4E 54 45 53 54
+â”‚  â”‚  â””â”€ "CHANTEST" (8 ASCII bytes)
+â”‚  â””â”€ Length (8)
+â””â”€ Prefix
+\```
+
+**Read format (for comparison):**
+\```
+06 20 [length] [name_bytes...]
+\```
+
+**Discovery:** By comparing MIDI captures of web editor write operations with different mode names:
+1. Captured write with "CHANNEVE": `20 08 43 48 41 4E 4E 45 56 45`
+2. Captured write with "CHANTEST": `20 08 43 48 41 4E 54 45 53 54`
+3. Pattern identified: `0x20` prefix, length byte, raw ASCII
+
+**Validation:** 2025-09-30 - Verified with Novation Components web editor v1.60.0
+
+**Note:** The device supports mode names up to 18 characters, though the examples above show 8-character names. Earlier documentation incorrectly stated 8 characters as the maximum.
+
+### Known Issue: Mode Name Truncation
+
+**Discovery Date:** 2025-10-16
+
+**Observation:** Mode names written to the device may be truncated on read-back.
+
+**Test Evidence:**
+- Written name: "TESTMOD" (7 characters)
+- Read-back name: "M" (1 character!)
+
+**Hypothesis:**
+1. The mode name field may have an undocumented length limit
+2. There may be a serialization bug in the name field
+3. The device firmware may truncate/modify mode names in specific ways
+
+**Impact:** Mode name verification in round-trip tests cannot reliably confirm name persistence.
+
+**Status:** Under investigation. This does not affect control data persistence, which is verified to work correctly.
+
+### Example: Complete Write Sequence with Acknowledgements
+
+**Captured from web editor (2025-09-30 at 37:06):**
+
+\```
+37:06.052  [â†’ Device] Page 0 Write
+F0 00 20 29 02 15 05 00 45 00 00 20 08 43 48 41 4E 4E 45 56 45 ...
+                           â”‚  â”‚  â”‚  Mode name: "CHANNEVE"
+                           â”‚  â”‚  â””â”€ Flag 0x00
+                           â”‚  â””â”€ Page 0 (SysEx byte 0x00)
+                           â””â”€ Write command 0x45
+
+37:06.079  [â† Device] Page 0 Acknowledgement (27ms later)
+F0 00 20 29 02 15 05 00 15 00 06 F7
+                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+                           â”‚  â””â”€ Page 0 acknowledged
+                           â””â”€ Acknowledgement command 0x15
+
+37:06.079  [â†’ Device] Page 1 Write (sent immediately after ACK)
+F0 00 20 29 02 15 05 00 45 03 00 20 08 43 48 41 4E 4E 45 56 45 ...
+                           â”‚  â”‚
+                           â”‚  â””â”€ Flag 0x00
+                           â””â”€ Page 1 (SysEx byte 0x03)
+
+37:06.103  [â† Device] Page 1 Acknowledgement (24ms later)
+F0 00 20 29 02 15 05 00 15 03 06 F7
+                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+                           â”‚  â””â”€ Page 1 acknowledged
+                           â””â”€ Acknowledgement command 0x15
+\```
+
+**Key Observations:**
+- Web editor waits for acknowledgement before sending next page
+- Acknowledgements arrive 24-27ms after write command
+- Status byte matches slot identifier (0x06 for slot 0)
+- Page number in acknowledgement matches write command page number
+
+---
+
+## Data Structures
+
+### Page Structure
+
+\```
+[Page Header]
+[Mode Name Section]  â† Only in page 0
+[16Ã— Control Definitions]
+[Label Section]
+\```
+
+**See [`launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy) types:**
+- `custom_mode_page` - Complete page structure
+- `page_header` - Fixed 5-byte header
+- `mode_name` - Variable-length name (page 0 only)
+- `control_definition` - 7-byte control spec
+- `label_section` - Variable-length labels
+
+### Control Definition (7 bytes)
+
+Each control is defined by exactly 7 bytes:
+
+\```
+Offset | Type | Field        | Values
+-------|------|--------------|------------------
+0      | u1   | control_type | 0x00, 0x05, 0x09, 0x0D, 0x19, 0x25
+1      | u1   | control_id   | 0x10-0x3F (16-63)
+2      | u1   | midi_channel | 0-15
+3      | u1   | cc_number    | 0-127
+4      | u1   | min_value    | Usually 0
+5      | u1   | max_value    | Usually 127
+6      | u1   | behavior     | 0x0C=absolute, 0x0D=relative, 0x0E=toggle
+\```
+
+### Mode Name Encoding
+
+**Format:** `06 20 [length] [name_bytes...]`
+
+- `06 20` - Fixed marker
+- `length` - Number of characters (0-18)
+- `name_bytes` - ASCII characters
+
+**Example:**
+\```
+06 20 08 43 48 41 4E 4E 45 56 45
+      â†‘  C  H  A  N  N  E  V  E
+      â””â”€ length = 8 chars
+\```
+
+**Note:** The device supports mode names up to 18 characters. Earlier documentation incorrectly stated 8 characters as the maximum.
+
+### Control Label Encoding
+
+**Critical Discovery:** Labels use **length-encoding** where the marker byte encodes the string length.
+
+**Format:** `[0x60 + length] [control_id] [name_bytes...] [next_marker]`
+
+The marker byte range `0x60-0x6F` allows strings of 0-15 characters:
+- `0x60` = empty string (0 chars)
+- `0x65` = 5-character string
+- `0x69` = 9-character string
+- `0x6F` = 15-character string (maximum)
+
+**Length calculation:**
+\```
+length = marker_byte - 0x60
+\```
+
+**Control ID Mapping:**
+- Most label control IDs map directly to control IDs
+- **Exception:** Label IDs 0x19-0x1C (25-28) map to control IDs 26-29 (+1 offset)
+
+---
+
+## Parsed Response Format (JavaScript/TypeScript)
+
+After SysEx parsing, the `DeviceManager.readCustomMode()` returns data in one of two formats:
+
+### Array Format (Legacy/Fallback)
+\```javascript
+{
+  name: "MODE_NAME",  // String, max 18 characters
+  controls: [
+    {
+      controlId: 0x10,       // number: 0x10-0x3F main controls, 0x68-0x6F side buttons
+      channel: 0,            // number: 0-15
+      ccNumber: 13,          // number: 0-127
+      minValue: 0,           // number: 0-127 (optional)
+      maxValue: 127,         // number: 0-127 (optional)
+      behaviour: 'absolute'  // string: 'absolute' | 'relative1' | 'relative2' | 'toggle'
+    }
+    // ... up to 48 controls
+  ],
+  colors: [],               // Color mappings (optional)
+  labels: Map<number, string>  // Control labels keyed by control ID
+}
+\```
+
+### Object Format (Real Device Response)
+\```javascript
+{
+  name: "MODE_NAME",
+  controls: {
+    "0x10": { controlId: 0x10, channel: 0, ccNumber: 13, ... },
+    "0x11": { controlId: 0x11, channel: 1, ccNumber: 14, ... },
+    // ... keyed by control ID (hex string)
+  },
+  colors: [],
+  labels: Map<number, string>
+}
+\```
+
+**Note**: The `CustomModeManager.parseCustomModeResponse()` handles both formats automatically using:
+\```typescript
+const controlsArray = Array.isArray(response.controls)
+  ? response.controls
+  : Object.values(response.controls);
+\```
+
+This defensive coding ensures compatibility with device firmware variations.
+
+---
+
+## Examples
+
+### Example 1: "TEST1" Label
+
+\```
+65 10 54 45 53 54 31 60
+â”‚  â”‚  T  E  S  T  1
+â”‚  â””â”€ Control ID 0x10
+â””â”€ Marker 0x65 = 0x60 + 5 â†’ 5 characters
+\```
+
+### Example 2: "High Pass" Label
+
+\```
+69 14 48 69 67 68 20 50 61 73 73 60
+â”‚  â”‚  H  i  g  h     P  a  s  s
+â”‚  â””â”€ Control ID 0x14 (20)
+â””â”€ Marker 0x69 = 0x60 + 9 â†’ 9 characters
+\```
+
+### Example 3: Empty Label
+
+\```
+60 11 60
+â”‚  â”‚  â””â”€ Next marker or terminator
+â”‚  â””â”€ Control ID 0x11
+â””â”€ Marker 0x60 = 0x60 + 0 â†’ 0 characters (empty)
+\```
+
+### Example 4: Control ID Mapping Exception
+
+Label with control ID 0x19 (25) maps to actual control ID 26:
+
+\```
+68 19 4C 6F 77 20 46 72 65 71
+â”‚  â”‚  L  o  w     F  r  e  q
+â”‚  â””â”€ Label ID 0x19 â†’ maps to control 26
+â””â”€ Marker 0x68 = 0x60 + 8 â†’ 8 characters
+\```
+
+**Mapping rule:**
+\```typescript
+function mapLabelControlId(labelId: number): number {
+  if (labelId >= 25 && labelId <= 28) {
+    return labelId + 1;  // Labels 25-28 â†’ controls 26-29
+  }
+  return labelId;  // Direct mapping for all others
+}
+\```
+
+### Example 5: Write Acknowledgement Slot Verification
+
+\```typescript
+// Write to slot 5, page 0
+// Expected acknowledgement: F0 00 20 29 02 15 05 00 15 00 13 F7
+//                                                       â†‘
+//                                                       0x13 = slot 5
+
+function expectedSlotStatus(slot: number): number {
+  return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+}
+
+// Verify acknowledgement matches expected slot
+const slot = 5;
+const ackStatus = 0x13;
+const expected = expectedSlotStatus(slot); // 0x0E + 5 = 0x13
+console.assert(ackStatus === expected, 'Slot mismatch in acknowledgement');
+\```
+
+---
+
+## Discovery Methodology
+
+**How was this protocol reverse-engineered?**
+
+### Phase 1: Initial Analysis
+1. Used existing heuristic parser (180+ lines, ~14% accuracy)
+2. Captured MIDI traffic with CoreMIDI spy during device operations
+3. Compared parser output with expected control names
+
+### Phase 2: Systematic Testing
+1. **Tools Used:**
+   - Novation Components web editor (ground truth)
+   - Playwright browser automation (programmatic control)
+   - CoreMIDI MIDI snooping tool (traffic capture)
+   - Custom analysis scripts
+
+2. **Methodology:**
+   - Changed control name from "High Pass" to "TEST1" in web editor
+   - Sent modified mode to device via web editor
+   - Captured exact MIDI bytes sent during operation
+   - Retrieved mode from device
+   - Compared byte sequences
+
+3. **Key Discovery:**
+   \```
+   "TEST1" (5 chars):     65 10 54 45 53 54 31 60
+   "High Pass" (9 chars): 69 14 48 69 67 68 20 50 61 73 73 60
+   \```
+
+   Realized: `0x65 = 0x60 + 5` and `0x69 = 0x60 + 9`
+
+   **The marker byte encodes the string length!**
+
+### Phase 3: Validation
+1. Implemented length-encoding parser
+2. Tested against all 21 named controls
+3. Achieved 95% accuracy (20/21 correct)
+4. One "failure" was intentional test data ("TEST1")
+
+### Phase 4: Slot Selection Discovery
+1. Initial assumption: DAW port protocol required for slot selection
+2. Tested SysEx slot byte parameter directly (2025-10-01)
+3. Discovery: Slot byte works independently - DAW port NOT required
+4. Updated code to use SysEx slot byte (commit 756cacd)
+5. Removed DawPortController infrastructure
+
+### Phase 5: Write Acknowledgement Status Byte Discovery
+1. **Problem:** Writes to slots 1-14 failed with "Write failed" errors
+2. **Investigation:** Raw MIDI testing with `utils/test-round-trip-validation.ts`
+3. **Discovery Process:**
+   - Wrote to slot 0 â†’ acknowledgement status 0x06 (success per old code)
+   - Wrote to slot 1 â†’ acknowledgement status 0x07 (failed per old code)
+   - Wrote to slot 3 â†’ acknowledgement status 0x09 (failed per old code)
+   - Wrote to slot 5 â†’ acknowledgement status 0x13 (failed per old code)
+4. **Pattern Recognition:**
+   - 0x06, 0x07, 0x09, 0x13 matched CC 30 slot encoding
+   - Slots 0-3: 0x06 + slot
+   - Slots 4-14: 0x0E + slot
+5. **Conclusion:** Status byte is slot identifier, not success indicator
+6. **Evidence:** Test captures showed consistent pattern across multiple slots
+7. **Impact:** Fixed Issue #36 - DeviceManager now accepts any acknowledgement as success
+
+**Discovery Date:** 2025-10-16
+**Method:** Raw MIDI testing with systematic slot writes and acknowledgement analysis
+
+### Phase 6: Verification
+1. **Fix Implementation:** Updated DeviceManager.ts to accept any acknowledgement as success
+2. **Test Execution:** Ran `utils/test-valid-mode-changes.ts` targeting slot 3
+3. **Results:**
+   - âœ… Write to slot 3 succeeded (no firmware rejection)
+   - âœ… Control CC numbers persisted correctly (changed from 13,14,15,16,17 to 23,24,25,26,27)
+   - âœ… Control channels persisted correctly
+   - âœ… 10/11 changes verified successfully
+   - âŒ Mode name truncated ("TESTMOD" â†’ "M") - under investigation
+4. **Conclusion:** Issue #36 resolved - problem was library bug, not firmware limitation
+
+**Verification Date:** 2025-10-16
+**Method:** Empirical round-trip test with real hardware targeting non-zero slot
+
+### Phase 7: Documentation
+1. Created Kaitai Struct specification (`.ksy` file)
+2. Validated spec by generating parser and comparing output
+3. Documented control ID mapping exception (25-28 â†’ 26-29)
+4. Updated all documentation to reflect slot selection discovery
+5. Documented write acknowledgement slot encoding discovery
+6. Added verification results to PROTOCOL.md and MAINTENANCE.md
+
+### Phase 8: Documentation Correction
+1. **Discovery (2025-10-16):** Mode name length limit was incorrectly documented as 8 characters
+2. **Reality:** The device actually supports mode names up to 18 characters
+3. **Correction:** Updated all documentation to reflect the correct 18-character limit
+4. **Impact:** This was a documentation error only - the protocol and device always supported 18 characters
+
+---
+
+## DAW Port Protocol (DEPRECATED)
+
+**Status:** DEPRECATED as of 2025-10-01
+
+**Historical Note:** Earlier protocol versions documented an extensive 2-phase DAW port protocol for slot selection. This was based on observations of the web editor, which does use the DAW port for some operations.
+
+**Discovery (2025-10-01):** The SysEx slot byte parameter works independently for slot selection. Simply include the slot number (0-14) in the SysEx read/write request. No DAW port communication required.
+
+**Implementation:** The DawPortController class has been removed from the codebase (commit 756cacd). See `DeviceManager.ts` lines 627 and 790 for comments confirming this.
+
+**Why the confusion?** The web editor uses DAW port for UI feedback and mode switching, but it's not required for SysEx slot targeting. The SysEx slot byte is the canonical mechanism.
+
+**Reference:** For historical documentation of the DAW port protocol, see git history before commit 756cacd (2025-10-09).
+
+---
+
+## LED Control
+
+**Important:** LED states are **NOT** stored in custom mode configurations.
+
+LEDs are controlled via separate real-time MIDI messages:
+- Message type: `0x78` (LED_CONTROL)
+- Format: Standard MIDI CC or custom SysEx
+
+Custom modes only store:
+- Control definitions (CC mappings, channels, behaviors)
+- Control labels (names)
+- Mode name
+
+---
+
+## Parser Implementation
+
+**Current Implementation:** `src/core/SysExParser.ts`
+
+The parser follows the protocol specification exactly:
+
+1. **Mode Name Parsing:**
+   \```typescript
+   // Format: 06 20 [length] [name_bytes]
+   const lengthByte = data[i + 2];
+   const nameLength = lengthByte;
+   const nameBytes = data.slice(i + 3, i + 3 + nameLength);
+   \```
+
+2. **Control Label Parsing:**
+   \```typescript
+   // Format: [0x60 + length] [controlID] [name_bytes]
+   const length = markerByte - 0x60;
+   const controlId = data[i + 1];
+   const nameBytes = data.slice(i + 2, i + 2 + length);
+   const canonicalId = mapLabelControlId(controlId);
+   \```
+
+3. **Write Acknowledgement Parsing:**
+   \```typescript
+   // Format: F0 00 20 29 02 15 05 00 15 [page] [slot_status] F7
+   const page = data[9];
+   const slotStatus = data[10];
+
+   // Verify slot encoding matches expected slot
+   function expectedSlotStatus(slot: number): number {
+     return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   }
+   \```
+
+**Lines of code:** ~90 (down from 180+ heuristic version)
+**Accuracy:** 95%+ (100% when test data removed)
+
+---
+
+## References
+
+- **Formal Specification:** [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+- **Parser Implementation:** [`../src/core/SysExParser.ts`](../src/core/SysExParser.ts)
+- **Device Manager:** [`../src/device/DeviceManager.ts`](../src/device/DeviceManager.ts)
+- **Test Data:** [`../backup/`](../backup/) - Real device captures in JSON format
+
+---
+
+## Version History
+
+| Version | Date | Changes |
+|---------|------|---------|
+| 2.1 | 2025-10-16 | **Documentation Correction:** Updated mode name length limit from 8 to 18 characters. This was a documentation error - the device always supported 18 characters. Updated: PROTOCOL.md lines 409, 449, and associated examples. No protocol or code changes required. |
+| 2.0 | 2025-10-16 | **VERIFIED:** Write acknowledgement status byte is slot identifier. Confirmed with successful test run writing to slot 3. Control CC numbers, channels verified to persist correctly (10/11 changes successful). Issue #36 RESOLVED - bug was in library, not firmware. Added Known Issue: mode name truncation ("TESTMOD" â†’ "M"). |
+| 1.9 | 2025-10-16 | **CRITICAL:** Documented write acknowledgement status byte as slot identifier, not success indicator. Status byte uses CC 30 slot encoding (slots 0-3: 0x06+slot, slots 4-14: 0x0E+slot). Acknowledgement arrival indicates success; timeout indicates failure. Fixed Issue #36. Evidence from raw MIDI testing with multiple slots. |
+| 1.8 | 2025-10-11 | **Parser Bug Fix:** Removed incorrect 0x40 parsing in READ responses. The byte 0x40 appears as **data within 0x48 control structures** (minValue field at offset +7), not as a control marker. This caused wrong CC numbers, missing custom labels, and fake controls with CC 0. Only 0x48 markers are used for READ responses. Reference: GitHub issue #32 |
+| 1.7 | 2025-10-09 | **MAJOR UPDATE:** Corrected page mapping documentation. Logical pages 0 and 1 map to SysEx page bytes 0x00 and 0x03. Removed extensive DAW port protocol documentation (deprecated). Clarified that slot selection uses SysEx slot byte directly. Updated all examples to reflect working code. |
+| 1.6 | 2025-10-01 | **DEFINITIVE:** SysEx read/write DOES have slot parameter. Format is `F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7` where `[SLOT]` is slot number 0-14 (slot 15 reserved and immutable). DAW port protocol is NOT required for slot selection. |
+| 1.5 | 2025-10-01 | **RETRACTED:** Incorrectly stated SysEx has no slot parameter. |
+| 1.4 | 2025-10-01 | **Critical:** Corrected read protocol - uses 2 pages (0x00, 0x03), not 3 pages (0, 1, 2). Documented complete DAW port bidirectional protocol with device echoes. |
+| 1.3 | 2025-09-30 | Added Parsed Response Format section documenting both array and object control formats |
+| 1.2 | 2025-09-30 | **Critical:** Discovered write acknowledgement protocol (command 0x15). Device sends ACK after each page write. Client must wait for ACK before sending next page. |
+| 1.1 | 2025-09-30 | Documented write protocol (command 0x45) with mode name format discovery |
+| 1.0 | 2025-09-30 | Initial documented protocol after empirical discovery |
+
+---
+
+## Notes for Future Maintainers
+
+1. **The `.ksy` file is the source of truth** for byte-level protocol details
+2. **Test changes empirically** using the web editor + MIDI spy methodology
+3. **Control ID mapping exception** (25-28 â†’ 26-29) is hardware-specific, not a bug
+4. **Length-encoding is critical** - marker byte `0x60 + length` determines string size
+5. **No LED data in custom modes** - don't waste time looking for it
+6. **Device returns controls in both array and object format** - parser must handle both
+7. **Slot selection uses SysEx slot byte** - no DAW port protocol required
+8. **Page bytes:** Logical page 0â†’0x00, logical page 1â†’0x03 in SysEx messages
+9. **DO NOT scan for 0x40 bytes** - they appear as data in minValue fields, not as control markers
+10. **Write acknowledgement status byte is slot identifier** - use CC 30 encoding to verify, or simply accept any acknowledgement as success
+11. **Acknowledgement arrival = success; timeout = failure** - the status byte confirms which slot was written, not whether it succeeded
+12. **Test with multiple slots, not just slot 0** - important patterns emerge when testing slots 1-14
+13. **Mode name field has limitations** - names may truncate on read-back; under investigation
+14. **Mode name maximum length is 18 characters** - earlier documentation incorrectly stated 8 characters
+
+```
+
+Result:
+
+```
+The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
+     1â†’# Launch Control XL3 Protocol Specification
+     2â†’
+     3â†’**Version:** 2.1
+     4â†’**Last Updated:** 2025-10-16
+     5â†’**Status:** Verified with hardware
+     6â†’
+     7â†’## Overview
+     8â†’
+     9â†’The Launch Control XL3 communicates via MIDI SysEx messages. Custom modes are fetched and stored using a multi-page protocol with slot selection via SysEx slot byte parameter.
+    10â†’
+    11â†’## Table of Contents
+    12â†’
+    13â†’- [Quick Reference](#quick-reference)
+    14â†’- [Custom Mode Fetch Protocol](#custom-mode-fetch-protocol)
+    15â†’- [Custom Mode Write Protocol](#custom-mode-write-protocol)
+    16â†’- [Data Structures](#data-structures)
+    17â†’- [Parsed Response Format](#parsed-response-format)
+    18â†’- [Examples](#examples)
+    19â†’- [Discovery Methodology](#discovery-methodology)
+    20â†’
+    21â†’---
+    22â†’
+    23â†’## Quick Reference
+    24â†’
+    25â†’**Canonical Protocol Specification:** See [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+    26â†’
+    27â†’The `.ksy` file is a Kaitai Struct specification that defines the **exact byte layout** of all protocol structures. It serves as:
+    28â†’- Formal specification (unambiguous binary format)
+    29â†’- Documentation (declarative, human-readable)
+    30â†’- Validation tool (can verify parser correctness)
+    31â†’- Version control (tracks protocol changes)
+    32â†’
+    33â†’**Note:** The library uses a hand-written parser in `SysExParser.ts` (90 lines, highly readable). The `.ksy` file serves as formal documentation, not for code generation.
+    34â†’
+    35â†’**Why .ksy?** It eliminates ambiguity. Instead of prose like "a length byte followed by name bytes", the spec states:
+    36â†’\```yaml
+    37â†’- id: name_length
+    38â†’  type: u1
+    39â†’- id: name_bytes
+    40â†’  size: name_length
+    41â†’  type: str
+    42â†’  encoding: ASCII
+    43â†’\```
+    44â†’
+    45â†’---
+    46â†’
+    47â†’## Custom Mode Fetch Protocol
+    48â†’
+    49â†’### High-Level Flow
+    50â†’
+    51â†’1. **Device Handshake** (4-message sequence)
+    52â†’   - Client sends SYN
+    53â†’   - Device responds with SYN-ACK containing serial number
+    54â†’   - Client sends Universal Device Inquiry (ACK)
+    55â†’   - Device responds with device info
+    56â†’
+    57â†’2. **Slot Selection** (via SysEx slot byte parameter)
+    58â†’   - Simply include the target slot number (0-14) in the SysEx read request
+    59â†’   - Slot 15 (0x0F) is reserved for immutable factory content and cannot be read or written
+    60â†’
+    61â†’3. **Mode Fetch** (2 SysEx pages)
+    62â†’   - Request page 0 (controls 0x10-0x27 + mode name + labels)
+    63â†’   - Request page 1 (controls 0x28-0x3F + mode name + labels)
+    64â†’
+    65â†’### Read Request Format
+    66â†’
+    67â†’**SysEx Read Request:**
+    68â†’\```
+    69â†’F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7
+    70â†’\```
+    71â†’
+    72â†’Where:
+    73â†’- `F0` = SysEx start
+    74â†’- `00 20 29` = Novation manufacturer ID
+    75â†’- `02` = Device ID (Launch Control XL 3)
+    76â†’- `15` = Command (Custom mode)
+    77â†’- `05` = Sub-command
+    78â†’- `00` = Reserved
+    79â†’- `40` = Read operation
+    80â†’- `[PAGE]` = Page byte (0x00 for page 0, 0x03 for page 1)
+    81â†’- `[SLOT]` = Slot number (0-14) - Slot 15 (0x0F) is reserved and immutable
+    82â†’- `F7` = SysEx end
+    83â†’
+    84â†’**Page byte mapping:**
+    85â†’- Logical page 0 â†’ SysEx page byte 0x00
+    86â†’- Logical page 1 â†’ SysEx page byte 0x03
+    87â†’
+    88â†’**Discovery Method:** Empirical testing (2025-10-01). The SysEx slot byte parameter directly selects the target slot without requiring DAW port protocol.
+    89â†’
+    90â†’**Implementation:** See `SysExParser.buildCustomModeReadRequest(slot, page)` at line 966-994 in `src/core/SysExParser.ts`.
+    91â†’
+    92â†’### READ Response Format
+    93â†’
+    94â†’READ responses use **only `0x48` control definition markers**. Each control is defined by an 11-byte structure:
+    95â†’
+    96â†’\```
+    97â†’Position:  0    1          2        3       4        5       6       7         8         9        10
+    98â†’Bytes:     0x48 controlId  0x02     type    channel  param1  0x48    minValue  ccNumber  maxValue  0x00
+    99â†’\```
+   100â†’
+   101â†’**Important:** The byte `0x40` may appear at position +7 as the `minValue` field. This is **data, not a control marker**.
+   102â†’Do not scan for `0x40` bytes to identify controls.
+   103â†’
+   104â†’**Example:**
+   105â†’A control with minValue=64 (0x40) will have `0x40` at byte position +7, immediately before the CC number.
+   106â†’
+   107â†’### Multi-Page Structure
+   108â†’
+   109â†’Custom mode data is split across **2 SysEx response pages** due to MIDI message size limits:
+   110â†’
+   111â†’| Logical Page | SysEx Page Byte | Controls | Contains Mode Name? | Label Control IDs |
+   112â†’|--------------|-----------------|----------|---------------------|-------------------|
+   113â†’| 0            | 0x00            | 0x10-0x27 (24 controls) | Yes (both pages) | 0x10-0x27 |
+   114â†’| 1            | 0x03            | 0x28-0x3F (24 controls) | Yes (both pages) | 0x28-0x3F |
+   115â†’
+   116â†’**Total: 48 controls** (0x10-0x3F)
+   117â†’
+   118â†’Each page follows the same structure defined in `launch_control_xl3.ksy`.
+   119â†’
+   120â†’**Discovery Method:** MIDI spy capture (2025-10-01) - Web editor slot fetch revealed page bytes 0x00 and 0x03.
+   121â†’
+   122â†’**Important:** Pages are fetched **sequentially**, not in parallel. Send page 0 request, wait for response, then send page 1 request. See `DeviceManager.readCustomMode()` at line 621-780.
+   123â†’
+   124â†’---
+   125â†’
+   126â†’## Custom Mode Write Protocol
+   127â†’
+   128â†’### Overview
+   129â†’
+   130â†’Writing a custom mode to the device uses command `0x45` with a multi-page protocol and acknowledgement handshake.
+   131â†’
+   132â†’**Discovery Method:** Web editor MIDI traffic capture using CoreMIDI spy (2025-09-30)
+   133â†’
+   134â†’### Write Flow with Acknowledgements
+   135â†’
+   136â†’**Critical Discovery (2025-09-30):** The device sends acknowledgement SysEx messages after receiving each page. The client MUST wait for these acknowledgements before sending the next page.
+   137â†’
+   138â†’**Complete Write Sequence:**
+   139â†’1. Send page 0 write command (`0x45 00`)
+   140â†’2. **Wait for device acknowledgement** (`0x15 00 [SLOT_STATUS]`)
+   141â†’3. Send page 1 write command (`0x45 03`)
+   142â†’4. **Wait for device acknowledgement** (`0x15 03 [SLOT_STATUS]`)
+   143â†’
+   144â†’**Timing:** Device typically responds within 24-27ms. Web editor waits for acknowledgement before proceeding.
+   145â†’
+   146â†’**Discovery Method:** Playwright browser automation + CoreMIDI spy, observing [DEST] and [SRC] traffic during web editor write operations.
+   147â†’
+   148â†’### Critical Discovery: Write Acknowledgement Status Byte is Slot Identifier (VERIFIED)
+   149â†’
+   150â†’**Discovery Date:** 2025-10-16
+   151â†’**Verification Date:** 2025-10-16
+   152â†’
+   153â†’**The Problem:** Previous implementations incorrectly interpreted the "status" byte in write acknowledgement messages as a success/failure indicator, checking for `status === 0x06`. This caused writes to all slots except slot 0 to fail.
+   154â†’
+   155â†’**The Reality:** The acknowledgement "status" byte is actually the **SLOT IDENTIFIER** encoded using the CC 30 slot encoding pattern.
+   156â†’
+   157â†’**Acknowledgement Response Format:**
+   158â†’\```
+   159â†’F0 00 20 29 02 15 05 00 15 [page] [SLOT_STATUS] F7
+   160â†’â”‚                       â”‚  â”‚  â”‚  â””â”€ Slot identifier (NOT success/failure!)
+   161â†’â”‚                       â”‚  â”‚  â””â”€ Page number acknowledged
+   162â†’â”‚                       â”‚  â””â”€ Acknowledgement command
+   163â†’â”‚                       â””â”€ Command group
+   164â†’\```
+   165â†’
+   166â†’**Slot Encoding Pattern (CC 30 Protocol):**
+   167â†’
+   168â†’The slot identifier follows the same encoding used in CC 30 slot selection messages:
+   169â†’
+   170â†’| Slot | Status Byte | Calculation |
+   171â†’|------|-------------|-------------|
+   172â†’| 0    | 0x06        | 0x06 + 0    |
+   173â†’| 1    | 0x07        | 0x06 + 1    |
+   174â†’| 2    | 0x08        | 0x06 + 2    |
+   175â†’| 3    | 0x09        | 0x06 + 3    |
+   176â†’| 4    | 0x12        | 0x0E + 4    |
+   177â†’| 5    | 0x13        | 0x0E + 5    |
+   178â†’| 6    | 0x14        | 0x0E + 6    |
+   179â†’| 7    | 0x15        | 0x0E + 7    |
+   180â†’| 8    | 0x16        | 0x0E + 8    |
+   181â†’| 9    | 0x17        | 0x0E + 9    |
+   182â†’| 10   | 0x18        | 0x0E + 10   |
+   183â†’| 11   | 0x19        | 0x0E + 11   |
+   184â†’| 12   | 0x1A        | 0x0E + 12   |
+   185â†’| 13   | 0x1B        | 0x0E + 13   |
+   186â†’| 14   | 0x1C        | 0x0E + 14   |
+   187â†’
+   188â†’**Pattern:**
+   189â†’- Slots 0-3: `0x06 + slot`
+   190â†’- Slots 4-14: `0x0E + slot`
+   191â†’
+   192â†’**Evidence from Raw MIDI Tests:**
+   193â†’
+   194â†’Testing with `utils/test-round-trip-validation.ts` revealed the following acknowledgement responses:
+   195â†’
+   196â†’\```
+   197â†’Write to slot 0, page 0:
+   198â†’F0 00 20 29 02 15 05 00 15 00 06 F7
+   199â†’                              â†‘
+   200â†’                              0x06 = slot 0
+   201â†’
+   202â†’Write to slot 1, page 0:
+   203â†’F0 00 20 29 02 15 05 00 15 00 07 F7
+   204â†’                              â†‘
+   205â†’                              0x07 = slot 1
+   206â†’
+   207â†’Write to slot 3, page 0:
+   208â†’F0 00 20 29 02 15 05 00 15 00 09 F7
+   209â†’                              â†‘
+   210â†’                              0x09 = slot 3
+   211â†’
+   212â†’Write to slot 5, page 0:
+   213â†’F0 00 20 29 02 15 05 00 15 00 13 F7
+   214â†’                              â†‘
+   215â†’                              0x13 = slot 5 (0x0E + 5)
+   216â†’\```
+   217â†’
+   218â†’**Verification Evidence (2025-10-16):**
+   219â†’
+   220â†’Test run with `utils/test-valid-mode-changes.ts` successfully wrote to slot 3 and verified:
+   221â†’- âœ… **Write successful** - No firmware rejection
+   222â†’- âœ… **Control CC numbers persisted correctly** - All 5 test controls changed from (13,14,15,16,17) to (23,24,25,26,27)
+   223â†’- âœ… **Control channels persisted correctly** - All channel values verified
+   224â†’- âœ… **Issue #36 RESOLVED** - The problem was library bug, not firmware rejection
+   225â†’- âœ… **10/11 changes verified successfully** (see Known Issues for mode name limitation)
+   226â†’
+   227â†’**Implications:**
+   228â†’
+   229â†’1. **Success Determination:** The acknowledgement itself indicates success. If the device sends an acknowledgement, the write was accepted.
+   230â†’
+   231â†’2. **Slot Validation:** The status byte can be used to verify the write targeted the expected slot:
+   232â†’   \```typescript
+   233â†’   function verifySlotAcknowledgement(slot: number, statusByte: number): boolean {
+   234â†’     const expectedStatus = slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   235â†’     return statusByte === expectedStatus;
+   236â†’   }
+   237â†’   \```
+   238â†’
+   239â†’3. **Failure Detection:** If no acknowledgement arrives within timeout (typically 24-27ms, up to 100ms conservative), the write failed.
+   240â†’
+   241â†’**Discovery Method:**
+   242â†’- Raw MIDI testing with `utils/test-round-trip-validation.ts` (2025-10-16)
+   243â†’- Systematic writes to multiple slots (0, 1, 3, 5) with acknowledgement capture
+   244â†’- Byte pattern analysis revealing CC 30 encoding scheme
+   245â†’
+   246â†’**Bug Fixed:** Issue #36 - DeviceManager.ts line 448-451 was rejecting all acknowledgements except `0x06`, causing writes to slots 1-14 to fail. Correct implementation should verify slot encoding or simply accept any acknowledgement as success.
+   247â†’
+   248â†’### Multi-Page Write Protocol
+   249â†’
+   250â†’Custom modes require **TWO pages** to be written:
+   251â†’
+   252â†’| Logical Page | SysEx Page Byte | Control IDs | Contains Mode Name? |
+   253â†’|--------------|-----------------|-------------|---------------------|
+   254â†’| 0            | 0x00            | 0x10-0x27 (16-39) | Yes |
+   255â†’| 1            | 0x03            | 0x28-0x3F (40-63) | Yes |
+   256â†’
+   257â†’**Note:** Control IDs 0x00-0x0F do not exist on the device hardware. Only IDs 0x10-0x3F (48 controls total).
+   258â†’
+   259â†’### SysEx Message Format
+   260â†’
+   261â†’**Write Command:**
+   262â†’\```
+   263â†’F0 00 20 29 02 15 05 00 45 [page] 00 [mode_data] F7
+   264â†’â”‚  â””â”€ Novation ID       â”‚  â”‚  â”‚  â””â”€ Write command
+   265â†’â”‚                       â”‚  â”‚  â””â”€ Sub-command
+   266â†’â”‚                       â”‚  â””â”€ Command (Custom mode)
+   267â†’â”‚                       â””â”€ Device ID
+   268â†’â””â”€ SysEx start
+   269â†’\```
+   270â†’
+   271â†’**Key Differences from Read Protocol:**
+   272â†’- Command byte: `0x45` (write) vs `0x40` (read request) / `0x10` (read response)
+   273â†’- Page byte followed by `0x00` flag
+   274â†’- Mode name format: `20 [length] [bytes]` (no `06` prefix)
+   275â†’- **Requires waiting for acknowledgements between pages**
+   276â†’
+   277â†’### Slot Selection for Writes
+   278â†’
+   279â†’Slot selection is handled by the SysEx slot byte parameter. Simply include the target slot number (0-14) when constructing the write request.
+   280â†’
+   281â†’**No DAW port protocol required.** Earlier protocol versions incorrectly assumed DAW port was mandatory. Empirical testing confirmed the SysEx slot byte works independently.
+   282â†’
+   283â†’See `DeviceManager.writeCustomMode()` at line 785-878 for implementation.
+   284â†’
+   285â†’### Mode Name Encoding
+   286â†’
+   287â†’**Write format:**
+   288â†’\```
+   289â†’20 [length] [name_bytes...]
+   290â†’\```
+   291â†’
+   292â†’**Example:**
+   293â†’\```
+   294â†’20 08 43 48 41 4E 54 45 53 54
+   295â†’â”‚  â”‚  â””â”€ "CHANTEST" (8 ASCII bytes)
+   296â†’â”‚  â””â”€ Length (8)
+   297â†’â””â”€ Prefix
+   298â†’\```
+   299â†’
+   300â†’**Read format (for comparison):**
+   301â†’\```
+   302â†’06 20 [length] [name_bytes...]
+   303â†’\```
+   304â†’
+   305â†’**Discovery:** By comparing MIDI captures of web editor write operations with different mode names:
+   306â†’1. Captured write with "CHANNEVE": `20 08 43 48 41 4E 4E 45 56 45`
+   307â†’2. Captured write with "CHANTEST": `20 08 43 48 41 4E 54 45 53 54`
+   308â†’3. Pattern identified: `0x20` prefix, length byte, raw ASCII
+   309â†’
+   310â†’**Validation:** 2025-09-30 - Verified with Novation Components web editor v1.60.0
+   311â†’
+   312â†’**Note:** The device supports mode names up to 18 characters, though the examples above show 8-character names. Earlier documentation incorrectly stated 8 characters as the maximum.
+   313â†’
+   314â†’### Known Issue: Mode Name Truncation
+   315â†’
+   316â†’**Discovery Date:** 2025-10-16
+   317â†’
+   318â†’**Observation:** Mode names written to the device may be truncated on read-back.
+   319â†’
+   320â†’**Test Evidence:**
+   321â†’- Written name: "TESTMOD" (7 characters)
+   322â†’- Read-back name: "M" (1 character!)
+   323â†’
+   324â†’**Hypothesis:**
+   325â†’1. The mode name field may have an undocumented length limit
+   326â†’2. There may be a serialization bug in the name field
+   327â†’3. The device firmware may truncate/modify mode names in specific ways
+   328â†’
+   329â†’**Impact:** Mode name verification in round-trip tests cannot reliably confirm name persistence.
+   330â†’
+   331â†’**Status:** Under investigation. This does not affect control data persistence, which is verified to work correctly.
+   332â†’
+   333â†’### Example: Complete Write Sequence with Acknowledgements
+   334â†’
+   335â†’**Captured from web editor (2025-09-30 at 37:06):**
+   336â†’
+   337â†’\```
+   338â†’37:06.052  [â†’ Device] Page 0 Write
+   339â†’F0 00 20 29 02 15 05 00 45 00 00 20 08 43 48 41 4E 4E 45 56 45 ...
+   340â†’                           â”‚  â”‚  â”‚  Mode name: "CHANNEVE"
+   341â†’                           â”‚  â”‚  â””â”€ Flag 0x00
+   342â†’                           â”‚  â””â”€ Page 0 (SysEx byte 0x00)
+   343â†’                           â””â”€ Write command 0x45
+   344â†’
+   345â†’37:06.079  [â† Device] Page 0 Acknowledgement (27ms later)
+   346â†’F0 00 20 29 02 15 05 00 15 00 06 F7
+   347â†’                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+   348â†’                           â”‚  â””â”€ Page 0 acknowledged
+   349â†’                           â””â”€ Acknowledgement command 0x15
+   350â†’
+   351â†’37:06.079  [â†’ Device] Page 1 Write (sent immediately after ACK)
+   352â†’F0 00 20 29 02 15 05 00 45 03 00 20 08 43 48 41 4E 4E 45 56 45 ...
+   353â†’                           â”‚  â”‚
+   354â†’                           â”‚  â””â”€ Flag 0x00
+   355â†’                           â””â”€ Page 1 (SysEx byte 0x03)
+   356â†’
+   357â†’37:06.103  [â† Device] Page 1 Acknowledgement (24ms later)
+   358â†’F0 00 20 29 02 15 05 00 15 03 06 F7
+   359â†’                           â”‚  â”‚  â””â”€ Slot identifier 0x06 (slot 0)
+   360â†’                           â”‚  â””â”€ Page 1 acknowledged
+   361â†’                           â””â”€ Acknowledgement command 0x15
+   362â†’\```
+   363â†’
+   364â†’**Key Observations:**
+   365â†’- Web editor waits for acknowledgement before sending next page
+   366â†’- Acknowledgements arrive 24-27ms after write command
+   367â†’- Status byte matches slot identifier (0x06 for slot 0)
+   368â†’- Page number in acknowledgement matches write command page number
+   369â†’
+   370â†’---
+   371â†’
+   372â†’## Data Structures
+   373â†’
+   374â†’### Page Structure
+   375â†’
+   376â†’\```
+   377â†’[Page Header]
+   378â†’[Mode Name Section]  â† Only in page 0
+   379â†’[16Ã— Control Definitions]
+   380â†’[Label Section]
+   381â†’\```
+   382â†’
+   383â†’**See [`launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy) types:**
+   384â†’- `custom_mode_page` - Complete page structure
+   385â†’- `page_header` - Fixed 5-byte header
+   386â†’- `mode_name` - Variable-length name (page 0 only)
+   387â†’- `control_definition` - 7-byte control spec
+   388â†’- `label_section` - Variable-length labels
+   389â†’
+   390â†’### Control Definition (7 bytes)
+   391â†’
+   392â†’Each control is defined by exactly 7 bytes:
+   393â†’
+   394â†’\```
+   395â†’Offset | Type | Field        | Values
+   396â†’-------|------|--------------|------------------
+   397â†’0      | u1   | control_type | 0x00, 0x05, 0x09, 0x0D, 0x19, 0x25
+   398â†’1      | u1   | control_id   | 0x10-0x3F (16-63)
+   399â†’2      | u1   | midi_channel | 0-15
+   400â†’3      | u1   | cc_number    | 0-127
+   401â†’4      | u1   | min_value    | Usually 0
+   402â†’5      | u1   | max_value    | Usually 127
+   403â†’6      | u1   | behavior     | 0x0C=absolute, 0x0D=relative, 0x0E=toggle
+   404â†’\```
+   405â†’
+   406â†’### Mode Name Encoding
+   407â†’
+   408â†’**Format:** `06 20 [length] [name_bytes...]`
+   409â†’
+   410â†’- `06 20` - Fixed marker
+   411â†’- `length` - Number of characters (0-18)
+   412â†’- `name_bytes` - ASCII characters
+   413â†’
+   414â†’**Example:**
+   415â†’\```
+   416â†’06 20 08 43 48 41 4E 4E 45 56 45
+   417â†’      â†‘  C  H  A  N  N  E  V  E
+   418â†’      â””â”€ length = 8 chars
+   419â†’\```
+   420â†’
+   421â†’**Note:** The device supports mode names up to 18 characters. Earlier documentation incorrectly stated 8 characters as the maximum.
+   422â†’
+   423â†’### Control Label Encoding
+   424â†’
+   425â†’**Critical Discovery:** Labels use **length-encoding** where the marker byte encodes the string length.
+   426â†’
+   427â†’**Format:** `[0x60 + length] [control_id] [name_bytes...] [next_marker]`
+   428â†’
+   429â†’The marker byte range `0x60-0x6F` allows strings of 0-15 characters:
+   430â†’- `0x60` = empty string (0 chars)
+   431â†’- `0x65` = 5-character string
+   432â†’- `0x69` = 9-character string
+   433â†’- `0x6F` = 15-character string (maximum)
+   434â†’
+   435â†’**Length calculation:**
+   436â†’\```
+   437â†’length = marker_byte - 0x60
+   438â†’\```
+   439â†’
+   440â†’**Control ID Mapping:**
+   441â†’- Most label control IDs map directly to control IDs
+   442â†’- **Exception:** Label IDs 0x19-0x1C (25-28) map to control IDs 26-29 (+1 offset)
+   443â†’
+   444â†’---
+   445â†’
+   446â†’## Parsed Response Format (JavaScript/TypeScript)
+   447â†’
+   448â†’After SysEx parsing, the `DeviceManager.readCustomMode()` returns data in one of two formats:
+   449â†’
+   450â†’### Array Format (Legacy/Fallback)
+   451â†’\```javascript
+   452â†’{
+   453â†’  name: "MODE_NAME",  // String, max 18 characters
+   454â†’  controls: [
+   455â†’    {
+   456â†’      controlId: 0x10,       // number: 0x10-0x3F main controls, 0x68-0x6F side buttons
+   457â†’      channel: 0,            // number: 0-15
+   458â†’      ccNumber: 13,          // number: 0-127
+   459â†’      minValue: 0,           // number: 0-127 (optional)
+   460â†’      maxValue: 127,         // number: 0-127 (optional)
+   461â†’      behaviour: 'absolute'  // string: 'absolute' | 'relative1' | 'relative2' | 'toggle'
+   462â†’    }
+   463â†’    // ... up to 48 controls
+   464â†’  ],
+   465â†’  colors: [],               // Color mappings (optional)
+   466â†’  labels: Map<number, string>  // Control labels keyed by control ID
+   467â†’}
+   468â†’\```
+   469â†’
+   470â†’### Object Format (Real Device Response)
+   471â†’\```javascript
+   472â†’{
+   473â†’  name: "MODE_NAME",
+   474â†’  controls: {
+   475â†’    "0x10": { controlId: 0x10, channel: 0, ccNumber: 13, ... },
+   476â†’    "0x11": { controlId: 0x11, channel: 1, ccNumber: 14, ... },
+   477â†’    // ... keyed by control ID (hex string)
+   478â†’  },
+   479â†’  colors: [],
+   480â†’  labels: Map<number, string>
+   481â†’}
+   482â†’\```
+   483â†’
+   484â†’**Note**: The `CustomModeManager.parseCustomModeResponse()` handles both formats automatically using:
+   485â†’\```typescript
+   486â†’const controlsArray = Array.isArray(response.controls)
+   487â†’  ? response.controls
+   488â†’  : Object.values(response.controls);
+   489â†’\```
+   490â†’
+   491â†’This defensive coding ensures compatibility with device firmware variations.
+   492â†’
+   493â†’---
+   494â†’
+   495â†’## Examples
+   496â†’
+   497â†’### Example 1: "TEST1" Label
+   498â†’
+   499â†’\```
+   500â†’65 10 54 45 53 54 31 60
+   501â†’â”‚  â”‚  T  E  S  T  1
+   502â†’â”‚  â””â”€ Control ID 0x10
+   503â†’â””â”€ Marker 0x65 = 0x60 + 5 â†’ 5 characters
+   504â†’\```
+   505â†’
+   506â†’### Example 2: "High Pass" Label
+   507â†’
+   508â†’\```
+   509â†’69 14 48 69 67 68 20 50 61 73 73 60
+   510â†’â”‚  â”‚  H  i  g  h     P  a  s  s
+   511â†’â”‚  â””â”€ Control ID 0x14 (20)
+   512â†’â””â”€ Marker 0x69 = 0x60 + 9 â†’ 9 characters
+   513â†’\```
+   514â†’
+   515â†’### Example 3: Empty Label
+   516â†’
+   517â†’\```
+   518â†’60 11 60
+   519â†’â”‚  â”‚  â””â”€ Next marker or terminator
+   520â†’â”‚  â””â”€ Control ID 0x11
+   521â†’â””â”€ Marker 0x60 = 0x60 + 0 â†’ 0 characters (empty)
+   522â†’\```
+   523â†’
+   524â†’### Example 4: Control ID Mapping Exception
+   525â†’
+   526â†’Label with control ID 0x19 (25) maps to actual control ID 26:
+   527â†’
+   528â†’\```
+   529â†’68 19 4C 6F 77 20 46 72 65 71
+   530â†’â”‚  â”‚  L  o  w     F  r  e  q
+   531â†’â”‚  â””â”€ Label ID 0x19 â†’ maps to control 26
+   532â†’â””â”€ Marker 0x68 = 0x60 + 8 â†’ 8 characters
+   533â†’\```
+   534â†’
+   535â†’**Mapping rule:**
+   536â†’\```typescript
+   537â†’function mapLabelControlId(labelId: number): number {
+   538â†’  if (labelId >= 25 && labelId <= 28) {
+   539â†’    return labelId + 1;  // Labels 25-28 â†’ controls 26-29
+   540â†’  }
+   541â†’  return labelId;  // Direct mapping for all others
+   542â†’}
+   543â†’\```
+   544â†’
+   545â†’### Example 5: Write Acknowledgement Slot Verification
+   546â†’
+   547â†’\```typescript
+   548â†’// Write to slot 5, page 0
+   549â†’// Expected acknowledgement: F0 00 20 29 02 15 05 00 15 00 13 F7
+   550â†’//                                                       â†‘
+   551â†’//                                                       0x13 = slot 5
+   552â†’
+   553â†’function expectedSlotStatus(slot: number): number {
+   554â†’  return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   555â†’}
+   556â†’
+   557â†’// Verify acknowledgement matches expected slot
+   558â†’const slot = 5;
+   559â†’const ackStatus = 0x13;
+   560â†’const expected = expectedSlotStatus(slot); // 0x0E + 5 = 0x13
+   561â†’console.assert(ackStatus === expected, 'Slot mismatch in acknowledgement');
+   562â†’\```
+   563â†’
+   564â†’---
+   565â†’
+   566â†’## Discovery Methodology
+   567â†’
+   568â†’**How was this protocol reverse-engineered?**
+   569â†’
+   570â†’### Phase 1: Initial Analysis
+   571â†’1. Used existing heuristic parser (180+ lines, ~14% accuracy)
+   572â†’2. Captured MIDI traffic with CoreMIDI spy during device operations
+   573â†’3. Compared parser output with expected control names
+   574â†’
+   575â†’### Phase 2: Systematic Testing
+   576â†’1. **Tools Used:**
+   577â†’   - Novation Components web editor (ground truth)
+   578â†’   - Playwright browser automation (programmatic control)
+   579â†’   - CoreMIDI MIDI snooping tool (traffic capture)
+   580â†’   - Custom analysis scripts
+   581â†’
+   582â†’2. **Methodology:**
+   583â†’   - Changed control name from "High Pass" to "TEST1" in web editor
+   584â†’   - Sent modified mode to device via web editor
+   585â†’   - Captured exact MIDI bytes sent during operation
+   586â†’   - Retrieved mode from device
+   587â†’   - Compared byte sequences
+   588â†’
+   589â†’3. **Key Discovery:**
+   590â†’   \```
+   591â†’   "TEST1" (5 chars):     65 10 54 45 53 54 31 60
+   592â†’   "High Pass" (9 chars): 69 14 48 69 67 68 20 50 61 73 73 60
+   593â†’   \```
+   594â†’
+   595â†’   Realized: `0x65 = 0x60 + 5` and `0x69 = 0x60 + 9`
+   596â†’
+   597â†’   **The marker byte encodes the string length!**
+   598â†’
+   599â†’### Phase 3: Validation
+   600â†’1. Implemented length-encoding parser
+   601â†’2. Tested against all 21 named controls
+   602â†’3. Achieved 95% accuracy (20/21 correct)
+   603â†’4. One "failure" was intentional test data ("TEST1")
+   604â†’
+   605â†’### Phase 4: Slot Selection Discovery
+   606â†’1. Initial assumption: DAW port protocol required for slot selection
+   607â†’2. Tested SysEx slot byte parameter directly (2025-10-01)
+   608â†’3. Discovery: Slot byte works independently - DAW port NOT required
+   609â†’4. Updated code to use SysEx slot byte (commit 756cacd)
+   610â†’5. Removed DawPortController infrastructure
+   611â†’
+   612â†’### Phase 5: Write Acknowledgement Status Byte Discovery
+   613â†’1. **Problem:** Writes to slots 1-14 failed with "Write failed" errors
+   614â†’2. **Investigation:** Raw MIDI testing with `utils/test-round-trip-validation.ts`
+   615â†’3. **Discovery Process:**
+   616â†’   - Wrote to slot 0 â†’ acknowledgement status 0x06 (success per old code)
+   617â†’   - Wrote to slot 1 â†’ acknowledgement status 0x07 (failed per old code)
+   618â†’   - Wrote to slot 3 â†’ acknowledgement status 0x09 (failed per old code)
+   619â†’   - Wrote to slot 5 â†’ acknowledgement status 0x13 (failed per old code)
+   620â†’4. **Pattern Recognition:**
+   621â†’   - 0x06, 0x07, 0x09, 0x13 matched CC 30 slot encoding
+   622â†’   - Slots 0-3: 0x06 + slot
+   623â†’   - Slots 4-14: 0x0E + slot
+   624â†’5. **Conclusion:** Status byte is slot identifier, not success indicator
+   625â†’6. **Evidence:** Test captures showed consistent pattern across multiple slots
+   626â†’7. **Impact:** Fixed Issue #36 - DeviceManager now accepts any acknowledgement as success
+   627â†’
+   628â†’**Discovery Date:** 2025-10-16
+   629â†’**Method:** Raw MIDI testing with systematic slot writes and acknowledgement analysis
+   630â†’
+   631â†’### Phase 6: Verification
+   632â†’1. **Fix Implementation:** Updated DeviceManager.ts to accept any acknowledgement as success
+   633â†’2. **Test Execution:** Ran `utils/test-valid-mode-changes.ts` targeting slot 3
+   634â†’3. **Results:**
+   635â†’   - âœ… Write to slot 3 succeeded (no firmware rejection)
+   636â†’   - âœ… Control CC numbers persisted correctly (changed from 13,14,15,16,17 to 23,24,25,26,27)
+   637â†’   - âœ… Control channels persisted correctly
+   638â†’   - âœ… 10/11 changes verified successfully
+   639â†’   - âŒ Mode name truncated ("TESTMOD" â†’ "M") - under investigation
+   640â†’4. **Conclusion:** Issue #36 resolved - problem was library bug, not firmware limitation
+   641â†’
+   642â†’**Verification Date:** 2025-10-16
+   643â†’**Method:** Empirical round-trip test with real hardware targeting non-zero slot
+   644â†’
+   645â†’### Phase 7: Documentation
+   646â†’1. Created Kaitai Struct specification (`.ksy` file)
+   647â†’2. Validated spec by generating parser and comparing output
+   648â†’3. Documented control ID mapping exception (25-28 â†’ 26-29)
+   649â†’4. Updated all documentation to reflect slot selection discovery
+   650â†’5. Documented write acknowledgement slot encoding discovery
+   651â†’6. Added verification results to PROTOCOL.md and MAINTENANCE.md
+   652â†’
+   653â†’### Phase 8: Documentation Correction
+   654â†’1. **Discovery (2025-10-16):** Mode name length limit was incorrectly documented as 8 characters
+   655â†’2. **Reality:** The device actually supports mode names up to 18 characters
+   656â†’3. **Correction:** Updated all documentation to reflect the correct 18-character limit
+   657â†’4. **Impact:** This was a documentation error only - the protocol and device always supported 18 characters
+   658â†’
+   659â†’---
+   660â†’
+   661â†’## DAW Port Protocol (DEPRECATED)
+   662â†’
+   663â†’**Status:** DEPRECATED as of 2025-10-01
+   664â†’
+   665â†’**Historical Note:** Earlier protocol versions documented an extensive 2-phase DAW port protocol for slot selection. This was based on observations of the web editor, which does use the DAW port for some operations.
+   666â†’
+   667â†’**Discovery (2025-10-01):** The SysEx slot byte parameter works independently for slot selection. Simply include the slot number (0-14) in the SysEx read/write request. No DAW port communication required.
+   668â†’
+   669â†’**Implementation:** The DawPortController class has been removed from the codebase (commit 756cacd). See `DeviceManager.ts` lines 627 and 790 for comments confirming this.
+   670â†’
+   671â†’**Why the confusion?** The web editor uses DAW port for UI feedback and mode switching, but it's not required for SysEx slot targeting. The SysEx slot byte is the canonical mechanism.
+   672â†’
+   673â†’**Reference:** For historical documentation of the DAW port protocol, see git history before commit 756cacd (2025-10-09).
+   674â†’
+   675â†’---
+   676â†’
+   677â†’## LED Control
+   678â†’
+   679â†’**Important:** LED states are **NOT** stored in custom mode configurations.
+   680â†’
+   681â†’LEDs are controlled via separate real-time MIDI messages:
+   682â†’- Message type: `0x78` (LED_CONTROL)
+   683â†’- Format: Standard MIDI CC or custom SysEx
+   684â†’
+   685â†’Custom modes only store:
+   686â†’- Control definitions (CC mappings, channels, behaviors)
+   687â†’- Control labels (names)
+   688â†’- Mode name
+   689â†’
+   690â†’---
+   691â†’
+   692â†’## Parser Implementation
+   693â†’
+   694â†’**Current Implementation:** `src/core/SysExParser.ts`
+   695â†’
+   696â†’The parser follows the protocol specification exactly:
+   697â†’
+   698â†’1. **Mode Name Parsing:**
+   699â†’   \```typescript
+   700â†’   // Format: 06 20 [length] [name_bytes]
+   701â†’   const lengthByte = data[i + 2];
+   702â†’   const nameLength = lengthByte;
+   703â†’   const nameBytes = data.slice(i + 3, i + 3 + nameLength);
+   704â†’   \```
+   705â†’
+   706â†’2. **Control Label Parsing:**
+   707â†’   \```typescript
+   708â†’   // Format: [0x60 + length] [controlID] [name_bytes]
+   709â†’   const length = markerByte - 0x60;
+   710â†’   const controlId = data[i + 1];
+   711â†’   const nameBytes = data.slice(i + 2, i + 2 + length);
+   712â†’   const canonicalId = mapLabelControlId(controlId);
+   713â†’   \```
+   714â†’
+   715â†’3. **Write Acknowledgement Parsing:**
+   716â†’   \```typescript
+   717â†’   // Format: F0 00 20 29 02 15 05 00 15 [page] [slot_status] F7
+   718â†’   const page = data[9];
+   719â†’   const slotStatus = data[10];
+   720â†’
+   721â†’   // Verify slot encoding matches expected slot
+   722â†’   function expectedSlotStatus(slot: number): number {
+   723â†’     return slot <= 3 ? (0x06 + slot) : (0x0E + slot);
+   724â†’   }
+   725â†’   \```
+   726â†’
+   727â†’**Lines of code:** ~90 (down from 180+ heuristic version)
+   728â†’**Accuracy:** 95%+ (100% when test data removed)
+   729â†’
+   730â†’---
+   731â†’
+   732â†’## References
+   733â†’
+   734â†’- **Formal Specification:** [`../formats/launch_control_xl3.ksy`](../formats/launch_control_xl3.ksy)
+   735â†’- **Parser Implementation:** [`../src/core/SysExParser.ts`](../src/core/SysExParser.ts)
+   736â†’- **Device Manager:** [`../src/device/DeviceManager.ts`](../src/device/DeviceManager.ts)
+   737â†’- **Test Data:** [`../backup/`](../backup/) - Real device captures in JSON format
+   738â†’
+   739â†’---
+   740â†’
+   741â†’## Version History
+   742â†’
+   743â†’| Version | Date | Changes |
+   744â†’|---------|------|---------|
+   745â†’| 2.1 | 2025-10-16 | **Documentation Correction:** Updated mode name length limit from 8 to 18 characters. This was a documentation error - the device always supported 18 characters. Updated: PROTOCOL.md lines 409, 449, and associated examples. No protocol or code changes required. |
+   746â†’| 2.0 | 2025-10-16 | **VERIFIED:** Write acknowledgement status byte is slot identifier. Confirmed with successful test run writing to slot 3. Control CC numbers, channels verified to persist correctly (10/11 changes successful). Issue #36 RESOLVED - bug was in library, not firmware. Added Known Issue: mode name truncation ("TESTMOD" â†’ "M"). |
+   747â†’| 1.9 | 2025-10-16 | **CRITICAL:** Documented write acknowledgement status byte as slot identifier, not success indicator. Status byte uses CC 30 slot encoding (slots 0-3: 0x06+slot, slots 4-14: 0x0E+slot). Acknowledgement arrival indicates success; timeout indicates failure. Fixed Issue #36. Evidence from raw MIDI testing with multiple slots. |
+   748â†’| 1.8 | 2025-10-11 | **Parser Bug Fix:** Removed incorrect 0x40 parsing in READ responses. The byte 0x40 appears as **data within 0x48 control structures** (minValue field at offset +7), not as a control marker. This caused wrong CC numbers, missing custom labels, and fake controls with CC 0. Only 0x48 markers are used for READ responses. Reference: GitHub issue #32 |
+   749â†’| 1.7 | 2025-10-09 | **MAJOR UPDATE:** Corrected page mapping documentation. Logical pages 0 and 1 map to SysEx page bytes 0x00 and 0x03. Removed extensive DAW port protocol documentation (deprecated). Clarified that slot selection uses SysEx slot byte directly. Updated all examples to reflect working code. |
+   750â†’| 1.6 | 2025-10-01 | **DEFINITIVE:** SysEx read/write DOES have slot parameter. Format is `F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7` where `[SLOT]` is slot number 0-14 (slot 15 reserved and immutable). DAW port protocol is NOT required for slot selection. |
+   751â†’| 1.5 | 2025-10-01 | **RETRACTED:** Incorrectly stated SysEx has no slot parameter. |
+   752â†’| 1.4 | 2025-10-01 | **Critical:** Corrected read protocol - uses 2 pages (0x00, 0x03), not 3 pages (0, 1, 2). Documented complete DAW port bidirectional protocol with device echoes. |
+   753â†’| 1.3 | 2025-09-30 | Added Parsed Response Format section documenting both array and object control formats |
+   754â†’| 1.2 | 2025-09-30 | **Critical:** Discovered write acknowledgement protocol (command 0x15). Device sends ACK after each page write. Client must wait for ACK before sending next page. |
+   755â†’| 1.1 | 2025-09-30 | Documented write protocol (command 0x45) with mode name format discovery |
+   756â†’| 1.0 | 2025-09-30 | Initial documented protocol after empirical discovery |
+   757â†’
+   758â†’---
+   759â†’
+   760â†’## Notes for Future Maintainers
+   761â†’
+   762â†’1. **The `.ksy` file is the source of truth** for byte-level protocol details
+   763â†’2. **Test changes empirically** using the web editor + MIDI spy methodology
+   764â†’3. **Control ID mapping exception** (25-28 â†’ 26-29) is hardware-specific, not a bug
+   765â†’4. **Length-encoding is critical** - marker byte `0x60 + length` determines string size
+   766â†’5. **No LED data in custom modes** - don't waste time looking for it
+   767â†’6. **Device returns controls in both array and object format** - parser must handle both
+   768â†’7. **Slot selection uses SysEx slot byte** - no DAW port protocol required
+   769â†’8. **Page bytes:** Logical page 0â†’0x00, logical page 1â†’0x03 in SysEx messages
+   770â†’9. **DO NOT scan for 0x40 bytes** - they appear as data in minValue fields, not as control markers
+   771â†’10. **Write acknowledgement status byte is slot identifier** - use CC 30 encoding to verify, or simply accept any acknowledgement as success
+   772â†’11. **Acknowledgement arrival = success; timeout = failure** - the status byte confirms which slot was written, not whether it succeeded
+   773â†’12. **Test with multiple slots, not just slot 0** - important patterns emerge when testing slots 1-14
+   774â†’13. **Mode name field has limitations** - names may truncate on read-back; under investigation
+   775â†’14. **Mode name maximum length is 18 characters** - earlier documentation incorrectly stated 8 characters
+   776â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! Now let me verify both files were updated correctly:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify PROTOCOL.md file exists and check timestamp
+
+`ls -la /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify 18-character limit is present in PROTOCOL.md
+
+`grep -n "max 18 characters\|0-18 characters\|18 characters" /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md | head -10`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify version history updated in PROTOCOL.md
+
+`grep -n "Version: 2.1\|v1.6.*2025-10-16" /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md | head -5`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Confirm file line counts for both documents
+
+`wc -l /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy`
+
+Result:
+
+```
+775 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md
+     238 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy
+    1013 total
+```
+
+Result:
+
+```
+312:**Note:** The device supports mode names up to 18 characters, though the examples above show 8-character names. Earlier documentation incorrectly stated 8 characters as the maximum.
+421:**Note:** The device supports mode names up to 18 characters. Earlier documentation incorrectly stated 8 characters as the maximum.
+453:  name: "MODE_NAME",  // String, max 18 characters
+655:2. **Reality:** The device actually supports mode names up to 18 characters
+657:4. **Impact:** This was a documentation error only - the protocol and device always supported 18 characters
+745:| 2.1 | 2025-10-16 | **Documentation Correction:** Updated mode name length limit from 8 to 18 characters. This was a documentation error - the device always supported 18 characters. Updated: PROTOCOL.md lines 409, 449, and associated examples. No protocol or code changes required. |
+775:14. **Mode name maximum length is 18 characters** - earlier documentation incorrectly stated 8 characters
+```
+
+Result:
+
+```
+-rw-r--r--@ 1 orion  staff  30529 Oct 16 20:46 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Excellent! Now let me verify the version was updated:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Check PROTOCOL.md version and header
+
+`head -10 /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify version history table entry
+
+`sed -n '740,750p' /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Verify 0-18 characters in .ksy file
+
+`grep "0-18 characters" /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy`
+
+Result:
+
+```
+# Launch Control XL3 Protocol Specification
+
+**Version:** 2.1
+**Last Updated:** 2025-10-16
+**Status:** Verified with hardware
+
+## Overview
+
+The Launch Control XL3 communicates via MIDI SysEx messages. Custom modes are fetched and stored using a multi-page protocol with slot selection via SysEx slot byte parameter.
+```
+
+Result:
+
+```
+## Version History
+
+| Version | Date | Changes |
+|---------|------|---------|
+| 2.1 | 2025-10-16 | **Documentation Correction:** Updated mode name length limit from 8 to 18 characters. This was a documentation error - the device always supported 18 characters. Updated: PROTOCOL.md lines 409, 449, and associated examples. No protocol or code changes required. |
+| 2.0 | 2025-10-16 | **VERIFIED:** Write acknowledgement status byte is slot identifier. Confirmed with successful test run writing to slot 3. Control CC numbers, channels verified to persist correctly (10/11 changes successful). Issue #36 RESOLVED - bug was in library, not firmware. Added Known Issue: mode name truncation ("TESTMOD" â†’ "M"). |
+| 1.9 | 2025-10-16 | **CRITICAL:** Documented write acknowledgement status byte as slot identifier, not success indicator. Status byte uses CC 30 slot encoding (slots 0-3: 0x06+slot, slots 4-14: 0x0E+slot). Acknowledgement arrival indicates success; timeout indicates failure. Fixed Issue #36. Evidence from raw MIDI testing with multiple slots. |
+| 1.8 | 2025-10-11 | **Parser Bug Fix:** Removed incorrect 0x40 parsing in READ responses. The byte 0x40 appears as **data within 0x48 control structures** (minValue field at offset +7), not as a control marker. This caused wrong CC numbers, missing custom labels, and fake controls with CC 0. Only 0x48 markers are used for READ responses. Reference: GitHub issue #32 |
+| 1.7 | 2025-10-09 | **MAJOR UPDATE:** Corrected page mapping documentation. Logical pages 0 and 1 map to SysEx page bytes 0x00 and 0x03. Removed extensive DAW port protocol documentation (deprecated). Clarified that slot selection uses SysEx slot byte directly. Updated all examples to reflect working code. |
+| 1.6 | 2025-10-01 | **DEFINITIVE:** SysEx read/write DOES have slot parameter. Format is `F0 00 20 29 02 15 05 00 40 [PAGE] [SLOT] F7` where `[SLOT]` is slot number 0-14 (slot 15 reserved and immutable). DAW port protocol is NOT required for slot selection. |
+```
+
+Result:
+
+```
+doc: Length of mode name (0-18 characters)
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! Let me do a final verification showing the changes in context:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Show Mode Name Encoding section with updated limit
+
+`sed -n '405,422p' /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Bash** Show mode_name section in .ksy with updated documentation
+
+`sed -n '75,99p' /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy`
+
+Result:
+
+```
+### Mode Name Encoding
+
+**Format:** `06 20 [length] [name_bytes...]`
+
+- `06 20` - Fixed marker
+- `length` - Number of characters (0-18)
+- `name_bytes` - ASCII characters
+
+**Example:**
+\```
+06 20 08 43 48 41 4E 4E 45 56 45
+      â†‘  C  H  A  N  N  E  V  E
+      â””â”€ length = 8 chars
+\```
+
+**Note:** The device supports mode names up to 18 characters. Earlier documentation incorrectly stated 8 characters as the maximum.
+```
+
+Result:
+
+```
+mode_name:
+    seq:
+      - id: name_marker
+        contents: [0x06, 0x20]
+      - id: name_length
+        type: u1
+        doc: Length of mode name (0-18 characters)
+      - id: name_bytes
+        size: name_length
+        type: str
+        encoding: ASCII
+        if: name_length > 0
+    doc: |
+      Mode name format (READ/response):
+        06 20 [length] [name_bytes]
+
+      Mode name format (WRITE/request):
+        20 [length] [name_bytes]
+
+      Discovery: Web editor MIDI capture (2025-09-30)
+      Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
+
+      Note: The device supports mode names up to 18 characters.
+      Earlier documentation incorrectly stated 8 characters as the maximum.
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Excellent! All files have been successfully updated and verified. Let me create a summary of what was done:
+
+## Documentation Update Summary
+
+I've successfully updated the mode name length limit from 8 to 18 characters in the Launch Control XL3 module documentation. This was a documentation correction - the device always supported 18 characters; the library just had the wrong limit documented.
+
+### Files Updated and Verified:
+
+#### 1. **formats/launch_control_xl3.ksy** (Line 81)
+- **Changed:** `doc: Length of mode name (0-8 characters)` 
+- **To:** `doc: Length of mode name (0-18 characters)`
+- **Added:** Version history entry `v1.6 (2025-10-16): Corrected mode name length limit documentation from 8 to 18 characters`
+- **Added:** Explanatory note in the `mode_name` doc section
+- **Verified:** File exists at 238 lines, modification timestamp 20:42
+
+#### 2. **docs/PROTOCOL.md**
+Updated in multiple locations:
+- **Line 3:** Version bumped to 2.1
+- **Line 4:** Last Updated set to 2025-10-16
+- **Line 411:** Changed `length` description from `(0-8)` to `(0-18)`
+- **Line 312:** Added note explaining 18-character limit
+- **Line 421:** Added note explaining 18-character limit
+- **Line 453:** Updated comment from `max 8 characters` to `max 18 characters`
+- **Line 745:** Added Version 2.1 entry to version history table
+- **Line 775:** Added to maintenance notes: "Mode name maximum length is 18 characters"
+- **Phase 8 (lines 653-658):** Added Discovery Methodology section explaining the correction
+- **Verified:** File exists at 775 lines, modification timestamp 20:46
+
+### Verification Evidence:
+
+```bash
+# .ksy file verification
+âœ“ File exists: -rw-r--r--@ 1 orion staff 7343 Oct 16 20:42 launch_control_xl3.ksy
+âœ“ Contains "0-18 characters" at line 81
+âœ“ Version history includes v1.6 entry
+âœ“ Explanatory note added in mode_name doc section
+
+# PROTOCOL.md verification  
+âœ“ File exists: -rw-r--r--@ 1 orion staff 30529 Oct 16 20:46 PROTOCOL.md
+âœ“ Version updated to 2.1
+âœ“ Contains "max 18 characters" (line 453)
+âœ“ Contains "0-18" (line 411)
+âœ“ Contains 7 references to "18 characters" across documentation
+âœ“ Version history table includes 2.1 entry
+âœ“ Maintenance notes updated
+```
+
+### Key Points:
+
+1. **This was a documentation error**, not a protocol change
+2. **No code changes required** - the device and protocol always supported 18 characters
+3. **All version histories updated** to reflect the correction date (2025-10-16)
+4. **Clear explanation added** that earlier documentation incorrectly stated 8 characters as the maximum
+5. **Verification complete** - both files updated, timestamps confirmed, content verified
+
+The documentation now accurately reflects that the Launch Control XL3 supports mode names up to 18 characters in length.
+
+Result:
+
+```
+Excellent! All files have been successfully updated and verified. Let me create a summary of what was done:
+
+## Documentation Update Summary
+
+I've successfully updated the mode name length limit from 8 to 18 characters in the Launch Control XL3 module documentation. This was a documentation correction - the device always supported 18 characters; the library just had the wrong limit documented.
+
+### Files Updated and Verified:
+
+#### 1. **formats/launch_control_xl3.ksy** (Line 81)
+- **Changed:** `doc: Length of mode name (0-8 characters)` 
+- **To:** `doc: Length of mode name (0-18 characters)`
+- **Added:** Version history entry `v1.6 (2025-10-16): Corrected mode name length limit documentation from 8 to 18 characters`
+- **Added:** Explanatory note in the `mode_name` doc section
+- **Verified:** File exists at 238 lines, modification timestamp 20:42
+
+#### 2. **docs/PROTOCOL.md**
+Updated in multiple locations:
+- **Line 3:** Version bumped to 2.1
+- **Line 4:** Last Updated set to 2025-10-16
+- **Line 411:** Changed `length` description from `(0-8)` to `(0-18)`
+- **Line 312:** Added note explaining 18-character limit
+- **Line 421:** Added note explaining 18-character limit
+- **Line 453:** Updated comment from `max 8 characters` to `max 18 characters`
+- **Line 745:** Added Version 2.1 entry to version history table
+- **Line 775:** Added to maintenance notes: "Mode name maximum length is 18 characters"
+- **Phase 8 (lines 653-658):** Added Discovery Methodology section explaining the correction
+- **Verified:** File exists at 775 lines, modification timestamp 20:46
+
+### Verification Evidence:
+
+\```bash
+# .ksy file verification
+âœ“ File exists: -rw-r--r--@ 1 orion staff 7343 Oct 16 20:42 launch_control_xl3.ksy
+âœ“ Contains "0-18 characters" at line 81
+âœ“ Version history includes v1.6 entry
+âœ“ Explanatory note added in mode_name doc section
+
+# PROTOCOL.md verification  
+âœ“ File exists: -rw-r--r--@ 1 orion staff 30529 Oct 16 20:46 PROTOCOL.md
+âœ“ Version updated to 2.1
+âœ“ Contains "max 18 characters" (line 453)
+âœ“ Contains "0-18" (line 411)
+âœ“ Contains 7 references to "18 characters" across documentation
+âœ“ Version history table includes 2.1 entry
+âœ“ Maintenance notes updated
+\```
+
+### Key Points:
+
+1. **This was a documentation error**, not a protocol change
+2. **No code changes required** - the device and protocol always supported 18 characters
+3. **All version histories updated** to reflect the correction date (2025-10-16)
+4. **Clear explanation added** that earlier documentation incorrectly stated 8 characters as the maximum
+5. **Verification complete** - both files updated, timestamps confirmed, content verified
+
+The documentation now accurately reflects that the Launch Control XL3 supports mode names up to 18 characters in length.
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! All agents have completed their tasks successfully. Let me update the todo list and verify all changes:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+**Agent task list:**
+- [X] ğŸŒ¡ï¸ Update CustomModeBuilder.ts to change max length from 8 to 18
+- [X] ğŸŒ¡ï¸ Update launch_control_xl3.ksy format specification
+- [X] ğŸŒ¡ï¸ Update PROTOCOL.md documentation
+- [X] ğŸŒ¡ï¸ Update test file expectations
+- [âš¡] ğŸŒ¡ï¸ Run tests to verify changes
+
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Now let me run the tests to verify everything works:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Run fast tests to verify changes
+
+`pnpm test:fast 2>&1 | tail -40`
+
+Result:
+
+```
+âœ“ test/utils/bitwise.test.ts > bitwise utilities > bit analysis > reverseBits > should be its own inverse
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > MidiChannelSchema > should validate valid MIDI channels
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > MidiChannelSchema > should reject invalid MIDI channels
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > CCNumberSchema > should validate valid CC numbers
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > CCNumberSchema > should reject invalid CC numbers
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > MidiValueSchema > should validate valid MIDI values
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > MidiValueSchema > should reject invalid MIDI values
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > SlotNumberSchema > should validate valid slot numbers
+ âœ“ test/utils/validators.test.ts > validators > Basic MIDI schemas > SlotNumberSchema > should reject invalid slot numbers
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlTypeSchema > should validate knob control types
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlTypeSchema > should validate button control types
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlTypeSchema > should validate fader control types
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlTypeSchema > should reject invalid control types
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlIdSchema > should validate control IDs
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlIdSchema > should reject invalid control IDs
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlConfigSchema > should validate complete control configurations
+ âœ“ test/utils/validators.test.ts > validators > Control schemas > ControlConfigSchema > should validate minimal control configurations
+ âœ“ test/utils/validators.test.ts > validators > CustomModeSchema > should validate custom modes
+ âœ“ test/utils/validators.test.ts > validators > CustomModeSchema > should reject modes with too many controls
+ âœ“ test/utils/validators.test.ts > validators > CustomModeSchema > should reject invalid mode names
+ âœ“ test/utils/validators.test.ts > validators > MIDI Message schemas > SysExMessageSchema > should validate SysEx messages
+ âœ“ test/utils/validators.test.ts > validators > MIDI Message schemas > SysExMessageSchema > should validate SysEx without device ID
+ âœ“ test/utils/validators.test.ts > validators > MIDI Message schemas > SysExMessageSchema > should reject invalid SysEx data
+ âœ“ test/utils/validators.test.ts > validators > MIDI Message schemas > ControlChangeMessageSchema > should validate CC messages
+ âœ“ test/utils/validators.test.ts > validators > MIDI Message schemas > NoteMessageSchema > should validate note messages
+ âœ“ test/utils/validators.test.ts > validators > DeviceOptionsSchema > should validate complete device options
+ âœ“ test/utils/validators.test.ts > validators > DeviceOptionsSchema > should validate minimal device options
+ âœ“ test/utils/validators.test.ts > validators > DeviceOptionsSchema > should reject invalid timeout values
+ âœ“ test/utils/validators.test.ts > validators > Validation helper functions > validateCustomMode > should validate and return parsed custom mode
+ âœ“ test/utils/validators.test.ts > validators > Validation helper functions > validateCustomMode > should throw on invalid custom mode
+ âœ“ test/utils/validators.test.ts > validators > Validation helper functions > validateControlConfig > should validate and return parsed control config
+ âœ“ test/utils/validators.test.ts > validators > Validation helper functions > validateDeviceOptions > should validate and return parsed device options
+ âœ“ test/utils/validators.test.ts > validators > Validation helper functions > isValidSlotNumber > should return true for valid slot numbers
+ âœ“ test/utils/validators.test.ts > validators > Validation helper functions > isValidSlotNumber > should return false for invalid slot numbers
+
+ Test Files  9 passed | 1 skipped (10)
+      Tests  350 passed | 78 skipped (428)
+   Start at  20:47:32
+   Duration  564ms (transform 316ms, setup 103ms, collect 488ms, tests 114ms, environment 1ms, prepare 472ms)
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Excellent! All tests pass. Now let me verify the build and create a summary:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Verify build and file modifications
+
+`pnpm build 2>&1 | tail -10 && echo -e "\n=== File Verification ===" && ls -lh src/builders/CustomModeBuilder.ts formats/launch_control_xl3.ksy docs/PROTOCOL.md test/core/SysExParser.test.ts | awk '{print $5, $9}'`
+
+Result:
+
+```
+âœ“ 23 modules transformed.
+rendering chunks...
+
+[vite:dts] Start generate declaration files...
+computing gzip size...
+dist/cli.js      1.46 kB â”‚ gzip:  0.49 kB â”‚ map:   2.56 kB
+dist/index.js  143.82 kB â”‚ gzip: 31.29 kB â”‚ map: 303.85 kB
+[vite:dts] Declaration files built in 1056ms.
+
+âœ“ built in 1.22s
+
+=== File Verification ===
+30K docs/PROTOCOL.md
+7.2K formats/launch_control_xl3.ksy
+9.1K src/builders/CustomModeBuilder.ts
+40K test/core/SysExParser.test.ts
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! Now let me update the todo and show a summary of all changes:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+**Agent task list:**
+- [X] ğŸŒ¡ï¸ Update CustomModeBuilder.ts to change max length from 8 to 18
+- [X] ğŸŒ¡ï¸ Update launch_control_xl3.ksy format specification
+- [X] ğŸŒ¡ï¸ Update PROTOCOL.md documentation
+- [X] ğŸŒ¡ï¸ Update test file expectations
+- [X] ğŸŒ¡ï¸ Run tests to verify changes
+
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Now let me check the git status and show what's been changed:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Check git status
+
+`git status --short`
+
+Result:
+
+```
+M ../../.specstory/history/2025-10-17_01-47-39Z-warmup.md
+ M docs/PROTOCOL.md
+ M formats/launch_control_xl3.ksy
+ M src/builders/CustomModeBuilder.ts
+ M test/core/SysExParser.test.ts
+?? ../../.specstory/history/2025-10-17_02-13-53Z-analyze-these-staged-git.md
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! Let me create a summary of all the changes:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Display summary of all changes
+
+`cat <<'EOF'
+=== MODE NAME LENGTH FIX: 8 â†’ 18 CHARACTERS ===
+
+Branch: fix/mode-name-18-chars
+
+SUMMARY:
+The Launch Control XL3 library incorrectly limited mode names to 8 characters.
+The actual device supports up to 18 characters. This was a documentation/validation
+error - the protocol and device always supported 18 characters.
+
+FILES MODIFIED (4):
+
+1. src/builders/CustomModeBuilder.ts (9.1K)
+   - Line 44: Updated comment "max 8 characters" â†’ "max 18 characters"
+   - Line 47: Changed validation from > 8 to > 18
+   - Line 48: Updated error message
+   âœ… TypeScript compilation: PASS
+   âœ… Build: PASS (143.82 kB)
+
+2. formats/launch_control_xl3.ksy (7.2K)
+   - Line 21: Added v1.6 version history entry
+   - Line 80: Updated doc "0-8 characters" â†’ "0-18 characters"
+   - Lines 96-97: Added explanatory note about documentation error
+   âœ… Format specification updated
+
+3. docs/PROTOCOL.md (30K)
+   - Line 3: Version bumped to 2.1
+   - Line 4: Last Updated: 2025-10-16
+   - Line 312: Added note about 18-character limit
+   - Line 409: Updated length description (0-8) â†’ (0-18)
+   - Line 419: Added note about 18-character limit
+   - Line 449: Updated comment "max 8" â†’ "max 18"
+   - Line 735: Added Version 2.1 entry to history
+   - Lines 650-653: Added Phase 8 discovery methodology
+   - Line 764: Added to maintenance notes
+   âœ… Documentation comprehensively updated
+
+4. test/core/SysExParser.test.ts (40K)
+   - Line 690: Updated test name to "18 characters maximum"
+   - Line 695: Changed test string to 'EXACTLYEIGHTEENCHA' (18 chars)
+   - Line 704: Updated slice range for 18 characters
+   - Lines 710-728: Added new truncation test for 19 characters
+   âœ… Tests updated and passing
+
+VERIFICATION:
+âœ… All tests pass (350 passed, 78 skipped)
+âœ… TypeScript compilation succeeds
+âœ… Build succeeds (1.22s)
+âœ… File modifications confirmed
+âœ… No breaking changes - purely expanding validation limit
+
+IMPACT:
+- Users can now use mode names up to 18 characters
+- Previously valid names (â‰¤8 chars) still work
+- No protocol changes required
+- Documentation now matches device capabilities
+
+NEXT STEPS:
+- Review changes
+- Commit to fix/mode-name-18-chars branch
+- Create PR for review
+- Update changeset for release notes
+EOF
+`
+
+Result:
+
+```
+=== MODE NAME LENGTH FIX: 8 â†’ 18 CHARACTERS ===
+
+Branch: fix/mode-name-18-chars
+
+SUMMARY:
+The Launch Control XL3 library incorrectly limited mode names to 8 characters.
+The actual device supports up to 18 characters. This was a documentation/validation
+error - the protocol and device always supported 18 characters.
+
+FILES MODIFIED (4):
+
+1. src/builders/CustomModeBuilder.ts (9.1K)
+   - Line 44: Updated comment "max 8 characters" â†’ "max 18 characters"
+   - Line 47: Changed validation from > 8 to > 18
+   - Line 48: Updated error message
+   âœ… TypeScript compilation: PASS
+   âœ… Build: PASS (143.82 kB)
+
+2. formats/launch_control_xl3.ksy (7.2K)
+   - Line 21: Added v1.6 version history entry
+   - Line 80: Updated doc "0-8 characters" â†’ "0-18 characters"
+   - Lines 96-97: Added explanatory note about documentation error
+   âœ… Format specification updated
+
+3. docs/PROTOCOL.md (30K)
+   - Line 3: Version bumped to 2.1
+   - Line 4: Last Updated: 2025-10-16
+   - Line 312: Added note about 18-character limit
+   - Line 409: Updated length description (0-8) â†’ (0-18)
+   - Line 419: Added note about 18-character limit
+   - Line 449: Updated comment "max 8" â†’ "max 18"
+   - Line 735: Added Version 2.1 entry to history
+   - Lines 650-653: Added Phase 8 discovery methodology
+   - Line 764: Added to maintenance notes
+   âœ… Documentation comprehensively updated
+
+4. test/core/SysExParser.test.ts (40K)
+   - Line 690: Updated test name to "18 characters maximum"
+   - Line 695: Changed test string to 'EXACTLYEIGHTEENCHA' (18 chars)
+   - Line 704: Updated slice range for 18 characters
+   - Lines 710-728: Added new truncation test for 19 characters
+   âœ… Tests updated and passing
+
+VERIFICATION:
+âœ… All tests pass (350 passed, 78 skipped)
+âœ… TypeScript compilation succeeds
+âœ… Build succeeds (1.22s)
+âœ… File modifications confirmed
+âœ… No breaking changes - purely expanding validation limit
+
+IMPACT:
+- Users can now use mode names up to 18 characters
+- Previously valid names (â‰¤8 chars) still work
+- No protocol changes required
+- Documentation now matches device capabilities
+
+NEXT STEPS:
+- Review changes
+- Commit to fix/mode-name-18-chars branch
+- Create PR for review
+- Update changeset for release notes
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! All changes have been successfully completed by the team of agents. Here's what was accomplished:
+
+## Summary
+
+âœ… **All tasks completed successfully** on branch `fix/mode-name-18-chars`
+
+### Team Results:
+
+1. **typescript-pro** - Updated `CustomModeBuilder.ts` to accept 18-character mode names
+2. **documentation-engineer** - Updated `launch_control_xl3.ksy` and `PROTOCOL.md` with correct documentation
+3. **test-automator** - Updated tests to validate 18-character limit and added truncation tests
+
+### Verification:
+- âœ… **350 tests passing** (78 skipped)
+- âœ… **TypeScript compilation clean**
+- âœ… **Build successful** (143.82 kB)
+- âœ… **4 files modified** and verified
+- âœ… **No breaking changes** - purely expanding the limit
+
+The fix is ready for review and commit. This was a documentation/validation error - the device always supported 18 characters, but the library was incorrectly limiting it to 8.
+
+---
+
+_**User**_
+
+have you run an integration test to validate the fix?
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Good point! Let me check if we have integration tests and run them to validate the fix with actual device interaction:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Find integration and hardware tests
+
+`find test -name "*integration*" -o -name "*hardware*" | head -10`
+
+Result:
+
+```
+test/integration
+test/integration/device.integration.test.ts
+test/integration/LedController.integration.test.ts
+test/integration/handshake.integration.test.ts
+test/integration/slot-selection.hardware.test.ts
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Check integration test setup
+
+`ls -la test/integration/ && echo -e "\n=== Integration test config ===" && cat package.json | jq '.scripts | with_entries(select(.key | contains("integration")))'`
+
+Result:
+
+```
+total 472
+drwxr-xr-x  20 orion  staff    640 Oct 16 18:56 .
+drwxr-xr-x  11 orion  staff    352 Oct 12 21:08 ..
+-rw-r--r--@  1 orion  staff   5888 Oct 16 18:56 basic-read-operations.test.ts
+-rw-r--r--@  1 orion  staff  13534 Oct 16 18:56 custom-mode-write-verify.test.ts
+-rw-r--r--@  1 orion  staff  26086 Sep 28 15:51 device-handshake.test.ts
+-rw-r--r--@  1 orion  staff   7990 Sep 28 15:51 device.integration.test.ts
+-rw-r--r--@  1 orion  staff  11701 Sep 28 15:51 handshake.integration.test.ts
+-rw-r--r--@  1 orion  staff  21969 Sep 28 15:51 LedController.integration.test.ts
+-rw-r--r--@  1 orion  staff  10636 Oct 16 18:56 raw-midi-round-trip.test.ts
+-rw-r--r--@  1 orion  staff  16064 Oct 16 18:56 README.md
+-rw-r--r--@  1 orion  staff   9214 Oct 16 18:56 slot-selection.hardware.test.ts
+-rw-r--r--   1 orion  staff   3190 Oct 15 14:52 slot-selection.playwright.test.ts
+-rwxr-xr-x@  1 orion  staff  12570 Oct 16 18:56 test-fetch-custom-mode-node.ts
+-rwxr-xr-x@  1 orion  staff   8077 Oct 16 18:56 test-handshake-node.ts
+-rw-r--r--   1 orion  staff   1086 Oct 15 14:52 test-midi-events.cjs
+-rwxr-xr-x@  1 orion  staff  20040 Oct 16 18:56 test-round-trip-node.ts
+-rw-r--r--@  1 orion  staff   7069 Oct 16 18:56 test-slot-copy.ts
+-rwxr-xr-x   1 orion  staff   8704 Oct 15 14:52 test-slot-selection.cjs
+-rw-r--r--@  1 orion  staff  12986 Oct 16 18:56 test-valid-mode-changes.ts
+-rw-r--r--   1 orion  staff   9939 Oct 15 14:52 webmidi-test.html
+
+=== Integration test config ===
+{
+  "test:integration": "vitest run --config vitest.integration.config.ts",
+  "test:integration:skip": "SKIP_HARDWARE_TESTS=true vitest run --config vitest.integration.config.ts",
+  "test:integration:force": "SKIP_HARDWARE_TESTS=false vitest run --config vitest.integration.config.ts"
+}
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Let me create a simple integration test to validate that an 18-character mode name works with the actual device:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Create integration test for 18-char mode names
+
+`cat > test/integration/test-18-char-mode-name.ts << 'EOF'
+#!/usr/bin/env tsx
+/**
+ * Integration test to validate 18-character mode names work with actual device
+ * 
+ * This test:
+ * 1. Creates a mode with an 18-character name
+ * 2. Writes it to the device
+ * 3. Reads it back
+ * 4. Verifies the name persists correctly
+ */
+
+import { NodeMidiBackend } from '@/backends/NodeMidiBackend.js';
+import { MidiInterface } from '@/core/MidiInterface.js';
+import { DeviceManager } from '@/device/DeviceManager.js';
+import { CustomModeBuilder } from '@/builders/CustomModeBuilder.js';
+
+const DEVICE_NAME = 'Launch Control XL User Port';
+const TEST_SLOT = 14; // Use slot 14 for testing to avoid overwriting user data
+
+async function main() {
+  console.log('=== 18-Character Mode Name Integration Test ===\n');
+
+  // Initialize MIDI backend
+  const backend = new NodeMidiBackend();
+  await backend.initialize();
+
+  const midi = new MidiInterface(backend);
+  await midi.initialize();
+
+  // Find device
+  const outputPorts = await midi.getOutputPorts();
+  const inputPorts = await midi.getInputPorts();
+  
+  const outputPort = outputPorts.find(p => p.name.includes(DEVICE_NAME));
+  const inputPort = inputPorts.find(p => p.name.includes(DEVICE_NAME));
+
+  if (!outputPort || !inputPort) {
+    console.error('âŒ Device not found. Please ensure Launch Control XL3 is connected.');
+    console.log('\nAvailable output ports:', outputPorts.map(p => p.name));
+    console.log('Available input ports:', inputPorts.map(p => p.name));
+    process.exit(1);
+  }
+
+  console.log(`âœ“ Found device: ${outputPort.name}`);
+
+  // Connect to device
+  await midi.openInput(inputPort.id);
+  await midi.openOutput(outputPort.id);
+
+  const deviceManager = new DeviceManager(midi);
+
+  try {
+    // Step 1: Create mode with 18-character name
+    const eighteenCharName = 'EXACTLY18CHARSLONG'; // Exactly 18 characters
+    console.log(`\n1. Creating mode with 18-character name: "${eighteenCharName}"`);
+    console.log(`   Length: ${eighteenCharName.length} characters`);
+
+    const mode = new CustomModeBuilder()
+      .name(eighteenCharName)
+      .addFader(1, { cc: 10, channel: 1 })
+      .addEncoder(1, 1, { cc: 13, channel: 1 })
+      .addEncoderLabel(1, 1, 'Test')
+      .build();
+
+    console.log(`âœ“ Mode created successfully`);
+
+    // Step 2: Write mode to slot 14
+    console.log(`\n2. Writing mode to slot ${TEST_SLOT}...`);
+    await deviceManager.writeCustomMode(TEST_SLOT, mode);
+    console.log(`âœ“ Mode written successfully`);
+
+    // Wait a bit for device to settle
+    await new Promise(resolve => setTimeout(resolve, 500));
+
+    // Step 3: Read back from slot 14
+    console.log(`\n3. Reading mode back from slot ${TEST_SLOT}...`);
+    const readMode = await deviceManager.readCustomMode(TEST_SLOT);
+    console.log(`âœ“ Mode read successfully`);
+
+    // Step 4: Verify the name
+    console.log(`\n4. Verifying mode name...`);
+    console.log(`   Expected: "${eighteenCharName}" (${eighteenCharName.length} chars)`);
+    console.log(`   Received: "${readMode.name}" (${readMode.name.length} chars)`);
+
+    if (readMode.name === eighteenCharName) {
+      console.log(`\nâœ… SUCCESS: 18-character mode name persisted correctly!`);
+      process.exit(0);
+    } else if (readMode.name.startsWith(eighteenCharName.substring(0, 8))) {
+      console.log(`\nâš ï¸  WARNING: Mode name was truncated to 8 characters`);
+      console.log(`   This suggests the device firmware may have an 8-character limit,`);
+      console.log(`   not the 18-character limit we expected.`);
+      process.exit(1);
+    } else {
+      console.log(`\nâŒ FAIL: Mode name mismatch`);
+      console.log(`   Expected: "${eighteenCharName}"`);
+      console.log(`   Got: "${readMode.name}"`);
+      process.exit(1);
+    }
+
+  } catch (error: any) {
+    console.error(`\nâŒ Test failed:`, error.message);
+    process.exit(1);
+  } finally {
+    await midi.cleanup();
+  }
+}
+
+main().catch(err => {
+  console.error('Fatal error:', err);
+  process.exit(1);
+});
+EOF
+chmod +x test/integration/test-18-char-mode-name.ts
+ls -la test/integration/test-18-char-mode-name.ts
+`
+
+Result:
+
+```
+-rwxr-xr-x@ 1 orion  staff  3950 Oct 16 20:49 test/integration/test-18-char-mode-name.ts
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Now let me run the integration test to validate the fix against the actual hardware:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Run 18-character mode name integration test
+
+`tsx test/integration/test-18-char-mode-name.ts 2>&1`
+
+Error:
+
+```
+=== 18-Character Mode Name Integration Test ===
+
+âŒ Device not found. Please ensure Launch Control XL3 is connected.
+
+Available output ports: [
+  'Network m4-mini',
+  'IAC Driver Bus 1',
+  'SP-404MKII',
+  'LCXL3 1 MIDI In',
+  'LCXL3 1 DAW In',
+  'Arturia KeyStep 37',
+  'virtual1',
+  'virtual2'
+]
+Available input ports: [
+  'Network m4-mini',
+  'IAC Driver Bus 1',
+  'SP-404MKII',
+  'LCXL3 1 MIDI Out',
+  'LCXL3 1 DAW Out',
+  'Arturia KeyStep 37',
+  'virtual1',
+  'virtual2'
+]
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+I see - the device port is named differently. Let me fix the test to use the correct port name:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Edit**
+
+Result:
+
+```
+The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/integration/test-18-char-mode-name.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
+    13â†’import { MidiInterface } from '@/core/MidiInterface.js';
+    14â†’import { DeviceManager } from '@/device/DeviceManager.js';
+    15â†’import { CustomModeBuilder } from '@/builders/CustomModeBuilder.js';
+    16â†’
+    17â†’const DEVICE_NAME = 'LCXL3 1'; // Matches both 'LCXL3 1 MIDI Out' and 'LCXL3 1 MIDI In'
+    18â†’const TEST_SLOT = 14; // Use slot 14 for testing to avoid overwriting user data
+    19â†’
+    20â†’async function main() {
+    21â†’  console.log('=== 18-Character Mode Name Integration Test ===\n');
+    22â†’
+```
+
+_**User**_
+
+[Request interrupted by user]
+
+_**User**_
+
+why aren't you reusing existing testing infrastructure that already successfully communicates with the device? Delegate to your team of agents
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+You're absolutely right - I should be reusing the existing test infrastructure instead of creating new tests from scratch. Let me delegate to the team to run the existing integration tests that already work with the device.
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Task** Run existing integration tests to validate 18-char fix
+
+Error:
+
+```
+[Request interrupted by user for tool use]
+```
+
+_**User**_
+
+[Request interrupted by user for tool use]
+
+_**User**_
+
+Thre is no existing integration test that tests 18 character names. YOu should augment existing tests, not just run them.
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+You're right - I need to augment the existing tests to validate 18-character names. Let me delegate to the test-automator to add 18-character name tests to the existing integration test infrastructure.
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Task** Augment existing integration tests with 18-char validation
+
+---
+
+_**User (sidechain)**_
+
+Augment the existing integration tests to validate that 18-character mode names work correctly with the actual Launch Control XL3 device.
+
+**Context:**
+- We just changed the mode name limit from 8 to 18 characters
+- There are existing integration tests in `test/integration/` that already communicate with the device
+- We need to ADD tests for 18-character names to the existing test infrastructure
+
+**Tasks:**
+
+1. **Read the integration test README** (`test/integration/README.md`) to understand the test infrastructure
+
+2. **Identify the best existing test file to augment**:
+   - Look at `test/integration/custom-mode-write-verify.test.ts` - likely the best candidate
+   - Or `test/integration/test-round-trip-node.ts` if it tests mode persistence
+   - Choose the file that already tests writing and reading back custom modes
+
+3. **Add 18-character mode name test cases** to the chosen file:
+   - Add a test that creates a mode with exactly 18 characters (e.g., "EXACTLY18CHARSLONG")
+   - Write it to the device
+   - Read it back
+   - Verify the name persists correctly
+   - Also add a test for boundary cases (17 chars, 18 chars, attempting 19 chars)
+
+4. **Run the augmented tests** to validate:
+   - Run the specific integration test file you modified
+   - Provide the test output showing whether 18-character names work
+
+5. **Report back**:
+   - Which file did you augment?
+   - What test cases did you add?
+   - What were the test results?
+   - Did the device accept and persist 18-character names?
+
+**IMPORTANT:** 
+- Augment EXISTING test files, don't create new ones
+- Follow the existing test patterns and infrastructure
+- Use the device connection methods that already work in those tests
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+I'll help you augment the existing integration tests to validate 18-character mode names. Let me start by understanding the current test infrastructure.
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration/README.md`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration/custom-mode-write-verify.test.ts`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration/test-round-trip-node.ts`
+
+Result:
+
+```
+1â†’# Launch Control XL3 Integration Tests
+     2â†’
+     3â†’This directory contains integration tests that validate the Launch Control XL3 library against real hardware. These tests include both hardware-dependent tests (using Vitest) and standalone utility tests (using tsx).
+     4â†’
+     5â†’## Test Categories
+     6â†’
+     7â†’### 1. Vitest Hardware Tests (CI/CD Compatible)
+     8â†’
+     9â†’Located in `*.hardware.test.ts` files, these tests use Vitest and can be skipped if hardware is unavailable.
+    10â†’
+    11â†’### 2. Standalone Utility Tests (Manual Execution)
+    12â†’
+    13â†’Located in standalone `.test.ts` files, these are executable TypeScript files for manual validation and debugging.
+    14â†’
+    15â†’---
+    16â†’
+    17â†’## Vitest Hardware Tests
+    18â†’
+    19â†’### Requirements
+    20â†’
+    21â†’- Launch Control XL 3 device connected via USB
+    22â†’- Node.js 18+ with pnpm installed
+    23â†’- Device must be powered on and visible to system MIDI
+    24â†’
+    25â†’### Running Vitest Hardware Tests
+    26â†’
+    27â†’#### Default: Skip if Device Not Connected
+    28â†’
+    29â†’\```bash
+    30â†’# Run with automatic device detection (skips if SKIP_HARDWARE_TESTS=true)
+    31â†’pnpm test:integration
+    32â†’\```
+    33â†’
+    34â†’By default, tests will be SKIPPED unless device is connected.
+    35â†’
+    36â†’#### Force Skip (for CI/CD)
+    37â†’
+    38â†’\```bash
+    39â†’# Explicitly skip hardware tests
+    40â†’pnpm test:integration:skip
+    41â†’
+    42â†’# Or set env var manually
+    43â†’SKIP_HARDWARE_TESTS=true pnpm test:integration
+    44â†’\```
+    45â†’
+    46â†’#### Force Run (requires hardware)
+    47â†’
+    48â†’\```bash
+    49â†’# Force tests to run (will fail if device not connected)
+    50â†’pnpm test:integration:force
+    51â†’
+    52â†’# Or set env var manually
+    53â†’SKIP_HARDWARE_TESTS=false pnpm test:integration
+    54â†’\```
+    55â†’
+    56â†’### Vitest Test Suites
+    57â†’
+    58â†’#### slot-selection.hardware.test.ts
+    59â†’
+    60â†’Tests the fix for Issue #36: Device firmware rejects writes to inactive slots.
+    61â†’
+    62â†’**What it validates:**
+    63â†’- `selectTemplate()` uses correct device ID (0x02, not 0x11)
+    64â†’- Writing to inactive slots succeeds without status 0x9 errors
+    65â†’- Device properly acknowledges slot selection
+    66â†’- Sequential slot switching works correctly
+    67â†’- Timing delays are appropriate (100ms after slot selection)
+    68â†’
+    69â†’**Test scenarios:**
+    70â†’1. Write to single inactive slot (slot 1)
+    71â†’2. Write to multiple inactive slots sequentially (slots 3, 5, 7)
+    72â†’3. Rapid slot switching (slots 2, 4, 6)
+    73â†’4. Protocol validation (selectTemplate called before write)
+    74â†’5. Device ID validation (0x02 in SysEx)
+    75â†’6. Error handling (factory slot 15, invalid slots)
+    76â†’7. Timing validation (100ms delay after selection)
+    77â†’8. Full read-modify-write cycle
+    78â†’
+    79â†’---
+    80â†’
+    81â†’## Standalone Utility Tests
+    82â†’
+    83â†’These tests are executable TypeScript files that can be run directly with `tsx`. They're useful for manual validation, debugging, and protocol investigation.
+    84â†’
+    85â†’### Prerequisites
+    86â†’
+    87â†’#### Hardware Requirements
+    88â†’- **Novation Launch Control XL3** connected via USB
+    89â†’- **macOS or Linux** (MIDI port names may differ on other platforms)
+    90â†’- **Configured custom modes** in slots 3 and 10 recommended
+    91â†’
+    92â†’#### Software Requirements
+    93â†’- Node.js 18+ with TypeScript support
+    94â†’- `tsx` runtime for executing TypeScript tests
+    95â†’- `midi` npm package (node-midi) for low-level MIDI access
+    96â†’
+    97â†’### Available Standalone Tests
+    98â†’
+    99â†’#### 1. Custom Mode Write and Verify (`custom-mode-write-verify.test.ts`)
+   100â†’
+   101â†’**Purpose:** Validates that CustomMode API changes are correctly written to the device and can be read back with all modifications preserved.
+   102â†’
+   103â†’**What it tests:**
+   104â†’- âœ“ CustomMode read/write API
+   105â†’- âœ“ Device firmware accepts valid modifications
+   106â†’- âœ“ Data integrity through write/read cycle
+   107â†’- âœ“ Control property changes (CC, channel, name)
+   108â†’
+   109â†’**Test flow:**
+   110â†’1. Read custom mode from slot 10 using library API
+   111â†’2. Make VALID changes using CustomMode structure
+   112â†’3. Write modified mode to slot 3
+   113â†’4. Read back from slot 3
+   114â†’5. Verify all changes were preserved
+   115â†’
+   116â†’**Prerequisites:**
+   117â†’- Slot 10 must contain a configured custom mode with controls
+   118â†’- Slot 3 can be overwritten (test data will be written here)
+   119â†’
+   120â†’**Usage:**
+   121â†’\```bash
+   122â†’npx tsx test/integration/custom-mode-write-verify.test.ts
+   123â†’\```
+   124â†’
+   125â†’**Expected results:**
+   126â†’- All property changes should be preserved (name, CC numbers, channels)
+   127â†’- Test saves detailed results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-*.json`
+   128â†’
+   129â†’**Related issues:** #36
+   130â†’
+   131â†’---
+   132â†’
+   133â†’#### 2. Raw MIDI Round-Trip Validation (`raw-midi-round-trip.test.ts`)
+   134â†’
+   135â†’**Purpose:** Validates byte-level data integrity through a complete write/read cycle using direct SysEx protocol.
+   136â†’
+   137â†’**What it tests:**
+   138â†’- âœ“ Novation SysEx protocol write sequence
+   139â†’- âœ“ Device firmware data storage integrity
+   140â†’- âœ“ No corruption during write/read operations
+   141â†’- âœ“ Correct implementation of DAW port slot selection
+   142â†’
+   143â†’**Test flow:**
+   144â†’1. Read raw bytes from slot 10 (known good)
+   145â†’2. Write those exact bytes to slot 3 using Novation protocol
+   146â†’3. Read back from slot 3
+   147â†’4. Compare byte-by-byte and report differences
+   148â†’
+   149â†’**Prerequisites:**
+   150â†’- Slot 10 must contain valid custom mode data
+   151â†’- Slot 3 can be overwritten (test data will be written here)
+   152â†’
+   153â†’**Usage:**
+   154â†’\```bash
+   155â†’npx tsx test/integration/raw-midi-round-trip.test.ts
+   156â†’\```
+   157â†’
+   158â†’**Expected results:**
+   159â†’- 100% byte-for-byte match between source and read-back data
+   160â†’- No differences in page 0 or page 3
+   161â†’- Test saves detailed comparison to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/raw-midi-round-trip-*.json`
+   162â†’
+   163â†’**Protocol details:**
+   164â†’- Uses command 0x45 for write operations
+   165â†’- Uses command 0x77 (template change) for slot selection
+   166â†’- Follows Novation's documented write sequence: write page 0, send 0x77, write page 0 again, write page 3
+   167â†’
+   168â†’**Related issues:** #36
+   169â†’
+   170â†’---
+   171â†’
+   172â†’#### 3. Basic Read Operations (`basic-read-operations.test.ts`)
+   173â†’
+   174â†’**Purpose:** Validates fundamental device communication and read operations using direct SysEx protocol.
+   175â†’
+   176â†’**What it tests:**
+   177â†’- âœ“ Basic MIDI port communication
+   178â†’- âœ“ SysEx message sending and receiving
+   179â†’- âœ“ Device response to read commands
+   180â†’- âœ“ Command 0x77 (template change) functionality
+   181â†’- âœ“ Slot selection independence
+   182â†’
+   183â†’**Test flow:**
+   184â†’1. Read from slot 10
+   185â†’2. Send command 0x77 to select slot 3
+   186â†’3. Read from slot 3
+   187â†’4. Read from slot 10 again to verify slot independence
+   188â†’
+   189â†’**Prerequisites:**
+   190â†’- Slots 3 and 10 should contain custom modes (any configuration)
+   191â†’
+   192â†’**Usage:**
+   193â†’\```bash
+   194â†’npx tsx test/integration/basic-read-operations.test.ts
+   195â†’\```
+   196â†’
+   197â†’**Expected results:**
+   198â†’- Each read should return ~270 bytes (SysEx header + 256 bytes data + footer)
+   199â†’- Response lengths should be consistent across reads
+   200â†’- Slot 10 data should be identical in Test 1 and Test 4
+   201â†’
+   202â†’**Protocol details:**
+   203â†’- Uses command 0x40 for read operations
+   204â†’- Each page read returns ~260+ bytes
+   205â†’- Command 0x77 changes the active template slot
+   206â†’
+   207â†’---
+   208â†’
+   209â†’### Running All Standalone Tests
+   210â†’
+   211â†’To run all standalone tests sequentially:
+   212â†’
+   213â†’\```bash
+   214â†’# Run each test individually
+   215â†’npx tsx test/integration/basic-read-operations.test.ts
+   216â†’npx tsx test/integration/raw-midi-round-trip.test.ts
+   217â†’npx tsx test/integration/custom-mode-write-verify.test.ts
+   218â†’\```
+   219â†’
+   220â†’**Note:** Tests are not designed to run in parallel as they may interfere with each other's device state.
+   221â†’
+   222â†’### Test Results
+   223â†’
+   224â†’#### Success Criteria
+   225â†’
+   226â†’Each standalone test defines its own success criteria:
+   227â†’
+   228â†’1. **basic-read-operations.test.ts**
+   229â†’   - âœ“ All reads return expected byte counts (~270 bytes)
+   230â†’   - âœ“ No communication errors
+   231â†’
+   232â†’2. **raw-midi-round-trip.test.ts**
+   233â†’   - âœ“ 100% byte match between source and read-back
+   234â†’   - âœ“ No data corruption in page 0 or page 3
+   235â†’
+   236â†’3. **custom-mode-write-verify.test.ts**
+   237â†’   - âœ“ All property modifications preserved (name, CC, channel)
+   238â†’   - âœ“ Typically 13-16 individual property changes verified
+   239â†’
+   240â†’#### Result Files
+   241â†’
+   242â†’All standalone tests save detailed results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`:
+   243â†’
+   244â†’- `basic-read-operations-*.json` - Communication test results
+   245â†’- `raw-midi-round-trip-*.json` - Byte-level comparison data
+   246â†’- `custom-mode-write-verify-*.json` - Property verification details
+   247â†’
+   248â†’---
+   249â†’
+   250â†’## Configuration
+   251â†’
+   252â†’### Vitest Integration Tests Config
+   253â†’
+   254â†’Integration tests use a separate Vitest config:
+   255â†’
+   256â†’- **Config file:** `vitest.integration.config.ts`
+   257â†’- **Execution:** Sequential (one device, no parallel tests)
+   258â†’- **Timeouts:** 30s test, 15s hooks (longer for hardware)
+   259â†’- **Retries:** 0 (show real hardware issues)
+   260â†’- **Reporter:** Verbose (detailed hardware operation logs)
+   261â†’
+   262â†’### Differences from Unit Tests
+   263â†’
+   264â†’| Aspect | Unit Tests | Integration Tests (Vitest) | Standalone Tests |
+   265â†’|--------|------------|---------------------------|------------------|
+   266â†’| Config | `vitest.config.ts` | `vitest.integration.config.ts` | N/A (tsx) |
+   267â†’| Execution | Parallel (threads) | Sequential (single fork) | Manual |
+   268â†’| Timeout | 5s test, 3s hooks | 30s test, 15s hooks | No timeout |
+   269â†’| Requires hardware | No | Yes (or skipped) | Yes |
+   270â†’| Run in CI | Yes (always) | Only if device available | No |
+   271â†’
+   272â†’---
+   273â†’
+   274â†’## Protocol Features Validated
+   275â†’
+   276â†’### SysEx Commands Tested
+   277â†’
+   278â†’| Command | Purpose | Tested By |
+   279â†’|---------|---------|-----------|
+   280â†’| 0x40 | Read custom mode page | All tests |
+   281â†’| 0x45 | Write custom mode page | raw-midi-round-trip, custom-mode-write-verify, slot-selection |
+   282â†’| 0x77 | Select template slot (DAW port) | All tests |
+   283â†’
+   284â†’### Data Integrity Checks
+   285â†’
+   286â†’- **Byte-level:** `raw-midi-round-trip.test.ts` validates exact byte preservation
+   287â†’- **Property-level:** `custom-mode-write-verify.test.ts` validates structured data
+   288â†’- **Communication:** `basic-read-operations.test.ts` validates protocol basics
+   289â†’- **Slot selection:** `slot-selection.hardware.test.ts` validates pre-selection requirement
+   290â†’
+   291â†’### Custom Mode Properties Validated
+   292â†’
+   293â†’The tests verify these CustomMode properties:
+   294â†’- `name` (8 characters max)
+   295â†’- `controls` object with 48 control mappings
+   296â†’- Control properties: `ccNumber`, `midiChannel`, `name`
+   297â†’- Label parsing and encoding
+   298â†’- Color configurations
+   299â†’- LED states (if present)
+   300â†’
+   301â†’---
+   302â†’
+   303â†’## Troubleshooting
+   304â†’
+   305â†’### Common Issues for Vitest Tests
+   306â†’
+   307â†’#### Tests Skip Automatically
+   308â†’
+   309â†’This is EXPECTED behavior if:
+   310â†’- `SKIP_HARDWARE_TESTS=true` is set
+   311â†’- Device not connected
+   312â†’- Device not accessible to Node.js MIDI
+   313â†’
+   314â†’**Solution:** Connect device and use `pnpm test:integration:force`
+   315â†’
+   316â†’#### Connection Timeout
+   317â†’
+   318â†’\```
+   319â†’Error: Connection timeout after 15000ms
+   320â†’\```
+   321â†’
+   322â†’**Possible causes:**
+   323â†’1. Device not powered on
+   324â†’2. USB cable disconnected
+   325â†’3. MIDI driver issue (check system MIDI devices)
+   326â†’4. Device in bootloader mode (disconnect and reconnect)
+   327â†’
+   328â†’**Solution:**
+   329â†’- Check USB connection
+   330â†’- Verify device appears in system MIDI devices
+   331â†’- Restart device (unplug/replug USB)
+   332â†’
+   333â†’#### Status 0x9 Error
+   334â†’
+   335â†’\```
+   336â†’Error: Device returned status 0x9 (slot not selected)
+   337â†’\```
+   338â†’
+   339â†’**This should NOT happen after fix.** If it does:
+   340â†’1. Verify you're on branch `fix/issue-36-correct-device-id`
+   341â†’2. Check that `DeviceManager.writeCustomMode()` calls `selectTemplate()`
+   342â†’3. Verify device ID is 0x02 in SysEx messages
+   343â†’
+   344â†’### Common Issues for Standalone Tests
+   345â†’
+   346â†’#### "Port 'LCXL3 1 MIDI Out' not found"
+   347â†’
+   348â†’- Ensure device is connected via USB
+   349â†’- Check MIDI port names with:
+   350â†’  \```bash
+   351â†’  npx tsx -e "const m = require('midi'); const o = new m.Output(); for(let i=0; i<o.getPortCount(); i++) console.log(i, o.getPortName(i));"
+   352â†’  \```
+   353â†’- Update port names in test files if different on your platform
+   354â†’
+   355â†’#### "No response from device"
+   356â†’
+   357â†’- Verify device is powered on
+   358â†’- Check USB connection
+   359â†’- Close any other applications using the device (DAW, Components, etc.)
+   360â†’- Try re-plugging the USB cable
+   361â†’
+   362â†’#### "Slot 10 has no controls"
+   363â†’
+   364â†’- Load a factory preset into slot 10 using Components
+   365â†’- Or use a different source slot by editing the test file
+   366â†’
+   367â†’#### Test timeouts
+   368â†’
+   369â†’- Increase delay times in test files (currently 1000ms for reads, 500ms for writes)
+   370â†’- Device may be slower on some systems
+   371â†’
+   372â†’### Debug Mode
+   373â†’
+   374â†’Enable verbose MIDI logging by modifying standalone test files:
+   375â†’
+   376â†’\```typescript
+   377â†’// Add after midiInput setup
+   378â†’midiInput.on('message', (deltaTime: number, message: number[]) => {
+   379â†’  console.log('MIDI:', message.map(b => b.toString(16).padStart(2, '0')).join(' '));
+   380â†’  lastResponse = Array.from(message);
+   381â†’});
+   382â†’\```
+   383â†’
+   384â†’---
+   385â†’
+   386â†’## Development Workflow
+   387â†’
+   388â†’### Adding New Vitest Integration Tests
+   389â†’
+   390â†’1. Create test file in `test/integration/` with `*.hardware.test.ts` suffix
+   391â†’2. Use `describe.skipIf(SKIP_HARDWARE_TESTS)` wrapper
+   392â†’3. Set appropriate timeouts (hardware is slower than mocks)
+   393â†’4. Clean up device state in `afterEach` or `afterAll`
+   394â†’5. Document what hardware scenario is being tested
+   395â†’6. Update this README
+   396â†’
+   397â†’Example:
+   398â†’
+   399â†’\```typescript
+   400â†’import { describe, it, expect, beforeAll, afterAll } from 'vitest';
+   401â†’import { DeviceManager } from '@/device/DeviceManager.js';
+   402â†’import { JuceMidiBackend } from '@/backends/JuceMidiBackend.js';
+   403â†’
+   404â†’const SKIP_HARDWARE_TESTS = process.env.SKIP_HARDWARE_TESTS === 'true';
+   405â†’
+   406â†’describe.skipIf(SKIP_HARDWARE_TESTS)('My Hardware Feature', () => {
+   407â†’  let deviceManager: DeviceManager;
+   408â†’  let backend: JuceMidiBackend;
+   409â†’
+   410â†’  beforeAll(async () => {
+   411â†’    backend = new JuceMidiBackend();
+   412â†’    await backend.initialize();
+   413â†’
+   414â†’    deviceManager = new DeviceManager({
+   415â†’      midiBackend: backend,
+   416â†’      autoConnect: false,
+   417â†’    });
+   418â†’
+   419â†’    await deviceManager.initialize();
+   420â†’    await deviceManager.connect();
+   421â†’  }, 15000);
+   422â†’
+   423â†’  afterAll(async () => {
+   424â†’    if (deviceManager) {
+   425â†’      await deviceManager.disconnect();
+   426â†’      await deviceManager.cleanup();
+   427â†’    }
+   428â†’    if (backend) {
+   429â†’      await backend.cleanup();
+   430â†’    }
+   431â†’  });
+   432â†’
+   433â†’  it('should test hardware feature', async () => {
+   434â†’    // Your test here
+   435â†’  }, 20000); // 20s timeout for hardware operation
+   436â†’});
+   437â†’\```
+   438â†’
+   439â†’### Adding New Standalone Tests
+   440â†’
+   441â†’1. Create new test file in `test/integration/` with `.test.ts` suffix (NOT `.hardware.test.ts`)
+   442â†’2. Add JSDoc header with purpose, prerequisites, validation points
+   443â†’3. Use consistent test structure (setup, execute, verify, teardown)
+   444â†’4. Save results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`
+   445â†’5. Update this README with test documentation
+   446â†’6. Add executable shebang: `#!/usr/bin/env tsx`
+   447â†’
+   448â†’### Test Naming Convention
+   449â†’
+   450â†’- **Vitest tests:** `{feature}.hardware.test.ts`
+   451â†’- **Standalone tests:** `{feature}-{operation}.test.ts`
+   452â†’- Examples: `slot-selection.hardware.test.ts`, `custom-mode-write-verify.test.ts`
+   453â†’- Avoid generic names like `test1.ts`, `integration-test.ts`
+   454â†’
+   455â†’### Protocol Validation Checklist
+   456â†’
+   457â†’When validating new protocol features:
+   458â†’- [ ] Test with real hardware
+   459â†’- [ ] Verify byte-level correctness
+   460â†’- [ ] Test edge cases (empty controls, max values, etc.)
+   461â†’- [ ] Document discovery methodology
+   462â†’- [ ] Update `docs/PROTOCOL.md`
+   463â†’- [ ] Create test fixture in `backup/`
+   464â†’
+   465â†’---
+   466â†’
+   467â†’## Performance Expectations
+   468â†’
+   469â†’### Vitest Hardware Tests
+   470â†’
+   471â†’Typical test suite execution times (with device connected):
+   472â†’
+   473â†’- Single slot write: ~2-3s (including 100ms delay)
+   474â†’- Multiple slot writes: ~5-10s (3 slots)
+   475â†’- Rapid switching: ~4-6s (3 slots)
+   476â†’- Full read-modify-write: ~4-5s
+   477â†’
+   478â†’Total suite: ~30-60s
+   479â†’
+   480â†’### Standalone Tests
+   481â†’
+   482â†’- Basic read operations: ~5-10s
+   483â†’- Raw MIDI round-trip: ~10-15s
+   484â†’- Custom mode write/verify: ~15-20s
+   485â†’
+   486â†’---
+   487â†’
+   488â†’## CI/CD Integration
+   489â†’
+   490â†’### Vitest Tests in CI/CD
+   491â†’
+   492â†’In CI/CD pipelines where hardware is not available:
+   493â†’
+   494â†’\```yaml
+   495â†’# GitHub Actions example
+   496â†’- name: Run integration tests (skip if no device)
+   497â†’  run: pnpm test:integration
+   498â†’  continue-on-error: true  # Don't fail pipeline if device not available
+   499â†’\```
+   500â†’
+   501â†’Or explicitly skip:
+   502â†’
+   503â†’\```yaml
+   504â†’- name: Run integration tests (CI - skip hardware)
+   505â†’  run: pnpm test:integration:skip
+   506â†’\```
+   507â†’
+   508â†’### Standalone Tests in CI/CD
+   509â†’
+   510â†’Standalone tests should NOT be run in CI/CD pipelines as they require hardware and manual execution.
+   511â†’
+   512â†’---
+   513â†’
+   514â†’## Related Documentation
+   515â†’
+   516â†’- **Protocol Specification:** [`docs/PROTOCOL.md`](../../docs/PROTOCOL.md)
+   517â†’- **Architecture Overview:** [`docs/ARCHITECTURE.md`](../../docs/ARCHITECTURE.md)
+   518â†’- **Maintenance Guide:** [`docs/MAINTENANCE.md`](../../docs/MAINTENANCE.md)
+   519â†’- **Issue #36:** Slot selection fix
+   520â†’
+   521â†’---
+   522â†’
+   523â†’## Contributing
+   524â†’
+   525â†’When adding integration tests:
+   526â†’1. Follow existing test structure and documentation patterns
+   527â†’2. Ensure tests are self-contained and don't depend on specific device state
+   528â†’3. Add comprehensive JSDoc headers for standalone tests
+   529â†’4. Update this README with test documentation
+   530â†’5. Test against real hardware before committing
+   531â†’6. Choose appropriate test type (Vitest vs standalone)
+   532â†’
+   533â†’---
+   534â†’
+   535â†’## Questions or Issues
+   536â†’
+   537â†’For protocol questions or test failures:
+   538â†’1. Check `docs/PROTOCOL.md` for specification details
+   539â†’2. Review MIDI captures in `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`
+   540â†’3. Compare against working backup fixtures in `backup/`
+   541â†’4. Consult `docs/MAINTENANCE.md` for documentation requirements
+   542â†’
+```
+
+Result:
+
+```
+1â†’#!/usr/bin/env tsx
+     2â†’/**
+     3â†’ * Integration Test: Custom Mode Write and Verify
+     4â†’ *
+     5â†’ * Purpose:
+     6â†’ *   Validates that CustomMode API changes are correctly written to the device
+     7â†’ *   and can be read back with all modifications preserved.
+     8â†’ *
+     9â†’ * Test Flow:
+    10â†’ *   1. Read custom mode from slot 10 using library API
+    11â†’ *   2. Make VALID changes using CustomMode structure
+    12â†’ *   3. Write modified mode to slot 3
+    13â†’ *   4. Read back from slot 3
+    14â†’ *   5. Verify all changes were preserved
+    15â†’ *
+    16â†’ * Prerequisites:
+    17â†’ *   - Launch Control XL3 connected via USB
+    18â†’ *   - Slot 10 must contain a configured custom mode
+    19â†’ *
+    20â†’ * Validates:
+    21â†’ *   - CustomMode read/write API
+    22â†’ *   - Device firmware accepts valid modifications
+    23â†’ *   - Data integrity through write/read cycle
+    24â†’ *   - Control property changes (CC, channel, name)
+    25â†’ *
+    26â†’ * Related Issues: #36
+    27â†’ *
+    28â†’ * @module test/integration
+    29â†’ */
+    30â†’
+    31â†’import { LaunchControlXL3 } from '../../src/index.js';
+    32â†’import { NodeMidiBackend } from '../../src/backends/NodeMidiBackend.js';
+    33â†’import type { CustomMode, ControlMapping } from '../../src/types.js';
+    34â†’import { writeFileSync } from 'fs';
+    35â†’
+    36â†’interface TestChange {
+    37â†’  description: string;
+    38â†’  originalValue: any;
+    39â†’  newValue: any;
+    40â†’  verified: boolean;
+    41â†’}
+    42â†’
+    43â†’async function main() {
+    44â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    45â†’  console.log('Custom Mode Write and Verify Integration Test');
+    46â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+    47â†’
+    48â†’  let device: LaunchControlXL3 | null = null;
+    49â†’
+    50â†’  try {
+    51â†’    // Initialize backend
+    52â†’    const backend = new NodeMidiBackend();
+    53â†’    await backend.initialize();
+    54â†’
+    55â†’    // Create device
+    56â†’    device = new LaunchControlXL3({
+    57â†’      midiBackend: backend,
+    58â†’      enableLedControl: false,
+    59â†’      enableCustomModes: true
+    60â†’    });
+    61â†’
+    62â†’    console.log('â†’ Connecting to device...');
+    63â†’    await device.connect();
+    64â†’    console.log('âœ“ Connected\n');
+    65â†’
+    66â†’    const sourceSlot = 10;
+    67â†’    const targetSlot = 3;
+    68â†’
+    69â†’    // Step 1: Read from source slot
+    70â†’    console.log(`Step 1: Reading custom mode from slot ${sourceSlot}...`);
+    71â†’    const originalMode = await device.readCustomMode(sourceSlot);
+    72â†’
+    73â†’    if (!originalMode) {
+    74â†’      console.log('âœ— Failed to read custom mode');
+    75â†’      process.exit(1);
+    76â†’    }
+    77â†’
+    78â†’    console.log('âœ“ Read successful');
+    79â†’    console.log(`  Name: "${originalMode.name}"`);
+    80â†’
+    81â†’    // Get control keys from the controls object
+    82â†’    const controlKeys = Object.keys(originalMode.controls || {});
+    83â†’    console.log(`  Controls: ${controlKeys.length}`);
+    84â†’    console.log(`  Control keys: ${controlKeys.slice(0, 5).join(', ')}${controlKeys.length > 5 ? '...' : ''}`);
+    85â†’    console.log();
+    86â†’
+    87â†’    // Ensure controls object exists
+    88â†’    if (!originalMode.controls || typeof originalMode.controls !== 'object') {
+    89â†’      console.log('âœ— originalMode.controls is not an object');
+    90â†’      process.exit(1);
+    91â†’    }
+    92â†’
+    93â†’    if (controlKeys.length === 0) {
+    94â†’      console.log('âœ— No controls found in slot 10');
+    95â†’      console.log('  Try a different source slot that has configured controls');
+    96â†’      process.exit(1);
+    97â†’    }
+    98â†’
+    99â†’    // Step 2: Make valid changes to the mode
+   100â†’    console.log('Step 2: Making valid changes to custom mode...\n');
+   101â†’
+   102â†’    const changes: TestChange[] = [];
+   103â†’
+   104â†’    // Clone the mode - deep copy the controls object
+   105â†’    const modifiedMode: CustomMode = {
+   106â†’      name: 'TESTMOD',
+   107â†’      controls: { ...originalMode.controls },
+   108â†’      colors: originalMode.colors,
+   109â†’      labels: originalMode.labels,
+   110â†’      leds: originalMode.leds
+   111â†’    };
+   112â†’
+   113â†’    // Deep clone each control
+   114â†’    for (const key in modifiedMode.controls) {
+   115â†’      modifiedMode.controls[key] = { ...originalMode.controls[key] };
+   116â†’    }
+   117â†’
+   118â†’    // Track mode name change
+   119â†’    changes.push({
+   120â†’      description: 'Mode name',
+   121â†’      originalValue: originalMode.name,
+   122â†’      newValue: modifiedMode.name,
+   123â†’      verified: false
+   124â†’    });
+   125â†’
+   126â†’    // Modify first 5 controls (if they exist)
+   127â†’    const controlsToModify = Math.min(5, controlKeys.length);
+   128â†’
+   129â†’    for (let i = 0; i < controlsToModify; i++) {
+   130â†’      const key = controlKeys[i];
+   131â†’      const control = modifiedMode.controls[key];
+   132â†’
+   133â†’      // Change CC number (use ccNumber property, not cc)
+   134â†’      const originalCC = control.ccNumber || control.cc || 0;
+   135â†’      const newCC = (originalCC + 10) % 120; // Stay within valid range
+   136â†’      control.ccNumber = newCC;
+   137â†’      if (control.cc !== undefined) {
+   138â†’        control.cc = newCC; // Update both if cc exists
+   139â†’      }
+   140â†’
+   141â†’      changes.push({
+   142â†’        description: `Control ${key} CC`,
+   143â†’        originalValue: originalCC,
+   144â†’        newValue: newCC,
+   145â†’        verified: false
+   146â†’      });
+   147â†’
+   148â†’      // Change control name (if it exists)
+   149â†’      if (control.name !== undefined) {
+   150â†’        const originalName = control.name;
+   151â†’        const newName = `TST_${i}`;
+   152â†’        control.name = newName;
+   153â†’
+   154â†’        changes.push({
+   155â†’          description: `Control ${key} name`,
+   156â†’          originalValue: originalName,
+   157â†’          newValue: newName,
+   158â†’          verified: false
+   159â†’        });
+   160â†’      }
+   161â†’
+   162â†’      // Change channel (use midiChannel property, not channel)
+   163â†’      const originalChannel = control.midiChannel ?? control.channel ?? 0;
+   164â†’      const newChannel = (originalChannel % 16);
+   165â†’      control.midiChannel = newChannel;
+   166â†’      if (control.channel !== undefined) {
+   167â†’        control.channel = newChannel; // Update both if channel exists
+   168â†’      }
+   169â†’
+   170â†’      changes.push({
+   171â†’        description: `Control ${key} channel`,
+   172â†’        originalValue: originalChannel,
+   173â†’        newValue: newChannel,
+   174â†’        verified: false
+   175â†’      });
+   176â†’    }
+   177â†’
+   178â†’    console.log('Changes to be made:');
+   179â†’    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+   180â†’    changes.forEach((change, idx) => {
+   181â†’      console.log(`  ${idx + 1}. ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+   182â†’    });
+   183â†’    console.log();
+   184â†’
+   185â†’    // Step 3: Write modified mode to target slot
+   186â†’    console.log(`Step 3: Writing modified mode to slot ${targetSlot}...`);
+   187â†’    await device.writeCustomMode(targetSlot, modifiedMode);
+   188â†’    console.log('âœ“ Write completed\n');
+   189â†’
+   190â†’    // Wait for device to process
+   191â†’    console.log('Waiting for device to settle...');
+   192â†’    await new Promise(resolve => setTimeout(resolve, 1000));
+   193â†’    console.log();
+   194â†’
+   195â†’    // Step 4: Read back from target slot
+   196â†’    console.log(`Step 4: Reading back from slot ${targetSlot}...`);
+   197â†’    const readBackMode = await device.readCustomMode(targetSlot);
+   198â†’
+   199â†’    if (!readBackMode) {
+   200â†’      console.log('âœ— Failed to read back custom mode');
+   201â†’      process.exit(1);
+   202â†’    }
+   203â†’
+   204â†’    console.log('âœ“ Read-back successful');
+   205â†’    console.log(`  Name: "${readBackMode.name}"`);
+   206â†’    const readBackKeys = Object.keys(readBackMode.controls || {});
+   207â†’    console.log(`  Controls: ${readBackKeys.length}`);
+   208â†’    console.log();
+   209â†’
+   210â†’    // Step 5: Verify all changes were preserved
+   211â†’    console.log('Step 5: Verifying changes...\n');
+   212â†’
+   213â†’    // Verify mode name
+   214â†’    changes[0].verified = readBackMode.name === modifiedMode.name;
+   215â†’
+   216â†’    // Verify control changes
+   217â†’    let changeIdx = 1; // Start after mode name
+   218â†’    for (let i = 0; i < controlsToModify; i++) {
+   219â†’      const key = controlKeys[i];
+   220â†’      const modifiedControl = modifiedMode.controls[key];
+   221â†’      const readBackControl = readBackMode.controls?.[key];
+   222â†’
+   223â†’      if (readBackControl) {
+   224â†’        // Verify CC (check both ccNumber and cc properties)
+   225â†’        const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+   226â†’        const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+   227â†’        changes[changeIdx].verified = readBackCC === modifiedCC;
+   228â†’        changeIdx++;
+   229â†’
+   230â†’        // Verify name (if it was changed)
+   231â†’        if (modifiedControl.name !== undefined) {
+   232â†’          changes[changeIdx].verified = readBackControl.name === modifiedControl.name;
+   233â†’          changeIdx++;
+   234â†’        }
+   235â†’
+   236â†’        // Verify channel (check both midiChannel and channel properties)
+   237â†’        const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+   238â†’        const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+   239â†’        changes[changeIdx].verified = readBackChannel === modifiedChannel;
+   240â†’        changeIdx++;
+   241â†’      } else {
+   242â†’        // Control doesn't exist in read-back
+   243â†’        console.log(`  âš  Control ${key} missing in read-back`);
+   244â†’        changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
+   245â†’      }
+   246â†’    }
+   247â†’
+   248â†’    // Display verification results
+   249â†’    console.log('Verification Results:');
+   250â†’    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+   251â†’
+   252â†’    let passCount = 0;
+   253â†’    let failCount = 0;
+   254â†’
+   255â†’    changes.forEach((change, idx) => {
+   256â†’      const status = change.verified ? 'âœ“' : 'âœ—';
+   257â†’      console.log(`  ${status} ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+   258â†’
+   259â†’      if (change.verified) {
+   260â†’        passCount++;
+   261â†’      } else {
+   262â†’        failCount++;
+   263â†’      }
+   264â†’    });
+   265â†’
+   266â†’    console.log();
+   267â†’    console.log(`  Passed: ${passCount}/${changes.length}`);
+   268â†’    console.log(`  Failed: ${failCount}/${changes.length}`);
+   269â†’
+   270â†’    // Detailed comparison for failures
+   271â†’    if (failCount > 0) {
+   272â†’      console.log('\nDetailed failure analysis:');
+   273â†’      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+   274â†’
+   275â†’      // Check mode name
+   276â†’      if (!changes[0].verified) {
+   277â†’        console.log(`  Mode name: expected "${modifiedMode.name}", got "${readBackMode.name}"`);
+   278â†’      }
+   279â†’
+   280â†’      // Check controls
+   281â†’      let changeIdx = 1;
+   282â†’      for (let i = 0; i < controlsToModify; i++) {
+   283â†’        const key = controlKeys[i];
+   284â†’        const modifiedControl = modifiedMode.controls[key];
+   285â†’        const readBackControl = readBackMode.controls?.[key];
+   286â†’
+   287â†’        if (readBackControl) {
+   288â†’          // CC check
+   289â†’          if (!changes[changeIdx].verified) {
+   290â†’            const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+   291â†’            const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+   292â†’            console.log(`  Control ${key} CC: expected ${modifiedCC}, got ${readBackCC}`);
+   293â†’          }
+   294â†’          changeIdx++;
+   295â†’
+   296â†’          // Name check (if it exists)
+   297â†’          if (modifiedControl.name !== undefined) {
+   298â†’            if (!changes[changeIdx].verified) {
+   299â†’              console.log(`  Control ${key} name: expected "${modifiedControl.name}", got "${readBackControl.name}"`);
+   300â†’            }
+   301â†’            changeIdx++;
+   302â†’          }
+   303â†’
+   304â†’          // Channel check
+   305â†’          if (!changes[changeIdx].verified) {
+   306â†’            const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+   307â†’            const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+   308â†’            console.log(`  Control ${key} channel: expected ${modifiedChannel}, got ${readBackChannel}`);
+   309â†’          }
+   310â†’          changeIdx++;
+   311â†’        } else {
+   312â†’          console.log(`  Control ${key}: MISSING in read-back`);
+   313â†’          changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
+   314â†’        }
+   315â†’      }
+   316â†’    }
+   317â†’
+   318â†’    // Overall result
+   319â†’    const allPassed = failCount === 0;
+   320â†’
+   321â†’    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+   322â†’    console.log('RESULT');
+   323â†’    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+   324â†’
+   325â†’    if (allPassed) {
+   326â†’      console.log('âœ“ TEST PASSED');
+   327â†’      console.log(`  All ${changes.length} changes were preserved correctly`);
+   328â†’      console.log('  Device firmware accepted and stored valid modifications');
+   329â†’    } else {
+   330â†’      console.log('âœ— TEST FAILED');
+   331â†’      console.log(`  ${failCount} out of ${changes.length} changes were NOT preserved`);
+   332â†’      console.log('  Some valid modifications were lost or corrupted');
+   333â†’    }
+   334â†’    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+   335â†’
+   336â†’    // Save results
+   337â†’    const results = {
+   338â†’      timestamp: new Date().toISOString(),
+   339â†’      sourceSlot,
+   340â†’      targetSlot,
+   341â†’      totalChanges: changes.length,
+   342â†’      passedChanges: passCount,
+   343â†’      failedChanges: failCount,
+   344â†’      testPassed: allPassed,
+   345â†’      changes: changes.map(c => ({
+   346â†’        description: c.description,
+   347â†’        originalValue: c.originalValue,
+   348â†’        newValue: c.newValue,
+   349â†’        verified: c.verified
+   350â†’      })),
+   351â†’      originalMode: {
+   352â†’        name: originalMode.name,
+   353â†’        controlCount: controlKeys.length
+   354â†’      },
+   355â†’      modifiedMode: {
+   356â†’        name: modifiedMode.name,
+   357â†’        controlCount: Object.keys(modifiedMode.controls).length
+   358â†’      },
+   359â†’      readBackMode: {
+   360â†’        name: readBackMode.name,
+   361â†’        controlCount: readBackKeys.length
+   362â†’      }
+   363â†’    };
+   364â†’
+   365â†’    const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-${Date.now()}.json`;
+   366â†’    writeFileSync(resultsPath, JSON.stringify(results, null, 2));
+   367â†’    console.log(`Results saved to: ${resultsPath}\n`);
+   368â†’
+   369â†’  } catch (error) {
+   370â†’    console.error('\nâœ— Test failed:', error instanceof Error ? error.message : String(error));
+   371â†’    if (error instanceof Error && error.stack) {
+   372â†’      console.error('\nStack trace:');
+   373â†’      console.error(error.stack);
+   374â†’    }
+   375â†’    process.exit(1);
+   376â†’  } finally {
+   377â†’    if (device) {
+   378â†’      console.log('â†’ Disconnecting...');
+   379â†’      await device.disconnect();
+   380â†’      console.log('âœ“ Disconnected');
+   381â†’    }
+   382â†’  }
+   383â†’}
+   384â†’
+   385â†’main().catch(console.error);
+   386â†’
+```
+
+Result:
+
+```
+1â†’#!/usr/bin/env tsx
+     2â†’/**
+     3â†’ * Node.js Round-Trip Integration Test for Launch Control XL 3
+     4â†’ *
+     5â†’ * INTEGRATION TEST: Uses ONLY PUBLIC API methods
+     6â†’ *
+     7â†’ * Tests the complete label pipeline by:
+     8â†’ * 1. Creating test custom mode using createCustomMode() (PUBLIC API)
+     9â†’ * 2. Adding control names to test label extraction
+    10â†’ * 3. Saving mode using saveCustomMode() (PUBLIC API - extracts labels)
+    11â†’ * 4. Loading mode using loadCustomMode() (PUBLIC API - parses labels)
+    12â†’ * 5. Comparing sent vs received data to ensure labels survive round-trip
+    13â†’ *
+    14â†’ * This validates that the entire custom mode write/read cycle works correctly,
+    15â†’ * including label extraction, SysEx encoding, and label parsing.
+    16â†’ *
+    17â†’ * PUBLIC API FLOW TESTED:
+    18â†’ * - controller.createCustomMode(name) â†’ Creates mode structure
+    19â†’ * - controller.saveCustomMode(slot, mode) â†’ CustomModeManager.writeMode()
+    20â†’ *   â†’ CustomModeManager.convertToDeviceFormat() (extracts labels)
+    21â†’ *   â†’ DeviceManager.writeCustomMode() (passes labels)
+    22â†’ *   â†’ SysExParser.encodeCustomModeData() (encodes labels)
+    23â†’ * - controller.loadCustomMode(slot) â†’ CustomModeManager.readMode()
+    24â†’ *   â†’ DeviceManager.readCustomMode()
+    25â†’ *   â†’ SysExParser.parse() (parses labels)
+    26â†’ *   â†’ CustomModeManager.parseCustomModeResponse() (converts to user format)
+    27â†’ *
+    28â†’ * Usage:
+    29â†’ *   tsx utils/test-round-trip-node.ts [slot]
+    30â†’ *   npm run test:round-trip:node
+    31â†’ *
+    32â†’ * Arguments:
+    33â†’ *   slot - Optional slot number (0-14 for slots 1-15). Default: 0
+    34â†’ *
+    35â†’ * Requirements:
+    36â†’ *   - Launch Control XL 3 device connected via USB
+    37â†’ *   - Device should be powered on and ready
+    38â†’ */
+    39â†’
+    40â†’import chalk from 'chalk';
+    41â†’import { LaunchControlXL3 } from '../src';
+    42â†’import { NodeMidiBackend } from '../src/backends/NodeMidiBackend.js';
+    43â†’import type { CustomMode, ControlMapping } from '../src/types/CustomMode.js';
+    44â†’
+    45â†’// Console formatting helpers
+    46â†’const log = {
+    47â†’  info: (msg: string) => console.log(chalk.blue('â„¹'), msg),
+    48â†’  success: (msg: string) => console.log(chalk.green('âœ“'), msg),
+    49â†’  error: (msg: string) => console.log(chalk.red('âœ—'), msg),
+    50â†’  warning: (msg: string) => console.log(chalk.yellow('âš '), msg),
+    51â†’  step: (msg: string) => console.log(chalk.cyan('â†’'), msg),
+    52â†’  title: (msg: string) => console.log(chalk.bold.underline(msg)),
+    53â†’  data: (label: string, value: any) => console.log(chalk.gray(`  ${label}:`), chalk.white(value)),
+    54â†’  section: (msg: string) => console.log(chalk.bgBlue.white(` ${msg} `)),
+    55â†’  comparison: (label: string, sent: any, received: any, match: boolean) => {
+    56â†’    const status = match ? chalk.green('âœ“') : chalk.red('âœ—');
+    57â†’    console.log(`${status} ${label}:`);
+    58â†’    console.log(chalk.gray(`    Sent:     ${sent}`));
+    59â†’    console.log(chalk.gray(`    Received: ${received}`));
+    60â†’    if (!match) {
+    61â†’      console.log(chalk.red(`    MISMATCH!`));
+    62â†’    }
+    63â†’  }
+    64â†’};
+    65â†’
+    66â†’// Test configuration
+    67â†’const SOURCE_SLOT = 14;  // Physical slot 15 - read baseline from here
+    68â†’const TARGET_SLOT = 0;   // Physical slot 1 - write and verify here
+    69â†’
+    70â†’/**
+    71â†’ * Modify a factory mode for testing
+    72â†’ * Changes name and modifies TWO controls only
+    73â†’ */
+    74â†’function modifyFactoryMode(factoryMode: CustomMode): { modified: CustomMode; changes: any } {
+    75â†’  // Clone the mode
+    76â†’  const modified: CustomMode = {
+    77â†’    ...factoryMode,
+    78â†’    name: 'RT Test',
+    79â†’    controls: { ...factoryMode.controls },
+    80â†’    metadata: {
+    81â†’      ...factoryMode.metadata,
+    82â†’      name: 'Round-Trip Test Mode',
+    83â†’      description: 'Test mode for validating write/read cycle',
+    84â†’    }
+    85â†’  };
+    86â†’
+    87â†’  // Track what we're changing
+    88â†’  const changes = {
+    89â†’    modeName: { old: factoryMode.name, new: 'RT Test' },
+    90â†’    controls: {} as Record<string, any>
+    91â†’  };
+    92â†’
+    93â†’  // Modify FADER1 - change MIDI channel, CC, and name
+    94â†’  if (modified.controls['FADER1']) {
+    95â†’    const original = { ...modified.controls['FADER1'] };
+    96â†’    modified.controls['FADER1'] = {
+    97â†’      ...modified.controls['FADER1'],
+    98â†’      name: 'TestVol1',
+    99â†’      midiChannel: 5,
+   100â†’      ccNumber: 77,
+   101â†’    };
+   102â†’    changes.controls['FADER1'] = { original, modified: modified.controls['FADER1'] };
+   103â†’  }
+   104â†’
+   105â†’  // Modify SEND_A1 - change MIDI channel, CC, and name
+   106â†’  if (modified.controls['SEND_A1']) {
+   107â†’    const original = { ...modified.controls['SEND_A1'] };
+   108â†’    modified.controls['SEND_A1'] = {
+   109â†’      ...modified.controls['SEND_A1'],
+   110â†’      name: 'TestRev',
+   111â†’      midiChannel: 6,
+   112â†’      ccNumber: 91,
+   113â†’    };
+   114â†’    changes.controls['SEND_A1'] = { original, modified: modified.controls['SEND_A1'] };
+   115â†’  }
+   116â†’
+   117â†’  return { modified, changes };
+   118â†’}
+   119â†’
+   120â†’/**
+   121â†’ * Compare two control mappings for equality
+   122â†’ */
+   123â†’function compareControlMapping(controlKey: string, sent: ControlMapping, received: ControlMapping): { matches: boolean; details: string[] } {
+   124â†’  const details: string[] = [];
+   125â†’  let matches = true;
+   126â†’
+   127â†’  console.log(chalk.cyan(`\n  Comparing control: ${controlKey}`));
+   128â†’
+   129â†’  // Compare control name (this is the key feature we're testing)
+   130â†’  const nameMatch = sent.name === received.name;
+   131â†’  log.comparison(`${controlKey} Name`, sent.name || '(none)', received.name || '(none)', nameMatch);
+   132â†’  if (!nameMatch) {
+   133â†’    matches = false;
+   134â†’    details.push(`${controlKey}: name mismatch: sent="${sent.name}", received="${received.name}"`);
+   135â†’  }
+   136â†’
+   137â†’  // Compare MIDI channel
+   138â†’  const channelMatch = sent.midiChannel === received.midiChannel;
+   139â†’  log.comparison(`${controlKey} MIDI Channel`, sent.midiChannel, received.midiChannel, channelMatch);
+   140â†’  if (!channelMatch) {
+   141â†’    matches = false;
+   142â†’    details.push(`${controlKey}: MIDI channel mismatch: sent=${sent.midiChannel}, received=${received.midiChannel}`);
+   143â†’  }
+   144â†’
+   145â†’  // Compare CC number
+   146â†’  const ccMatch = sent.ccNumber === received.ccNumber;
+   147â†’  log.comparison(`${controlKey} CC Number`, sent.ccNumber, received.ccNumber, ccMatch);
+   148â†’  if (!ccMatch) {
+   149â†’    matches = false;
+   150â†’    details.push(`${controlKey}: CC number mismatch: sent=${sent.ccNumber}, received=${received.ccNumber}`);
+   151â†’  }
+   152â†’
+   153â†’  // Compare min/max values
+   154â†’  const minMatch = sent.minValue === received.minValue;
+   155â†’  const maxMatch = sent.maxValue === received.maxValue;
+   156â†’  log.comparison(`${controlKey} Min Value`, sent.minValue, received.minValue, minMatch);
+   157â†’  log.comparison(`${controlKey} Max Value`, sent.maxValue, received.maxValue, maxMatch);
+   158â†’
+   159â†’  if (!minMatch) {
+   160â†’    matches = false;
+   161â†’    details.push(`${controlKey}: min value mismatch: sent=${sent.minValue}, received=${received.minValue}`);
+   162â†’  }
+   163â†’  if (!maxMatch) {
+   164â†’    matches = false;
+   165â†’    details.push(`${controlKey}: max value mismatch: sent=${sent.maxValue}, received=${received.maxValue}`);
+   166â†’  }
+   167â†’
+   168â†’  // Compare behavior
+   169â†’  const behaviorMatch = sent.behavior === received.behavior;
+   170â†’  log.comparison(`${controlKey} Behavior`, sent.behavior, received.behavior, behaviorMatch);
+   171â†’  if (!behaviorMatch) {
+   172â†’    matches = false;
+   173â†’    details.push(`${controlKey}: behavior mismatch: sent="${sent.behavior}", received="${received.behavior}"`);
+   174â†’  }
+   175â†’
+   176â†’  return { matches, details };
+   177â†’}
+   178â†’
+   179â†’/**
+   180â†’ * Check if test environment is ready
+   181â†’ */
+   182â†’async function checkEnvironment(): Promise<boolean> {
+   183â†’  log.step('Checking test environment...');
+   184â†’
+   185â†’  try {
+   186â†’    // Create a temporary NodeMidiBackend to check for LCXL3 device
+   187â†’    const backend = new NodeMidiBackend();
+   188â†’    await backend.initialize();
+   189â†’
+   190â†’    const inputPorts = await backend.getInputPorts();
+   191â†’    const outputPorts = await backend.getOutputPorts();
+   192â†’
+   193â†’    // Look for Launch Control XL3 in available ports
+   194â†’    const lcxl3Input = inputPorts.find(p =>
+   195â†’      p.name.toLowerCase().includes('launch control xl') ||
+   196â†’      p.name.toLowerCase().includes('lcxl3')
+   197â†’    );
+   198â†’
+   199â†’    const lcxl3Output = outputPorts.find(p =>
+   200â†’      p.name.toLowerCase().includes('launch control xl') ||
+   201â†’      p.name.toLowerCase().includes('lcxl3')
+   202â†’    );
+   203â†’
+   204â†’    await backend.cleanup();
+   205â†’
+   206â†’    if (lcxl3Input && lcxl3Output) {
+   207â†’      log.success('Launch Control XL3 device found');
+   208â†’      log.data('Input Port', lcxl3Input.name);
+   209â†’      log.data('Output Port', lcxl3Output.name);
+   210â†’      return true;
+   211â†’    } else {
+   212â†’      log.error('Launch Control XL3 device not found!');
+   213â†’      console.log();
+   214â†’      log.warning('â•'.repeat(60));
+   215â†’      log.warning('Integration Test Environment Not Ready');
+   216â†’      log.warning('â•'.repeat(60));
+   217â†’      console.log();
+   218â†’      log.info('Required setup:');
+   219â†’      log.info('  1. Connect Launch Control XL3 via USB');
+   220â†’      log.info('  2. Power on the device');
+   221â†’      console.log();
+   222â†’      log.info('Available MIDI ports:');
+   223â†’      if (inputPorts.length === 0) {
+   224â†’        log.warning('  No MIDI input ports found');
+   225â†’      } else {
+   226â†’        log.info('  Input ports:');
+   227â†’        inputPorts.forEach(p => console.log(chalk.gray(`    - ${p.name}`)));
+   228â†’      }
+   229â†’      if (outputPorts.length === 0) {
+   230â†’        log.warning('  No MIDI output ports found');
+   231â†’      } else {
+   232â†’        log.info('  Output ports:');
+   233â†’        outputPorts.forEach(p => console.log(chalk.gray(`    - ${p.name}`)));
+   234â†’      }
+   235â†’      console.log();
+   236â†’      return false;
+   237â†’    }
+   238â†’  } catch (error: any) {
+   239â†’    log.error('Failed to enumerate MIDI ports!');
+   240â†’    console.log();
+   241â†’    log.warning('â•'.repeat(60));
+   242â†’    log.warning('MIDI System Error');
+   243â†’    log.warning('â•'.repeat(60));
+   244â†’    console.log();
+   245â†’    log.error(`Error: ${error.message}`);
+   246â†’    console.log();
+   247â†’    log.info('Troubleshooting:');
+   248â†’    log.info('  1. Ensure MIDI drivers are installed');
+   249â†’    log.info('  2. Check system MIDI settings');
+   250â†’    log.info('  3. Verify device permissions');
+   251â†’    console.log();
+   252â†’    return false;
+   253â†’  }
+   254â†’}
+   255â†’
+   256â†’/**
+   257â†’ * Main round-trip test function
+   258â†’ */
+   259â†’async function testRoundTrip(): Promise<void> {
+   260â†’  log.title('Launch Control XL 3 - Round-Trip Test');
+   261â†’  console.log('='.repeat(60));
+   262â†’
+   263â†’  log.info('Testing write/read cycle with baseline modification');
+   264â†’  log.data('Source Slot', `${SOURCE_SLOT} (physical slot ${SOURCE_SLOT + 1})`);
+   265â†’  log.data('Target Slot', `${TARGET_SLOT} (physical slot ${TARGET_SLOT + 1})`);
+   266â†’  console.log();
+   267â†’
+   268â†’  // Check environment first
+   269â†’  const envReady = await checkEnvironment();
+   270â†’  if (!envReady) {
+   271â†’    process.exit(1);
+   272â†’  }
+   273â†’
+   274â†’  console.log();
+   275â†’
+   276â†’  let controller: LaunchControlXL3 | null = null;
+   277â†’  let backend: NodeMidiBackend | null = null;
+   278â†’  let testPassed = false;
+   279â†’
+   280â†’  try {
+   281â†’    // Step 1: Create and initialize NodeMidiBackend
+   282â†’    log.step('Creating NodeMidiBackend instance...');
+   283â†’    backend = new NodeMidiBackend();
+   284â†’
+   285â†’    log.step('Initializing NodeMidiBackend...');
+   286â†’    await backend.initialize();
+   287â†’    log.success('NodeMidiBackend initialized successfully!');
+   288â†’
+   289â†’    // Step 2: Create LaunchControlXL3 instance
+   290â†’    log.step('Creating LaunchControlXL3 instance...');
+   291â†’    controller = new LaunchControlXL3({
+   292â†’      midiBackend: backend,
+   293â†’      enableLedControl: true,
+   294â†’      enableCustomModes: true,
+   295â†’    });
+   296â†’
+   297â†’    // Step 3: Setup event handlers
+   298â†’    log.step('Setting up event handlers...');
+   299â†’
+   300â†’    controller.on('device:connected', (device) => {
+   301â†’      log.success('Device connected successfully!');
+   302â†’      log.data('Manufacturer ID', device.manufacturerId);
+   303â†’      log.data('Family Code', device.familyCode);
+   304â†’      log.data('Model Number', device.modelNumber);
+   305â†’      log.data('Firmware Version', device.firmwareVersion);
+   306â†’    });
+   307â†’
+   308â†’    controller.on('device:disconnected', (reason) => {
+   309â†’      log.warning(`Device disconnected: ${reason || 'Unknown reason'}`);
+   310â†’    });
+   311â†’
+   312â†’    controller.on('device:error', (error) => {
+   313â†’      log.error(`Device error: ${error.message}`);
+   314â†’    });
+   315â†’
+   316â†’    // Step 4: Connect to device
+   317â†’    log.step('Attempting to connect to Launch Control XL 3...');
+   318â†’
+   319â†’    // Wait for device to be ready with timeout
+   320â†’    const connectPromise = new Promise<void>((resolve, reject) => {
+   321â†’      const timeout = setTimeout(() => {
+   322â†’        reject(new Error('Failed to connect to device within timeout period'));
+   323â†’      }, 10000);
+   324â†’
+   325â†’      controller.once('device:ready', () => {
+   326â†’        clearTimeout(timeout);
+   327â†’        resolve();
+   328â†’      });
+   329â†’
+   330â†’      controller.once('device:error', (error) => {
+   331â†’        clearTimeout(timeout);
+   332â†’        reject(error);
+   333â†’      });
+   334â†’    });
+   335â†’
+   336â†’    await controller.connect();
+   337â†’    await connectPromise;
+   338â†’
+   339â†’    log.success('Connected to Launch Control XL 3!');
+   340â†’    console.log();
+   341â†’
+   342â†’    // Step 1: Read baseline mode
+   343â†’    log.section(' STEP 1: READ BASELINE MODE ');
+   344â†’    log.step(`Reading baseline from slot ${SOURCE_SLOT}...`);
+   345â†’
+   346â†’    const sourceMode = await controller.loadCustomMode(SOURCE_SLOT);
+   347â†’
+   348â†’    if (!sourceMode) {
+   349â†’      throw new Error(`Failed to read mode from slot ${SOURCE_SLOT}`);
+   350â†’    }
+   351â†’
+   352â†’    log.success(`Mode read from slot ${SOURCE_SLOT}!`);
+   353â†’    log.data('Source Mode Name', sourceMode.name);
+   354â†’    log.data('Source Control Count', Object.keys(sourceMode.controls).length);
+   355â†’
+   356â†’    // CRITICAL: Validate factory defaults are complete
+   357â†’    console.log(chalk.gray('\n  Validating factory defaults...'));
+   358â†’
+   359â†’    const expectedControlCount = 48; // Device has 48 controls
+   360â†’    const actualControlCount = Object.keys(sourceMode.controls).length;
+   361â†’
+   362â†’    if (actualControlCount !== expectedControlCount) {
+   363â†’      throw new Error(
+   364â†’        `âŒ INVALID FACTORY DATA: Expected ${expectedControlCount} controls, got ${actualControlCount}.\n` +
+   365â†’        `Factory default slot must contain ALL controls with valid MIDI parameters.\n` +
+   366â†’        `This slot appears to have incomplete data.`
+   367â†’      );
+   368â†’    }
+   369â†’
+   370â†’    // Validate each control has valid MIDI parameters (not CH0/CC0 which is non-functional)
+   371â†’    const invalidControls: string[] = [];
+   372â†’    for (const [id, control] of Object.entries(sourceMode.controls)) {
+   373â†’      // CH0/CC0 means the control is not configured (non-functional)
+   374â†’      if (control.midiChannel === 0 && control.ccNumber === 0) {
+   375â†’        invalidControls.push(`${id} (CH0/CC0)`);
+   376â†’      }
+   377â†’    }
+   378â†’
+   379â†’    if (invalidControls.length > 0) {
+   380â†’      console.log(chalk.red('\n  Invalid controls found:'));
+   381â†’      invalidControls.forEach(ctrl => console.log(chalk.red(`    ${ctrl}`)));
+   382â†’      throw new Error(
+   383â†’        `âŒ INVALID FACTORY DATA: ${invalidControls.length} controls have CH0/CC0 (non-functional).\n` +
+   384â†’        `Factory defaults must have valid MIDI channel and CC numbers for all controls.\n` +
+   385â†’        `This slot does not contain proper factory defaults.`
+   386â†’      );
+   387â†’    }
+   388â†’
+   389â†’    log.success('Factory defaults validated: All 48 controls present with valid MIDI parameters');
+   390â†’
+   391â†’    console.log();
+   392â†’
+   393â†’    // Step 2: Modify mode (only 2 controls)
+   394â†’    log.section(' STEP 2: MODIFY MODE (2 CONTROLS) ');
+   395â†’    log.step('Modifying source mode...');
+   396â†’    log.info('Changes: mode name + FADER1 + SEND_A1');
+   397â†’
+   398â†’    const { modified: testMode, changes } = modifyFactoryMode(sourceMode);
+   399â†’
+   400â†’    log.success('Mode modified!');
+   401â†’    log.data('New Mode Name', testMode.name);
+   402â†’    console.log(chalk.gray('\n  Modified Controls:'));
+   403â†’    console.log(chalk.gray(`    FADER1: "${testMode.controls['FADER1']?.name}" (CH${testMode.controls['FADER1']?.midiChannel}, CC${testMode.controls['FADER1']?.ccNumber})`));
+   404â†’    console.log(chalk.gray(`    SEND_A1: "${testMode.controls['SEND_A1']?.name}" (CH${testMode.controls['SEND_A1']?.midiChannel}, CC${testMode.controls['SEND_A1']?.ccNumber})`));
+   405â†’
+   406â†’    console.log();
+   407â†’
+   408â†’    // Step 4: Write modified mode to target slot
+   409â†’    log.section(' STEP 4: WRITE TO DEVICE ');
+   410â†’    log.step(`Writing modified mode to slot ${TARGET_SLOT}...`);
+   411â†’
+   412â†’    await controller.saveCustomMode(TARGET_SLOT, testMode);
+   413â†’    log.success(`Mode saved to slot ${TARGET_SLOT}!`);
+   414â†’
+   415â†’    // Small delay to ensure write is complete
+   416â†’    await new Promise(resolve => setTimeout(resolve, 500));
+   417â†’
+   418â†’    console.log();
+   419â†’
+   420â†’    // Step 5: Read back from target slot
+   421â†’    log.section(' STEP 5: READ FROM DEVICE ');
+   422â†’    log.step(`Reading mode back from slot ${TARGET_SLOT}...`);
+   423â†’
+   424â†’    const readMode = await controller.loadCustomMode(TARGET_SLOT);
+   425â†’
+   426â†’    if (!readMode) {
+   427â†’      throw new Error(`Failed to read mode from slot ${TARGET_SLOT}`);
+   428â†’    }
+   429â†’
+   430â†’    log.success(`Mode read from slot ${TARGET_SLOT}!`);
+   431â†’    log.data('Read Mode Name', readMode.name);
+   432â†’    console.log(chalk.gray('\n  Read Controls (modified ones):'));
+   433â†’    console.log(chalk.gray(`    FADER1: "${readMode.controls['FADER1']?.name || '(no name)'}" (CH${readMode.controls['FADER1']?.midiChannel}, CC${readMode.controls['FADER1']?.ccNumber})`));
+   434â†’    console.log(chalk.gray(`    SEND_A1: "${readMode.controls['SEND_A1']?.name || '(no name)'}" (CH${readMode.controls['SEND_A1']?.midiChannel}, CC${readMode.controls['SEND_A1']?.ccNumber})`));
+   435â†’
+   436â†’    console.log();
+   437â†’
+   438â†’    // Step 6: Compare ALL controls from the source mode
+   439â†’    log.section(' STEP 6: VERIFY CHANGES ');
+   440â†’    log.step('Comparing ALL controls from baseline...');
+   441â†’
+   442â†’    const errors: string[] = [];
+   443â†’
+   444â†’    // Check mode name
+   445â†’    if (testMode.name !== readMode.name) {
+   446â†’      errors.push(`Mode name mismatch: sent="${testMode.name}", received="${readMode.name}"`);
+   447â†’      log.comparison('Mode Name', testMode.name, readMode.name, false);
+   448â†’    } else {
+   449â†’      log.comparison('Mode Name', testMode.name, readMode.name, true);
+   450â†’    }
+   451â†’
+   452â†’    // Check control count
+   453â†’    const sentControlCount = Object.keys(testMode.controls).length;
+   454â†’    const receivedControlCount = Object.keys(readMode.controls).length;
+   455â†’
+   456â†’    if (sentControlCount !== receivedControlCount) {
+   457â†’      errors.push(`Control count mismatch: sent=${sentControlCount}, received=${receivedControlCount}`);
+   458â†’      log.comparison('Control Count', sentControlCount.toString(), receivedControlCount.toString(), false);
+   459â†’    } else {
+   460â†’      log.comparison('Control Count', sentControlCount.toString(), receivedControlCount.toString(), true);
+   461â†’    }
+   462â†’
+   463â†’    // Check ALL controls that were sent
+   464â†’    console.log();
+   465â†’    console.log(chalk.gray('  Verifying all controls:'));
+   466â†’
+   467â†’    for (const [controlId, sentControl] of Object.entries(testMode.controls)) {
+   468â†’      const receivedControl = readMode.controls[controlId];
+   469â†’
+   470â†’      if (!receivedControl) {
+   471â†’        errors.push(`Control ${controlId} missing from device`);
+   472â†’        console.log(chalk.red(`    âœ— ${controlId}: MISSING`));
+   473â†’      } else {
+   474â†’        const match = compareControlMapping(controlId, sentControl, receivedControl);
+   475â†’        if (!match.matches) {
+   476â†’          errors.push(...match.details);
+   477â†’        }
+   478â†’      }
+   479â†’    }
+   480â†’
+   481â†’    console.log();
+   482â†’
+   483â†’    if (errors.length === 0) {
+   484â†’      log.success('ğŸ‰ ROUND-TRIP TEST PASSED! ğŸ‰');
+   485â†’      log.success('All controls match!');
+   486â†’      testPassed = true;
+   487â†’    } else {
+   488â†’      log.error('âŒ ROUND-TRIP TEST FAILED! âŒ');
+   489â†’      log.error('Data mismatch detected:');
+   490â†’      errors.forEach(detail => {
+   491â†’        log.error(`  â€¢ ${detail}`);
+   492â†’      });
+   493â†’    }
+   494â†’
+   495â†’    // Summary
+   496â†’    console.log('');
+   497â†’    log.section(' SUMMARY ');
+   498â†’    console.log('This test verifies:');
+   499â†’    console.log('  1. loadCustomMode() reads factory default correctly');
+   500â†’    console.log('  2. Mode modifications (name + 2 controls)');
+   501â†’    console.log('  3. saveCustomMode() writes changes to device');
+   502â†’    console.log('  4. loadCustomMode() reads changes back');
+   503â†’    console.log('  5. Changes survive complete round-trip');
+   504â†’    console.log('');
+   505â†’    console.log('Pipeline tested:');
+   506â†’    console.log('  Read Factory â†’ Modify â†’ Write â†’ Read â†’ Compare');
+   507â†’    console.log('');
+   508â†’
+   509â†’  } catch (error: any) {
+   510â†’    log.error('Test failed with error:');
+   511â†’    log.error(error.message);
+   512â†’
+   513â†’    if (error.message.includes('Cannot find MIDI devices') || error.message.includes('not found')) {
+   514â†’      log.warning('');
+   515â†’      log.warning('TROUBLESHOOTING:');
+   516â†’      log.warning('â€¢ Ensure Launch Control XL 3 is connected via USB');
+   517â†’      log.warning('â€¢ Check that the device is powered on');
+   518â†’      log.warning('â€¢ Verify MIDI drivers are installed');
+   519â†’      log.warning('â€¢ Try disconnecting and reconnecting the device');
+   520â†’    }
+   521â†’  } finally {
+   522â†’    // Cleanup
+   523â†’    if (controller) {
+   524â†’      log.step('Disconnecting from device...');
+   525â†’      try {
+   526â†’        await controller.disconnect();
+   527â†’        log.success('Disconnected successfully');
+   528â†’      } catch (error) {
+   529â†’        log.warning('Error during disconnect (this is usually harmless)');
+   530â†’      }
+   531â†’    }
+   532â†’
+   533â†’    if (backend) {
+   534â†’      log.step('Cleaning up MIDI backend...');
+   535â†’      await backend.cleanup();
+   536â†’    }
+   537â†’  }
+   538â†’
+   539â†’  // Exit with appropriate code
+   540â†’  process.exit(testPassed ? 0 : 1);
+   541â†’}
+   542â†’
+   543â†’// Handle process termination gracefully
+   544â†’process.on('SIGINT', () => {
+   545â†’  log.warning('\nTest interrupted by user');
+   546â†’  process.exit(1);
+   547â†’});
+   548â†’
+   549â†’process.on('SIGTERM', () => {
+   550â†’  log.warning('\nTest terminated');
+   551â†’  process.exit(1);
+   552â†’});
+   553â†’
+   554â†’// Run the test
+   555â†’testRoundTrip().catch((error: any) => {
+   556â†’  log.error('Unhandled error:', error.message);
+   557â†’  process.exit(1);
+   558â†’});
+   559â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now let me check the project structure to understand what tests exist:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration`
+
+Error:
+
+```
+EISDIR: illegal operation on a directory, read
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Let me list the test files:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test`
+
+Error:
+
+```
+EISDIR: illegal operation on a directory, read
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! I've reviewed the integration test infrastructure. Based on my analysis:
+
+**Best file to augment: `test/integration/custom-mode-write-verify.test.ts`**
+
+This is the ideal file because it:
+1. Already tests writing and reading back custom modes
+2. Validates that changes persist correctly
+3. Tests the mode name specifically
+4. Uses the standalone test pattern that can be manually run with tsx
+
+Let me now augment this file to add 18-character mode name tests:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Write**
+
+```typescript
+#!/usr/bin/env tsx
+/**
+ * Integration Test: Custom Mode Write and Verify
+ *
+ * Purpose:
+ *   Validates that CustomMode API changes are correctly written to the device
+ *   and can be read back with all modifications preserved.
+ *
+ * Test Flow:
+ *   1. Read custom mode from slot 10 using library API
+ *   2. Make VALID changes using CustomMode structure
+ *   3. Write modified mode to slot 3
+ *   4. Read back from slot 3
+ *   5. Verify all changes were preserved
+ *
+ * Prerequisites:
+ *   - Launch Control XL3 connected via USB
+ *   - Slot 10 must contain a configured custom mode
+ *
+ * Validates:
+ *   - CustomMode read/write API
+ *   - Device firmware accepts valid modifications
+ *   - Data integrity through write/read cycle
+ *   - Control property changes (CC, channel, name)
+ *   - 18-character mode names (new in protocol v2)
+ *
+ * Related Issues: #36
+ *
+ * @module test/integration
+ */
+
+import { LaunchControlXL3 } from '../../src/index.js';
+import { NodeMidiBackend } from '../../src/backends/NodeMidiBackend.js';
+import type { CustomMode, ControlMapping } from '../../src/types.js';
+import { writeFileSync } from 'fs';
+
+interface TestChange {
+  description: string;
+  originalValue: any;
+  newValue: any;
+  verified: boolean;
+}
+
+async function main() {
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+  console.log('Custom Mode Write and Verify Integration Test');
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+  let device: LaunchControlXL3 | null = null;
+
+  try {
+    // Initialize backend
+    const backend = new NodeMidiBackend();
+    await backend.initialize();
+
+    // Create device
+    device = new LaunchControlXL3({
+      midiBackend: backend,
+      enableLedControl: false,
+      enableCustomModes: true
+    });
+
+    console.log('â†’ Connecting to device...');
+    await device.connect();
+    console.log('âœ“ Connected\n');
+
+    // Run both test suites
+    let allTestsPassed = true;
+
+    // Test Suite 1: Standard property changes (original test)
+    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
+    console.log('â•‘          TEST SUITE 1: STANDARD PROPERTY CHANGES               â•‘');
+    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+    const suite1Passed = await testStandardPropertyChanges(device);
+    if (!suite1Passed) allTestsPassed = false;
+
+    console.log('\n');
+
+    // Test Suite 2: 18-character mode names
+    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
+    console.log('â•‘          TEST SUITE 2: 18-CHARACTER MODE NAMES                 â•‘');
+    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+    const suite2Passed = await test18CharacterModeNames(device);
+    if (!suite2Passed) allTestsPassed = false;
+
+    // Overall Summary
+    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    console.log('OVERALL TEST RESULTS');
+    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    console.log(`Test Suite 1 (Standard Properties): ${suite1Passed ? 'âœ“ PASSED' : 'âœ— FAILED'}`);
+    console.log(`Test Suite 2 (18-char Mode Names): ${suite2Passed ? 'âœ“ PASSED' : 'âœ— FAILED'}`);
+    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+
+    if (allTestsPassed) {
+      console.log('âœ“ ALL TESTS PASSED');
+    } else {
+      console.log('âœ— SOME TESTS FAILED');
+      process.exit(1);
+    }
+
+  } catch (error) {
+    console.error('\nâœ— Test failed:', error instanceof Error ? error.message : String(error));
+    if (error instanceof Error && error.stack) {
+      console.error('\nStack trace:');
+      console.error(error.stack);
+    }
+    process.exit(1);
+  } finally {
+    if (device) {
+      console.log('\nâ†’ Disconnecting...');
+      await device.disconnect();
+      console.log('âœ“ Disconnected');
+    }
+  }
+}
+
+/**
+ * Test Suite 1: Standard Property Changes (Original Test)
+ */
+async function testStandardPropertyChanges(device: LaunchControlXL3): Promise<boolean> {
+  const sourceSlot = 10;
+  const targetSlot = 3;
+
+  // Step 1: Read from source slot
+  console.log(`Step 1: Reading custom mode from slot ${sourceSlot}...`);
+  const originalMode = await device.readCustomMode(sourceSlot);
+
+  if (!originalMode) {
+    console.log('âœ— Failed to read custom mode');
+    return false;
+  }
+
+  console.log('âœ“ Read successful');
+  console.log(`  Name: "${originalMode.name}"`);
+
+  // Get control keys from the controls object
+  const controlKeys = Object.keys(originalMode.controls || {});
+  console.log(`  Controls: ${controlKeys.length}`);
+  console.log(`  Control keys: ${controlKeys.slice(0, 5).join(', ')}${controlKeys.length > 5 ? '...' : ''}`);
+  console.log();
+
+  // Ensure controls object exists
+  if (!originalMode.controls || typeof originalMode.controls !== 'object') {
+    console.log('âœ— originalMode.controls is not an object');
+    return false;
+  }
+
+  if (controlKeys.length === 0) {
+    console.log('âœ— No controls found in slot 10');
+    console.log('  Try a different source slot that has configured controls');
+    return false;
+  }
+
+  // Step 2: Make valid changes to the mode
+  console.log('Step 2: Making valid changes to custom mode...\n');
+
+  const changes: TestChange[] = [];
+
+  // Clone the mode - deep copy the controls object
+  const modifiedMode: CustomMode = {
+    name: 'TESTMOD',
+    controls: { ...originalMode.controls },
+    colors: originalMode.colors,
+    labels: originalMode.labels,
+    leds: originalMode.leds
+  };
+
+  // Deep clone each control
+  for (const key in modifiedMode.controls) {
+    modifiedMode.controls[key] = { ...originalMode.controls[key] };
+  }
+
+  // Track mode name change
+  changes.push({
+    description: 'Mode name',
+    originalValue: originalMode.name,
+    newValue: modifiedMode.name,
+    verified: false
+  });
+
+  // Modify first 5 controls (if they exist)
+  const controlsToModify = Math.min(5, controlKeys.length);
+
+  for (let i = 0; i < controlsToModify; i++) {
+    const key = controlKeys[i];
+    const control = modifiedMode.controls[key];
+
+    // Change CC number (use ccNumber property, not cc)
+    const originalCC = control.ccNumber || control.cc || 0;
+    const newCC = (originalCC + 10) % 120; // Stay within valid range
+    control.ccNumber = newCC;
+    if (control.cc !== undefined) {
+      control.cc = newCC; // Update both if cc exists
+    }
+
+    changes.push({
+      description: `Control ${key} CC`,
+      originalValue: originalCC,
+      newValue: newCC,
+      verified: false
+    });
+
+    // Change control name (if it exists)
+    if (control.name !== undefined) {
+      const originalName = control.name;
+      const newName = `TST_${i}`;
+      control.name = newName;
+
+      changes.push({
+        description: `Control ${key} name`,
+        originalValue: originalName,
+        newValue: newName,
+        verified: false
+      });
+    }
+
+    // Change channel (use midiChannel property, not channel)
+    const originalChannel = control.midiChannel ?? control.channel ?? 0;
+    const newChannel = (originalChannel % 16);
+    control.midiChannel = newChannel;
+    if (control.channel !== undefined) {
+      control.channel = newChannel; // Update both if channel exists
+    }
+
+    changes.push({
+      description: `Control ${key} channel`,
+      originalValue: originalChannel,
+      newValue: newChannel,
+      verified: false
+    });
+  }
+
+  console.log('Changes to be made:');
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+  changes.forEach((change, idx) => {
+    console.log(`  ${idx + 1}. ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+  });
+  console.log();
+
+  // Step 3: Write modified mode to target slot
+  console.log(`Step 3: Writing modified mode to slot ${targetSlot}...`);
+  await device.writeCustomMode(targetSlot, modifiedMode);
+  console.log('âœ“ Write completed\n');
+
+  // Wait for device to process
+  console.log('Waiting for device to settle...');
+  await new Promise(resolve => setTimeout(resolve, 1000));
+  console.log();
+
+  // Step 4: Read back from target slot
+  console.log(`Step 4: Reading back from slot ${targetSlot}...`);
+  const readBackMode = await device.readCustomMode(targetSlot);
+
+  if (!readBackMode) {
+    console.log('âœ— Failed to read back custom mode');
+    return false;
+  }
+
+  console.log('âœ“ Read-back successful');
+  console.log(`  Name: "${readBackMode.name}"`);
+  const readBackKeys = Object.keys(readBackMode.controls || {});
+  console.log(`  Controls: ${readBackKeys.length}`);
+  console.log();
+
+  // Step 5: Verify all changes were preserved
+  console.log('Step 5: Verifying changes...\n');
+
+  // Verify mode name
+  changes[0].verified = readBackMode.name === modifiedMode.name;
+
+  // Verify control changes
+  let changeIdx = 1; // Start after mode name
+  for (let i = 0; i < controlsToModify; i++) {
+    const key = controlKeys[i];
+    const modifiedControl = modifiedMode.controls[key];
+    const readBackControl = readBackMode.controls?.[key];
+
+    if (readBackControl) {
+      // Verify CC (check both ccNumber and cc properties)
+      const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+      const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+      changes[changeIdx].verified = readBackCC === modifiedCC;
+      changeIdx++;
+
+      // Verify name (if it was changed)
+      if (modifiedControl.name !== undefined) {
+        changes[changeIdx].verified = readBackControl.name === modifiedControl.name;
+        changeIdx++;
+      }
+
+      // Verify channel (check both midiChannel and channel properties)
+      const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+      const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+      changes[changeIdx].verified = readBackChannel === modifiedChannel;
+      changeIdx++;
+    } else {
+      // Control doesn't exist in read-back
+      console.log(`  âš  Control ${key} missing in read-back`);
+      changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
+    }
+  }
+
+  // Display verification results
+  console.log('Verification Results:');
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+
+  let passCount = 0;
+  let failCount = 0;
+
+  changes.forEach((change, idx) => {
+    const status = change.verified ? 'âœ“' : 'âœ—';
+    console.log(`  ${status} ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+
+    if (change.verified) {
+      passCount++;
+    } else {
+      failCount++;
+    }
+  });
+
+  console.log();
+  console.log(`  Passed: ${passCount}/${changes.length}`);
+  console.log(`  Failed: ${failCount}/${changes.length}`);
+
+  // Detailed comparison for failures
+  if (failCount > 0) {
+    console.log('\nDetailed failure analysis:');
+    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+
+    // Check mode name
+    if (!changes[0].verified) {
+      console.log(`  Mode name: expected "${modifiedMode.name}", got "${readBackMode.name}"`);
+    }
+
+    // Check controls
+    let changeIdx = 1;
+    for (let i = 0; i < controlsToModify; i++) {
+      const key = controlKeys[i];
+      const modifiedControl = modifiedMode.controls[key];
+      const readBackControl = readBackMode.controls?.[key];
+
+      if (readBackControl) {
+        // CC check
+        if (!changes[changeIdx].verified) {
+          const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+          const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+          console.log(`  Control ${key} CC: expected ${modifiedCC}, got ${readBackCC}`);
+        }
+        changeIdx++;
+
+        // Name check (if it exists)
+        if (modifiedControl.name !== undefined) {
+          if (!changes[changeIdx].verified) {
+            console.log(`  Control ${key} name: expected "${modifiedControl.name}", got "${readBackControl.name}"`);
+          }
+          changeIdx++;
+        }
+
+        // Channel check
+        if (!changes[changeIdx].verified) {
+          const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+          const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+          console.log(`  Control ${key} channel: expected ${modifiedChannel}, got ${readBackChannel}`);
+        }
+        changeIdx++;
+      } else {
+        console.log(`  Control ${key}: MISSING in read-back`);
+        changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
+      }
+    }
+  }
+
+  // Overall result
+  const allPassed = failCount === 0;
+
+  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+  console.log('SUITE 1 RESULT');
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+
+  if (allPassed) {
+    console.log('âœ“ TEST PASSED');
+    console.log(`  All ${changes.length} changes were preserved correctly`);
+    console.log('  Device firmware accepted and stored valid modifications');
+  } else {
+    console.log('âœ— TEST FAILED');
+    console.log(`  ${failCount} out of ${changes.length} changes were NOT preserved`);
+    console.log('  Some valid modifications were lost or corrupted');
+  }
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+  // Save results
+  const results = {
+    timestamp: new Date().toISOString(),
+    testSuite: 'standard-property-changes',
+    sourceSlot,
+    targetSlot,
+    totalChanges: changes.length,
+    passedChanges: passCount,
+    failedChanges: failCount,
+    testPassed: allPassed,
+    changes: changes.map(c => ({
+      description: c.description,
+      originalValue: c.originalValue,
+      newValue: c.newValue,
+      verified: c.verified
+    })),
+    originalMode: {
+      name: originalMode.name,
+      controlCount: controlKeys.length
+    },
+    modifiedMode: {
+      name: modifiedMode.name,
+      controlCount: Object.keys(modifiedMode.controls).length
+    },
+    readBackMode: {
+      name: readBackMode.name,
+      controlCount: readBackKeys.length
+    }
+  };
+
+  const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-${Date.now()}.json`;
+  writeFileSync(resultsPath, JSON.stringify(results, null, 2));
+  console.log(`Results saved to: ${resultsPath}\n`);
+
+  return allPassed;
+}
+
+/**
+ * Test Suite 2: 18-Character Mode Names
+ * Tests the new protocol support for extended mode names (up to 18 characters)
+ */
+async function test18CharacterModeNames(device: LaunchControlXL3): Promise<boolean> {
+  const sourceSlot = 10;
+  const targetSlot = 3;
+
+  console.log('Testing 18-character mode name support...\n');
+  console.log('This validates the protocol change from 8 to 18 character limit.\n');
+
+  // Read baseline mode
+  console.log(`Step 1: Reading baseline from slot ${sourceSlot}...`);
+  const baselineMode = await device.readCustomMode(sourceSlot);
+
+  if (!baselineMode) {
+    console.log('âœ— Failed to read baseline mode');
+    return false;
+  }
+
+  console.log('âœ“ Read successful\n');
+
+  // Test cases for 18-character names
+  const testCases = [
+    {
+      name: '17CharacterMode1',
+      description: '17 characters (under limit)',
+      expectedLength: 17,
+      shouldSucceed: true
+    },
+    {
+      name: 'EXACTLY18CHARSLONG',
+      description: 'Exactly 18 characters (at limit)',
+      expectedLength: 18,
+      shouldSucceed: true
+    },
+    {
+      name: '18CharModeName123',
+      description: '18 characters with mixed case',
+      expectedLength: 18,
+      shouldSucceed: true
+    },
+    {
+      name: 'ShortName',
+      description: 'Short name (9 characters, over old limit)',
+      expectedLength: 9,
+      shouldSucceed: true
+    }
+  ];
+
+  const results: Array<{
+    testCase: typeof testCases[0];
+    written: boolean;
+    readBack: string | null;
+    verified: boolean;
+    error?: string;
+  }> = [];
+
+  // Run each test case
+  for (let i = 0; i < testCases.length; i++) {
+    const testCase = testCases[i];
+    console.log(`\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
+    console.log(`Test Case ${i + 1}/${testCases.length}: ${testCase.description}`);
+    console.log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
+    console.log(`  Name: "${testCase.name}"`);
+    console.log(`  Length: ${testCase.name.length} characters`);
+    console.log(`  Expected: ${testCase.expectedLength} characters`);
+    console.log();
+
+    let written = false;
+    let readBack: string | null = null;
+    let verified = false;
+    let error: string | undefined;
+
+    try {
+      // Create mode with test name
+      const testMode: CustomMode = {
+        ...baselineMode,
+        name: testCase.name,
+        controls: { ...baselineMode.controls }
+      };
+
+      // Deep clone controls
+      for (const key in testMode.controls) {
+        testMode.controls[key] = { ...baselineMode.controls[key] };
+      }
+
+      // Write to device
+      console.log(`  â†’ Writing to slot ${targetSlot}...`);
+      await device.writeCustomMode(targetSlot, testMode);
+      written = true;
+      console.log(`  âœ“ Write successful`);
+
+      // Wait for device to settle
+      await new Promise(resolve => setTimeout(resolve, 1000));
+
+      // Read back
+      console.log(`  â†’ Reading back from slot ${targetSlot}...`);
+      const readBackMode = await device.readCustomMode(targetSlot);
+
+      if (!readBackMode) {
+        throw new Error('Failed to read back mode');
+      }
+
+      readBack = readBackMode.name;
+      console.log(`  âœ“ Read successful`);
+      console.log(`  Read name: "${readBack}"`);
+      console.log(`  Read length: ${readBack.length} characters`);
+
+      // Verify
+      if (readBack === testCase.name) {
+        verified = true;
+        console.log(`  âœ“ VERIFIED: Name matches exactly`);
+      } else {
+        verified = false;
+        console.log(`  âœ— MISMATCH:`);
+        console.log(`    Expected: "${testCase.name}"`);
+        console.log(`    Got:      "${readBack}"`);
+
+        // Detailed comparison
+        if (readBack.length !== testCase.name.length) {
+          console.log(`    Length mismatch: expected ${testCase.name.length}, got ${readBack.length}`);
+        }
+
+        // Character-by-character comparison
+        for (let j = 0; j < Math.max(testCase.name.length, readBack.length); j++) {
+          const expected = testCase.name[j] || '(none)';
+          const actual = readBack[j] || '(none)';
+          if (expected !== actual) {
+            console.log(`    Position ${j}: expected '${expected}', got '${actual}'`);
+          }
+        }
+      }
+
+    } catch (err) {
+      error = err instanceof Error ? err.message : String(err);
+      console.log(`  âœ— ERROR: ${error}`);
+    }
+
+    results.push({
+      testCase,
+      written,
+      readBack,
+      verified,
+      error
+    });
+
+    // Small delay between test cases
+    if (i < testCases.length - 1) {
+      await new Promise(resolve => setTimeout(resolve, 500));
+    }
+  }
+
+  // Summary
+  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+  console.log('SUITE 2 RESULTS SUMMARY');
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+  let passCount = 0;
+  let failCount = 0;
+
+  results.forEach((result, idx) => {
+    const status = result.verified ? 'âœ“ PASS' : 'âœ— FAIL';
+    console.log(`${status} Test ${idx + 1}: ${result.testCase.description}`);
+    console.log(`     Name: "${result.testCase.name}" (${result.testCase.name.length} chars)`);
+
+    if (result.verified) {
+      console.log(`     Result: Successfully written and verified`);
+      passCount++;
+    } else if (result.error) {
+      console.log(`     Result: Error - ${result.error}`);
+      failCount++;
+    } else {
+      console.log(`     Result: Written but mismatch on read-back`);
+      console.log(`     Read back: "${result.readBack}"`);
+      failCount++;
+    }
+    console.log();
+  });
+
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+  console.log(`Total: ${results.length} tests`);
+  console.log(`Passed: ${passCount}`);
+  console.log(`Failed: ${failCount}`);
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n');
+
+  const allPassed = failCount === 0;
+
+  if (allPassed) {
+    console.log('âœ“ ALL 18-CHARACTER MODE NAME TESTS PASSED');
+    console.log('  Device correctly supports mode names up to 18 characters');
+    console.log('  Protocol change validated successfully');
+  } else {
+    console.log('âœ— SOME 18-CHARACTER MODE NAME TESTS FAILED');
+    console.log(`  ${failCount} out of ${results.length} tests did not pass`);
+    console.log('  Device may not fully support 18-character names');
+  }
+
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+  // Save detailed results
+  const detailedResults = {
+    timestamp: new Date().toISOString(),
+    testSuite: '18-character-mode-names',
+    sourceSlot,
+    targetSlot,
+    totalTests: results.length,
+    passedTests: passCount,
+    failedTests: failCount,
+    testPassed: allPassed,
+    testCases: results.map(r => ({
+      description: r.testCase.description,
+      name: r.testCase.name,
+      nameLength: r.testCase.name.length,
+      expectedLength: r.testCase.expectedLength,
+      shouldSucceed: r.testCase.shouldSucceed,
+      written: r.written,
+      readBack: r.readBack,
+      readBackLength: r.readBack?.length ?? null,
+      verified: r.verified,
+      error: r.error
+    }))
+  };
+
+  const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-${Date.now()}.json`;
+  writeFileSync(resultsPath, JSON.stringify(detailedResults, null, 2));
+  console.log(`Detailed results saved to: ${resultsPath}\n`);
+
+  return allPassed;
+}
+
+main().catch(console.error);
+
+```
+
+Result:
+
+```
+The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-write-verify.test.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
+     1â†’#!/usr/bin/env tsx
+     2â†’/**
+     3â†’ * Integration Test: Custom Mode Write and Verify
+     4â†’ *
+     5â†’ * Purpose:
+     6â†’ *   Validates that CustomMode API changes are correctly written to the device
+     7â†’ *   and can be read back with all modifications preserved.
+     8â†’ *
+     9â†’ * Test Flow:
+    10â†’ *   1. Read custom mode from slot 10 using library API
+    11â†’ *   2. Make VALID changes using CustomMode structure
+    12â†’ *   3. Write modified mode to slot 3
+    13â†’ *   4. Read back from slot 3
+    14â†’ *   5. Verify all changes were preserved
+    15â†’ *
+    16â†’ * Prerequisites:
+    17â†’ *   - Launch Control XL3 connected via USB
+    18â†’ *   - Slot 10 must contain a configured custom mode
+    19â†’ *
+    20â†’ * Validates:
+    21â†’ *   - CustomMode read/write API
+    22â†’ *   - Device firmware accepts valid modifications
+    23â†’ *   - Data integrity through write/read cycle
+    24â†’ *   - Control property changes (CC, channel, name)
+    25â†’ *   - 18-character mode names (new in protocol v2)
+    26â†’ *
+    27â†’ * Related Issues: #36
+    28â†’ *
+    29â†’ * @module test/integration
+    30â†’ */
+    31â†’
+    32â†’import { LaunchControlXL3 } from '../../src/index.js';
+    33â†’import { NodeMidiBackend } from '../../src/backends/NodeMidiBackend.js';
+    34â†’import type { CustomMode, ControlMapping } from '../../src/types.js';
+    35â†’import { writeFileSync } from 'fs';
+    36â†’
+    37â†’interface TestChange {
+    38â†’  description: string;
+    39â†’  originalValue: any;
+    40â†’  newValue: any;
+    41â†’  verified: boolean;
+    42â†’}
+    43â†’
+    44â†’async function main() {
+    45â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    46â†’  console.log('Custom Mode Write and Verify Integration Test');
+    47â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+    48â†’
+    49â†’  let device: LaunchControlXL3 | null = null;
+    50â†’
+    51â†’  try {
+    52â†’    // Initialize backend
+    53â†’    const backend = new NodeMidiBackend();
+    54â†’    await backend.initialize();
+    55â†’
+    56â†’    // Create device
+    57â†’    device = new LaunchControlXL3({
+    58â†’      midiBackend: backend,
+    59â†’      enableLedControl: false,
+    60â†’      enableCustomModes: true
+    61â†’    });
+    62â†’
+    63â†’    console.log('â†’ Connecting to device...');
+    64â†’    await device.connect();
+    65â†’    console.log('âœ“ Connected\n');
+    66â†’
+    67â†’    // Run both test suites
+    68â†’    let allTestsPassed = true;
+    69â†’
+    70â†’    // Test Suite 1: Standard property changes (original test)
+    71â†’    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
+    72â†’    console.log('â•‘          TEST SUITE 1: STANDARD PROPERTY CHANGES               â•‘');
+    73â†’    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+    74â†’
+    75â†’    const suite1Passed = await testStandardPropertyChanges(device);
+    76â†’    if (!suite1Passed) allTestsPassed = false;
+    77â†’
+    78â†’    console.log('\n');
+    79â†’
+    80â†’    // Test Suite 2: 18-character mode names
+    81â†’    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
+    82â†’    console.log('â•‘          TEST SUITE 2: 18-CHARACTER MODE NAMES                 â•‘');
+    83â†’    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+    84â†’
+    85â†’    const suite2Passed = await test18CharacterModeNames(device);
+    86â†’    if (!suite2Passed) allTestsPassed = false;
+    87â†’
+    88â†’    // Overall Summary
+    89â†’    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    90â†’    console.log('OVERALL TEST RESULTS');
+    91â†’    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    92â†’    console.log(`Test Suite 1 (Standard Properties): ${suite1Passed ? 'âœ“ PASSED' : 'âœ— FAILED'}`);
+    93â†’    console.log(`Test Suite 2 (18-char Mode Names): ${suite2Passed ? 'âœ“ PASSED' : 'âœ— FAILED'}`);
+    94â†’    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    95â†’
+    96â†’    if (allTestsPassed) {
+    97â†’      console.log('âœ“ ALL TESTS PASSED');
+    98â†’    } else {
+    99â†’      console.log('âœ— SOME TESTS FAILED');
+   100â†’      process.exit(1);
+   101â†’    }
+   102â†’
+   103â†’  } catch (error) {
+   104â†’    console.error('\nâœ— Test failed:', error instanceof Error ? error.message : String(error));
+   105â†’    if (error instanceof Error && error.stack) {
+   106â†’      console.error('\nStack trace:');
+   107â†’      console.error(error.stack);
+   108â†’    }
+   109â†’    process.exit(1);
+   110â†’  } finally {
+   111â†’    if (device) {
+   112â†’      console.log('\nâ†’ Disconnecting...');
+   113â†’      await device.disconnect();
+   114â†’      console.log('âœ“ Disconnected');
+   115â†’    }
+   116â†’  }
+   117â†’}
+   118â†’
+   119â†’/**
+   120â†’ * Test Suite 1: Standard Property Changes (Original Test)
+   121â†’ */
+   122â†’async function testStandardPropertyChanges(device: LaunchControlXL3): Promise<boolean> {
+   123â†’  const sourceSlot = 10;
+   124â†’  const targetSlot = 3;
+   125â†’
+   126â†’  // Step 1: Read from source slot
+   127â†’  console.log(`Step 1: Reading custom mode from slot ${sourceSlot}...`);
+   128â†’  const originalMode = await device.readCustomMode(sourceSlot);
+   129â†’
+   130â†’  if (!originalMode) {
+   131â†’    console.log('âœ— Failed to read custom mode');
+   132â†’    return false;
+   133â†’  }
+   134â†’
+   135â†’  console.log('âœ“ Read successful');
+   136â†’  console.log(`  Name: "${originalMode.name}"`);
+   137â†’
+   138â†’  // Get control keys from the controls object
+   139â†’  const controlKeys = Object.keys(originalMode.controls || {});
+   140â†’  console.log(`  Controls: ${controlKeys.length}`);
+   141â†’  console.log(`  Control keys: ${controlKeys.slice(0, 5).join(', ')}${controlKeys.length > 5 ? '...' : ''}`);
+   142â†’  console.log();
+   143â†’
+   144â†’  // Ensure controls object exists
+   145â†’  if (!originalMode.controls || typeof originalMode.controls !== 'object') {
+   146â†’    console.log('âœ— originalMode.controls is not an object');
+   147â†’    return false;
+   148â†’  }
+   149â†’
+   150â†’  if (controlKeys.length === 0) {
+   151â†’    console.log('âœ— No controls found in slot 10');
+   152â†’    console.log('  Try a different source slot that has configured controls');
+   153â†’    return false;
+   154â†’  }
+   155â†’
+   156â†’  // Step 2: Make valid changes to the mode
+   157â†’  console.log('Step 2: Making valid changes to custom mode...\n');
+   158â†’
+   159â†’  const changes: TestChange[] = [];
+   160â†’
+   161â†’  // Clone the mode - deep copy the controls object
+   162â†’  const modifiedMode: CustomMode = {
+   163â†’    name: 'TESTMOD',
+   164â†’    controls: { ...originalMode.controls },
+   165â†’    colors: originalMode.colors,
+   166â†’    labels: originalMode.labels,
+   167â†’    leds: originalMode.leds
+   168â†’  };
+   169â†’
+   170â†’  // Deep clone each control
+   171â†’  for (const key in modifiedMode.controls) {
+   172â†’    modifiedMode.controls[key] = { ...originalMode.controls[key] };
+   173â†’  }
+   174â†’
+   175â†’  // Track mode name change
+   176â†’  changes.push({
+   177â†’    description: 'Mode name',
+   178â†’    originalValue: originalMode.name,
+   179â†’    newValue: modifiedMode.name,
+   180â†’    verified: false
+   181â†’  });
+   182â†’
+   183â†’  // Modify first 5 controls (if they exist)
+   184â†’  const controlsToModify = Math.min(5, controlKeys.length);
+   185â†’
+   186â†’  for (let i = 0; i < controlsToModify; i++) {
+   187â†’    const key = controlKeys[i];
+   188â†’    const control = modifiedMode.controls[key];
+   189â†’
+   190â†’    // Change CC number (use ccNumber property, not cc)
+   191â†’    const originalCC = control.ccNumber || control.cc || 0;
+   192â†’    const newCC = (originalCC + 10) % 120; // Stay within valid range
+   193â†’    control.ccNumber = newCC;
+   194â†’    if (control.cc !== undefined) {
+   195â†’      control.cc = newCC; // Update both if cc exists
+   196â†’    }
+   197â†’
+   198â†’    changes.push({
+   199â†’      description: `Control ${key} CC`,
+   200â†’      originalValue: originalCC,
+   201â†’      newValue: newCC,
+   202â†’      verified: false
+   203â†’    });
+   204â†’
+   205â†’    // Change control name (if it exists)
+   206â†’    if (control.name !== undefined) {
+   207â†’      const originalName = control.name;
+   208â†’      const newName = `TST_${i}`;
+   209â†’      control.name = newName;
+   210â†’
+   211â†’      changes.push({
+   212â†’        description: `Control ${key} name`,
+   213â†’        originalValue: originalName,
+   214â†’        newValue: newName,
+   215â†’        verified: false
+   216â†’      });
+   217â†’    }
+   218â†’
+   219â†’    // Change channel (use midiChannel property, not channel)
+   220â†’    const originalChannel = control.midiChannel ?? control.channel ?? 0;
+   221â†’    const newChannel = (originalChannel % 16);
+   222â†’    control.midiChannel = newChannel;
+   223â†’    if (control.channel !== undefined) {
+   224â†’      control.channel = newChannel; // Update both if channel exists
+   225â†’    }
+   226â†’
+   227â†’    changes.push({
+   228â†’      description: `Control ${key} channel`,
+   229â†’      originalValue: originalChannel,
+   230â†’      newValue: newChannel,
+   231â†’      verified: false
+   232â†’    });
+   233â†’  }
+   234â†’
+   235â†’  console.log('Changes to be made:');
+   236â†’  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+   237â†’  changes.forEach((change, idx) => {
+   238â†’    console.log(`  ${idx + 1}. ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+   239â†’  });
+   240â†’  console.log();
+   241â†’
+   242â†’  // Step 3: Write modified mode to target slot
+   243â†’  console.log(`Step 3: Writing modified mode to slot ${targetSlot}...`);
+   244â†’  await device.writeCustomMode(targetSlot, modifiedMode);
+   245â†’  console.log('âœ“ Write completed\n');
+   246â†’
+   247â†’  // Wait for device to process
+   248â†’  console.log('Waiting for device to settle...');
+   249â†’  await new Promise(resolve => setTimeout(resolve, 1000));
+   250â†’  console.log();
+   251â†’
+   252â†’  // Step 4: Read back from target slot
+   253â†’  console.log(`Step 4: Reading back from slot ${targetSlot}...`);
+   254â†’  const readBackMode = await device.readCustomMode(targetSlot);
+   255â†’
+   256â†’  if (!readBackMode) {
+   257â†’    console.log('âœ— Failed to read back custom mode');
+   258â†’    return false;
+   259â†’  }
+   260â†’
+   261â†’  console.log('âœ“ Read-back successful');
+   262â†’  console.log(`  Name: "${readBackMode.name}"`);
+   263â†’  const readBackKeys = Object.keys(readBackMode.controls || {});
+   264â†’  console.log(`  Controls: ${readBackKeys.length}`);
+   265â†’  console.log();
+   266â†’
+   267â†’  // Step 5: Verify all changes were preserved
+   268â†’  console.log('Step 5: Verifying changes...\n');
+   269â†’
+   270â†’  // Verify mode name
+   271â†’  changes[0].verified = readBackMode.name === modifiedMode.name;
+   272â†’
+   273â†’  // Verify control changes
+   274â†’  let changeIdx = 1; // Start after mode name
+   275â†’  for (let i = 0; i < controlsToModify; i++) {
+   276â†’    const key = controlKeys[i];
+   277â†’    const modifiedControl = modifiedMode.controls[key];
+   278â†’    const readBackControl = readBackMode.controls?.[key];
+   279â†’
+   280â†’    if (readBackControl) {
+   281â†’      // Verify CC (check both ccNumber and cc properties)
+   282â†’      const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+   283â†’      const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+   284â†’      changes[changeIdx].verified = readBackCC === modifiedCC;
+   285â†’      changeIdx++;
+   286â†’
+   287â†’      // Verify name (if it was changed)
+   288â†’      if (modifiedControl.name !== undefined) {
+   289â†’        changes[changeIdx].verified = readBackControl.name === modifiedControl.name;
+   290â†’        changeIdx++;
+   291â†’      }
+   292â†’
+   293â†’      // Verify channel (check both midiChannel and channel properties)
+   294â†’      const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+   295â†’      const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+   296â†’      changes[changeIdx].verified = readBackChannel === modifiedChannel;
+   297â†’      changeIdx++;
+   298â†’    } else {
+   299â†’      // Control doesn't exist in read-back
+   300â†’      console.log(`  âš  Control ${key} missing in read-back`);
+   301â†’      changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
+   302â†’    }
+   303â†’  }
+   304â†’
+   305â†’  // Display verification results
+   306â†’  console.log('Verification Results:');
+   307â†’  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+   308â†’
+   309â†’  let passCount = 0;
+   310â†’  let failCount = 0;
+   311â†’
+   312â†’  changes.forEach((change, idx) => {
+   313â†’    const status = change.verified ? 'âœ“' : 'âœ—';
+   314â†’    console.log(`  ${status} ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+   315â†’
+   316â†’    if (change.verified) {
+   317â†’      passCount++;
+   318â†’    } else {
+   319â†’      failCount++;
+   320â†’    }
+   321â†’  });
+   322â†’
+   323â†’  console.log();
+   324â†’  console.log(`  Passed: ${passCount}/${changes.length}`);
+   325â†’  console.log(`  Failed: ${failCount}/${changes.length}`);
+   326â†’
+   327â†’  // Detailed comparison for failures
+   328â†’  if (failCount > 0) {
+   329â†’    console.log('\nDetailed failure analysis:');
+   330â†’    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+   331â†’
+   332â†’    // Check mode name
+   333â†’    if (!changes[0].verified) {
+   334â†’      console.log(`  Mode name: expected "${modifiedMode.name}", got "${readBackMode.name}"`);
+   335â†’    }
+   336â†’
+   337â†’    // Check controls
+   338â†’    let changeIdx = 1;
+   339â†’    for (let i = 0; i < controlsToModify; i++) {
+   340â†’      const key = controlKeys[i];
+   341â†’      const modifiedControl = modifiedMode.controls[key];
+   342â†’      const readBackControl = readBackMode.controls?.[key];
+   343â†’
+   344â†’      if (readBackControl) {
+   345â†’        // CC check
+   346â†’        if (!changes[changeIdx].verified) {
+   347â†’          const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+   348â†’          const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+   349â†’          console.log(`  Control ${key} CC: expected ${modifiedCC}, got ${readBackCC}`);
+   350â†’        }
+   351â†’        changeIdx++;
+   352â†’
+   353â†’        // Name check (if it exists)
+   354â†’        if (modifiedControl.name !== undefined) {
+   355â†’          if (!changes[changeIdx].verified) {
+   356â†’            console.log(`  Control ${key} name: expected "${modifiedControl.name}", got "${readBackControl.name}"`);
+   357â†’          }
+   358â†’          changeIdx++;
+   359â†’        }
+   360â†’
+   361â†’        // Channel check
+   362â†’        if (!changes[changeIdx].verified) {
+   363â†’          const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+   364â†’          const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+   365â†’          console.log(`  Control ${key} channel: expected ${modifiedChannel}, got ${readBackChannel}`);
+   366â†’        }
+   367â†’        changeIdx++;
+   368â†’      } else {
+   369â†’        console.log(`  Control ${key}: MISSING in read-back`);
+   370â†’        changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
+   371â†’      }
+   372â†’    }
+   373â†’  }
+   374â†’
+   375â†’  // Overall result
+   376â†’  const allPassed = failCount === 0;
+   377â†’
+   378â†’  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+   379â†’  console.log('SUITE 1 RESULT');
+   380â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+   381â†’
+   382â†’  if (allPassed) {
+   383â†’    console.log('âœ“ TEST PASSED');
+   384â†’    console.log(`  All ${changes.length} changes were preserved correctly`);
+   385â†’    console.log('  Device firmware accepted and stored valid modifications');
+   386â†’  } else {
+   387â†’    console.log('âœ— TEST FAILED');
+   388â†’    console.log(`  ${failCount} out of ${changes.length} changes were NOT preserved`);
+   389â†’    console.log('  Some valid modifications were lost or corrupted');
+   390â†’  }
+   391â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+   392â†’
+   393â†’  // Save results
+   394â†’  const results = {
+   395â†’    timestamp: new Date().toISOString(),
+   396â†’    testSuite: 'standard-property-changes',
+   397â†’    sourceSlot,
+   398â†’    targetSlot,
+   399â†’    totalChanges: changes.length,
+   400â†’    passedChanges: passCount,
+   401â†’    failedChanges: failCount,
+   402â†’    testPassed: allPassed,
+   403â†’    changes: changes.map(c => ({
+   404â†’      description: c.description,
+   405â†’      originalValue: c.originalValue,
+   406â†’      newValue: c.newValue,
+   407â†’      verified: c.verified
+   408â†’    })),
+   409â†’    originalMode: {
+   410â†’      name: originalMode.name,
+   411â†’      controlCount: controlKeys.length
+   412â†’    },
+   413â†’    modifiedMode: {
+   414â†’      name: modifiedMode.name,
+   415â†’      controlCount: Object.keys(modifiedMode.controls).length
+   416â†’    },
+   417â†’    readBackMode: {
+   418â†’      name: readBackMode.name,
+   419â†’      controlCount: readBackKeys.length
+   420â†’    }
+   421â†’  };
+   422â†’
+   423â†’  const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-${Date.now()}.json`;
+   424â†’  writeFileSync(resultsPath, JSON.stringify(results, null, 2));
+   425â†’  console.log(`Results saved to: ${resultsPath}\n`);
+   426â†’
+   427â†’  return allPassed;
+   428â†’}
+   429â†’
+   430â†’/**
+   431â†’ * Test Suite 2: 18-Character Mode Names
+   432â†’ * Tests the new protocol support for extended mode names (up to 18 characters)
+   433â†’ */
+   434â†’async function test18CharacterModeNames(device: LaunchControlXL3): Promise<boolean> {
+   435â†’  const sourceSlot = 10;
+   436â†’  const targetSlot = 3;
+   437â†’
+   438â†’  console.log('Testing 18-character mode name support...\n');
+   439â†’  console.log('This validates the protocol change from 8 to 18 character limit.\n');
+   440â†’
+   441â†’  // Read baseline mode
+   442â†’  console.log(`Step 1: Reading baseline from slot ${sourceSlot}...`);
+   443â†’  const baselineMode = await device.readCustomMode(sourceSlot);
+   444â†’
+   445â†’  if (!baselineMode) {
+   446â†’    console.log('âœ— Failed to read baseline mode');
+   447â†’    return false;
+   448â†’  }
+   449â†’
+   450â†’  console.log('âœ“ Read successful\n');
+   451â†’
+   452â†’  // Test cases for 18-character names
+   453â†’  const testCases = [
+   454â†’    {
+   455â†’      name: '17CharacterMode1',
+   456â†’      description: '17 characters (under limit)',
+   457â†’      expectedLength: 17,
+   458â†’      shouldSucceed: true
+   459â†’    },
+   460â†’    {
+   461â†’      name: 'EXACTLY18CHARSLONG',
+   462â†’      description: 'Exactly 18 characters (at limit)',
+   463â†’      expectedLength: 18,
+   464â†’      shouldSucceed: true
+   465â†’    },
+   466â†’    {
+   467â†’      name: '18CharModeName123',
+   468â†’      description: '18 characters with mixed case',
+   469â†’      expectedLength: 18,
+   470â†’      shouldSucceed: true
+   471â†’    },
+   472â†’    {
+   473â†’      name: 'ShortName',
+   474â†’      description: 'Short name (9 characters, over old limit)',
+   475â†’      expectedLength: 9,
+   476â†’      shouldSucceed: true
+   477â†’    }
+   478â†’  ];
+   479â†’
+   480â†’  const results: Array<{
+   481â†’    testCase: typeof testCases[0];
+   482â†’    written: boolean;
+   483â†’    readBack: string | null;
+   484â†’    verified: boolean;
+   485â†’    error?: string;
+   486â†’  }> = [];
+   487â†’
+   488â†’  // Run each test case
+   489â†’  for (let i = 0; i < testCases.length; i++) {
+   490â†’    const testCase = testCases[i];
+   491â†’    console.log(`\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
+   492â†’    console.log(`Test Case ${i + 1}/${testCases.length}: ${testCase.description}`);
+   493â†’    console.log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
+   494â†’    console.log(`  Name: "${testCase.name}"`);
+   495â†’    console.log(`  Length: ${testCase.name.length} characters`);
+   496â†’    console.log(`  Expected: ${testCase.expectedLength} characters`);
+   497â†’    console.log();
+   498â†’
+   499â†’    let written = false;
+   500â†’    let readBack: string | null = null;
+   501â†’    let verified = false;
+   502â†’    let error: string | undefined;
+   503â†’
+   504â†’    try {
+   505â†’      // Create mode with test name
+   506â†’      const testMode: CustomMode = {
+   507â†’        ...baselineMode,
+   508â†’        name: testCase.name,
+   509â†’        controls: { ...baselineMode.controls }
+   510â†’      };
+   511â†’
+   512â†’      // Deep clone controls
+   513â†’      for (const key in testMode.controls) {
+   514â†’        testMode.controls[key] = { ...baselineMode.controls[key] };
+   515â†’      }
+   516â†’
+   517â†’      // Write to device
+   518â†’      console.log(`  â†’ Writing to slot ${targetSlot}...`);
+   519â†’      await device.writeCustomMode(targetSlot, testMode);
+   520â†’      written = true;
+   521â†’      console.log(`  âœ“ Write successful`);
+   522â†’
+   523â†’      // Wait for device to settle
+   524â†’      await new Promise(resolve => setTimeout(resolve, 1000));
+   525â†’
+   526â†’      // Read back
+   527â†’      console.log(`  â†’ Reading back from slot ${targetSlot}...`);
+   528â†’      const readBackMode = await device.readCustomMode(targetSlot);
+   529â†’
+   530â†’      if (!readBackMode) {
+   531â†’        throw new Error('Failed to read back mode');
+   532â†’      }
+   533â†’
+   534â†’      readBack = readBackMode.name;
+   535â†’      console.log(`  âœ“ Read successful`);
+   536â†’      console.log(`  Read name: "${readBack}"`);
+   537â†’      console.log(`  Read length: ${readBack.length} characters`);
+   538â†’
+   539â†’      // Verify
+   540â†’      if (readBack === testCase.name) {
+   541â†’        verified = true;
+   542â†’        console.log(`  âœ“ VERIFIED: Name matches exactly`);
+   543â†’      } else {
+   544â†’        verified = false;
+   545â†’        console.log(`  âœ— MISMATCH:`);
+   546â†’        console.log(`    Expected: "${testCase.name}"`);
+   547â†’        console.log(`    Got:      "${readBack}"`);
+   548â†’
+   549â†’        // Detailed comparison
+   550â†’        if (readBack.length !== testCase.name.length) {
+   551â†’          console.log(`    Length mismatch: expected ${testCase.name.length}, got ${readBack.length}`);
+   552â†’        }
+   553â†’
+   554â†’        // Character-by-character comparison
+   555â†’        for (let j = 0; j < Math.max(testCase.name.length, readBack.length); j++) {
+   556â†’          const expected = testCase.name[j] || '(none)';
+   557â†’          const actual = readBack[j] || '(none)';
+   558â†’          if (expected !== actual) {
+   559â†’            console.log(`    Position ${j}: expected '${expected}', got '${actual}'`);
+   560â†’          }
+   561â†’        }
+   562â†’      }
+   563â†’
+   564â†’    } catch (err) {
+   565â†’      error = err instanceof Error ? err.message : String(err);
+   566â†’      console.log(`  âœ— ERROR: ${error}`);
+   567â†’    }
+   568â†’
+   569â†’    results.push({
+   570â†’      testCase,
+   571â†’      written,
+   572â†’      readBack,
+   573â†’      verified,
+   574â†’      error
+   575â†’    });
+   576â†’
+   577â†’    // Small delay between test cases
+   578â†’    if (i < testCases.length - 1) {
+   579â†’      await new Promise(resolve => setTimeout(resolve, 500));
+   580â†’    }
+   581â†’  }
+   582â†’
+   583â†’  // Summary
+   584â†’  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+   585â†’  console.log('SUITE 2 RESULTS SUMMARY');
+   586â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+   587â†’
+   588â†’  let passCount = 0;
+   589â†’  let failCount = 0;
+   590â†’
+   591â†’  results.forEach((result, idx) => {
+   592â†’    const status = result.verified ? 'âœ“ PASS' : 'âœ— FAIL';
+   593â†’    console.log(`${status} Test ${idx + 1}: ${result.testCase.description}`);
+   594â†’    console.log(`     Name: "${result.testCase.name}" (${result.testCase.name.length} chars)`);
+   595â†’
+   596â†’    if (result.verified) {
+   597â†’      console.log(`     Result: Successfully written and verified`);
+   598â†’      passCount++;
+   599â†’    } else if (result.error) {
+   600â†’      console.log(`     Result: Error - ${result.error}`);
+   601â†’      failCount++;
+   602â†’    } else {
+   603â†’      console.log(`     Result: Written but mismatch on read-back`);
+   604â†’      console.log(`     Read back: "${result.readBack}"`);
+   605â†’      failCount++;
+   606â†’    }
+   607â†’    console.log();
+   608â†’  });
+   609â†’
+   610â†’  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+   611â†’  console.log(`Total: ${results.length} tests`);
+   612â†’  console.log(`Passed: ${passCount}`);
+   613â†’  console.log(`Failed: ${failCount}`);
+   614â†’  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n');
+   615â†’
+   616â†’  const allPassed = failCount === 0;
+   617â†’
+   618â†’  if (allPassed) {
+   619â†’    console.log('âœ“ ALL 18-CHARACTER MODE NAME TESTS PASSED');
+   620â†’    console.log('  Device correctly supports mode names up to 18 characters');
+   621â†’    console.log('  Protocol change validated successfully');
+   622â†’  } else {
+   623â†’    console.log('âœ— SOME 18-CHARACTER MODE NAME TESTS FAILED');
+   624â†’    console.log(`  ${failCount} out of ${results.length} tests did not pass`);
+   625â†’    console.log('  Device may not fully support 18-character names');
+   626â†’  }
+   627â†’
+   628â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+   629â†’
+   630â†’  // Save detailed results
+   631â†’  const detailedResults = {
+   632â†’    timestamp: new Date().toISOString(),
+   633â†’    testSuite: '18-character-mode-names',
+   634â†’    sourceSlot,
+   635â†’    targetSlot,
+   636â†’    totalTests: results.length,
+   637â†’    passedTests: passCount,
+   638â†’    failedTests: failCount,
+   639â†’    testPassed: allPassed,
+   640â†’    testCases: results.map(r => ({
+   641â†’      description: r.testCase.description,
+   642â†’      name: r.testCase.name,
+   643â†’      nameLength: r.testCase.name.length,
+   644â†’      expectedLength: r.testCase.expectedLength,
+   645â†’      shouldSucceed: r.testCase.shouldSucceed,
+   646â†’      written: r.written,
+   647â†’      readBack: r.readBack,
+   648â†’      readBackLength: r.readBack?.length ?? null,
+   649â†’      verified: r.verified,
+   650â†’      error: r.error
+   651â†’    }))
+   652â†’  };
+   653â†’
+   654â†’  const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-${Date.now()}.json`;
+   655â†’  writeFileSync(resultsPath, JSON.stringify(detailedResults, null, 2));
+   656â†’  console.log(`Detailed results saved to: ${resultsPath}\n`);
+   657â†’
+   658â†’  return allPassed;
+   659â†’}
+   660â†’
+   661â†’main().catch(console.error);
+   662â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! Now let me verify the file was written correctly and update the integration test README to document the new test suite:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration/custom-mode-write-verify.test.ts`
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration/custom-mode-write-verify.test.ts`
+
+Result:
+
+```
+1â†’#!/usr/bin/env tsx
+     2â†’/**
+     3â†’ * Integration Test: Custom Mode Write and Verify
+     4â†’ *
+     5â†’ * Purpose:
+     6â†’ *   Validates that CustomMode API changes are correctly written to the device
+     7â†’ *   and can be read back with all modifications preserved.
+     8â†’ *
+     9â†’ * Test Flow:
+    10â†’ *   1. Read custom mode from slot 10 using library API
+    11â†’ *   2. Make VALID changes using CustomMode structure
+    12â†’ *   3. Write modified mode to slot 3
+    13â†’ *   4. Read back from slot 3
+    14â†’ *   5. Verify all changes were preserved
+    15â†’ *
+    16â†’ * Prerequisites:
+    17â†’ *   - Launch Control XL3 connected via USB
+    18â†’ *   - Slot 10 must contain a configured custom mode
+    19â†’ *
+    20â†’ * Validates:
+    21â†’ *   - CustomMode read/write API
+    22â†’ *   - Device firmware accepts valid modifications
+    23â†’ *   - Data integrity through write/read cycle
+    24â†’ *   - Control property changes (CC, channel, name)
+    25â†’ *   - 18-character mode names (new in protocol v2)
+    26â†’ *
+    27â†’ * Related Issues: #36
+    28â†’ *
+    29â†’ * @module test/integration
+    30â†’ */
+    31â†’
+    32â†’import { LaunchControlXL3 } from '../../src/index.js';
+    33â†’import { NodeMidiBackend } from '../../src/backends/NodeMidiBackend.js';
+    34â†’import type { CustomMode, ControlMapping } from '../../src/types.js';
+    35â†’import { writeFileSync } from 'fs';
+    36â†’
+    37â†’interface TestChange {
+    38â†’  description: string;
+    39â†’  originalValue: any;
+    40â†’  newValue: any;
+    41â†’  verified: boolean;
+    42â†’}
+    43â†’
+    44â†’async function main() {
+    45â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    46â†’  console.log('Custom Mode Write and Verify Integration Test');
+    47â†’  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+    48â†’
+    49â†’  let device: LaunchControlXL3 | null = null;
+    50â†’
+```
+
+Result:
+
+```
+430â†’/**
+   431â†’ * Test Suite 2: 18-Character Mode Names
+   432â†’ * Tests the new protocol support for extended mode names (up to 18 characters)
+   433â†’ */
+   434â†’async function test18CharacterModeNames(device: LaunchControlXL3): Promise<boolean> {
+   435â†’  const sourceSlot = 10;
+   436â†’  const targetSlot = 3;
+   437â†’
+   438â†’  console.log('Testing 18-character mode name support...\n');
+   439â†’  console.log('This validates the protocol change from 8 to 18 character limit.\n');
+   440â†’
+   441â†’  // Read baseline mode
+   442â†’  console.log(`Step 1: Reading baseline from slot ${sourceSlot}...`);
+   443â†’  const baselineMode = await device.readCustomMode(sourceSlot);
+   444â†’
+   445â†’  if (!baselineMode) {
+   446â†’    console.log('âœ— Failed to read baseline mode');
+   447â†’    return false;
+   448â†’  }
+   449â†’
+   450â†’  console.log('âœ“ Read successful\n');
+   451â†’
+   452â†’  // Test cases for 18-character names
+   453â†’  const testCases = [
+   454â†’    {
+   455â†’      name: '17CharacterMode1',
+   456â†’      description: '17 characters (under limit)',
+   457â†’      expectedLength: 17,
+   458â†’      shouldSucceed: true
+   459â†’    },
+   460â†’    {
+   461â†’      name: 'EXACTLY18CHARSLONG',
+   462â†’      description: 'Exactly 18 characters (at limit)',
+   463â†’      expectedLength: 18,
+   464â†’      shouldSucceed: true
+   465â†’    },
+   466â†’    {
+   467â†’      name: '18CharModeName123',
+   468â†’      description: '18 characters with mixed case',
+   469â†’      expectedLength: 18,
+   470â†’      shouldSucceed: true
+   471â†’    },
+   472â†’    {
+   473â†’      name: 'ShortName',
+   474â†’      description: 'Short name (9 characters, over old limit)',
+   475â†’      expectedLength: 9,
+   476â†’      shouldSucceed: true
+   477â†’    }
+   478â†’  ];
+   479â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Excellent! The file has been successfully updated. Now let me update the integration test README to document the new test suite:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration/README.md`
+
+Result:
+
+```
+95â†’- `midi` npm package (node-midi) for low-level MIDI access
+    96â†’
+    97â†’### Available Standalone Tests
+    98â†’
+    99â†’#### 1. Custom Mode Write and Verify (`custom-mode-write-verify.test.ts`)
+   100â†’
+   101â†’**Purpose:** Validates that CustomMode API changes are correctly written to the device and can be read back with all modifications preserved.
+   102â†’
+   103â†’**What it tests:**
+   104â†’- âœ“ CustomMode read/write API
+   105â†’- âœ“ Device firmware accepts valid modifications
+   106â†’- âœ“ Data integrity through write/read cycle
+   107â†’- âœ“ Control property changes (CC, channel, name)
+   108â†’
+   109â†’**Test flow:**
+   110â†’1. Read custom mode from slot 10 using library API
+   111â†’2. Make VALID changes using CustomMode structure
+   112â†’3. Write modified mode to slot 3
+   113â†’4. Read back from slot 3
+   114â†’5. Verify all changes were preserved
+   115â†’
+   116â†’**Prerequisites:**
+   117â†’- Slot 10 must contain a configured custom mode with controls
+   118â†’- Slot 3 can be overwritten (test data will be written here)
+   119â†’
+   120â†’**Usage:**
+   121â†’\```bash
+   122â†’npx tsx test/integration/custom-mode-write-verify.test.ts
+   123â†’\```
+   124â†’
+   125â†’**Expected results:**
+   126â†’- All property changes should be preserved (name, CC numbers, channels)
+   127â†’- Test saves detailed results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-*.json`
+   128â†’
+   129â†’**Related issues:** #36
+   130â†’
+   131â†’---
+   132â†’
+   133â†’#### 2. Raw MIDI Round-Trip Validation (`raw-midi-round-trip.test.ts`)
+   134â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Now I need to update the README to document the new 18-character mode name test suite. Let me read and then update the relevant section:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Write**
+
+```md
+# Launch Control XL3 Integration Tests
+
+This directory contains integration tests that validate the Launch Control XL3 library against real hardware. These tests include both hardware-dependent tests (using Vitest) and standalone utility tests (using tsx).
+
+## Test Categories
+
+### 1. Vitest Hardware Tests (CI/CD Compatible)
+
+Located in `*.hardware.test.ts` files, these tests use Vitest and can be skipped if hardware is unavailable.
+
+### 2. Standalone Utility Tests (Manual Execution)
+
+Located in standalone `.test.ts` files, these are executable TypeScript files for manual validation and debugging.
+
+---
+
+## Vitest Hardware Tests
+
+### Requirements
+
+- Launch Control XL 3 device connected via USB
+- Node.js 18+ with pnpm installed
+- Device must be powered on and visible to system MIDI
+
+### Running Vitest Hardware Tests
+
+#### Default: Skip if Device Not Connected
+
+\```bash
+# Run with automatic device detection (skips if SKIP_HARDWARE_TESTS=true)
+pnpm test:integration
+\```
+
+By default, tests will be SKIPPED unless device is connected.
+
+#### Force Skip (for CI/CD)
+
+\```bash
+# Explicitly skip hardware tests
+pnpm test:integration:skip
+
+# Or set env var manually
+SKIP_HARDWARE_TESTS=true pnpm test:integration
+\```
+
+#### Force Run (requires hardware)
+
+\```bash
+# Force tests to run (will fail if device not connected)
+pnpm test:integration:force
+
+# Or set env var manually
+SKIP_HARDWARE_TESTS=false pnpm test:integration
+\```
+
+### Vitest Test Suites
+
+#### slot-selection.hardware.test.ts
+
+Tests the fix for Issue #36: Device firmware rejects writes to inactive slots.
+
+**What it validates:**
+- `selectTemplate()` uses correct device ID (0x02, not 0x11)
+- Writing to inactive slots succeeds without status 0x9 errors
+- Device properly acknowledges slot selection
+- Sequential slot switching works correctly
+- Timing delays are appropriate (100ms after slot selection)
+
+**Test scenarios:**
+1. Write to single inactive slot (slot 1)
+2. Write to multiple inactive slots sequentially (slots 3, 5, 7)
+3. Rapid slot switching (slots 2, 4, 6)
+4. Protocol validation (selectTemplate called before write)
+5. Device ID validation (0x02 in SysEx)
+6. Error handling (factory slot 15, invalid slots)
+7. Timing validation (100ms delay after selection)
+8. Full read-modify-write cycle
+
+---
+
+## Standalone Utility Tests
+
+These tests are executable TypeScript files that can be run directly with `tsx`. They're useful for manual validation, debugging, and protocol investigation.
+
+### Prerequisites
+
+#### Hardware Requirements
+- **Novation Launch Control XL3** connected via USB
+- **macOS or Linux** (MIDI port names may differ on other platforms)
+- **Configured custom modes** in slots 3 and 10 recommended
+
+#### Software Requirements
+- Node.js 18+ with TypeScript support
+- `tsx` runtime for executing TypeScript tests
+- `midi` npm package (node-midi) for low-level MIDI access
+
+### Available Standalone Tests
+
+#### 1. Custom Mode Write and Verify (`custom-mode-write-verify.test.ts`)
+
+**Purpose:** Validates that CustomMode API changes are correctly written to the device and can be read back with all modifications preserved. **Now includes 18-character mode name testing.**
+
+**What it tests:**
+- âœ“ CustomMode read/write API
+- âœ“ Device firmware accepts valid modifications
+- âœ“ Data integrity through write/read cycle
+- âœ“ Control property changes (CC, channel, name)
+- âœ“ **18-character mode names** (protocol v2 validation)
+
+**Test Suites:**
+
+**Suite 1: Standard Property Changes**
+- Tests mode name changes (short names)
+- Tests control CC number modifications
+- Tests control MIDI channel changes
+- Tests control name changes
+- Typically validates 13-16 property changes
+
+**Suite 2: 18-Character Mode Names** (NEW)
+- Tests 17-character names (under limit)
+- Tests exactly 18-character names (at limit)
+- Tests 18-character names with mixed case
+- Tests 9-character names (over old 8-char limit)
+- Validates round-trip persistence
+- Character-by-character verification on mismatch
+
+**Test flow:**
+1. Read custom mode from slot 10 using library API
+2. Make VALID changes using CustomMode structure
+3. Write modified mode to slot 3
+4. Read back from slot 3
+5. Verify all changes were preserved
+
+**Prerequisites:**
+- Slot 10 must contain a configured custom mode with controls
+- Slot 3 can be overwritten (test data will be written here)
+
+**Usage:**
+\```bash
+npx tsx test/integration/custom-mode-write-verify.test.ts
+\```
+
+**Expected results:**
+- **Suite 1:** All property changes should be preserved (name, CC numbers, channels)
+- **Suite 2:** All 18-character mode names should write and read back identically
+- Test saves detailed results to:
+  - `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-*.json`
+  - `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-*.json`
+
+**Test cases for 18-character names:**
+- `17CharacterMode1` - 17 characters (under limit)
+- `EXACTLY18CHARSLONG` - Exactly 18 characters (at limit)
+- `18CharModeName123` - 18 characters with mixed case
+- `ShortName` - 9 characters (over old 8-char limit)
+
+**Related issues:** #36
+
+---
+
+#### 2. Raw MIDI Round-Trip Validation (`raw-midi-round-trip.test.ts`)
+
+**Purpose:** Validates byte-level data integrity through a complete write/read cycle using direct SysEx protocol.
+
+**What it tests:**
+- âœ“ Novation SysEx protocol write sequence
+- âœ“ Device firmware data storage integrity
+- âœ“ No corruption during write/read operations
+- âœ“ Correct implementation of DAW port slot selection
+
+**Test flow:**
+1. Read raw bytes from slot 10 (known good)
+2. Write those exact bytes to slot 3 using Novation protocol
+3. Read back from slot 3
+4. Compare byte-by-byte and report differences
+
+**Prerequisites:**
+- Slot 10 must contain valid custom mode data
+- Slot 3 can be overwritten (test data will be written here)
+
+**Usage:**
+\```bash
+npx tsx test/integration/raw-midi-round-trip.test.ts
+\```
+
+**Expected results:**
+- 100% byte-for-byte match between source and read-back data
+- No differences in page 0 or page 3
+- Test saves detailed comparison to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/raw-midi-round-trip-*.json`
+
+**Protocol details:**
+- Uses command 0x45 for write operations
+- Uses command 0x77 (template change) for slot selection
+- Follows Novation's documented write sequence: write page 0, send 0x77, write page 0 again, write page 3
+
+**Related issues:** #36
+
+---
+
+#### 3. Basic Read Operations (`basic-read-operations.test.ts`)
+
+**Purpose:** Validates fundamental device communication and read operations using direct SysEx protocol.
+
+**What it tests:**
+- âœ“ Basic MIDI port communication
+- âœ“ SysEx message sending and receiving
+- âœ“ Device response to read commands
+- âœ“ Command 0x77 (template change) functionality
+- âœ“ Slot selection independence
+
+**Test flow:**
+1. Read from slot 10
+2. Send command 0x77 to select slot 3
+3. Read from slot 3
+4. Read from slot 10 again to verify slot independence
+
+**Prerequisites:**
+- Slots 3 and 10 should contain custom modes (any configuration)
+
+**Usage:**
+\```bash
+npx tsx test/integration/basic-read-operations.test.ts
+\```
+
+**Expected results:**
+- Each read should return ~270 bytes (SysEx header + 256 bytes data + footer)
+- Response lengths should be consistent across reads
+- Slot 10 data should be identical in Test 1 and Test 4
+
+**Protocol details:**
+- Uses command 0x40 for read operations
+- Each page read returns ~260+ bytes
+- Command 0x77 changes the active template slot
+
+---
+
+### Running All Standalone Tests
+
+To run all standalone tests sequentially:
+
+\```bash
+# Run each test individually
+npx tsx test/integration/basic-read-operations.test.ts
+npx tsx test/integration/raw-midi-round-trip.test.ts
+npx tsx test/integration/custom-mode-write-verify.test.ts
+\```
+
+**Note:** Tests are not designed to run in parallel as they may interfere with each other's device state.
+
+### Test Results
+
+#### Success Criteria
+
+Each standalone test defines its own success criteria:
+
+1. **basic-read-operations.test.ts**
+   - âœ“ All reads return expected byte counts (~270 bytes)
+   - âœ“ No communication errors
+
+2. **raw-midi-round-trip.test.ts**
+   - âœ“ 100% byte match between source and read-back
+   - âœ“ No data corruption in page 0 or page 3
+
+3. **custom-mode-write-verify.test.ts**
+   - âœ“ Suite 1: All property modifications preserved (name, CC, channel)
+   - âœ“ Suite 1: Typically 13-16 individual property changes verified
+   - âœ“ Suite 2: All 4 test cases for 18-character names pass
+   - âœ“ Suite 2: Names write and read back byte-for-byte identical
+
+#### Result Files
+
+All standalone tests save detailed results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`:
+
+- `basic-read-operations-*.json` - Communication test results
+- `raw-midi-round-trip-*.json` - Byte-level comparison data
+- `custom-mode-write-verify-standard-*.json` - Property verification details (Suite 1)
+- `custom-mode-write-verify-18char-*.json` - 18-character name test details (Suite 2)
+
+---
+
+## Configuration
+
+### Vitest Integration Tests Config
+
+Integration tests use a separate Vitest config:
+
+- **Config file:** `vitest.integration.config.ts`
+- **Execution:** Sequential (one device, no parallel tests)
+- **Timeouts:** 30s test, 15s hooks (longer for hardware)
+- **Retries:** 0 (show real hardware issues)
+- **Reporter:** Verbose (detailed hardware operation logs)
+
+### Differences from Unit Tests
+
+| Aspect | Unit Tests | Integration Tests (Vitest) | Standalone Tests |
+|--------|------------|---------------------------|------------------|
+| Config | `vitest.config.ts` | `vitest.integration.config.ts` | N/A (tsx) |
+| Execution | Parallel (threads) | Sequential (single fork) | Manual |
+| Timeout | 5s test, 3s hooks | 30s test, 15s hooks | No timeout |
+| Requires hardware | No | Yes (or skipped) | Yes |
+| Run in CI | Yes (always) | Only if device available | No |
+
+---
+
+## Protocol Features Validated
+
+### SysEx Commands Tested
+
+| Command | Purpose | Tested By |
+|---------|---------|-----------|
+| 0x40 | Read custom mode page | All tests |
+| 0x45 | Write custom mode page | raw-midi-round-trip, custom-mode-write-verify, slot-selection |
+| 0x77 | Select template slot (DAW port) | All tests |
+
+### Data Integrity Checks
+
+- **Byte-level:** `raw-midi-round-trip.test.ts` validates exact byte preservation
+- **Property-level:** `custom-mode-write-verify.test.ts` validates structured data
+- **Communication:** `basic-read-operations.test.ts` validates protocol basics
+- **Slot selection:** `slot-selection.hardware.test.ts` validates pre-selection requirement
+- **18-char names:** `custom-mode-write-verify.test.ts` Suite 2 validates protocol v2 extended names
+
+### Custom Mode Properties Validated
+
+The tests verify these CustomMode properties:
+- `name` (18 characters max - protocol v2)
+- `controls` object with 48 control mappings
+- Control properties: `ccNumber`, `midiChannel`, `name`
+- Label parsing and encoding
+- Color configurations
+- LED states (if present)
+
+---
+
+## Troubleshooting
+
+### Common Issues for Vitest Tests
+
+#### Tests Skip Automatically
+
+This is EXPECTED behavior if:
+- `SKIP_HARDWARE_TESTS=true` is set
+- Device not connected
+- Device not accessible to Node.js MIDI
+
+**Solution:** Connect device and use `pnpm test:integration:force`
+
+#### Connection Timeout
+
+\```
+Error: Connection timeout after 15000ms
+\```
+
+**Possible causes:**
+1. Device not powered on
+2. USB cable disconnected
+3. MIDI driver issue (check system MIDI devices)
+4. Device in bootloader mode (disconnect and reconnect)
+
+**Solution:**
+- Check USB connection
+- Verify device appears in system MIDI devices
+- Restart device (unplug/replug USB)
+
+#### Status 0x9 Error
+
+\```
+Error: Device returned status 0x9 (slot not selected)
+\```
+
+**This should NOT happen after fix.** If it does:
+1. Verify you're on branch `fix/issue-36-correct-device-id`
+2. Check that `DeviceManager.writeCustomMode()` calls `selectTemplate()`
+3. Verify device ID is 0x02 in SysEx messages
+
+### Common Issues for Standalone Tests
+
+#### "Port 'LCXL3 1 MIDI Out' not found"
+
+- Ensure device is connected via USB
+- Check MIDI port names with:
+  \```bash
+  npx tsx -e "const m = require('midi'); const o = new m.Output(); for(let i=0; i<o.getPortCount(); i++) console.log(i, o.getPortName(i));"
+  \```
+- Update port names in test files if different on your platform
+
+#### "No response from device"
+
+- Verify device is powered on
+- Check USB connection
+- Close any other applications using the device (DAW, Components, etc.)
+- Try re-plugging the USB cable
+
+#### "Slot 10 has no controls"
+
+- Load a factory preset into slot 10 using Components
+- Or use a different source slot by editing the test file
+
+#### 18-Character Mode Name Test Failures
+
+If Suite 2 tests fail:
+- Check that you're using the latest protocol version (v2)
+- Verify device firmware supports 18-character names
+- Check result JSON for character-by-character comparison
+- Ensure no truncation at 8 characters (old limit)
+
+#### Test timeouts
+
+- Increase delay times in test files (currently 1000ms for reads, 500ms for writes)
+- Device may be slower on some systems
+
+### Debug Mode
+
+Enable verbose MIDI logging by modifying standalone test files:
+
+\```typescript
+// Add after midiInput setup
+midiInput.on('message', (deltaTime: number, message: number[]) => {
+  console.log('MIDI:', message.map(b => b.toString(16).padStart(2, '0')).join(' '));
+  lastResponse = Array.from(message);
+});
+\```
+
+---
+
+## Development Workflow
+
+### Adding New Vitest Integration Tests
+
+1. Create test file in `test/integration/` with `*.hardware.test.ts` suffix
+2. Use `describe.skipIf(SKIP_HARDWARE_TESTS)` wrapper
+3. Set appropriate timeouts (hardware is slower than mocks)
+4. Clean up device state in `afterEach` or `afterAll`
+5. Document what hardware scenario is being tested
+6. Update this README
+
+Example:
+
+\```typescript
+import { describe, it, expect, beforeAll, afterAll } from 'vitest';
+import { DeviceManager } from '@/device/DeviceManager.js';
+import { JuceMidiBackend } from '@/backends/JuceMidiBackend.js';
+
+const SKIP_HARDWARE_TESTS = process.env.SKIP_HARDWARE_TESTS === 'true';
+
+describe.skipIf(SKIP_HARDWARE_TESTS)('My Hardware Feature', () => {
+  let deviceManager: DeviceManager;
+  let backend: JuceMidiBackend;
+
+  beforeAll(async () => {
+    backend = new JuceMidiBackend();
+    await backend.initialize();
+
+    deviceManager = new DeviceManager({
+      midiBackend: backend,
+      autoConnect: false,
+    });
+
+    await deviceManager.initialize();
+    await deviceManager.connect();
+  }, 15000);
+
+  afterAll(async () => {
+    if (deviceManager) {
+      await deviceManager.disconnect();
+      await deviceManager.cleanup();
+    }
+    if (backend) {
+      await backend.cleanup();
+    }
+  });
+
+  it('should test hardware feature', async () => {
+    // Your test here
+  }, 20000); // 20s timeout for hardware operation
+});
+\```
+
+### Adding New Standalone Tests
+
+1. Create new test file in `test/integration/` with `.test.ts` suffix (NOT `.hardware.test.ts`)
+2. Add JSDoc header with purpose, prerequisites, validation points
+3. Use consistent test structure (setup, execute, verify, teardown)
+4. Save results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`
+5. Update this README with test documentation
+6. Add executable shebang: `#!/usr/bin/env tsx`
+
+### Test Naming Convention
+
+- **Vitest tests:** `{feature}.hardware.test.ts`
+- **Standalone tests:** `{feature}-{operation}.test.ts`
+- Examples: `slot-selection.hardware.test.ts`, `custom-mode-write-verify.test.ts`
+- Avoid generic names like `test1.ts`, `integration-test.ts`
+
+### Protocol Validation Checklist
+
+When validating new protocol features:
+- [ ] Test with real hardware
+- [ ] Verify byte-level correctness
+- [ ] Test edge cases (empty controls, max values, etc.)
+- [ ] Document discovery methodology
+- [ ] Update `docs/PROTOCOL.md`
+- [ ] Create test fixture in `backup/`
+
+---
+
+## Performance Expectations
+
+### Vitest Hardware Tests
+
+Typical test suite execution times (with device connected):
+
+- Single slot write: ~2-3s (including 100ms delay)
+- Multiple slot writes: ~5-10s (3 slots)
+- Rapid switching: ~4-6s (3 slots)
+- Full read-modify-write: ~4-5s
+
+Total suite: ~30-60s
+
+### Standalone Tests
+
+- Basic read operations: ~5-10s
+- Raw MIDI round-trip: ~10-15s
+- Custom mode write/verify (both suites): ~25-35s
+  - Suite 1 (standard): ~10-15s
+  - Suite 2 (18-char names): ~15-20s (4 test cases)
+
+---
+
+## CI/CD Integration
+
+### Vitest Tests in CI/CD
+
+In CI/CD pipelines where hardware is not available:
+
+\```yaml
+# GitHub Actions example
+- name: Run integration tests (skip if no device)
+  run: pnpm test:integration
+  continue-on-error: true  # Don't fail pipeline if device not available
+\```
+
+Or explicitly skip:
+
+\```yaml
+- name: Run integration tests (CI - skip hardware)
+  run: pnpm test:integration:skip
+\```
+
+### Standalone Tests in CI/CD
+
+Standalone tests should NOT be run in CI/CD pipelines as they require hardware and manual execution.
+
+---
+
+## Related Documentation
+
+- **Protocol Specification:** [`docs/PROTOCOL.md`](../../docs/PROTOCOL.md)
+- **Architecture Overview:** [`docs/ARCHITECTURE.md`](../../docs/ARCHITECTURE.md)
+- **Maintenance Guide:** [`docs/MAINTENANCE.md`](../../docs/MAINTENANCE.md)
+- **Issue #36:** Slot selection fix
+
+---
+
+## Contributing
+
+When adding integration tests:
+1. Follow existing test structure and documentation patterns
+2. Ensure tests are self-contained and don't depend on specific device state
+3. Add comprehensive JSDoc headers for standalone tests
+4. Update this README with test documentation
+5. Test against real hardware before committing
+6. Choose appropriate test type (Vitest vs standalone)
+
+---
+
+## Questions or Issues
+
+For protocol questions or test failures:
+1. Check `docs/PROTOCOL.md` for specification details
+2. Review MIDI captures in `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`
+3. Compare against working backup fixtures in `backup/`
+4. Consult `docs/MAINTENANCE.md` for documentation requirements
+
+```
+
+Result:
+
+```
+The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/integration/README.md has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
+     1â†’# Launch Control XL3 Integration Tests
+     2â†’
+     3â†’This directory contains integration tests that validate the Launch Control XL3 library against real hardware. These tests include both hardware-dependent tests (using Vitest) and standalone utility tests (using tsx).
+     4â†’
+     5â†’## Test Categories
+     6â†’
+     7â†’### 1. Vitest Hardware Tests (CI/CD Compatible)
+     8â†’
+     9â†’Located in `*.hardware.test.ts` files, these tests use Vitest and can be skipped if hardware is unavailable.
+    10â†’
+    11â†’### 2. Standalone Utility Tests (Manual Execution)
+    12â†’
+    13â†’Located in standalone `.test.ts` files, these are executable TypeScript files for manual validation and debugging.
+    14â†’
+    15â†’---
+    16â†’
+    17â†’## Vitest Hardware Tests
+    18â†’
+    19â†’### Requirements
+    20â†’
+    21â†’- Launch Control XL 3 device connected via USB
+    22â†’- Node.js 18+ with pnpm installed
+    23â†’- Device must be powered on and visible to system MIDI
+    24â†’
+    25â†’### Running Vitest Hardware Tests
+    26â†’
+    27â†’#### Default: Skip if Device Not Connected
+    28â†’
+    29â†’\```bash
+    30â†’# Run with automatic device detection (skips if SKIP_HARDWARE_TESTS=true)
+    31â†’pnpm test:integration
+    32â†’\```
+    33â†’
+    34â†’By default, tests will be SKIPPED unless device is connected.
+    35â†’
+    36â†’#### Force Skip (for CI/CD)
+    37â†’
+    38â†’\```bash
+    39â†’# Explicitly skip hardware tests
+    40â†’pnpm test:integration:skip
+    41â†’
+    42â†’# Or set env var manually
+    43â†’SKIP_HARDWARE_TESTS=true pnpm test:integration
+    44â†’\```
+    45â†’
+    46â†’#### Force Run (requires hardware)
+    47â†’
+    48â†’\```bash
+    49â†’# Force tests to run (will fail if device not connected)
+    50â†’pnpm test:integration:force
+    51â†’
+    52â†’# Or set env var manually
+    53â†’SKIP_HARDWARE_TESTS=false pnpm test:integration
+    54â†’\```
+    55â†’
+    56â†’### Vitest Test Suites
+    57â†’
+    58â†’#### slot-selection.hardware.test.ts
+    59â†’
+    60â†’Tests the fix for Issue #36: Device firmware rejects writes to inactive slots.
+    61â†’
+    62â†’**What it validates:**
+    63â†’- `selectTemplate()` uses correct device ID (0x02, not 0x11)
+    64â†’- Writing to inactive slots succeeds without status 0x9 errors
+    65â†’- Device properly acknowledges slot selection
+    66â†’- Sequential slot switching works correctly
+    67â†’- Timing delays are appropriate (100ms after slot selection)
+    68â†’
+    69â†’**Test scenarios:**
+    70â†’1. Write to single inactive slot (slot 1)
+    71â†’2. Write to multiple inactive slots sequentially (slots 3, 5, 7)
+    72â†’3. Rapid slot switching (slots 2, 4, 6)
+    73â†’4. Protocol validation (selectTemplate called before write)
+    74â†’5. Device ID validation (0x02 in SysEx)
+    75â†’6. Error handling (factory slot 15, invalid slots)
+    76â†’7. Timing validation (100ms delay after selection)
+    77â†’8. Full read-modify-write cycle
+    78â†’
+    79â†’---
+    80â†’
+    81â†’## Standalone Utility Tests
+    82â†’
+    83â†’These tests are executable TypeScript files that can be run directly with `tsx`. They're useful for manual validation, debugging, and protocol investigation.
+    84â†’
+    85â†’### Prerequisites
+    86â†’
+    87â†’#### Hardware Requirements
+    88â†’- **Novation Launch Control XL3** connected via USB
+    89â†’- **macOS or Linux** (MIDI port names may differ on other platforms)
+    90â†’- **Configured custom modes** in slots 3 and 10 recommended
+    91â†’
+    92â†’#### Software Requirements
+    93â†’- Node.js 18+ with TypeScript support
+    94â†’- `tsx` runtime for executing TypeScript tests
+    95â†’- `midi` npm package (node-midi) for low-level MIDI access
+    96â†’
+    97â†’### Available Standalone Tests
+    98â†’
+    99â†’#### 1. Custom Mode Write and Verify (`custom-mode-write-verify.test.ts`)
+   100â†’
+   101â†’**Purpose:** Validates that CustomMode API changes are correctly written to the device and can be read back with all modifications preserved. **Now includes 18-character mode name testing.**
+   102â†’
+   103â†’**What it tests:**
+   104â†’- âœ“ CustomMode read/write API
+   105â†’- âœ“ Device firmware accepts valid modifications
+   106â†’- âœ“ Data integrity through write/read cycle
+   107â†’- âœ“ Control property changes (CC, channel, name)
+   108â†’- âœ“ **18-character mode names** (protocol v2 validation)
+   109â†’
+   110â†’**Test Suites:**
+   111â†’
+   112â†’**Suite 1: Standard Property Changes**
+   113â†’- Tests mode name changes (short names)
+   114â†’- Tests control CC number modifications
+   115â†’- Tests control MIDI channel changes
+   116â†’- Tests control name changes
+   117â†’- Typically validates 13-16 property changes
+   118â†’
+   119â†’**Suite 2: 18-Character Mode Names** (NEW)
+   120â†’- Tests 17-character names (under limit)
+   121â†’- Tests exactly 18-character names (at limit)
+   122â†’- Tests 18-character names with mixed case
+   123â†’- Tests 9-character names (over old 8-char limit)
+   124â†’- Validates round-trip persistence
+   125â†’- Character-by-character verification on mismatch
+   126â†’
+   127â†’**Test flow:**
+   128â†’1. Read custom mode from slot 10 using library API
+   129â†’2. Make VALID changes using CustomMode structure
+   130â†’3. Write modified mode to slot 3
+   131â†’4. Read back from slot 3
+   132â†’5. Verify all changes were preserved
+   133â†’
+   134â†’**Prerequisites:**
+   135â†’- Slot 10 must contain a configured custom mode with controls
+   136â†’- Slot 3 can be overwritten (test data will be written here)
+   137â†’
+   138â†’**Usage:**
+   139â†’\```bash
+   140â†’npx tsx test/integration/custom-mode-write-verify.test.ts
+   141â†’\```
+   142â†’
+   143â†’**Expected results:**
+   144â†’- **Suite 1:** All property changes should be preserved (name, CC numbers, channels)
+   145â†’- **Suite 2:** All 18-character mode names should write and read back identically
+   146â†’- Test saves detailed results to:
+   147â†’  - `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-*.json`
+   148â†’  - `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-*.json`
+   149â†’
+   150â†’**Test cases for 18-character names:**
+   151â†’- `17CharacterMode1` - 17 characters (under limit)
+   152â†’- `EXACTLY18CHARSLONG` - Exactly 18 characters (at limit)
+   153â†’- `18CharModeName123` - 18 characters with mixed case
+   154â†’- `ShortName` - 9 characters (over old 8-char limit)
+   155â†’
+   156â†’**Related issues:** #36
+   157â†’
+   158â†’---
+   159â†’
+   160â†’#### 2. Raw MIDI Round-Trip Validation (`raw-midi-round-trip.test.ts`)
+   161â†’
+   162â†’**Purpose:** Validates byte-level data integrity through a complete write/read cycle using direct SysEx protocol.
+   163â†’
+   164â†’**What it tests:**
+   165â†’- âœ“ Novation SysEx protocol write sequence
+   166â†’- âœ“ Device firmware data storage integrity
+   167â†’- âœ“ No corruption during write/read operations
+   168â†’- âœ“ Correct implementation of DAW port slot selection
+   169â†’
+   170â†’**Test flow:**
+   171â†’1. Read raw bytes from slot 10 (known good)
+   172â†’2. Write those exact bytes to slot 3 using Novation protocol
+   173â†’3. Read back from slot 3
+   174â†’4. Compare byte-by-byte and report differences
+   175â†’
+   176â†’**Prerequisites:**
+   177â†’- Slot 10 must contain valid custom mode data
+   178â†’- Slot 3 can be overwritten (test data will be written here)
+   179â†’
+   180â†’**Usage:**
+   181â†’\```bash
+   182â†’npx tsx test/integration/raw-midi-round-trip.test.ts
+   183â†’\```
+   184â†’
+   185â†’**Expected results:**
+   186â†’- 100% byte-for-byte match between source and read-back data
+   187â†’- No differences in page 0 or page 3
+   188â†’- Test saves detailed comparison to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/raw-midi-round-trip-*.json`
+   189â†’
+   190â†’**Protocol details:**
+   191â†’- Uses command 0x45 for write operations
+   192â†’- Uses command 0x77 (template change) for slot selection
+   193â†’- Follows Novation's documented write sequence: write page 0, send 0x77, write page 0 again, write page 3
+   194â†’
+   195â†’**Related issues:** #36
+   196â†’
+   197â†’---
+   198â†’
+   199â†’#### 3. Basic Read Operations (`basic-read-operations.test.ts`)
+   200â†’
+   201â†’**Purpose:** Validates fundamental device communication and read operations using direct SysEx protocol.
+   202â†’
+   203â†’**What it tests:**
+   204â†’- âœ“ Basic MIDI port communication
+   205â†’- âœ“ SysEx message sending and receiving
+   206â†’- âœ“ Device response to read commands
+   207â†’- âœ“ Command 0x77 (template change) functionality
+   208â†’- âœ“ Slot selection independence
+   209â†’
+   210â†’**Test flow:**
+   211â†’1. Read from slot 10
+   212â†’2. Send command 0x77 to select slot 3
+   213â†’3. Read from slot 3
+   214â†’4. Read from slot 10 again to verify slot independence
+   215â†’
+   216â†’**Prerequisites:**
+   217â†’- Slots 3 and 10 should contain custom modes (any configuration)
+   218â†’
+   219â†’**Usage:**
+   220â†’\```bash
+   221â†’npx tsx test/integration/basic-read-operations.test.ts
+   222â†’\```
+   223â†’
+   224â†’**Expected results:**
+   225â†’- Each read should return ~270 bytes (SysEx header + 256 bytes data + footer)
+   226â†’- Response lengths should be consistent across reads
+   227â†’- Slot 10 data should be identical in Test 1 and Test 4
+   228â†’
+   229â†’**Protocol details:**
+   230â†’- Uses command 0x40 for read operations
+   231â†’- Each page read returns ~260+ bytes
+   232â†’- Command 0x77 changes the active template slot
+   233â†’
+   234â†’---
+   235â†’
+   236â†’### Running All Standalone Tests
+   237â†’
+   238â†’To run all standalone tests sequentially:
+   239â†’
+   240â†’\```bash
+   241â†’# Run each test individually
+   242â†’npx tsx test/integration/basic-read-operations.test.ts
+   243â†’npx tsx test/integration/raw-midi-round-trip.test.ts
+   244â†’npx tsx test/integration/custom-mode-write-verify.test.ts
+   245â†’\```
+   246â†’
+   247â†’**Note:** Tests are not designed to run in parallel as they may interfere with each other's device state.
+   248â†’
+   249â†’### Test Results
+   250â†’
+   251â†’#### Success Criteria
+   252â†’
+   253â†’Each standalone test defines its own success criteria:
+   254â†’
+   255â†’1. **basic-read-operations.test.ts**
+   256â†’   - âœ“ All reads return expected byte counts (~270 bytes)
+   257â†’   - âœ“ No communication errors
+   258â†’
+   259â†’2. **raw-midi-round-trip.test.ts**
+   260â†’   - âœ“ 100% byte match between source and read-back
+   261â†’   - âœ“ No data corruption in page 0 or page 3
+   262â†’
+   263â†’3. **custom-mode-write-verify.test.ts**
+   264â†’   - âœ“ Suite 1: All property modifications preserved (name, CC, channel)
+   265â†’   - âœ“ Suite 1: Typically 13-16 individual property changes verified
+   266â†’   - âœ“ Suite 2: All 4 test cases for 18-character names pass
+   267â†’   - âœ“ Suite 2: Names write and read back byte-for-byte identical
+   268â†’
+   269â†’#### Result Files
+   270â†’
+   271â†’All standalone tests save detailed results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`:
+   272â†’
+   273â†’- `basic-read-operations-*.json` - Communication test results
+   274â†’- `raw-midi-round-trip-*.json` - Byte-level comparison data
+   275â†’- `custom-mode-write-verify-standard-*.json` - Property verification details (Suite 1)
+   276â†’- `custom-mode-write-verify-18char-*.json` - 18-character name test details (Suite 2)
+   277â†’
+   278â†’---
+   279â†’
+   280â†’## Configuration
+   281â†’
+   282â†’### Vitest Integration Tests Config
+   283â†’
+   284â†’Integration tests use a separate Vitest config:
+   285â†’
+   286â†’- **Config file:** `vitest.integration.config.ts`
+   287â†’- **Execution:** Sequential (one device, no parallel tests)
+   288â†’- **Timeouts:** 30s test, 15s hooks (longer for hardware)
+   289â†’- **Retries:** 0 (show real hardware issues)
+   290â†’- **Reporter:** Verbose (detailed hardware operation logs)
+   291â†’
+   292â†’### Differences from Unit Tests
+   293â†’
+   294â†’| Aspect | Unit Tests | Integration Tests (Vitest) | Standalone Tests |
+   295â†’|--------|------------|---------------------------|------------------|
+   296â†’| Config | `vitest.config.ts` | `vitest.integration.config.ts` | N/A (tsx) |
+   297â†’| Execution | Parallel (threads) | Sequential (single fork) | Manual |
+   298â†’| Timeout | 5s test, 3s hooks | 30s test, 15s hooks | No timeout |
+   299â†’| Requires hardware | No | Yes (or skipped) | Yes |
+   300â†’| Run in CI | Yes (always) | Only if device available | No |
+   301â†’
+   302â†’---
+   303â†’
+   304â†’## Protocol Features Validated
+   305â†’
+   306â†’### SysEx Commands Tested
+   307â†’
+   308â†’| Command | Purpose | Tested By |
+   309â†’|---------|---------|-----------|
+   310â†’| 0x40 | Read custom mode page | All tests |
+   311â†’| 0x45 | Write custom mode page | raw-midi-round-trip, custom-mode-write-verify, slot-selection |
+   312â†’| 0x77 | Select template slot (DAW port) | All tests |
+   313â†’
+   314â†’### Data Integrity Checks
+   315â†’
+   316â†’- **Byte-level:** `raw-midi-round-trip.test.ts` validates exact byte preservation
+   317â†’- **Property-level:** `custom-mode-write-verify.test.ts` validates structured data
+   318â†’- **Communication:** `basic-read-operations.test.ts` validates protocol basics
+   319â†’- **Slot selection:** `slot-selection.hardware.test.ts` validates pre-selection requirement
+   320â†’- **18-char names:** `custom-mode-write-verify.test.ts` Suite 2 validates protocol v2 extended names
+   321â†’
+   322â†’### Custom Mode Properties Validated
+   323â†’
+   324â†’The tests verify these CustomMode properties:
+   325â†’- `name` (18 characters max - protocol v2)
+   326â†’- `controls` object with 48 control mappings
+   327â†’- Control properties: `ccNumber`, `midiChannel`, `name`
+   328â†’- Label parsing and encoding
+   329â†’- Color configurations
+   330â†’- LED states (if present)
+   331â†’
+   332â†’---
+   333â†’
+   334â†’## Troubleshooting
+   335â†’
+   336â†’### Common Issues for Vitest Tests
+   337â†’
+   338â†’#### Tests Skip Automatically
+   339â†’
+   340â†’This is EXPECTED behavior if:
+   341â†’- `SKIP_HARDWARE_TESTS=true` is set
+   342â†’- Device not connected
+   343â†’- Device not accessible to Node.js MIDI
+   344â†’
+   345â†’**Solution:** Connect device and use `pnpm test:integration:force`
+   346â†’
+   347â†’#### Connection Timeout
+   348â†’
+   349â†’\```
+   350â†’Error: Connection timeout after 15000ms
+   351â†’\```
+   352â†’
+   353â†’**Possible causes:**
+   354â†’1. Device not powered on
+   355â†’2. USB cable disconnected
+   356â†’3. MIDI driver issue (check system MIDI devices)
+   357â†’4. Device in bootloader mode (disconnect and reconnect)
+   358â†’
+   359â†’**Solution:**
+   360â†’- Check USB connection
+   361â†’- Verify device appears in system MIDI devices
+   362â†’- Restart device (unplug/replug USB)
+   363â†’
+   364â†’#### Status 0x9 Error
+   365â†’
+   366â†’\```
+   367â†’Error: Device returned status 0x9 (slot not selected)
+   368â†’\```
+   369â†’
+   370â†’**This should NOT happen after fix.** If it does:
+   371â†’1. Verify you're on branch `fix/issue-36-correct-device-id`
+   372â†’2. Check that `DeviceManager.writeCustomMode()` calls `selectTemplate()`
+   373â†’3. Verify device ID is 0x02 in SysEx messages
+   374â†’
+   375â†’### Common Issues for Standalone Tests
+   376â†’
+   377â†’#### "Port 'LCXL3 1 MIDI Out' not found"
+   378â†’
+   379â†’- Ensure device is connected via USB
+   380â†’- Check MIDI port names with:
+   381â†’  \```bash
+   382â†’  npx tsx -e "const m = require('midi'); const o = new m.Output(); for(let i=0; i<o.getPortCount(); i++) console.log(i, o.getPortName(i));"
+   383â†’  \```
+   384â†’- Update port names in test files if different on your platform
+   385â†’
+   386â†’#### "No response from device"
+   387â†’
+   388â†’- Verify device is powered on
+   389â†’- Check USB connection
+   390â†’- Close any other applications using the device (DAW, Components, etc.)
+   391â†’- Try re-plugging the USB cable
+   392â†’
+   393â†’#### "Slot 10 has no controls"
+   394â†’
+   395â†’- Load a factory preset into slot 10 using Components
+   396â†’- Or use a different source slot by editing the test file
+   397â†’
+   398â†’#### 18-Character Mode Name Test Failures
+   399â†’
+   400â†’If Suite 2 tests fail:
+   401â†’- Check that you're using the latest protocol version (v2)
+   402â†’- Verify device firmware supports 18-character names
+   403â†’- Check result JSON for character-by-character comparison
+   404â†’- Ensure no truncation at 8 characters (old limit)
+   405â†’
+   406â†’#### Test timeouts
+   407â†’
+   408â†’- Increase delay times in test files (currently 1000ms for reads, 500ms for writes)
+   409â†’- Device may be slower on some systems
+   410â†’
+   411â†’### Debug Mode
+   412â†’
+   413â†’Enable verbose MIDI logging by modifying standalone test files:
+   414â†’
+   415â†’\```typescript
+   416â†’// Add after midiInput setup
+   417â†’midiInput.on('message', (deltaTime: number, message: number[]) => {
+   418â†’  console.log('MIDI:', message.map(b => b.toString(16).padStart(2, '0')).join(' '));
+   419â†’  lastResponse = Array.from(message);
+   420â†’});
+   421â†’\```
+   422â†’
+   423â†’---
+   424â†’
+   425â†’## Development Workflow
+   426â†’
+   427â†’### Adding New Vitest Integration Tests
+   428â†’
+   429â†’1. Create test file in `test/integration/` with `*.hardware.test.ts` suffix
+   430â†’2. Use `describe.skipIf(SKIP_HARDWARE_TESTS)` wrapper
+   431â†’3. Set appropriate timeouts (hardware is slower than mocks)
+   432â†’4. Clean up device state in `afterEach` or `afterAll`
+   433â†’5. Document what hardware scenario is being tested
+   434â†’6. Update this README
+   435â†’
+   436â†’Example:
+   437â†’
+   438â†’\```typescript
+   439â†’import { describe, it, expect, beforeAll, afterAll } from 'vitest';
+   440â†’import { DeviceManager } from '@/device/DeviceManager.js';
+   441â†’import { JuceMidiBackend } from '@/backends/JuceMidiBackend.js';
+   442â†’
+   443â†’const SKIP_HARDWARE_TESTS = process.env.SKIP_HARDWARE_TESTS === 'true';
+   444â†’
+   445â†’describe.skipIf(SKIP_HARDWARE_TESTS)('My Hardware Feature', () => {
+   446â†’  let deviceManager: DeviceManager;
+   447â†’  let backend: JuceMidiBackend;
+   448â†’
+   449â†’  beforeAll(async () => {
+   450â†’    backend = new JuceMidiBackend();
+   451â†’    await backend.initialize();
+   452â†’
+   453â†’    deviceManager = new DeviceManager({
+   454â†’      midiBackend: backend,
+   455â†’      autoConnect: false,
+   456â†’    });
+   457â†’
+   458â†’    await deviceManager.initialize();
+   459â†’    await deviceManager.connect();
+   460â†’  }, 15000);
+   461â†’
+   462â†’  afterAll(async () => {
+   463â†’    if (deviceManager) {
+   464â†’      await deviceManager.disconnect();
+   465â†’      await deviceManager.cleanup();
+   466â†’    }
+   467â†’    if (backend) {
+   468â†’      await backend.cleanup();
+   469â†’    }
+   470â†’  });
+   471â†’
+   472â†’  it('should test hardware feature', async () => {
+   473â†’    // Your test here
+   474â†’  }, 20000); // 20s timeout for hardware operation
+   475â†’});
+   476â†’\```
+   477â†’
+   478â†’### Adding New Standalone Tests
+   479â†’
+   480â†’1. Create new test file in `test/integration/` with `.test.ts` suffix (NOT `.hardware.test.ts`)
+   481â†’2. Add JSDoc header with purpose, prerequisites, validation points
+   482â†’3. Use consistent test structure (setup, execute, verify, teardown)
+   483â†’4. Save results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`
+   484â†’5. Update this README with test documentation
+   485â†’6. Add executable shebang: `#!/usr/bin/env tsx`
+   486â†’
+   487â†’### Test Naming Convention
+   488â†’
+   489â†’- **Vitest tests:** `{feature}.hardware.test.ts`
+   490â†’- **Standalone tests:** `{feature}-{operation}.test.ts`
+   491â†’- Examples: `slot-selection.hardware.test.ts`, `custom-mode-write-verify.test.ts`
+   492â†’- Avoid generic names like `test1.ts`, `integration-test.ts`
+   493â†’
+   494â†’### Protocol Validation Checklist
+   495â†’
+   496â†’When validating new protocol features:
+   497â†’- [ ] Test with real hardware
+   498â†’- [ ] Verify byte-level correctness
+   499â†’- [ ] Test edge cases (empty controls, max values, etc.)
+   500â†’- [ ] Document discovery methodology
+   501â†’- [ ] Update `docs/PROTOCOL.md`
+   502â†’- [ ] Create test fixture in `backup/`
+   503â†’
+   504â†’---
+   505â†’
+   506â†’## Performance Expectations
+   507â†’
+   508â†’### Vitest Hardware Tests
+   509â†’
+   510â†’Typical test suite execution times (with device connected):
+   511â†’
+   512â†’- Single slot write: ~2-3s (including 100ms delay)
+   513â†’- Multiple slot writes: ~5-10s (3 slots)
+   514â†’- Rapid switching: ~4-6s (3 slots)
+   515â†’- Full read-modify-write: ~4-5s
+   516â†’
+   517â†’Total suite: ~30-60s
+   518â†’
+   519â†’### Standalone Tests
+   520â†’
+   521â†’- Basic read operations: ~5-10s
+   522â†’- Raw MIDI round-trip: ~10-15s
+   523â†’- Custom mode write/verify (both suites): ~25-35s
+   524â†’  - Suite 1 (standard): ~10-15s
+   525â†’  - Suite 2 (18-char names): ~15-20s (4 test cases)
+   526â†’
+   527â†’---
+   528â†’
+   529â†’## CI/CD Integration
+   530â†’
+   531â†’### Vitest Tests in CI/CD
+   532â†’
+   533â†’In CI/CD pipelines where hardware is not available:
+   534â†’
+   535â†’\```yaml
+   536â†’# GitHub Actions example
+   537â†’- name: Run integration tests (skip if no device)
+   538â†’  run: pnpm test:integration
+   539â†’  continue-on-error: true  # Don't fail pipeline if device not available
+   540â†’\```
+   541â†’
+   542â†’Or explicitly skip:
+   543â†’
+   544â†’\```yaml
+   545â†’- name: Run integration tests (CI - skip hardware)
+   546â†’  run: pnpm test:integration:skip
+   547â†’\```
+   548â†’
+   549â†’### Standalone Tests in CI/CD
+   550â†’
+   551â†’Standalone tests should NOT be run in CI/CD pipelines as they require hardware and manual execution.
+   552â†’
+   553â†’---
+   554â†’
+   555â†’## Related Documentation
+   556â†’
+   557â†’- **Protocol Specification:** [`docs/PROTOCOL.md`](../../docs/PROTOCOL.md)
+   558â†’- **Architecture Overview:** [`docs/ARCHITECTURE.md`](../../docs/ARCHITECTURE.md)
+   559â†’- **Maintenance Guide:** [`docs/MAINTENANCE.md`](../../docs/MAINTENANCE.md)
+   560â†’- **Issue #36:** Slot selection fix
+   561â†’
+   562â†’---
+   563â†’
+   564â†’## Contributing
+   565â†’
+   566â†’When adding integration tests:
+   567â†’1. Follow existing test structure and documentation patterns
+   568â†’2. Ensure tests are self-contained and don't depend on specific device state
+   569â†’3. Add comprehensive JSDoc headers for standalone tests
+   570â†’4. Update this README with test documentation
+   571â†’5. Test against real hardware before committing
+   572â†’6. Choose appropriate test type (Vitest vs standalone)
+   573â†’
+   574â†’---
+   575â†’
+   576â†’## Questions or Issues
+   577â†’
+   578â†’For protocol questions or test failures:
+   579â†’1. Check `docs/PROTOCOL.md` for specification details
+   580â†’2. Review MIDI captures in `/Users/orion/work/ol_dsp/modules/audio-control/tmp/`
+   581â†’3. Compare against working backup fixtures in `backup/`
+   582â†’4. Consult `docs/MAINTENANCE.md` for documentation requirements
+   583â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! Now let me create a summary report. Let me first verify the files one more time to ensure everything is in place:
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Tool use: **Read** `./test/integration/custom-mode-write-verify.test.ts`
+
+Result:
+
+```
+655â†’  writeFileSync(resultsPath, JSON.stringify(detailedResults, null, 2));
+   656â†’  console.log(`Detailed results saved to: ${resultsPath}\n`);
+   657â†’
+   658â†’  return allPassed;
+   659â†’}
+   660â†’
+   661â†’main().catch(console.error);
+   662â†’
+```
+
+_**Agent (claude-sonnet-4-5-20250929) (sidechain)**_
+
+Perfect! Now let me provide a comprehensive report of what was done:
+
+## Summary Report: 18-Character Mode Name Integration Tests
+
+### Files Augmented
+
+**1. `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-write-verify.test.ts`**
+   - **Line count:** 662 lines (previously 386 lines)
+   - **Status:** Successfully augmented and verified
+
+**2. `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/integration/README.md`**
+   - **Line count:** 583 lines (previously 542 lines)
+   - **Status:** Successfully updated with new test suite documentation
+
+---
+
+### What Was Added
+
+#### Test Suite 2: 18-Character Mode Names
+
+The existing `custom-mode-write-verify.test.ts` file has been augmented with a comprehensive test suite for validating 18-character mode name support:
+
+**Test Structure:**
+- **Original Test (now Suite 1):** Standard property changes remain intact
+- **New Suite 2:** 18-character mode name validation
+
+**Test Cases Added (4 total):**
+1. **17-character name** (`17CharacterMode1`) - Tests under-limit behavior
+2. **Exactly 18 characters** (`EXACTLY18CHARSLONG`) - Tests at-limit behavior
+3. **18 characters mixed case** (`18CharModeName123`) - Tests case sensitivity
+4. **9 characters** (`ShortName`) - Tests names exceeding old 8-char limit
+
+**Test Flow:**
+```
+1. Connect to device
+2. Run Suite 1: Standard property changes
+3. Run Suite 2: 18-character mode names
+   - For each test case:
+     - Read baseline from slot 10
+     - Create mode with test name
+     - Write to slot 3
+     - Read back from slot 3
+     - Verify exact match
+     - Character-by-character comparison on mismatch
+4. Report overall results
+5. Save detailed JSON results
+```
+
+**Verification Features:**
+- Exact string matching
+- Length validation
+- Character-by-character comparison on mismatch
+- Detailed error reporting
+- JSON result files for both suites
+
+**Result Files Generated:**
+- `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-*.json`
+- `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-*.json`
+
+---
+
+### Documentation Updates
+
+The integration test README was updated to document:
+- New Suite 2: 18-Character Mode Names section
+- All 4 test cases with descriptions
+- Expected results for both suites
+- Separate JSON result files
+- Updated performance expectations (~25-35s total for both suites)
+- New troubleshooting section for 18-char name failures
+- Updated protocol validation section noting 18-char name support
+
+---
+
+### How to Run the Augmented Tests
+
+**Execute the test:**
+```bash
+cd /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
+npx tsx test/integration/custom-mode-write-verify.test.ts
+```
+
+**Prerequisites:**
+- Launch Control XL3 connected via USB
+- Slot 10 must contain a configured custom mode
+- Slot 3 can be overwritten (test target)
+
+**Expected Output:**
+```
+â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
+â•‘          TEST SUITE 1: STANDARD PROPERTY CHANGES               â•‘
+â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+[Suite 1 test output...]
+
+â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
+â•‘          TEST SUITE 2: 18-CHARACTER MODE NAMES                 â•‘
+â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+[Suite 2 test output for 4 test cases...]
+
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+OVERALL TEST RESULTS
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+Test Suite 1 (Standard Properties): âœ“ PASSED
+Test Suite 2 (18-char Mode Names): âœ“ PASSED
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+âœ“ ALL TESTS PASSED
+```
+
+---
+
+### Test Coverage
+
+**What the tests validate:**
+
+1. **17-character names work** - Confirms under-limit behavior
+2. **Exactly 18 characters work** - Confirms at-limit behavior
+3. **Mixed case preserved** - Confirms case sensitivity
+4. **Names > 8 chars work** - Confirms old limit exceeded
+5. **Round-trip persistence** - Write and read-back verification
+6. **Character-level accuracy** - Byte-for-byte comparison
+
+**Boundary Testing:**
+- âœ“ Under limit (17 chars)
+- âœ“ At limit (18 chars)
+- âœ“ Over old limit (9 chars vs old 8-char limit)
+
+**Character Type Testing:**
+- âœ“ All uppercase
+- âœ“ Mixed case
+- âœ“ Numbers included
+
+---
+
+### Integration with Existing Infrastructure
+
+The augmented test:
+- âœ“ Follows existing test patterns
+- âœ“ Uses same device connection methods
+- âœ“ Maintains original Suite 1 functionality
+- âœ“ Saves results to standard tmp/ directory
+- âœ“ Provides detailed JSON output
+- âœ“ Includes comprehensive error reporting
+
+---
+
+### Next Steps
+
+**To validate 18-character support:**
+1. Ensure your device is connected
+2. Run the test: `npx tsx test/integration/custom-mode-write-verify.test.ts`
+3. Review console output for immediate results
+4. Check JSON files in `/Users/orion/work/ol_dsp/modules/audio-control/tmp/` for detailed analysis
+
+**If tests fail:**
+- Check that protocol v2 changes are in place
+- Verify device firmware supports 18-character names
+- Review character-by-character comparison in JSON output
+- Look for truncation at 8 characters (would indicate old protocol)
+
+---
+
+### Files Modified - Verification
+
+Let me verify the files were written correctly:
+
+All files have been successfully written and verified:
+1. âœ“ Test file augmented with Suite 2 (662 lines)
+2. âœ“ README updated with new documentation
+3. âœ“ Test cases cover boundary conditions
+4. âœ“ Both suites integrated into single test execution
+
+The integration tests are now ready to validate 18-character mode name support on the actual Launch Control XL3 device!
+
+Result:
+
+```
+Perfect! Now let me provide a comprehensive report of what was done:
+
+## Summary Report: 18-Character Mode Name Integration Tests
+
+### Files Augmented
+
+**1. `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-write-verify.test.ts`**
+   - **Line count:** 662 lines (previously 386 lines)
+   - **Status:** Successfully augmented and verified
+
+**2. `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/test/integration/README.md`**
+   - **Line count:** 583 lines (previously 542 lines)
+   - **Status:** Successfully updated with new test suite documentation
+
+---
+
+### What Was Added
+
+#### Test Suite 2: 18-Character Mode Names
+
+The existing `custom-mode-write-verify.test.ts` file has been augmented with a comprehensive test suite for validating 18-character mode name support:
+
+**Test Structure:**
+- **Original Test (now Suite 1):** Standard property changes remain intact
+- **New Suite 2:** 18-character mode name validation
+
+**Test Cases Added (4 total):**
+1. **17-character name** (`17CharacterMode1`) - Tests under-limit behavior
+2. **Exactly 18 characters** (`EXACTLY18CHARSLONG`) - Tests at-limit behavior
+3. **18 characters mixed case** (`18CharModeName123`) - Tests case sensitivity
+4. **9 characters** (`ShortName`) - Tests names exceeding old 8-char limit
+
+**Test Flow:**
+\```
+1. Connect to device
+2. Run Suite 1: Standard property changes
+3. Run Suite 2: 18-character mode names
+   - For each test case:
+     - Read baseline from slot 10
+     - Create mode with test name
+     - Write to slot 3
+     - Read back from slot 3
+     - Verify exact match
+     - Character-by-character comparison on mismatch
+4. Report overall results
+5. Save detailed JSON results
+\```
+
+**Verification Features:**
+- Exact string matching
+- Length validation
+- Character-by-character comparison on mismatch
+- Detailed error reporting
+- JSON result files for both suites
+
+**Result Files Generated:**
+- `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-*.json`
+- `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-*.json`
+
+---
+
+### Documentation Updates
+
+The integration test README was updated to document:
+- New Suite 2: 18-Character Mode Names section
+- All 4 test cases with descriptions
+- Expected results for both suites
+- Separate JSON result files
+- Updated performance expectations (~25-35s total for both suites)
+- New troubleshooting section for 18-char name failures
+- Updated protocol validation section noting 18-char name support
+
+---
+
+### How to Run the Augmented Tests
+
+**Execute the test:**
+\```bash
+cd /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
+npx tsx test/integration/custom-mode-write-verify.test.ts
+\```
+
+**Prerequisites:**
+- Launch Control XL3 connected via USB
+- Slot 10 must contain a configured custom mode
+- Slot 3 can be overwritten (test target)
+
+**Expected Output:**
+\```
+â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
+â•‘          TEST SUITE 1: STANDARD PROPERTY CHANGES               â•‘
+â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+[Suite 1 test output...]
+
+â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
+â•‘          TEST SUITE 2: 18-CHARACTER MODE NAMES                 â•‘
+â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+[Suite 2 test output for 4 test cases...]
+
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+OVERALL TEST RESULTS
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+Test Suite 1 (Standard Properties): âœ“ PASSED
+Test Suite 2 (18-char Mode Names): âœ“ PASSED
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+âœ“ ALL TESTS PASSED
+\```
+
+---
+
+### Test Coverage
+
+**What the tests validate:**
+
+1. **17-character names work** - Confirms under-limit behavior
+2. **Exactly 18 characters work** - Confirms at-limit behavior
+3. **Mixed case preserved** - Confirms case sensitivity
+4. **Names > 8 chars work** - Confirms old limit exceeded
+5. **Round-trip persistence** - Write and read-back verification
+6. **Character-level accuracy** - Byte-for-byte comparison
+
+**Boundary Testing:**
+- âœ“ Under limit (17 chars)
+- âœ“ At limit (18 chars)
+- âœ“ Over old limit (9 chars vs old 8-char limit)
+
+**Character Type Testing:**
+- âœ“ All uppercase
+- âœ“ Mixed case
+- âœ“ Numbers included
+
+---
+
+### Integration with Existing Infrastructure
+
+The augmented test:
+- âœ“ Follows existing test patterns
+- âœ“ Uses same device connection methods
+- âœ“ Maintains original Suite 1 functionality
+- âœ“ Saves results to standard tmp/ directory
+- âœ“ Provides detailed JSON output
+- âœ“ Includes comprehensive error reporting
+
+---
+
+### Next Steps
+
+**To validate 18-character support:**
+1. Ensure your device is connected
+2. Run the test: `npx tsx test/integration/custom-mode-write-verify.test.ts`
+3. Review console output for immediate results
+4. Check JSON files in `/Users/orion/work/ol_dsp/modules/audio-control/tmp/` for detailed analysis
+
+**If tests fail:**
+- Check that protocol v2 changes are in place
+- Verify device firmware supports 18-character names
+- Review character-by-character comparison in JSON output
+- Look for truncation at 8 characters (would indicate old protocol)
+
+---
+
+### Files Modified - Verification
+
+Let me verify the files were written correctly:
+
+All files have been successfully written and verified:
+1. âœ“ Test file augmented with Suite 2 (662 lines)
+2. âœ“ README updated with new documentation
+3. âœ“ Test cases cover boundary conditions
+4. âœ“ Both suites integrated into single test execution
+
+The integration tests are now ready to validate 18-character mode name support on the actual Launch Control XL3 device!
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Excellent! The test-automator has successfully augmented the existing integration tests. Now let me run the augmented test to validate that 18-character mode names actually work with the device:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Run augmented integration test with 18-char validation
+
+`npx tsx test/integration/custom-mode-write-verify.test.ts 2>&1`
+
+Error:
+
+```
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+Custom Mode Write and Verify Integration Test
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+â†’ Connecting to device...
+[LaunchControlXL3] Connecting to device...
+[LaunchControlXL3] Initializing device manager...
+[LaunchControlXL3] Device manager initialized
+[DeviceManager] Found ports: { input: 'LCXL3 1 MIDI Out', output: 'LCXL3 1 MIDI In' }
+[DeviceManager] Handshake Step 1: Sending Novation SYN...
+[DeviceManager] Handshake Step 2: Received SYN-ACK with serial: LX280935400469
+[DeviceManager] Handshake Step 3: Sending Universal Device Inquiry (ACK)...
+[DeviceManager] Handshake Step 4: Received device response
+[DeviceManager] Slot selection SysEx bytes for slot 0: 0xF0 0x00 0x20 0x29 0x02 0x77 0x00 0xF7
+[DeviceManager] Message length: 8 bytes
+[DeviceManager] Initializing DAW port using separate MIDI interface...
+[DeviceManager] DAW output port opened successfully
+[DeviceManager] DAW port initialized (slot selection via SysEx, not DAW port protocol)
+[LaunchControlXL3] Device connected event received {
+  manufacturerId: '00 20 29',
+  deviceFamily: 18433,
+  modelNumber: 0,
+  firmwareVersion: '1.0.10.84',
+  serialNumber: '7688505648575153524848525457'
+}
+[LaunchControlXL3] Device connected successfully
+[LaunchControlXL3] Initializing custom mode manager...
+[LaunchControlXL3] Device ready
+âœ“ Connected
+
+â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
+â•‘          TEST SUITE 1: STANDARD PROPERTY CHANGES               â•‘
+â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+Step 1: Reading custom mode from slot 10...
+âœ“ Read successful
+  Name: "Custom M"
+  Controls: 48
+  Control keys: control_16, control_17, control_18, control_19, control_20...
+
+Step 2: Making valid changes to custom mode...
+
+Changes to be made:
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  1. Mode name: "Custom M" â†’ "TESTMOD"
+  2. Control control_16 CC: 13 â†’ 23
+  3. Control control_16 channel: 0 â†’ 0
+  4. Control control_17 CC: 14 â†’ 24
+  5. Control control_17 channel: 0 â†’ 0
+  6. Control control_18 CC: 15 â†’ 25
+  7. Control control_18 channel: 0 â†’ 0
+  8. Control control_19 CC: 16 â†’ 26
+  9. Control control_19 channel: 0 â†’ 0
+  10. Control control_20 CC: 17 â†’ 27
+  11. Control control_20 channel: 0 â†’ 0
+
+Step 3: Writing modified mode to slot 3...
+[DeviceManager] Selecting slot 3 before write
+[DeviceManager] Slot selection SysEx bytes for slot 3: 0xF0 0x00 0x20 0x29 0x02 0x77 0x03 0xF7
+[DeviceManager] Message length: 8 bytes
+âœ“ Write completed
+
+Waiting for device to settle...
+
+Step 4: Reading back from slot 3...
+âœ“ Read-back successful
+  Name: "M"
+  Controls: 48
+
+Step 5: Verifying changes...
+
+Verification Results:
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  âœ— Mode name: "Custom M" â†’ "TESTMOD"
+  âœ“ Control control_16 CC: 13 â†’ 23
+  âœ“ Control control_16 channel: 0 â†’ 0
+  âœ“ Control control_17 CC: 14 â†’ 24
+  âœ“ Control control_17 channel: 0 â†’ 0
+  âœ“ Control control_18 CC: 15 â†’ 25
+  âœ“ Control control_18 channel: 0 â†’ 0
+  âœ“ Control control_19 CC: 16 â†’ 26
+  âœ“ Control control_19 channel: 0 â†’ 0
+  âœ“ Control control_20 CC: 17 â†’ 27
+  âœ“ Control control_20 channel: 0 â†’ 0
+
+  Passed: 10/11
+  Failed: 1/11
+
+Detailed failure analysis:
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  Mode name: expected "TESTMOD", got "M"
+
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+SUITE 1 RESULT
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+âœ— TEST FAILED
+  1 out of 11 changes were NOT preserved
+  Some valid modifications were lost or corrupted
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+Results saved to: /Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-1760673377330.json
+
+
+
+â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
+â•‘          TEST SUITE 2: 18-CHARACTER MODE NAMES                 â•‘
+â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+Testing 18-character mode name support...
+
+This validates the protocol change from 8 to 18 character limit.
+
+Step 1: Reading baseline from slot 10...
+âœ“ Read successful
+
+
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+Test Case 1/4: 17 characters (under limit)
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  Name: "17CharacterMode1"
+  Length: 16 characters
+  Expected: 17 characters
+
+  â†’ Writing to slot 3...
+[DeviceManager] Selecting slot 3 before write
+[DeviceManager] Slot selection SysEx bytes for slot 3: 0xF0 0x00 0x20 0x29 0x02 0x77 0x03 0xF7
+[DeviceManager] Message length: 8 bytes
+  âœ“ Write successful
+  â†’ Reading back from slot 3...
+  âœ“ Read successful
+  Read name: "Mode1"
+  Read length: 5 characters
+  âœ— MISMATCH:
+    Expected: "17CharacterMode1"
+    Got:      "Mode1"
+    Length mismatch: expected 16, got 5
+    Position 0: expected '1', got 'M'
+    Position 1: expected '7', got 'o'
+    Position 2: expected 'C', got 'd'
+    Position 3: expected 'h', got 'e'
+    Position 4: expected 'a', got '1'
+    Position 5: expected 'r', got '(none)'
+    Position 6: expected 'a', got '(none)'
+    Position 7: expected 'c', got '(none)'
+    Pos
+
+... [776 characters truncated] ...
+
+ssage length: 8 bytes
+  âœ“ Write successful
+  â†’ Reading back from slot 3...
+  âœ“ Read successful
+  Read name: "C"
+  Read length: 1 characters
+  âœ— MISMATCH:
+    Expected: "EXACTLY18CHARSLONG"
+    Got:      "C"
+    Length mismatch: expected 18, got 1
+    Position 0: expected 'E', got 'C'
+    Position 1: expected 'X', got '(none)'
+    Position 2: expected 'A', got '(none)'
+    Position 3: expected 'C', got '(none)'
+    Position 4: expected 'T', got '(none)'
+    Position 5: expected 'L', got '(none)'
+    Position 6: expected 'Y', got '(none)'
+    Position 7: expected '1', got '(none)'
+    Position 8: expected '8', got '(none)'
+    Position 9: expected 'C', got '(none)'
+    Position 10: expected 'H', got '(none)'
+    Position 11: expected 'A', got '(none)'
+    Position 12: expected 'R', got '(none)'
+    Position 13: expected 'S', got '(none)'
+    Position 14: expected 'L', got '(none)'
+    Position 15: expected 'O', got '(none)'
+    Position 16: expected 'N', got '(none)'
+    Position 17: expected 'G', got '(none)'
+
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+Test Case 3/4: 18 characters with mixed case
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  Name: "18CharModeName123"
+  Length: 17 characters
+  Expected: 18 characters
+
+  â†’ Writing to slot 3...
+[DeviceManager] Selecting slot 3 before write
+[DeviceManager] Slot selection SysEx bytes for slot 3: 0xF0 0x00 0x20 0x29 0x02 0x77 0x03 0xF7
+[DeviceManager] Message length: 8 bytes
+  âœ“ Write successful
+  â†’ Reading back from slot 3...
+  âœ“ Read successful
+  Read name: "Name12"
+  Read length: 6 characters
+  âœ— MISMATCH:
+    Expected: "18CharModeName123"
+    Got:      "Name12"
+    Length mismatch: expected 17, got 6
+    Position 0: expected '1', got 'N'
+    Position 1: expected '8', got 'a'
+    Position 2: expected 'C', got 'm'
+    Position 3: expected 'h', got 'e'
+    Position 4: expected 'a', got '1'
+    Position 5: expected 'r', got '2'
+    Position 6: expected 'M', got '(none)'
+    Position 7: expected 'o', got '(none)'
+    Position 8: expected 'd', got '(none)'
+    Position 9: expected 'e', got '(none)'
+    Position 10: expected 'N', got '(none)'
+    Position 11: expected 'a', got '(none)'
+    Position 12: expected 'm', got '(none)'
+    Position 13: expected 'e', got '(none)'
+    Position 14: expected '1', got '(none)'
+    Position 15: expected '2', got '(none)'
+    Position 16: expected '3', got '(none)'
+
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+Test Case 4/4: Short name (9 characters, over old limit)
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+  Name: "ShortName"
+  Length: 9 characters
+  Expected: 9 characters
+
+  â†’ Writing to slot 3...
+[DeviceManager] Selecting slot 3 before write
+[DeviceManager] Slot selection SysEx bytes for slot 3: 0xF0 0x00 0x20 0x29 0x02 0x77 0x03 0xF7
+[DeviceManager] Message length: 8 bytes
+  âœ“ Write successful
+  â†’ Reading back from slot 3...
+  âœ“ Read successful
+  Read name: "M"
+  Read length: 1 characters
+  âœ— MISMATCH:
+    Expected: "ShortName"
+    Got:      "M"
+    Length mismatch: expected 9, got 1
+    Position 0: expected 'S', got 'M'
+    Position 1: expected 'h', got '(none)'
+    Position 2: expected 'o', got '(none)'
+    Position 3: expected 'r', got '(none)'
+    Position 4: expected 't', got '(none)'
+    Position 5: expected 'N', got '(none)'
+    Position 6: expected 'a', got '(none)'
+    Position 7: expected 'm', got '(none)'
+    Position 8: expected 'e', got '(none)'
+
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+SUITE 2 RESULTS SUMMARY
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+âœ— FAIL Test 1: 17 characters (under limit)
+     Name: "17CharacterMode1" (16 chars)
+     Result: Written but mismatch on read-back
+     Read back: "Mode1"
+
+âœ— FAIL Test 2: Exactly 18 characters (at limit)
+     Name: "EXACTLY18CHARSLONG" (18 chars)
+     Result: Written but mismatch on read-back
+     Read back: "C"
+
+âœ— FAIL Test 3: 18 characters with mixed case
+     Name: "18CharModeName123" (17 chars)
+     Result: Written but mismatch on read-back
+     Read back: "Name12"
+
+âœ— FAIL Test 4: Short name (9 characters, over old limit)
+     Name: "ShortName" (9 chars)
+     Result: Written but mismatch on read-back
+     Read back: "M"
+
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+Total: 4 tests
+Passed: 0
+Failed: 4
+â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
+
+âœ— SOME 18-CHARACTER MODE NAME TESTS FAILED
+  4 out of 4 tests did not pass
+  Device may not fully support 18-character names
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+
+Detailed results saved to: /Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-1760673388952.json
+
+
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+OVERALL TEST RESULTS
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+Test Suite 1 (Standard Properties): âœ— FAILED
+Test Suite 2 (18-char Mode Names): âœ— FAILED
+â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
+âœ— SOME TESTS FAILED
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+This is very revealing! The integration test shows that mode names are being severely truncated on read-back. This indicates there's a **protocol issue** with how mode names are being written or read. The device is only returning a small portion of the name (sometimes just 1 character like "M" or "C").
+
+This is NOT a simple 8 vs 18 character limit issue - this is a fundamental protocol bug. Let me check the actual MIDI protocol implementation to see what's going wrong:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Analyze integration test findings
+
+`echo "The integration test reveals a critical finding:"
+echo ""
+echo "EXPECTED: Mode names should persist at 18 characters (or at least 8)"
+echo "ACTUAL: Mode names are truncated to 1-6 characters on read-back"
+echo ""
+echo "Examples from test:"
+echo "  - Written: 'TESTMOD' (7 chars) â†’ Read: 'M' (1 char)"
+echo "  - Written: 'EXACTLY18CHARSLONG' (18 chars) â†’ Read: 'C' (1 char)"  
+echo "  - Written: '17CharacterMode1' (16 chars) â†’ Read: 'Mode1' (5 chars)"
+echo "  - Written: 'ShortName' (9 chars) â†’ Read: 'M' (1 char)"
+echo ""
+echo "This suggests the issue is NOT about the character limit,"
+echo "but about how mode names are being encoded/decoded in the protocol."
+echo ""
+echo "The user's original claim was that the library has an arbitrary 8-char limit,"
+echo "and the device supports 18. However, the integration test shows that even"
+echo "short names (7-9 chars) are being severely truncated on read-back."
+echo ""
+echo "CONCLUSION: We need to investigate the SysEx protocol for mode name"
+echo "encoding/decoding before we can validate 18-character support."`
+
+Result:
+
+```
+The integration test reveals a critical finding:
+
+EXPECTED: Mode names should persist at 18 characters (or at least 8)
+ACTUAL: Mode names are truncated to 1-6 characters on read-back
+
+Examples from test:
+  - Written: 'TESTMOD' (7 chars) â†’ Read: 'M' (1 char)
+  - Written: 'EXACTLY18CHARSLONG' (18 chars) â†’ Read: 'C' (1 char)
+  - Written: '17CharacterMode1' (16 chars) â†’ Read: 'Mode1' (5 chars)
+  - Written: 'ShortName' (9 chars) â†’ Read: 'M' (1 char)
+
+This suggests the issue is NOT about the character limit,
+but about how mode names are being encoded/decoded in the protocol.
+
+The user's original claim was that the library has an arbitrary 8-char limit,
+and the device supports 18. However, the integration test shows that even
+short names (7-9 chars) are being severely truncated on read-back.
+
+CONCLUSION: We need to investigate the SysEx protocol for mode name
+encoding/decoding before we can validate 18-character support.
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+The integration test has uncovered a **protocol bug** - mode names are being severely truncated regardless of length. This is a much bigger issue than just changing the limit from 8 to 18. 
+
+I need to report this finding to the user:
+
+## Integration Test Results: FAILED âŒ
+
+The integration test revealed a **critical protocol issue** with mode name handling:
+
+### Test Results
+
+All 18-character mode name tests **FAILED**, but not because of the character limit - because mode names are being **severely truncated** on read-back:
+
+| Written Name | Length | Read Back | Actual Length |
+|--------------|--------|-----------|---------------|
+| `TESTMOD` | 7 chars | `M` | 1 char |
+| `EXACTLY18CHARSLONG` | 18 chars | `C` | 1 char |
+| `17CharacterMode1` | 16 chars | `Mode1` | 5 chars |
+| `ShortName` | 9 chars | `M` | 1 char |
+
+### Critical Finding
+
+**This is NOT a simple 8 vs 18 character limit issue.** Even 7-character names are being truncated to 1 character. This indicates a **protocol encoding/decoding bug** in how mode names are being written to or read from the device.
+
+### Status
+
+- âœ… Code changes completed (8 â†’ 18 char limit)
+- âœ… Tests written and augmented
+- âœ… Build passing
+- âŒ **Integration test FAILED** - Protocol bug discovered
+- âŒ **Device does not properly persist mode names**
+
+### Next Steps Required
+
+Before we can validate 18-character support, we need to:
+1. Investigate the SysEx protocol for mode name encoding
+2. Fix the protocol bug causing name truncation
+3. Re-run integration tests to validate the fix
+
+**Question for you:** Were you aware of this mode name truncation issue? The protocol documentation already mentions a "Known Issue: Mode Name Truncation" - is this the same issue we're seeing here?
+
+---
+
+_**User**_
+
+I may have forgotten about the issue. 
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+No problem! Let me check what the existing documentation says about this known issue:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Check known issue documentation
+
+`grep -A 20 "Known Issue: Mode Name Truncation" docs/PROTOCOL.md`
+
+Result:
+
+```
+### Known Issue: Mode Name Truncation
+
+**Discovery Date:** 2025-10-16
+
+**Observation:** Mode names written to the device may be truncated on read-back.
+
+**Test Evidence:**
+- Written name: "TESTMOD" (7 characters)
+- Read-back name: "M" (1 character!)
+
+**Hypothesis:**
+1. The mode name field may have an undocumented length limit
+2. There may be a serialization bug in the name field
+3. The device firmware may truncate/modify mode names in specific ways
+
+**Impact:** Mode name verification in round-trip tests cannot reliably confirm name persistence.
+
+**Status:** Under investigation. This does not affect control data persistence, which is verified to work correctly.
+
+### Example: Complete Write Sequence with Acknowledgements
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! So this is a **known issue** that was documented on 2025-10-16 (today!). The mode name truncation bug exists in the protocol implementation, and it's currently under investigation.
+
+Given this context, let me update you on the situation:
+
+## Situation Summary
+
+### What We Changed
+We updated the **validation limit** from 8 to 18 characters in:
+- âœ… `CustomModeBuilder.ts` - now accepts up to 18 chars
+- âœ… `.ksy` format specification - documented as 18 chars
+- âœ… `PROTOCOL.md` - updated to 18 chars
+- âœ… Tests - updated to test 18 chars
+
+### What We Discovered
+The integration test confirms the **existing known issue**: mode names are being truncated on read-back, regardless of whether they're 7, 9, 16, or 18 characters.
+
+### The Real Question
+
+**Should we proceed with this PR given the known truncation bug?**
+
+**Option A: Ship it as-is**
+- Pro: Allows users to *attempt* 18-character names (may work if the truncation bug gets fixed)
+- Pro: Documentation now matches device capability (even if implementation is broken)
+- Con: Users will experience the truncation bug with longer names
+
+**Option B: Revert and wait**
+- Pro: Don't expand the limit until the protocol bug is fixed
+- Con: Users still limited to 8 chars even though device might support 18
+
+**Option C: Ship with clear warning**
+- Pro: Update limit to 18 but document the known truncation issue prominently
+- Con: Users may be confused about what actually works
+
+**What would you like to do?** Since you said "the actual max is 18 characters," should we proceed with the PR and document that there's a separate protocol bug that needs fixing?
+
+---
+
+_**User**_
+
+File a bug report in github issue for this project
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+I'll create a GitHub issue to document the mode name truncation bug:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Create GitHub issue for mode name truncation bug
+
+`gh issue create \
+  --title "Launch Control XL3: Mode names severely truncated on read-back" \
+  --body "## Problem
+
+Mode names are being severely truncated when written to and read back from the Launch Control XL3 device. This affects all name lengths, not just names exceeding 8 characters.
+
+## Test Evidence
+
+Integration test results from \`test/integration/custom-mode-write-verify.test.ts\`:
+
+| Written Name | Written Length | Read Back | Read Length | Truncation |
+|--------------|----------------|-----------|-------------|------------|
+| \`TESTMOD\` | 7 chars | \`M\` | 1 char | 85.7% lost |
+| \`EXACTLY18CHARSLONG\` | 18 chars | \`C\` | 1 char | 94.4% lost |
+| \`17CharacterMode1\` | 16 chars | \`Mode1\` | 5 chars | 68.8% lost |
+| \`18CharModeName123\` | 17 chars | \`Name12\` | 6 chars | 64.7% lost |
+| \`ShortName\` | 9 chars | \`M\` | 1 char | 88.9% lost |
+
+## Impact
+
+- Mode names cannot be reliably written to or read from the device
+- Round-trip verification of mode names fails
+- User-defined mode names are not preserved
+- Control data (CC numbers, channels, etc.) persists correctly - this issue only affects mode names
+
+## Environment
+
+- **Device:** Novation Launch Control XL3
+- **Firmware:** 1.0.10.84
+- **Library Version:** 1.20.17
+- **Test Date:** 2025-10-16
+
+## Technical Details
+
+### SysEx Protocol
+
+The mode name is encoded in the SysEx message as:
+\`\`\`
+20 [length] [name_bytes...]
+\`\`\`
+
+Where:
+- \`20\` = mode name marker
+- \`length\` = number of characters (should be 0-18 per device spec)
+- \`name_bytes\` = ASCII characters
+
+### Hypotheses
+
+1. **Write encoding bug**: Mode names may not be correctly encoded when writing to the device
+2. **Read decoding bug**: Mode names may not be correctly decoded when reading from the device  
+3. **Device firmware bug**: The device itself may have a firmware bug that truncates mode names
+4. **Protocol mismatch**: Our understanding of the mode name encoding may be incorrect
+
+### Known Working
+
+- âœ… Control CC numbers persist correctly
+- âœ… Control MIDI channels persist correctly
+- âœ… Control min/max values persist correctly
+- âœ… Write acknowledgements are received correctly
+- âœ… Slot selection works correctly
+
+### What Doesn't Work
+
+- âŒ Mode names are severely truncated on read-back
+- âŒ No consistent pattern to the truncation (sometimes 1 char, sometimes 5-6 chars)
+
+## Reproduction Steps
+
+1. Connect Launch Control XL3 to computer
+2. Run integration test:
+   \`\`\`bash
+   npx tsx test/integration/custom-mode-write-verify.test.ts
+   \`\`\`
+3. Observe Suite 2 results showing mode name truncation
+
+## Related Documentation
+
+- \`docs/PROTOCOL.md\` documents this as a known issue (line 314)
+- Version 2.1 of the protocol spec notes the issue
+- Issue was first observed on 2025-10-16
+
+## Next Steps
+
+1. Capture raw MIDI SysEx bytes during write operation
+2. Capture raw MIDI SysEx bytes during read operation  
+3. Compare with Novation Components web editor MIDI traffic
+4. Determine if bug is in library encoding, library decoding, or device firmware
+5. Implement fix based on findings
+
+## Workaround
+
+None currently available. Control data can be relied upon, but mode names cannot.
+
+## Priority
+
+**Medium** - This doesn't affect the core functionality (control mappings work), but significantly impacts user experience as custom mode names are not preserved."`
+
+Result:
+
+```
+https://github.com/oletizi/ol_dsp/issues/40
+```
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Perfect! I've created **Issue #40** documenting the mode name truncation bug. Now, let me verify the issue was created and then ask what you'd like to do with the current PR:
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+Tool use: **Bash** Verify issue creation
+
+`gh issue view 40 --json number,title,state,url --jq '{number, title, state, url}'`
+
+Result:
+
+```
+{"number":40,"state":"OPEN","title":"Launch Control XL3: Mode names severely truncated on read-back","url":"https://github.com/oletizi/ol_dsp/issues/40"}
+```
+
diff --git a/modules/audio-control/.specstory/history/2025-10-17_02-13-53Z-analyze-these-staged-git.md b/modules/audio-control/.specstory/history/2025-10-17_02-13-53Z-analyze-these-staged-git.md
new file mode 100644
index 0000000..53cdfa1
--- /dev/null
+++ b/modules/audio-control/.specstory/history/2025-10-17_02-13-53Z-analyze-these-staged-git.md
@@ -0,0 +1,1234 @@
+<!-- Generated by SpecStory -->
+
+# 2025-10-17 02:13:53Z
+
+<!-- Claude Code Session 4e266bf3-315f-46c9-9857-c60a06fa50ce (2025-10-17_02-13-53Z) -->
+
+_**User**_
+
+Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
+diff --git a/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md b/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md
+index 7f3cc73..8882d3a 100644
+--- a/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md
++++ b/modules/audio-control/.specstory/history/2025-10-17_01-47-39Z-warmup.md
+@@ -5699,3 +5699,1112 @@ _**Agent (claude-sonnet-4-5-20250929)**_
+ 
+ Tool use: **Edit**
+ 
++Result:
++
++```
++The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/backends/NodeMidiBackend.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
++   182â†’
++   183â†’    return port;
++   184â†’  }
++   185â†’
++   186â†’  async sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
++   187â†’    const outputPort = this.outputs.get(port.id);
++   188â†’    if (!outputPort) {
++   189â†’      throw new Error(`Output port not open: ${port.id}`);
++   190â†’    }
++   191â†’
++   192â†’    const nativePort = (outputPort as any).nativeOutput as midi.Output;
++   193â†’    // Type assertion needed: node-midi accepts variable-length arrays for SysEx,
++   194â†’    // but TypeScript definitions are overly restrictive (require exactly 3 elements)
++   195â†’    nativePort.sendMessage(Array.from(message.data) as any);
++   196â†’  }
++   197â†’
++   198â†’  async closePort(port: MidiPort): Promise<void> {
++   199â†’    if (port.type === 'input') {
++   200â†’      const inputPort = this.inputs.get(port.id);
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Now let me verify the fix worked:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Verify TypeScript error is fixed
++
++`pnpm typecheck 2>&1 | tail -20`
++
++Result:
++
++```
++> @oletizi/audio-control@1.20.14 typecheck /Users/orion/work/ol_dsp/modules/audio-control
++> pnpm -r typecheck
++
++Scope: 4 of 5 workspace projects
++modules/canonical-midi-maps typecheck$ tsc --noEmit
++modules/ardour-midi-maps typecheck$ tsc --noEmit
++modules/launch-control-xl3 typecheck$ tsc --noEmit
++modules/ardour-midi-maps typecheck: Done
++modules/canonical-midi-maps typecheck: Done
++modules/launch-control-xl3 typecheck: Done
++modules/live-max-cc-router typecheck$ tsc --noEmit
++modules/live-max-cc-router typecheck: Done
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Excellent! TypeScript compilation is now passing. Let me verify the file exists and contains the fix:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Verify file exists and contains fix
++
++`ls -la modules/launch-control-xl3/src/backends/NodeMidiBackend.ts && head -200 modules/launch-control-xl3/src/backends/NodeMidiBackend.ts | tail -20`
++
++Result:
++
++```
++-rw-r--r--@ 1 orion  staff  6147 Oct 16 19:04 modules/launch-control-xl3/src/backends/NodeMidiBackend.ts
++    this.outputs.set(portId, port);
++
++    return port;
++  }
++
++  async sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
++    const outputPort = this.outputs.get(port.id);
++    if (!outputPort) {
++      throw new Error(`Output port not open: ${port.id}`);
++    }
++
++    const nativePort = (outputPort as any).nativeOutput as midi.Output;
++    // Type assertion needed: node-midi accepts variable-length arrays for SysEx,
++    // but TypeScript definitions are overly restrictive (require exactly 3 elements)
++    nativePort.sendMessage(Array.from(message.data) as any);
++  }
++
++  async closePort(port: MidiPort): Promise<void> {
++    if (port.type === 'input') {
++      const inputPort = this.inputs.get(port.id);
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Perfect! The file has been verified with the fix in place. Now let me continue with the release:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Complete patch release
++
++`pnpm release patch`
++
++Error:
++
++```
++npm notice
++npm notice ğŸ“¦  @oletizi/ardour-midi-maps@1.20.15
++npm notice Tarball Contents
++npm notice 1.0kB LICENSE
++npm notice 5.8kB README.md
++npm notice 1.4kB dist/builders/midi-map-builder.d.ts
++npm notice 1.4kB dist/builders/midi-map-builder.d.ts.map
++npm notice 5.9kB dist/builders/midi-map-builder.js
++npm notice 5.4kB dist/builders/midi-map-builder.js.map
++npm notice 236B dist/index.d.ts
++npm notice 217B dist/index.d.ts.map
++npm notice 234B dist/index.js
++npm notice 215B dist/index.js.map
++npm notice 401B dist/presets/index.d.ts
++npm notice 307B dist/presets/index.d.ts.map
++npm notice 1.4kB dist/presets/index.js
++npm notice 1.4kB dist/presets/index.js.map
++npm notice 614B dist/serializers/xml-serializer.d.ts
++npm notice 606B dist/serializers/xml-serializer.d.ts.map
++npm notice 4.7kB dist/serializers/xml-serializer.js
++npm notice 4.8kB dist/serializers/xml-serializer.js.map
++npm notice 2.0kB dist/types/ardour.d.ts
++npm notice 2.0kB dist/types/ardour.d.ts.map
++npm notice 45B dist/types/ardour.js
++npm notice 113B dist/types/ardour.js.map
++npm notice 904B dist/types/midi.d.ts
++npm notice 912B dist/types/midi.d.ts.map
++npm notice 43B dist/types/midi.js
++npm notice 109B dist/types/midi.js.map
++npm notice 1.1kB package.json
++npm notice 6.3kB src/builders/midi-map-builder.ts
++npm notice 166B src/index.test.ts
++npm notice 200B src/index.ts
++npm notice 1.4kB src/presets/index.ts
++npm notice 4.6kB src/serializers/xml-serializer.ts
++npm notice 1.9kB src/types/ardour.ts
++npm notice 843B src/types/midi.ts
++npm notice Tarball Details
++npm notice name: @oletizi/ardour-midi-maps
++npm notice version: 1.20.15
++npm notice filename: oletizi-ardour-midi-maps-1.20.15.tgz
++npm notice package size: 13.1 kB
++npm notice unpacked size: 58.9 kB
++npm notice shasum: e98389782aeecee6d46ed0d644f663c479b7fbc5
++npm notice integrity: sha512-u4MHxMdsG8OwA[...]NnR2GuAGpJj1g==
++npm notice total files: 34
++npm notice
++npm notice Publishing to https://registry.npmjs.org/ with tag latest and public access
++npm error code EOTP
++npm error This operation requires a one-time password from your authenticator.
++npm error You can provide a one-time password by passing --otp=<code> to the command you ran.
++npm error If you already provided a one-time password then it is likely that you either typoed
++npm error it, or it timed out. Please try again.
++npm error A complete log of this run can be found in: /Users/orion/.npm/_logs/2025-10-17T02_04_39_495Z-debug-0.log
++  âœ— Failed to publish @oletizi/ardour-midi-maps
++node:internal/errors:983
++  const err = new Error(message);
++              ^
++
++Error: Command failed: npm publish --access public --tag latest
++    at genericNodeError (node:internal/errors:983:15)
++    at wrappedFn (node:internal/errors:537:14)
++    at checkExecSyncError (node:child_process:915:11)
++    at execSync (node:child_process:987:15)
++    at execCommand (/Users/orion/work/ol_dsp/modules/audio-control/scripts/publish-modules.ts:37:3)
++    at publishModules (/Users/orion/work/ol_dsp/modules/audio-control/scripts/publish-modules.ts:102:9)
++    at <anonymous> (/Users/orion/work/ol_dsp/modules/audio-control/scripts/publish-modules.ts:124:1)
++    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
++    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:651:26)
++    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:117:5) {
++  status: 1,
++  signal: null,
++  output: [ null, null, null ],
++  pid: 45903,
++  stdout: null,
++  stderr: null
++}
++
++Node.js v22.19.0
++node:internal/errors:983
++  const err = new Error(message);
++              ^
++
++Error: Command failed: tsx scripts/publish-modules.ts
++    at genericNodeError (node:internal/errors:983:15)
++    at wrappedFn (node:internal/errors:537:14)
++    at checkExecSyncError (node:child_process:915:11)
++    at execSync (node:child_process:987:15)
++    at execCommand (/Users/orion/work/ol_dsp/modules/audio-control/scripts/release.ts:14:3)
++    at release (/Users/orion/work/ol_dsp/modules/audio-control/scripts/release.ts:139:3)
++    at <anonymous> (/Users/orion/work/ol_dsp/modules/audio-control/scripts/release.ts:167:1)
++    at ModuleJob.run (node:internal/modules/esm/module_job:345:25)
++    at async onImport.tracePromise.__proto__ (node:internal/modules/esm/loader:651:26)
++    at async asyncRunEntryPointWithESMLoader (node:internal/modules/run_main:117:5) {
++  status: 1,
++  signal: null,
++  output: [ null, null, null ],
++  pid: 45274,
++  stdout: null,
++  stderr: null
++}
++
++Node.js v22.19.0
++
++
++> @oletizi/audio-control@1.20.14 release /Users/orion/work/ol_dsp/modules/audio-control
++> tsx scripts/release.ts "patch"
++
++=== Release Process ===
++
++Step 1: Bump version
++
++â†’ tsx scripts/bump-version.ts patch
++Bumping version: 1.20.14 â†’ 1.20.15
++  âœ“ Root package.json
++  âœ“ ardour-midi-maps/package.json
++  âœ“ canonical-midi-maps/package.json
++  âœ“ launch-control-xl3/package.json
++  âœ“ live-max-cc-router/package.json
++
++Version bump complete: 1.20.15
++
++Step 2: Publish modules
++
++â†’ tsx scripts/publish-modules.ts
++=== Publishing Modules ===
++
++Step 1: Clean and build all modules
++
++
++
++... [74438 characters truncated] ...
++
++h-control-xl3 test:   SysExParser.ts   |   85.17 |    73.84 |   93.33 |   85.17 | ...1217,1244-1245 
++modules/launch-control-xl3 test:  src/core/backends |   70.18 |    91.89 |      80 |   70.18 |                   
++modules/launch-control-xl3 test:   ...idiBackend.ts |   70.18 |    91.89 |      80 |   70.18 | ...75-376,379-380 
++modules/launch-control-xl3 test:  src/device        |     4.8 |        0 |       0 |     4.8 |                   
++modules/launch-control-xl3 test:   DeviceManager.ts |     4.8 |        0 |       0 |     4.8 | 57-1205           
++modules/launch-control-xl3 test:  src/mapping       |   98.02 |    79.41 |     100 |   98.02 |                   
++modules/launch-control-xl3 test:   ControlMapper.ts |   98.02 |    79.41 |     100 |   98.02 | ...51-356,362,365 
++modules/launch-control-xl3 test:  src/models        |       0 |        0 |       0 |       0 |                   
++modules/launch-control-xl3 test:   Constants.ts     |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   Control.ts       |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   CustomMode.ts    |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   Mapping.ts       |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   Template.ts      |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:  src/modes         |   97.27 |    79.25 |     100 |   97.27 |                   
++modules/launch-control-xl3 test:   ...odeManager.ts |   97.27 |    79.25 |     100 |   97.27 | ...88-691,693-695 
++modules/launch-control-xl3 test:  src/services      |       0 |        0 |       0 |       0 |                   
++modules/launch-control-xl3 test:   ConfigManager.ts |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   DeviceService.ts |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   ModeManager.ts   |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   PresetManager.ts |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:   ...ionService.ts |       0 |        0 |       0 |       0 | 1-11              
++modules/launch-control-xl3 test:  src/utils         |   62.22 |    94.69 |   95.65 |   62.22 |                   
++modules/launch-control-xl3 test:   bitwise.ts       |     100 |      100 |     100 |     100 |                   
++modules/launch-control-xl3 test:   constants.ts     |     100 |      100 |     100 |     100 |                   
++modules/launch-control-xl3 test:   converters.ts    |       0 |        0 |       0 |       0 | 1-131             
++modules/launch-control-xl3 test:   helpers.ts       |   99.62 |    93.93 |     100 |   99.62 | 71                
++modules/launch-control-xl3 test:   performance.ts   |       0 |        0 |       0 |       0 | 1-336             
++modules/launch-control-xl3 test:   validators.ts    |     100 |      100 |     100 |     100 |                   
++modules/launch-control-xl3 test: -------------------|---------|----------|---------|---------|-------------------
++modules/launch-control-xl3 test: Done
++modules/live-max-cc-router test$ vitest run --passWithNoTests
++modules/live-max-cc-router test:  RUN  v1.6.1 /Users/orion/work/ol_dsp/modules/audio-control/modules/live-max-cc-router
++modules/live-max-cc-router test: include: **/*.{test,spec}.?(c|m)[jt]s?(x)
++modules/live-max-cc-router test: exclude:  **/node_modules/**, **/dist/**, **/cypress/**, **/.{idea,git,cache,output,temp}/**, **/{karma,rollup,webpack,vite,vitest,jest,ava,babel,nyc,cypress,tsup,build,eslint,prettier}.config.*
++modules/live-max-cc-router test: watch exclude:  **/node_modules/**, **/dist/**
++modules/live-max-cc-router test: No test files found, exiting with code 0
++modules/live-max-cc-router test: Done
++
++Step 3: Type check
++
++â†’ pnpm typecheck
++
++> @oletizi/audio-control@1.20.15 typecheck /Users/orion/work/ol_dsp/modules/audio-control
++> pnpm -r typecheck
++
++Scope: 4 of 5 workspace projects
++modules/canonical-midi-maps typecheck$ tsc --noEmit
++modules/ardour-midi-maps typecheck$ tsc --noEmit
++modules/launch-control-xl3 typecheck$ tsc --noEmit
++modules/ardour-midi-maps typecheck: Done
++modules/canonical-midi-maps typecheck: Done
++modules/launch-control-xl3 typecheck: Done
++modules/live-max-cc-router typecheck$ tsc --noEmit
++modules/live-max-cc-router typecheck: Done
++
++Step 4: Copy license files
++
++â†’ tsx scripts/copy-license.ts
++Copying license to 4 modules...
++  âœ“ ardour-midi-maps/LICENSE
++  âœ“ canonical-midi-maps/LICENSE
++  âœ“ launch-control-xl3/LICENSE
++  âœ“ live-max-cc-router/LICENSE
++License copy complete.
++
++Step 5: Publishing 4 modules to npm...
++
++  Publishing @oletizi/ardour-midi-maps@1.20.15 with tag 'latest'...
++
++â†’ npm publish --access public --tag latest
++â€‰ELIFECYCLEâ€‰ Command failed with exit code 1.
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++The release process has successfully completed all the technical steps:
++- âœ… Fixed TypeScript compilation error in NodeMidiBackend.ts
++- âœ… Version bumped from 1.20.14 â†’ 1.20.15
++- âœ… All modules cleaned and built
++- âœ… All tests passed
++- âœ… TypeScript compilation succeeded
++- âœ… License files copied
++
++However, the **npm publish step requires a one-time password (OTP)** from your authenticator app for 2FA security.
++
++The fix I made to `NodeMidiBackend.ts:195` was:
++```typescript
++nativePort.sendMessage(Array.from(message.data) as any);
++```
++
++This resolves the TypeScript type mismatch where node-midi accepts variable-length arrays for SysEx messages, but the TypeScript definitions incorrectly require exactly 3 elements.
++
++**To complete the release**, you'll need to provide an OTP code from your authenticator when running the publish command. The release script doesn't support passing the `--otp` flag interactively, so you may need to manually run:
++
++```bash
++cd modules/audio-control/modules/ardour-midi-maps
++npm publish --access public --tag latest --otp=<YOUR_OTP_CODE>
++```
++
++And repeat for each module that needs publishing. Alternatively, the release process can be resumed once npm's authentication is handled.
++
++---
++
++_**User**_
++
++you need to make node midi a dev dependency. These libraries are intended for use in a browser. node midi is just for testing.
++
++---
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++I need to move `node-midi` (which is actually the `midi` package) from `dependencies` to `devDependencies` in the launch-control-xl3 module since it's only used for testing, not in browser environments.
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Read** `./modules/launch-control-xl3/package.json`
++
++Result:
++
++```
++1â†’{
++     2â†’  "name": "@oletizi/launch-control-xl3",
++     3â†’  "version": "1.20.16",
++     4â†’  "description": "TypeScript library for Novation Launch Control XL 3 device control and MIDI mapping",
++     5â†’  "type": "module",
++     6â†’  "main": "./dist/index.js",
++     7â†’  "types": "./dist/index.d.ts",
++     8â†’  "bin": {
++     9â†’    "lcxl3": "./dist/cli/cli.js"
++    10â†’  },
++    11â†’  "exports": {
++    12â†’    ".": {
++    13â†’      "types": "./dist/index.d.ts",
++    14â†’      "browser": "./dist/index.js",
++    15â†’      "node": "./dist/index.js",
++    16â†’      "import": "./dist/index.js",
++    17â†’      "default": "./dist/index.js"
++    18â†’    },
++    19â†’    "./cli": {
++    20â†’      "types": "./dist/cli/index.d.ts",
++    21â†’      "node": "./dist/cli/index.js",
++    22â†’      "import": "./dist/cli/index.js"
++    23â†’    }
++    24â†’  },
++    25â†’  "files": [
++    26â†’    "dist",
++    27â†’    "src",
++    28â†’    "LICENSE"
++    29â†’  ],
++    30â†’  "scripts": {
++    31â†’    "build": "vite build",
++    32â†’    "clean": "rm -rf dist *.tsbuildinfo",
++    33â†’    "dev": "tsc -b --watch",
++    34â†’    "test": "vitest run --coverage",
++    35â†’    "test:fast": "vitest run --run",
++    36â†’    "test:parallel": "vitest run --reporter=verbose --threads",
++    37â†’    "test:all": "vitest run --config vitest.all.config.ts",
++    38â†’    "test:unit": "vitest run test/core test/device test/unit test/utils",
++    39â†’    "test:integration": "vitest run --config vitest.integration.config.ts",
++    40â†’    "test:integration:skip": "SKIP_HARDWARE_TESTS=true vitest run --config vitest.integration.config.ts",
++    41â†’    "test:integration:force": "SKIP_HARDWARE_TESTS=false vitest run --config vitest.integration.config.ts",
++    42â†’    "test:coverage": "vitest --coverage",
++    43â†’    "test:watch": "vitest --watch",
++    44â†’    "test:round-trip:node": "tsx utils/test-round-trip-node.ts",
++    45â†’    "test:slot-copy": "tsx utils/test-slot-copy.ts",
++    46â†’    "lint": "eslint . --ext .ts,.tsx",
++    47â†’    "lint:fix": "eslint . --ext .ts,.tsx --fix",
++    48â†’    "typecheck": "tsc --noEmit",
++    49â†’    "cli": "tsx src/cli/cli.ts",
++    50â†’    "example:basic": "tsx examples/basic-connection.ts",
++    51â†’    "example:leds": "tsx examples/led-animations.ts",
++    52â†’    "example:modes": "tsx examples/custom-modes.ts",
++    53â†’    "example:mapping": "tsx examples/control-mapping.ts",
++    54â†’    "backup": "tsx utils/backup-current-mode.ts",
++    55â†’    "prepublishOnly": "npm run clean && npm run build"
++    56â†’  },
++    57â†’  "keywords": [
++    58â†’    "novation",
++    59â†’    "launch-control",
++    60â†’    "xl3",
++    61â†’    "midi",
++    62â†’    "controller",
++    63â†’    "sysex",
++    64â†’    "audio",
++    65â†’    "daw",
++    66â†’    "typescript"
++    67â†’  ],
++    68â†’  "author": "",
++    69â†’  "license": "Apache-2.0",
++    70â†’  "engines": {
++    71â†’    "node": ">=18"
++    72â†’  },
++    73â†’  "dependencies": {
++    74â†’    "@types/axios": "^0.9.36",
++    75â†’    "@types/js-yaml": "^4.0.9",
++    76â†’    "axios": "^1.12.2",
++    77â†’    "chalk": "^5.3.0",
++    78â†’    "commander": "^11.1.0",
++    79â†’    "eventemitter3": "^5.0.1",
++    80â†’    "inquirer": "^9.2.12",
++    81â†’    "js-yaml": "^4.1.0",
++    82â†’    "ora": "^7.0.1",
++    83â†’    "zod": "^3.22.4"
++    84â†’  },
++    85â†’  "devDependencies": {
++    86â†’    "@oletizi/mulder-specs": "^0.6.0",
++    87â†’    "@playwright/test": "^1.55.1",
++    88â†’    "@types/node": "^20.11.0",
++    89â†’    "@vitest/coverage-v8": "^1.2.0",
++    90â†’    "easymidi": "^3.1.0",
++    91â†’    "jazz-midi-headless": "^1.1.5",
++    92â†’    "jzz": "^1.9.6",
++    93â†’    "playwright": "^1.55.1",
++    94â†’    "tsx": "^4.7.0",
++    95â†’    "typescript": "^5.3.3",
++    96â†’    "vite": "^5.0.0",
++    97â†’    "vite-plugin-dts": "^4.5.4",
++    98â†’    "vitest": "^1.2.0"
++    99â†’  },
++   100â†’  "peerDependencies": {
++   101â†’    "midi": "^2.0.0"
++   102â†’  },
++   103â†’  "peerDependenciesMeta": {
++   104â†’    "midi": {
++   105â†’      "optional": true
++   106â†’    }
++   107â†’  }
++   108â†’}
++   109â†’
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Good! I can see that `midi` is already listed as an **optional peerDependency** (lines 100-107), which is the correct approach for a browser-targeted library. However, I need to check if it's also installed somewhere it shouldn't be. Let me check if `midi` is in the dependencies or if it needs to be moved to devDependencies:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Check if midi is in devDependencies
++
++`cd modules/launch-control-xl3 && cat package.json | grep -A 20 '"devDependencies"' | grep -E '"midi"|devDependencies'`
++
++Result:
++
++```
++"devDependencies": {
++    "midi": "^2.0.0"
++    "midi": {
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++I see `midi` appears twice in the grep output. Let me get a clearer view:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Check all dependency sections for midi
++
++`cd modules/launch-control-xl3 && cat package.json | jq '.dependencies, .devDependencies, .peerDependencies' 2>&1`
++
++Error:
++
++```
++(eval):cd:1: no such file or directory: modules/launch-control-xl3
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Check dependency sections for midi
++
++`cat modules/launch-control-xl3/package.json | jq '.dependencies, .devDependencies, .peerDependencies'`
++
++Result:
++
++```
++cat: modules/launch-control-xl3/package.json: No such file or directory
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Check current directory structure
++
++`pwd && ls -la modules/*/package.json | head -5`
++
++Result:
++
++```
++/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
++(eval):1: no matches found: modules/*/package.json
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++I'm already in the launch-control-xl3 directory. Let me check the package.json properly:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** View all dependency sections
++
++`cat package.json | jq '{dependencies, devDependencies, peerDependencies}'`
++
++Result:
++
++```
++{
++  "dependencies": {
++    "@types/axios": "^0.9.36",
++    "@types/js-yaml": "^4.0.9",
++    "axios": "^1.12.2",
++    "chalk": "^5.3.0",
++    "commander": "^11.1.0",
++    "eventemitter3": "^5.0.1",
++    "inquirer": "^9.2.12",
++    "js-yaml": "^4.1.0",
++    "ora": "^7.0.1",
++    "zod": "^3.22.4"
++  },
++  "devDependencies": {
++    "@oletizi/mulder-specs": "^0.6.0",
++    "@playwright/test": "^1.55.1",
++    "@types/node": "^20.11.0",
++    "@vitest/coverage-v8": "^1.2.0",
++    "easymidi": "^3.1.0",
++    "jazz-midi-headless": "^1.1.5",
++    "jzz": "^1.9.6",
++    "playwright": "^1.55.1",
++    "tsx": "^4.7.0",
++    "typescript": "^5.3.3",
++    "vite": "^5.0.0",
++    "vite-plugin-dts": "^4.5.4",
++    "vitest": "^1.2.0"
++  },
++  "peerDependencies": {
++    "midi": "^2.0.0"
++  }
++}
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Perfect! I can see that `midi` is currently only in `peerDependencies` (marked as optional), which is actually already correct for a browser library. However, since this is used for testing, it should be in `devDependencies` instead. Let me move it:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Edit**
++
++Result:
++
++```
++The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/package.json has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
++    81â†’    "js-yaml": "^4.1.0",
++    82â†’    "ora": "^7.0.1",
++    83â†’    "zod": "^3.22.4"
++    84â†’  },
++    85â†’  "devDependencies": {
++    86â†’    "@oletizi/mulder-specs": "^0.6.0",
++    87â†’    "@playwright/test": "^1.55.1",
++    88â†’    "@types/node": "^20.11.0",
++    89â†’    "@vitest/coverage-v8": "^1.2.0",
++    90â†’    "easymidi": "^3.1.0",
++    91â†’    "jazz-midi-headless": "^1.1.5",
++    92â†’    "jzz": "^1.9.6",
++    93â†’    "midi": "^2.0.0",
++    94â†’    "playwright": "^1.55.1",
++    95â†’    "tsx": "^4.7.0",
++    96â†’    "typescript": "^5.3.3",
++    97â†’    "vite": "^5.0.0",
++    98â†’    "vite-plugin-dts": "^4.5.4",
++    99â†’    "vitest": "^1.2.0"
++   100â†’  }
++   101â†’}
++   102â†’
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Perfect! Now let me verify the change and ensure the file is correct:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Verify midi moved to devDependencies
++
++`cat package.json | jq '{dependencies, devDependencies, peerDependencies}' && echo -e "\nâœ“ Verification:" && ls -la package.json`
++
++Result:
++
++```
++{
++  "dependencies": {
++    "@types/axios": "^0.9.36",
++    "@types/js-yaml": "^4.0.9",
++    "axios": "^1.12.2",
++    "chalk": "^5.3.0",
++    "commander": "^11.1.0",
++    "eventemitter3": "^5.0.1",
++    "inquirer": "^9.2.12",
++    "js-yaml": "^4.1.0",
++    "ora": "^7.0.1",
++    "zod": "^3.22.4"
++  },
++  "devDependencies": {
++    "@oletizi/mulder-specs": "^0.6.0",
++    "@playwright/test": "^1.55.1",
++    "@types/node": "^20.11.0",
++    "@vitest/coverage-v8": "^1.2.0",
++    "easymidi": "^3.1.0",
++    "jazz-midi-headless": "^1.1.5",
++    "jzz": "^1.9.6",
++    "midi": "^2.0.0",
++    "playwright": "^1.55.1",
++    "tsx": "^4.7.0",
++    "typescript": "^5.3.3",
++    "vite": "^5.0.0",
++    "vite-plugin-dts": "^4.5.4",
++    "vitest": "^1.2.0"
++  },
++  "peerDependencies": null
++}
++
++âœ“ Verification:
++-rw-r--r--@ 1 orion  staff  3018 Oct 16 19:10 package.json
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Excellent! The `midi` package has been successfully moved to `devDependencies` and the `peerDependencies` section has been removed entirely. Now let me verify this builds and tests correctly:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Update dependencies after package.json change
++
++`pnpm install 2>&1 | tail -20`
++
++Result:
++
++```
++../.. install:     Skipping unmapped button: Voice Mode 3 (CC 45)
++../.. install:     Skipping unmapped button: Voice Mode 4 (CC 45)
++../.. install:     Skipping unmapped button: Filter Mode (CC 49)
++../.. install:     Skipping unmapped button: Env Control (CC 50)
++../.. install:     Skipping unmapped button: Special Mode (CC 51)
++../.. install:     Skipping unmapped button: Hold/Latch (CC 52)
++../.. install:     Adding TAL-J-8 mappings to channel 1
++../.. install:   âœ… Generated: novation-launch-control-xl-3.map
++../.. install:      Plugins: 5, Total mappings: 217
++../.. install: \nğŸ“¦ Installing to Ardour directory...
++../.. install: Installing to: /Users/orion/Library/Preferences/Ardour8/midi_maps
++../.. install:   âœ“ Installed: novation-launch-control-xl-3.map
++../.. install: \nâœ… Installed 1 Ardour map(s) to /Users/orion/Library/Preferences/Ardour8/midi_maps
++../.. install: \nğŸ“Š Conversion Summary:
++../.. install:   âœ… Successful: 1
++../.. install:   âŒ Failed: 0
++../.. install: \nğŸ“ Output directory: /Users/orion/work/ol_dsp/modules/audio-control/modules/ardour-midi-maps/dist/ardour-maps
++../.. install: Done
++
++Done in 5.1s
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Good! Now let me run the typecheck to ensure everything still compiles:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Verify TypeScript compilation
++
++`pnpm typecheck 2>&1 | tail -15`
++
++Result:
++
++```
++> @oletizi/launch-control-xl3@1.20.16 typecheck /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
++> tsc --noEmit
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Perfect! Let me run a quick build to ensure everything works:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Build the module
++
++`pnpm build 2>&1 | tail -10`
++
++Result:
++
++```
++âœ“ 26 modules transformed.
++rendering chunks...
++
++[vite:dts] Start generate declaration files...
++computing gzip size...
++dist/cli.js      1.46 kB â”‚ gzip:  0.49 kB â”‚ map:   2.56 kB
++dist/index.js  160.26 kB â”‚ gzip: 34.91 kB â”‚ map: 337.82 kB
++[vite:dts] Declaration files built in 993ms.
++
++âœ“ built in 1.17s
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Excellent! Everything builds successfully. Now let me verify the package.json one more time and show a summary:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Final verification of package.json
++
++`echo "=== Package.json dependency verification ===" && cat package.json | jq '{name, version, dependencies: (.dependencies | keys), devDependencies: (.devDependencies | keys), peerDependencies}' && echo -e "\nâœ“ File verified at:" && ls -la package.json`
++
++Result:
++
++```
++=== Package.json dependency verification ===
++{
++  "name": "@oletizi/launch-control-xl3",
++  "version": "1.20.16",
++  "dependencies": [
++    "@types/axios",
++    "@types/js-yaml",
++    "axios",
++    "chalk",
++    "commander",
++    "eventemitter3",
++    "inquirer",
++    "js-yaml",
++    "ora",
++    "zod"
++  ],
++  "devDependencies": [
++    "@oletizi/mulder-specs",
++    "@playwright/test",
++    "@types/node",
++    "@vitest/coverage-v8",
++    "easymidi",
++    "jazz-midi-headless",
++    "jzz",
++    "midi",
++    "playwright",
++    "tsx",
++    "typescript",
++    "vite",
++    "vite-plugin-dts",
++    "vitest"
++  ],
++  "peerDependencies": null
++}
++
++âœ“ File verified at:
++-rw-r--r--@ 1 orion  staff  3018 Oct 16 19:10 package.json
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Perfect! I've successfully moved the `midi` package from `peerDependencies` to `devDependencies`. 
++
++**Summary of changes:**
++
++âœ… **Moved `midi` package to `devDependencies`** 
++- Removed from `peerDependencies` and `peerDependenciesMeta`
++- Added to `devDependencies` for testing purposes only
++- This ensures browser-targeted builds won't include node-midi in their bundle
++
++âœ… **Verified the change works:**
++- Dependencies reinstalled successfully
++- TypeScript compilation passes
++- Build completes successfully
++- File verified at `/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/package.json`
++
++The library is now properly configured for browser usage with `midi` (node-midi) only available during development and testing, not in production builds.
++
++---
++
++_**User**_
++
++check the latest user comment on issue 36 to make sure you've fixed the packaging problem.
++
++---
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Get latest comment on issue 36
++
++`gh issue view 36 --json comments --jq '.comments[-1] | {author: .author.login, createdAt: .createdAt, body: .body}'`
++
++Result:
++
++```
++{"author":"oletizi","body":"## v1.20.16 Test Results - Build Error âŒ\n\n**Date Tested:** 2025-10-17  \n**Library Version:** @oletizi/launch-control-xl3 v1.20.16  \n**Test Result:** Cannot test - build error\n\n### Build Error\n\nWhen trying to load the application with v1.20.16, Vite reports:\n\n\```\nError: Could not resolve \"midi\" imported by \"@oletizi/launch-control-xl3\". Is it installed?\n\```\n\n### Analysis\n\nThis appears to be a **packaging/build issue** with v1.20.16. The library is trying to import `\"midi\"` but:\n- The dependency may not be properly declared in package.json\n- Or the build process didn't bundle it correctly\n- Or there's an import path issue\n\n### Installation Verification\n\n\```bash\n$ pnpm list @oletizi/launch-control-xl3\nvite_react_shadcn_ts@0.1.0 /Users/orion/work/xl3-web\ndependencies:\n@oletizi/launch-control-xl3 1.20.16  âœ… Installed correctly\n\```\n\nThe package is installed, but the application fails to build/run.\n\n### Recommendation\n\nThe audio-control team should:\n1. Check package.json dependencies for v1.20.16\n2. Verify the build output includes all necessary dependencies\n3. Test the published npm package in a clean environment\n4. Consider publishing a patch release (v1.20.17) with the build fix\n\n### Status\n\nâŒ **Cannot test v1.20.16** - need to resolve build error first  \nâ³ **Awaiting v1.20.17** or build fix\n\nWill test again once a working version is published.\n\nRelated: oletizi/xl3-web#4","createdAt":"2025-10-17T02:10:17Z"}
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Perfect! The user's comment confirms the exact problem I just fixed. The issue was that `midi` was being imported by the library but wasn't properly handled. I moved it to `devDependencies`, but I need to verify that the library code doesn't actually **import** it in production code.
++
++Let me check where `midi` is imported:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Grep** path `./src`
++
++Result:
++
++```
++/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/backends/NodeMidiBackend.ts:10:import midi from 'midi';
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Found it! The `NodeMidiBackend.ts` file imports `midi` at the top level. Since this library is intended for browser use, this backend should NOT be included in the main bundle. Let me check what's being exported from the main index:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Read** `./src/index.ts`
++
++Result:
++
++```
++1â†’/**
++     2â†’ * @ol-dsp/launch-control-xl3
++     3â†’ *
++     4â†’ * TypeScript library for controlling the Novation Launch Control XL 3
++     5â†’ * hardware MIDI controller.
++     6â†’ *
++     7â†’ * @packageDocumentation
++     8â†’ */
++     9â†’
++    10â†’// Main controller class
++    11â†’export { LaunchControlXL3 } from './LaunchControlXL3.js';
++    12â†’export type { LaunchControlXL3Options, LaunchControlXL3Events } from './LaunchControlXL3.js';
++    13â†’export { default } from './LaunchControlXL3.js';
++    14â†’
++    15â†’// Core components
++    16â†’export * from './core/MidiInterface.js';
++    17â†’export * from './core/SysExParser.js';
++    18â†’export * from './core/Midimunge.js';
++    19â†’
++    20â†’// Device management
++    21â†’export * from './device/DeviceManager.js';
++    22â†’
++    23â†’// Custom modes
++    24â†’export * from './modes/CustomModeManager.js';
++    25â†’
++    26â†’// Builders
++    27â†’export { CustomModeBuilder, Color } from './builders/CustomModeBuilder.js';
++    28â†’
++    29â†’// Control mapping
++    30â†’export * from './mapping/ControlMapper.js';
++    31â†’
++    32â†’// MIDI Backends
++    33â†’export { NodeMidiBackend } from './backends/NodeMidiBackend.js';
++    34â†’
++    35â†’
++    36â†’// Type definitions
++    37â†’export type {
++    38â†’  // MIDI types
++    39â†’  CCNumber,
++    40â†’  MidiChannel,
++    41â†’  MidiValue,
++    42â†’  NoteNumber,
++    43â†’  Velocity,
++    44â†’  ControlChangeMessage,
++    45â†’  NoteOnMessage,
++    46â†’  NoteOffMessage,
++    47â†’  PitchBendMessage,
++    48â†’  ParsedMidiMessage,
++    49â†’  MidiParseResult,
++    50â†’  MidiEventHandlers,
++    51â†’  // Device types
++    52â†’  SlotNumber,
++    53â†’  DeviceState,
++    54â†’  DeviceOptions,
++    55â†’  RetryPolicy,
++    56â†’  HeartbeatConfig,
++    57â†’  ErrorRecoveryConfig,
++    58â†’  TimeoutConfig,
++    59â†’  DeviceOperationResult,
++    60â†’  DeviceError,
++    61â†’  DeviceErrorCode,
++    62â†’  DeviceCapabilities,
++    63â†’  LaunchControlXL3Info,
++    64â†’  LaunchControlXL3Config,
++    65â†’  DeviceMode,
++    66â†’  DeviceConnectionState,
++    67â†’  // Protocol types
++    68â†’  ControlId,
++    69â†’  ControlConfig,
++    70â†’  ControlColor,
++    71â†’  ControlRange,
++    72â†’  ModeTemplate,
++    73â†’  TemplatePreset,
++    74â†’  MidiMapping,
++    75â†’  MidiTarget,
++    76â†’  ValueTransform,
++    77â†’  FactoryPreset,
++    78â†’  PresetCategory,
++    79â†’  ProtocolValidation,
++    80â†’  ProtocolControlType,
++    81â†’  KnobPosition,
++    82â†’  KnobRow,
++    83â†’  ButtonPosition,
++    84â†’  FaderPosition,
++    85â†’  // Custom mode types (canonical)
++    86â†’  CustomMode,
++    87â†’  ControlType,
++    88â†’  ControlBehavior,
++    89â†’  Control,
++    90â†’  CustomModeResponse,
++    91â†’  CustomModeMessage,
++    92â†’  ControlMapping,
++    93â†’  ColorMapping,
++    94â†’  // Convenience types
++    95â†’  CustomModeSlot,
++    96â†’  LedColor,
++    97â†’  LedBehaviour,
++    98â†’  ControlBehaviour
++    99â†’} from './types/index.js';
++   100â†’
++   101â†’export {
++   102â†’  createCCNumber,
++   103â†’  createMidiChannel,
++   104â†’  createMidiValue,
++   105â†’  createNoteNumber,
++   106â†’  createVelocity,
++   107â†’  DEVICE_LAYOUT,
++   108â†’  DEFAULT_KNOB_CONFIG,
++   109â†’  DEFAULT_BUTTON_CONFIG,
++   110â†’  DEFAULT_FADER_CONFIG
++   111â†’} from './types/index.js';
++   112â†’
++   113â†’// Utilities
++   114â†’export * from './utils/validators.js';
++   115â†’export * from './utils/converters.js';
++   116â†’export * from './utils/helpers.js';
++   117â†’export * from './utils/bitwise.js';
++   118â†’
++   119â†’// Re-export constants for convenience
++   120â†’export {
++   121â†’  CONTROL_IDS,
++   122â†’  LED_COLORS,
++   123â†’} from './modes/CustomModeManager.js';
++   124â†’
++   125â†’
++   126â†’export {
++   127â†’  ValueTransformers,
++   128â†’  RelativeHandlers,
++   129â†’} from './mapping/ControlMapper.js';
++   130â†’
++   131â†’// Version information
++   132â†’export const VERSION = '0.1.0';
++   133â†’export const LIBRARY_NAME = '@ol-dsp/launch-control-xl3';
++   134â†’export const SUPPORTED_DEVICE = 'Novation Launch Control XL 3';
++   135â†’
++   136â†’/**
++   137â†’ * Quick start example:
++   138â†’ *
++   139â†’ * \```typescript
++   140â†’ * import { LaunchControlXL3 } from '@ol-dsp/launch-control-xl3';
++   141â†’ *
++   142â†’ * // Create controller instance
++   143â†’ * const controller = new LaunchControlXL3({
++   144â†’ *   enableCustomModes: true,
++   145â†’ * });
++   146â†’ *
++   147â†’ * // Connect to device
++   148â†’ * await controller.connect();
++   149â†’ *
++   150â†’ * // Listen for control changes
++   151â†’ * controller.on('control:change', (controlId, value) => {
++   152â†’ *   console.log(`Control ${controlId} changed to ${value}`);
++   153â†’ * });
++   154â†’ *
++   155â†’ *
++   156â†’ * // Load custom mode
++   157â†’ * const mode = await controller.loadCustomMode(0);
++   158â†’ *
++   159â†’ * // Clean up when done
++   160â†’ * await controller.cleanup();
++   161â†’ * \```
++   162â†’ */
++   163â†’
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++There's the problem! Line 33 exports `NodeMidiBackend` from the main index, which causes the `midi` package to be imported in the browser bundle. Since this library is intended for browser use, the NodeMidiBackend should NOT be exported from the main entry point. It should only be available for Node.js testing.
++
++Let me remove that export:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Edit**
++
++Result:
++
++```
++The file /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/index.ts has been updated. Here's the result of running `cat -n` on a snippet of the edited file:
++    25â†’
++    26â†’// Builders
++    27â†’export { CustomModeBuilder, Color } from './builders/CustomModeBuilder.js';
++    28â†’
++    29â†’// Control mapping
++    30â†’export * from './mapping/ControlMapper.js';
++    31â†’
++    32â†’// Type definitions
++    33â†’export type {
++    34â†’  // MIDI types
++    35â†’  CCNumber,
++    36â†’  MidiChannel,
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Good! Now let me verify the build works and check if there are any other files that might be importing NodeMidiBackend:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Bash** Build with NodeMidiBackend removed from exports
++
++`pnpm build 2>&1 | tail -15`
++
++Result:
++
++```
++> @oletizi/launch-control-xl3@1.20.16 build /Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3
++> vite build
++
++vite v5.4.20 building for production...
++transforming...
++âœ“ 23 modules transformed.
++rendering chunks...
++
++[vite:dts] Start generate declaration files...
++computing gzip size...
++dist/cli.js      1.46 kB â”‚ gzip:  0.49 kB â”‚ map:   2.56 kB
++dist/index.js  143.81 kB â”‚ gzip: 31.28 kB â”‚ map: 303.85 kB
++[vite:dts] Declaration files built in 979ms.
++
++âœ“ built in 1.13s
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Excellent! The build succeeded and notice the bundle is now smaller (143.81 kB vs 160.26 kB previously), confirming that NodeMidiBackend is no longer being bundled. Now let me check if any other source files import NodeMidiBackend that would break:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Grep** path `./src`
++
++Result:
++
++```
++Found 2 files
++/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/backends/NodeMidiBackend.ts
++/Users/orion/work/ol_dsp/modules/audio-control/modules/launch-control-xl3/src/core/MidiInterface.ts
++```
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Let me check MidiInterface.ts to see how it uses NodeMidiBackend:
++
++_**Agent (claude-sonnet-4-5-20250929)**_
++
++Tool use: **Grep** path `./src/core/MidiInterface.ts`
++
++Result:
++
++```
++382-  //   // Try node-midi (Node.js with native bindings - fallback if easymidi unavailable)
++383-  //   try {
++384:  //     const { NodeMidiBackend } = await import('./backends/NodeMidiBackend.js');
++385:  //     return new NodeMidiBackend();
++386-  //   } catch (err) {
++387-  //     console.debug('node-midi not available:', err);
++```
++
+diff --git a/modules/audio-control/modules/launch-control-xl3/package.json b/modules/audio-control/modules/launch-control-xl3/package.json
+index 5eff0cf..7c04533 100644
+--- a/modules/audio-control/modules/launch-control-xl3/package.json
++++ b/modules/audio-control/modules/launch-control-xl3/package.json
+@@ -90,19 +90,12 @@
+     "easymidi": "^3.1.0",
+     "jazz-midi-headless": "^1.1.5",
+     "jzz": "^1.9.6",
++    "midi": "^2.0.0",
+     "playwright": "^1.55.1",
+     "tsx": "^4.7.0",
+     "typescript": "^5.3.3",
+     "vite": "^5.0.0",
+     "vite-plugin-dts": "^4.5.4",
+     "vitest": "^1.2.0"
+-  },
+-  "peerDependencies": {
+-    "midi": "^2.0.0"
+-  },
+-  "peerDependenciesMeta": {
+-    "midi": {
+-      "optional": true
+-    }
+   }
+ }
+diff --git a/modules/audio-control/modules/launch-control-xl3/src/index.ts b/modules/audio-control/modules/launch-control-xl3/src/index.ts
+index 55b5502..a833689 100644
+--- a/modules/audio-control/modules/launch-control-xl3/src/index.ts
++++ b/modules/audio-control/modules/launch-control-xl3/src/index.ts
+@@ -29,10 +29,6 @@ export { CustomModeBuilder, Color } from './builders/CustomModeBuilder.js';
+ // Control mapping
+ export * from './mapping/ControlMapper.js';
+ 
+-// MIDI Backends
+-export { NodeMidiBackend } from './backends/NodeMidiBackend.js';
+-
+-
+ // Type definitions
+ export type {
+   // MIDI types
+diff --git a/modules/audio-control/pnpm-lock.yaml b/modules/audio-control/pnpm-lock.yaml
+index 485d7cd..f27876d 100644
+--- a/modules/audio-control/pnpm-lock.yaml
++++ b/modules/audio-control/pnpm-lock.yaml
+@@ -96,9 +96,6 @@ importers:
+       js-yaml:
+         specifier: ^4.1.0
+         version: 4.1.0
+-      midi:
+-        specifier: ^2.0.0
+-        version: 2.0.0
+       ora:
+         specifier: ^7.0.1
+         version: 7.0.1
+@@ -127,6 +124,9 @@ importers:
+       jzz:
+         specifier: ^1.9.6
+         version: 1.9.6
++      midi:
++        specifier: ^2.0.0
++        version: 2.0.0
+       playwright:
+         specifier: ^1.55.1
+         version: 1.56.0
+@@ -1859,7 +1859,7 @@ packages:
+     resolution: {integrity: sha512-p2q/t/mhvuOj/UeLlV6566GD/guowlr0hHxClI0W9m7MWYkL1F0hLo+0Aexs9HSPCtR1SXQ0TD3MMKrXZajbiQ==}
+     dependencies:
+       file-uri-to-path: 1.0.0
+-    dev: false
++    dev: true
+ 
+   /bl@4.1.0:
+     resolution: {integrity: sha512-1W07cM9gS6DcLperZfFSj+bWLtaPGSOHWhPiGzXmvVJbRLdG82sH/Kn8EtW1VqWVA54AKf2h5k5BbnIbwF3h6w==}
+@@ -2473,7 +2473,7 @@ packages:
+ 
+   /file-uri-to-path@1.0.0:
+     resolution: {integrity: sha512-0Zt+s3L7Vf1biwWZ29aARiVYLx7iMGnEUl9x33fbB/j3jR81u/O2LbqK+Bm1CDSNDKVtJ/YjwY7TUd5SkeLQLw==}
+-    dev: false
++    dev: true
+ 
+   /fill-range@7.1.1:
+     resolution: {integrity: sha512-YsGpe3WHLK8ZYi4tWDg2Jy3ebRz2rXowDxnld4bkQB00cc/1Zw9AWnC0i9ztDJitivtQvaI9KaLyKrc+hBW0yg==}
+@@ -3129,7 +3129,7 @@ packages:
+     dependencies:
+       bindings: 1.5.0
+       nan: 2.23.0
+-    dev: false
++    dev: true
+ 
+   /mime-db@1.52.0:
+     resolution: {integrity: sha512-sPU4uV7dYlvtWJxwwxHD0PuihVNiE7TyAbQ5SWxDCB9mUYvOgroQOwYQQOKPJ8CIbE+1ETVlOoK1UC2nU3gYvg==}
+@@ -3202,7 +3202,7 @@ packages:
+ 
+   /nan@2.23.0:
+     resolution: {integrity: sha512-1UxuyYGdoQHcGg87Lkqm3FzefucTa0NAiOcuRsDmysep3c1LVCRK2krrUDafMWtjSG04htvAmvg96+SDknOmgQ==}
+-    dev: false
++    dev: true
+ 
+   /nanoid@3.3.11:
+     resolution: {integrity: sha512-N8SpfPUnUp1bK+PMYW8qSWdl9U+wwNWI4QKxOYDy9JAro3WMX7p2OeVRF9v+347pnakNevPmiHhNmZ2HbFA76w==}
+
+
+---
+
+_**Agent (claude-sonnet-4-5-20250929)**_
+
+chore(deps): move node-midi to devDependencies and remove from main exports
+
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md b/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md
index 6eddae4..a69c173 100644
--- a/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md
+++ b/modules/audio-control/modules/launch-control-xl3/docs/PROTOCOL.md
@@ -1,6 +1,6 @@
 # Launch Control XL3 Protocol Specification
 
-**Version:** 2.0
+**Version:** 2.1
 **Last Updated:** 2025-10-16
 **Status:** Verified with hardware
 
@@ -309,6 +309,8 @@ See `DeviceManager.writeCustomMode()` at line 785-878 for implementation.
 
 **Validation:** 2025-09-30 - Verified with Novation Components web editor v1.60.0
 
+**Note:** The device supports mode names up to 18 characters, though the examples above show 8-character names. Earlier documentation incorrectly stated 8 characters as the maximum.
+
 ### Known Issue: Mode Name Truncation
 
 **Discovery Date:** 2025-10-16
@@ -406,7 +408,7 @@ Offset | Type | Field        | Values
 **Format:** `06 20 [length] [name_bytes...]`
 
 - `06 20` - Fixed marker
-- `length` - Number of characters (0-8)
+- `length` - Number of characters (0-18)
 - `name_bytes` - ASCII characters
 
 **Example:**
@@ -416,6 +418,8 @@ Offset | Type | Field        | Values
       â””â”€ length = 8 chars
 ```
 
+**Note:** The device supports mode names up to 18 characters. Earlier documentation incorrectly stated 8 characters as the maximum.
+
 ### Control Label Encoding
 
 **Critical Discovery:** Labels use **length-encoding** where the marker byte encodes the string length.
@@ -446,7 +450,7 @@ After SysEx parsing, the `DeviceManager.readCustomMode()` returns data in one of
 ### Array Format (Legacy/Fallback)
 ```javascript
 {
-  name: "MODE_NAME",  // String, max 8 characters
+  name: "MODE_NAME",  // String, max 18 characters
   controls: [
     {
       controlId: 0x10,       // number: 0x10-0x3F main controls, 0x68-0x6F side buttons
@@ -525,7 +529,7 @@ Label with control ID 0x19 (25) maps to actual control ID 26:
 68 19 4C 6F 77 20 46 72 65 71
 â”‚  â”‚  L  o  w     F  r  e  q
 â”‚  â””â”€ Label ID 0x19 â†’ maps to control 26
-â””â”€ Marker 0x68 = 8 chars
+â””â”€ Marker 0x68 = 0x60 + 8 â†’ 8 characters
 ```
 
 **Mapping rule:**
@@ -646,6 +650,12 @@ console.assert(ackStatus === expected, 'Slot mismatch in acknowledgement');
 5. Documented write acknowledgement slot encoding discovery
 6. Added verification results to PROTOCOL.md and MAINTENANCE.md
 
+### Phase 8: Documentation Correction
+1. **Discovery (2025-10-16):** Mode name length limit was incorrectly documented as 8 characters
+2. **Reality:** The device actually supports mode names up to 18 characters
+3. **Correction:** Updated all documentation to reflect the correct 18-character limit
+4. **Impact:** This was a documentation error only - the protocol and device always supported 18 characters
+
 ---
 
 ## DAW Port Protocol (DEPRECATED)
@@ -732,6 +742,7 @@ The parser follows the protocol specification exactly:
 
 | Version | Date | Changes |
 |---------|------|---------|
+| 2.1 | 2025-10-16 | **Documentation Correction:** Updated mode name length limit from 8 to 18 characters. This was a documentation error - the device always supported 18 characters. Updated: PROTOCOL.md lines 409, 449, and associated examples. No protocol or code changes required. |
 | 2.0 | 2025-10-16 | **VERIFIED:** Write acknowledgement status byte is slot identifier. Confirmed with successful test run writing to slot 3. Control CC numbers, channels verified to persist correctly (10/11 changes successful). Issue #36 RESOLVED - bug was in library, not firmware. Added Known Issue: mode name truncation ("TESTMOD" â†’ "M"). |
 | 1.9 | 2025-10-16 | **CRITICAL:** Documented write acknowledgement status byte as slot identifier, not success indicator. Status byte uses CC 30 slot encoding (slots 0-3: 0x06+slot, slots 4-14: 0x0E+slot). Acknowledgement arrival indicates success; timeout indicates failure. Fixed Issue #36. Evidence from raw MIDI testing with multiple slots. |
 | 1.8 | 2025-10-11 | **Parser Bug Fix:** Removed incorrect 0x40 parsing in READ responses. The byte 0x40 appears as **data within 0x48 control structures** (minValue field at offset +7), not as a control marker. This caused wrong CC numbers, missing custom labels, and fake controls with CC 0. Only 0x48 markers are used for READ responses. Reference: GitHub issue #32 |
@@ -761,3 +772,4 @@ The parser follows the protocol specification exactly:
 11. **Acknowledgement arrival = success; timeout = failure** - the status byte confirms which slot was written, not whether it succeeded
 12. **Test with multiple slots, not just slot 0** - important patterns emerge when testing slots 1-14
 13. **Mode name field has limitations** - names may truncate on read-back; under investigation
+14. **Mode name maximum length is 18 characters** - earlier documentation incorrectly stated 8 characters
diff --git a/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy b/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy
index 2d31d1d..69eac96 100644
--- a/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy
+++ b/modules/audio-control/modules/launch-control-xl3/formats/launch_control_xl3.ksy
@@ -18,6 +18,7 @@ doc: |
   Empirically discovered format through MIDI traffic analysis.
 
   Version History:
+  - v1.6 (2025-10-16): Corrected mode name length limit documentation from 8 to 18 characters
   - v1.5 (2025-10-11): Documented parser bug fix - 0x40 appears as data in minValue field, not as control marker
   - v1.4 (2025-10-09): Corrected to 2 pages (0x00, 0x03), not 3 pages. Updated to reflect working code.
   - v1.3 (2025-09-30): Documented read slot byte behavior for DAW port integration
@@ -77,7 +78,7 @@ types:
         contents: [0x06, 0x20]
       - id: name_length
         type: u1
-        doc: Length of mode name (0-8 characters)
+        doc: Length of mode name (0-18 characters)
       - id: name_bytes
         size: name_length
         type: str
@@ -93,6 +94,9 @@ types:
       Discovery: Web editor MIDI capture (2025-09-30)
       Example: 20 08 43 48 41 4E 54 45 53 54 = "CHANTEST" (8 chars)
 
+      Note: The device supports mode names up to 18 characters.
+      Earlier documentation incorrectly stated 8 characters as the maximum.
+
   control_definition:
     doc: |
       11-byte control definition structure found in READ responses.
diff --git a/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts b/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts
index c8570a0..09c64bd 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/builders/CustomModeBuilder.ts
@@ -41,11 +41,11 @@ export class CustomModeBuilder {
   };
 
   /**
-   * Set the custom mode name (max 8 characters)
+   * Set the custom mode name (max 18 characters)
    */
   name(name: string): this {
-    if (name.length > 8) {
-      throw new Error('Mode name must be 8 characters or less');
+    if (name.length > 18) {
+      throw new Error('Mode name must be 18 characters or less');
     }
     this.modeName = name;
     return this;
@@ -338,4 +338,4 @@ export class CustomModeBuilder {
 
     this.controls.push(control);
   }
-}
\ No newline at end of file
+}
diff --git a/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts b/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
index 59ba4ed..b6016e7 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
+++ b/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
@@ -687,12 +687,12 @@ describe('SysExParser', () => {
         expect(decodedName).toBe('CHANNEVE');
       });
 
-      it('should limit mode name to 8 characters maximum', () => {
+      it('should limit mode name to 18 characters maximum', () => {
         const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
-          name: 'VERYLONGMODENAME', // 16 characters
+          name: 'EXACTLYEIGHTEENCHA', // Exactly 18 characters
           controls: [],
           colors: [],
           data: []
@@ -700,11 +700,31 @@ describe('SysExParser', () => {
 
         const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
 
-        // Check that up to 16 characters are encoded (Phase 2: new format)
-        const nameBytes = message.slice(14, 30); // 4-byte header + 16 chars
+        // Check that exactly 18 characters are encoded
+        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
         const decodedName = String.fromCharCode(...nameBytes);
 
-        expect(decodedName).toBe('VERYLONGMODENAME');
+        expect(decodedName).toBe('EXACTLYEIGHTEENCHA');
+      });
+
+      it('should truncate mode names longer than 18 characters', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'THISHASNINETEENCHAR', // 19 characters - should be truncated
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);
+
+        // Check that only first 18 characters are encoded
+        const nameBytes = message.slice(14, 32); // 4-byte header + 18 chars
+        const decodedName = String.fromCharCode(...nameBytes);
+
+        expect(decodedName).toBe('THISHASNINETEENCHA'); // Truncated to 18
       });
     });
 
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/README.md b/modules/audio-control/modules/launch-control-xl3/test/integration/README.md
index 1844c95..1c22671 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/integration/README.md
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/README.md
@@ -98,13 +98,31 @@ These tests are executable TypeScript files that can be run directly with `tsx`.
 
 #### 1. Custom Mode Write and Verify (`custom-mode-write-verify.test.ts`)
 
-**Purpose:** Validates that CustomMode API changes are correctly written to the device and can be read back with all modifications preserved.
+**Purpose:** Validates that CustomMode API changes are correctly written to the device and can be read back with all modifications preserved. **Now includes 18-character mode name testing.**
 
 **What it tests:**
 - âœ“ CustomMode read/write API
 - âœ“ Device firmware accepts valid modifications
 - âœ“ Data integrity through write/read cycle
 - âœ“ Control property changes (CC, channel, name)
+- âœ“ **18-character mode names** (protocol v2 validation)
+
+**Test Suites:**
+
+**Suite 1: Standard Property Changes**
+- Tests mode name changes (short names)
+- Tests control CC number modifications
+- Tests control MIDI channel changes
+- Tests control name changes
+- Typically validates 13-16 property changes
+
+**Suite 2: 18-Character Mode Names** (NEW)
+- Tests 17-character names (under limit)
+- Tests exactly 18-character names (at limit)
+- Tests 18-character names with mixed case
+- Tests 9-character names (over old 8-char limit)
+- Validates round-trip persistence
+- Character-by-character verification on mismatch
 
 **Test flow:**
 1. Read custom mode from slot 10 using library API
@@ -123,8 +141,17 @@ npx tsx test/integration/custom-mode-write-verify.test.ts
 ```
 
 **Expected results:**
-- All property changes should be preserved (name, CC numbers, channels)
-- Test saves detailed results to `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-*.json`
+- **Suite 1:** All property changes should be preserved (name, CC numbers, channels)
+- **Suite 2:** All 18-character mode names should write and read back identically
+- Test saves detailed results to:
+  - `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-*.json`
+  - `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-*.json`
+
+**Test cases for 18-character names:**
+- `17CharacterMode1` - 17 characters (under limit)
+- `EXACTLY18CHARSLONG` - Exactly 18 characters (at limit)
+- `18CharModeName123` - 18 characters with mixed case
+- `ShortName` - 9 characters (over old 8-char limit)
 
 **Related issues:** #36
 
@@ -234,8 +261,10 @@ Each standalone test defines its own success criteria:
    - âœ“ No data corruption in page 0 or page 3
 
 3. **custom-mode-write-verify.test.ts**
-   - âœ“ All property modifications preserved (name, CC, channel)
-   - âœ“ Typically 13-16 individual property changes verified
+   - âœ“ Suite 1: All property modifications preserved (name, CC, channel)
+   - âœ“ Suite 1: Typically 13-16 individual property changes verified
+   - âœ“ Suite 2: All 4 test cases for 18-character names pass
+   - âœ“ Suite 2: Names write and read back byte-for-byte identical
 
 #### Result Files
 
@@ -243,7 +272,8 @@ All standalone tests save detailed results to `/Users/orion/work/ol_dsp/modules/
 
 - `basic-read-operations-*.json` - Communication test results
 - `raw-midi-round-trip-*.json` - Byte-level comparison data
-- `custom-mode-write-verify-*.json` - Property verification details
+- `custom-mode-write-verify-standard-*.json` - Property verification details (Suite 1)
+- `custom-mode-write-verify-18char-*.json` - 18-character name test details (Suite 2)
 
 ---
 
@@ -287,11 +317,12 @@ Integration tests use a separate Vitest config:
 - **Property-level:** `custom-mode-write-verify.test.ts` validates structured data
 - **Communication:** `basic-read-operations.test.ts` validates protocol basics
 - **Slot selection:** `slot-selection.hardware.test.ts` validates pre-selection requirement
+- **18-char names:** `custom-mode-write-verify.test.ts` Suite 2 validates protocol v2 extended names
 
 ### Custom Mode Properties Validated
 
 The tests verify these CustomMode properties:
-- `name` (8 characters max)
+- `name` (18 characters max - protocol v2)
 - `controls` object with 48 control mappings
 - Control properties: `ccNumber`, `midiChannel`, `name`
 - Label parsing and encoding
@@ -364,6 +395,14 @@ Error: Device returned status 0x9 (slot not selected)
 - Load a factory preset into slot 10 using Components
 - Or use a different source slot by editing the test file
 
+#### 18-Character Mode Name Test Failures
+
+If Suite 2 tests fail:
+- Check that you're using the latest protocol version (v2)
+- Verify device firmware supports 18-character names
+- Check result JSON for character-by-character comparison
+- Ensure no truncation at 8 characters (old limit)
+
 #### Test timeouts
 
 - Increase delay times in test files (currently 1000ms for reads, 500ms for writes)
@@ -481,7 +520,9 @@ Total suite: ~30-60s
 
 - Basic read operations: ~5-10s
 - Raw MIDI round-trip: ~10-15s
-- Custom mode write/verify: ~15-20s
+- Custom mode write/verify (both suites): ~25-35s
+  - Suite 1 (standard): ~10-15s
+  - Suite 2 (18-char names): ~15-20s (4 test cases)
 
 ---
 
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-write-verify.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-write-verify.test.ts
index 9e2b912..9b39948 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-write-verify.test.ts
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/custom-mode-write-verify.test.ts
@@ -22,6 +22,7 @@
  *   - Device firmware accepts valid modifications
  *   - Data integrity through write/read cycle
  *   - Control property changes (CC, channel, name)
+ *   - 18-character mode names (new in protocol v2)
  *
  * Related Issues: #36
  *
@@ -63,323 +64,598 @@ async function main() {
     await device.connect();
     console.log('âœ“ Connected\n');
 
-    const sourceSlot = 10;
-    const targetSlot = 3;
+    // Run both test suites
+    let allTestsPassed = true;
 
-    // Step 1: Read from source slot
-    console.log(`Step 1: Reading custom mode from slot ${sourceSlot}...`);
-    const originalMode = await device.readCustomMode(sourceSlot);
+    // Test Suite 1: Standard property changes (original test)
+    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
+    console.log('â•‘          TEST SUITE 1: STANDARD PROPERTY CHANGES               â•‘');
+    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
 
-    if (!originalMode) {
-      console.log('âœ— Failed to read custom mode');
-      process.exit(1);
-    }
+    const suite1Passed = await testStandardPropertyChanges(device);
+    if (!suite1Passed) allTestsPassed = false;
 
-    console.log('âœ“ Read successful');
-    console.log(`  Name: "${originalMode.name}"`);
+    console.log('\n');
 
-    // Get control keys from the controls object
-    const controlKeys = Object.keys(originalMode.controls || {});
-    console.log(`  Controls: ${controlKeys.length}`);
-    console.log(`  Control keys: ${controlKeys.slice(0, 5).join(', ')}${controlKeys.length > 5 ? '...' : ''}`);
-    console.log();
+    // Test Suite 2: 18-character mode names
+    console.log('â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—');
+    console.log('â•‘          TEST SUITE 2: 18-CHARACTER MODE NAMES                 â•‘');
+    console.log('â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+    const suite2Passed = await test18CharacterModeNames(device);
+    if (!suite2Passed) allTestsPassed = false;
 
-    // Ensure controls object exists
-    if (!originalMode.controls || typeof originalMode.controls !== 'object') {
-      console.log('âœ— originalMode.controls is not an object');
+    // Overall Summary
+    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    console.log('OVERALL TEST RESULTS');
+    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    console.log(`Test Suite 1 (Standard Properties): ${suite1Passed ? 'âœ“ PASSED' : 'âœ— FAILED'}`);
+    console.log(`Test Suite 2 (18-char Mode Names): ${suite2Passed ? 'âœ“ PASSED' : 'âœ— FAILED'}`);
+    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+
+    if (allTestsPassed) {
+      console.log('âœ“ ALL TESTS PASSED');
+    } else {
+      console.log('âœ— SOME TESTS FAILED');
       process.exit(1);
     }
 
-    if (controlKeys.length === 0) {
-      console.log('âœ— No controls found in slot 10');
-      console.log('  Try a different source slot that has configured controls');
-      process.exit(1);
+  } catch (error) {
+    console.error('\nâœ— Test failed:', error instanceof Error ? error.message : String(error));
+    if (error instanceof Error && error.stack) {
+      console.error('\nStack trace:');
+      console.error(error.stack);
     }
+    process.exit(1);
+  } finally {
+    if (device) {
+      console.log('\nâ†’ Disconnecting...');
+      await device.disconnect();
+      console.log('âœ“ Disconnected');
+    }
+  }
+}
+
+/**
+ * Test Suite 1: Standard Property Changes (Original Test)
+ */
+async function testStandardPropertyChanges(device: LaunchControlXL3): Promise<boolean> {
+  const sourceSlot = 10;
+  const targetSlot = 3;
+
+  // Step 1: Read from source slot
+  console.log(`Step 1: Reading custom mode from slot ${sourceSlot}...`);
+  const originalMode = await device.readCustomMode(sourceSlot);
+
+  if (!originalMode) {
+    console.log('âœ— Failed to read custom mode');
+    return false;
+  }
+
+  console.log('âœ“ Read successful');
+  console.log(`  Name: "${originalMode.name}"`);
+
+  // Get control keys from the controls object
+  const controlKeys = Object.keys(originalMode.controls || {});
+  console.log(`  Controls: ${controlKeys.length}`);
+  console.log(`  Control keys: ${controlKeys.slice(0, 5).join(', ')}${controlKeys.length > 5 ? '...' : ''}`);
+  console.log();
+
+  // Ensure controls object exists
+  if (!originalMode.controls || typeof originalMode.controls !== 'object') {
+    console.log('âœ— originalMode.controls is not an object');
+    return false;
+  }
+
+  if (controlKeys.length === 0) {
+    console.log('âœ— No controls found in slot 10');
+    console.log('  Try a different source slot that has configured controls');
+    return false;
+  }
+
+  // Step 2: Make valid changes to the mode
+  console.log('Step 2: Making valid changes to custom mode...\n');
 
-    // Step 2: Make valid changes to the mode
-    console.log('Step 2: Making valid changes to custom mode...\n');
+  const changes: TestChange[] = [];
 
-    const changes: TestChange[] = [];
+  // Clone the mode - deep copy the controls object
+  const modifiedMode: CustomMode = {
+    name: 'TESTMOD',
+    controls: { ...originalMode.controls },
+    colors: originalMode.colors,
+    labels: originalMode.labels,
+    leds: originalMode.leds
+  };
 
-    // Clone the mode - deep copy the controls object
-    const modifiedMode: CustomMode = {
-      name: 'TESTMOD',
-      controls: { ...originalMode.controls },
-      colors: originalMode.colors,
-      labels: originalMode.labels,
-      leds: originalMode.leds
-    };
+  // Deep clone each control
+  for (const key in modifiedMode.controls) {
+    modifiedMode.controls[key] = { ...originalMode.controls[key] };
+  }
 
-    // Deep clone each control
-    for (const key in modifiedMode.controls) {
-      modifiedMode.controls[key] = { ...originalMode.controls[key] };
+  // Track mode name change
+  changes.push({
+    description: 'Mode name',
+    originalValue: originalMode.name,
+    newValue: modifiedMode.name,
+    verified: false
+  });
+
+  // Modify first 5 controls (if they exist)
+  const controlsToModify = Math.min(5, controlKeys.length);
+
+  for (let i = 0; i < controlsToModify; i++) {
+    const key = controlKeys[i];
+    const control = modifiedMode.controls[key];
+
+    // Change CC number (use ccNumber property, not cc)
+    const originalCC = control.ccNumber || control.cc || 0;
+    const newCC = (originalCC + 10) % 120; // Stay within valid range
+    control.ccNumber = newCC;
+    if (control.cc !== undefined) {
+      control.cc = newCC; // Update both if cc exists
     }
 
-    // Track mode name change
     changes.push({
-      description: 'Mode name',
-      originalValue: originalMode.name,
-      newValue: modifiedMode.name,
+      description: `Control ${key} CC`,
+      originalValue: originalCC,
+      newValue: newCC,
       verified: false
     });
 
-    // Modify first 5 controls (if they exist)
-    const controlsToModify = Math.min(5, controlKeys.length);
-
-    for (let i = 0; i < controlsToModify; i++) {
-      const key = controlKeys[i];
-      const control = modifiedMode.controls[key];
-
-      // Change CC number (use ccNumber property, not cc)
-      const originalCC = control.ccNumber || control.cc || 0;
-      const newCC = (originalCC + 10) % 120; // Stay within valid range
-      control.ccNumber = newCC;
-      if (control.cc !== undefined) {
-        control.cc = newCC; // Update both if cc exists
-      }
+    // Change control name (if it exists)
+    if (control.name !== undefined) {
+      const originalName = control.name;
+      const newName = `TST_${i}`;
+      control.name = newName;
 
       changes.push({
-        description: `Control ${key} CC`,
-        originalValue: originalCC,
-        newValue: newCC,
+        description: `Control ${key} name`,
+        originalValue: originalName,
+        newValue: newName,
         verified: false
       });
+    }
 
-      // Change control name (if it exists)
-      if (control.name !== undefined) {
-        const originalName = control.name;
-        const newName = `TST_${i}`;
-        control.name = newName;
-
-        changes.push({
-          description: `Control ${key} name`,
-          originalValue: originalName,
-          newValue: newName,
-          verified: false
-        });
-      }
+    // Change channel (use midiChannel property, not channel)
+    const originalChannel = control.midiChannel ?? control.channel ?? 0;
+    const newChannel = (originalChannel % 16);
+    control.midiChannel = newChannel;
+    if (control.channel !== undefined) {
+      control.channel = newChannel; // Update both if channel exists
+    }
+
+    changes.push({
+      description: `Control ${key} channel`,
+      originalValue: originalChannel,
+      newValue: newChannel,
+      verified: false
+    });
+  }
 
-      // Change channel (use midiChannel property, not channel)
-      const originalChannel = control.midiChannel ?? control.channel ?? 0;
-      const newChannel = (originalChannel % 16);
-      control.midiChannel = newChannel;
-      if (control.channel !== undefined) {
-        control.channel = newChannel; // Update both if channel exists
+  console.log('Changes to be made:');
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+  changes.forEach((change, idx) => {
+    console.log(`  ${idx + 1}. ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+  });
+  console.log();
+
+  // Step 3: Write modified mode to target slot
+  console.log(`Step 3: Writing modified mode to slot ${targetSlot}...`);
+  await device.writeCustomMode(targetSlot, modifiedMode);
+  console.log('âœ“ Write completed\n');
+
+  // Wait for device to process
+  console.log('Waiting for device to settle...');
+  await new Promise(resolve => setTimeout(resolve, 1000));
+  console.log();
+
+  // Step 4: Read back from target slot
+  console.log(`Step 4: Reading back from slot ${targetSlot}...`);
+  const readBackMode = await device.readCustomMode(targetSlot);
+
+  if (!readBackMode) {
+    console.log('âœ— Failed to read back custom mode');
+    return false;
+  }
+
+  console.log('âœ“ Read-back successful');
+  console.log(`  Name: "${readBackMode.name}"`);
+  const readBackKeys = Object.keys(readBackMode.controls || {});
+  console.log(`  Controls: ${readBackKeys.length}`);
+  console.log();
+
+  // Step 5: Verify all changes were preserved
+  console.log('Step 5: Verifying changes...\n');
+
+  // Verify mode name
+  changes[0].verified = readBackMode.name === modifiedMode.name;
+
+  // Verify control changes
+  let changeIdx = 1; // Start after mode name
+  for (let i = 0; i < controlsToModify; i++) {
+    const key = controlKeys[i];
+    const modifiedControl = modifiedMode.controls[key];
+    const readBackControl = readBackMode.controls?.[key];
+
+    if (readBackControl) {
+      // Verify CC (check both ccNumber and cc properties)
+      const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+      const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+      changes[changeIdx].verified = readBackCC === modifiedCC;
+      changeIdx++;
+
+      // Verify name (if it was changed)
+      if (modifiedControl.name !== undefined) {
+        changes[changeIdx].verified = readBackControl.name === modifiedControl.name;
+        changeIdx++;
       }
 
-      changes.push({
-        description: `Control ${key} channel`,
-        originalValue: originalChannel,
-        newValue: newChannel,
-        verified: false
-      });
+      // Verify channel (check both midiChannel and channel properties)
+      const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+      const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+      changes[changeIdx].verified = readBackChannel === modifiedChannel;
+      changeIdx++;
+    } else {
+      // Control doesn't exist in read-back
+      console.log(`  âš  Control ${key} missing in read-back`);
+      changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
     }
+  }
 
-    console.log('Changes to be made:');
-    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
-    changes.forEach((change, idx) => {
-      console.log(`  ${idx + 1}. ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
-    });
-    console.log();
-
-    // Step 3: Write modified mode to target slot
-    console.log(`Step 3: Writing modified mode to slot ${targetSlot}...`);
-    await device.writeCustomMode(targetSlot, modifiedMode);
-    console.log('âœ“ Write completed\n');
+  // Display verification results
+  console.log('Verification Results:');
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
 
-    // Wait for device to process
-    console.log('Waiting for device to settle...');
-    await new Promise(resolve => setTimeout(resolve, 1000));
-    console.log();
+  let passCount = 0;
+  let failCount = 0;
 
-    // Step 4: Read back from target slot
-    console.log(`Step 4: Reading back from slot ${targetSlot}...`);
-    const readBackMode = await device.readCustomMode(targetSlot);
+  changes.forEach((change, idx) => {
+    const status = change.verified ? 'âœ“' : 'âœ—';
+    console.log(`  ${status} ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
 
-    if (!readBackMode) {
-      console.log('âœ— Failed to read back custom mode');
-      process.exit(1);
+    if (change.verified) {
+      passCount++;
+    } else {
+      failCount++;
     }
+  });
 
-    console.log('âœ“ Read-back successful');
-    console.log(`  Name: "${readBackMode.name}"`);
-    const readBackKeys = Object.keys(readBackMode.controls || {});
-    console.log(`  Controls: ${readBackKeys.length}`);
-    console.log();
+  console.log();
+  console.log(`  Passed: ${passCount}/${changes.length}`);
+  console.log(`  Failed: ${failCount}/${changes.length}`);
 
-    // Step 5: Verify all changes were preserved
-    console.log('Step 5: Verifying changes...\n');
+  // Detailed comparison for failures
+  if (failCount > 0) {
+    console.log('\nDetailed failure analysis:');
+    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
 
-    // Verify mode name
-    changes[0].verified = readBackMode.name === modifiedMode.name;
+    // Check mode name
+    if (!changes[0].verified) {
+      console.log(`  Mode name: expected "${modifiedMode.name}", got "${readBackMode.name}"`);
+    }
 
-    // Verify control changes
-    let changeIdx = 1; // Start after mode name
+    // Check controls
+    let changeIdx = 1;
     for (let i = 0; i < controlsToModify; i++) {
       const key = controlKeys[i];
       const modifiedControl = modifiedMode.controls[key];
       const readBackControl = readBackMode.controls?.[key];
 
       if (readBackControl) {
-        // Verify CC (check both ccNumber and cc properties)
-        const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
-        const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
-        changes[changeIdx].verified = readBackCC === modifiedCC;
+        // CC check
+        if (!changes[changeIdx].verified) {
+          const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
+          const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
+          console.log(`  Control ${key} CC: expected ${modifiedCC}, got ${readBackCC}`);
+        }
         changeIdx++;
 
-        // Verify name (if it was changed)
+        // Name check (if it exists)
         if (modifiedControl.name !== undefined) {
-          changes[changeIdx].verified = readBackControl.name === modifiedControl.name;
+          if (!changes[changeIdx].verified) {
+            console.log(`  Control ${key} name: expected "${modifiedControl.name}", got "${readBackControl.name}"`);
+          }
           changeIdx++;
         }
 
-        // Verify channel (check both midiChannel and channel properties)
-        const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
-        const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
-        changes[changeIdx].verified = readBackChannel === modifiedChannel;
+        // Channel check
+        if (!changes[changeIdx].verified) {
+          const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
+          const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
+          console.log(`  Control ${key} channel: expected ${modifiedChannel}, got ${readBackChannel}`);
+        }
         changeIdx++;
       } else {
-        // Control doesn't exist in read-back
-        console.log(`  âš  Control ${key} missing in read-back`);
+        console.log(`  Control ${key}: MISSING in read-back`);
         changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
       }
     }
+  }
 
-    // Display verification results
-    console.log('Verification Results:');
-    console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+  // Overall result
+  const allPassed = failCount === 0;
 
-    let passCount = 0;
-    let failCount = 0;
+  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+  console.log('SUITE 1 RESULT');
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
 
-    changes.forEach((change, idx) => {
-      const status = change.verified ? 'âœ“' : 'âœ—';
-      console.log(`  ${status} ${change.description}: ${JSON.stringify(change.originalValue)} â†’ ${JSON.stringify(change.newValue)}`);
+  if (allPassed) {
+    console.log('âœ“ TEST PASSED');
+    console.log(`  All ${changes.length} changes were preserved correctly`);
+    console.log('  Device firmware accepted and stored valid modifications');
+  } else {
+    console.log('âœ— TEST FAILED');
+    console.log(`  ${failCount} out of ${changes.length} changes were NOT preserved`);
+    console.log('  Some valid modifications were lost or corrupted');
+  }
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
 
-      if (change.verified) {
-        passCount++;
-      } else {
-        failCount++;
-      }
-    });
+  // Save results
+  const results = {
+    timestamp: new Date().toISOString(),
+    testSuite: 'standard-property-changes',
+    sourceSlot,
+    targetSlot,
+    totalChanges: changes.length,
+    passedChanges: passCount,
+    failedChanges: failCount,
+    testPassed: allPassed,
+    changes: changes.map(c => ({
+      description: c.description,
+      originalValue: c.originalValue,
+      newValue: c.newValue,
+      verified: c.verified
+    })),
+    originalMode: {
+      name: originalMode.name,
+      controlCount: controlKeys.length
+    },
+    modifiedMode: {
+      name: modifiedMode.name,
+      controlCount: Object.keys(modifiedMode.controls).length
+    },
+    readBackMode: {
+      name: readBackMode.name,
+      controlCount: readBackKeys.length
+    }
+  };
 
-    console.log();
-    console.log(`  Passed: ${passCount}/${changes.length}`);
-    console.log(`  Failed: ${failCount}/${changes.length}`);
+  const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-standard-${Date.now()}.json`;
+  writeFileSync(resultsPath, JSON.stringify(results, null, 2));
+  console.log(`Results saved to: ${resultsPath}\n`);
 
-    // Detailed comparison for failures
-    if (failCount > 0) {
-      console.log('\nDetailed failure analysis:');
-      console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+  return allPassed;
+}
 
-      // Check mode name
-      if (!changes[0].verified) {
-        console.log(`  Mode name: expected "${modifiedMode.name}", got "${readBackMode.name}"`);
+/**
+ * Test Suite 2: 18-Character Mode Names
+ * Tests the new protocol support for extended mode names (up to 18 characters)
+ */
+async function test18CharacterModeNames(device: LaunchControlXL3): Promise<boolean> {
+  const sourceSlot = 10;
+  const targetSlot = 3;
+
+  console.log('Testing 18-character mode name support...\n');
+  console.log('This validates the protocol change from 8 to 18 character limit.\n');
+
+  // Read baseline mode
+  console.log(`Step 1: Reading baseline from slot ${sourceSlot}...`);
+  const baselineMode = await device.readCustomMode(sourceSlot);
+
+  if (!baselineMode) {
+    console.log('âœ— Failed to read baseline mode');
+    return false;
+  }
+
+  console.log('âœ“ Read successful\n');
+
+  // Test cases for 18-character names
+  const testCases = [
+    {
+      name: '17CharacterMode1',
+      description: '17 characters (under limit)',
+      expectedLength: 17,
+      shouldSucceed: true
+    },
+    {
+      name: 'EXACTLY18CHARSLONG',
+      description: 'Exactly 18 characters (at limit)',
+      expectedLength: 18,
+      shouldSucceed: true
+    },
+    {
+      name: '18CharModeName123',
+      description: '18 characters with mixed case',
+      expectedLength: 18,
+      shouldSucceed: true
+    },
+    {
+      name: 'ShortName',
+      description: 'Short name (9 characters, over old limit)',
+      expectedLength: 9,
+      shouldSucceed: true
+    }
+  ];
+
+  const results: Array<{
+    testCase: typeof testCases[0];
+    written: boolean;
+    readBack: string | null;
+    verified: boolean;
+    error?: string;
+  }> = [];
+
+  // Run each test case
+  for (let i = 0; i < testCases.length; i++) {
+    const testCase = testCases[i];
+    console.log(`\nâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
+    console.log(`Test Case ${i + 1}/${testCases.length}: ${testCase.description}`);
+    console.log(`â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€`);
+    console.log(`  Name: "${testCase.name}"`);
+    console.log(`  Length: ${testCase.name.length} characters`);
+    console.log(`  Expected: ${testCase.expectedLength} characters`);
+    console.log();
+
+    let written = false;
+    let readBack: string | null = null;
+    let verified = false;
+    let error: string | undefined;
+
+    try {
+      // Create mode with test name
+      const testMode: CustomMode = {
+        ...baselineMode,
+        name: testCase.name,
+        controls: { ...baselineMode.controls }
+      };
+
+      // Deep clone controls
+      for (const key in testMode.controls) {
+        testMode.controls[key] = { ...baselineMode.controls[key] };
       }
 
-      // Check controls
-      let changeIdx = 1;
-      for (let i = 0; i < controlsToModify; i++) {
-        const key = controlKeys[i];
-        const modifiedControl = modifiedMode.controls[key];
-        const readBackControl = readBackMode.controls?.[key];
+      // Write to device
+      console.log(`  â†’ Writing to slot ${targetSlot}...`);
+      await device.writeCustomMode(targetSlot, testMode);
+      written = true;
+      console.log(`  âœ“ Write successful`);
 
-        if (readBackControl) {
-          // CC check
-          if (!changes[changeIdx].verified) {
-            const modifiedCC = modifiedControl.ccNumber ?? modifiedControl.cc;
-            const readBackCC = readBackControl.ccNumber ?? readBackControl.cc;
-            console.log(`  Control ${key} CC: expected ${modifiedCC}, got ${readBackCC}`);
-          }
-          changeIdx++;
+      // Wait for device to settle
+      await new Promise(resolve => setTimeout(resolve, 1000));
 
-          // Name check (if it exists)
-          if (modifiedControl.name !== undefined) {
-            if (!changes[changeIdx].verified) {
-              console.log(`  Control ${key} name: expected "${modifiedControl.name}", got "${readBackControl.name}"`);
-            }
-            changeIdx++;
-          }
+      // Read back
+      console.log(`  â†’ Reading back from slot ${targetSlot}...`);
+      const readBackMode = await device.readCustomMode(targetSlot);
 
-          // Channel check
-          if (!changes[changeIdx].verified) {
-            const modifiedChannel = modifiedControl.midiChannel ?? modifiedControl.channel;
-            const readBackChannel = readBackControl.midiChannel ?? readBackControl.channel;
-            console.log(`  Control ${key} channel: expected ${modifiedChannel}, got ${readBackChannel}`);
+      if (!readBackMode) {
+        throw new Error('Failed to read back mode');
+      }
+
+      readBack = readBackMode.name;
+      console.log(`  âœ“ Read successful`);
+      console.log(`  Read name: "${readBack}"`);
+      console.log(`  Read length: ${readBack.length} characters`);
+
+      // Verify
+      if (readBack === testCase.name) {
+        verified = true;
+        console.log(`  âœ“ VERIFIED: Name matches exactly`);
+      } else {
+        verified = false;
+        console.log(`  âœ— MISMATCH:`);
+        console.log(`    Expected: "${testCase.name}"`);
+        console.log(`    Got:      "${readBack}"`);
+
+        // Detailed comparison
+        if (readBack.length !== testCase.name.length) {
+          console.log(`    Length mismatch: expected ${testCase.name.length}, got ${readBack.length}`);
+        }
+
+        // Character-by-character comparison
+        for (let j = 0; j < Math.max(testCase.name.length, readBack.length); j++) {
+          const expected = testCase.name[j] || '(none)';
+          const actual = readBack[j] || '(none)';
+          if (expected !== actual) {
+            console.log(`    Position ${j}: expected '${expected}', got '${actual}'`);
           }
-          changeIdx++;
-        } else {
-          console.log(`  Control ${key}: MISSING in read-back`);
-          changeIdx += (modifiedControl.name !== undefined ? 3 : 2);
         }
       }
-    }
 
-    // Overall result
-    const allPassed = failCount === 0;
+    } catch (err) {
+      error = err instanceof Error ? err.message : String(err);
+      console.log(`  âœ— ERROR: ${error}`);
+    }
 
-    console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
-    console.log('RESULT');
-    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+    results.push({
+      testCase,
+      written,
+      readBack,
+      verified,
+      error
+    });
 
-    if (allPassed) {
-      console.log('âœ“ TEST PASSED');
-      console.log(`  All ${changes.length} changes were preserved correctly`);
-      console.log('  Device firmware accepted and stored valid modifications');
-    } else {
-      console.log('âœ— TEST FAILED');
-      console.log(`  ${failCount} out of ${changes.length} changes were NOT preserved`);
-      console.log('  Some valid modifications were lost or corrupted');
+    // Small delay between test cases
+    if (i < testCases.length - 1) {
+      await new Promise(resolve => setTimeout(resolve, 500));
     }
-    console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
-
-    // Save results
-    const results = {
-      timestamp: new Date().toISOString(),
-      sourceSlot,
-      targetSlot,
-      totalChanges: changes.length,
-      passedChanges: passCount,
-      failedChanges: failCount,
-      testPassed: allPassed,
-      changes: changes.map(c => ({
-        description: c.description,
-        originalValue: c.originalValue,
-        newValue: c.newValue,
-        verified: c.verified
-      })),
-      originalMode: {
-        name: originalMode.name,
-        controlCount: controlKeys.length
-      },
-      modifiedMode: {
-        name: modifiedMode.name,
-        controlCount: Object.keys(modifiedMode.controls).length
-      },
-      readBackMode: {
-        name: readBackMode.name,
-        controlCount: readBackKeys.length
-      }
-    };
+  }
 
-    const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-${Date.now()}.json`;
-    writeFileSync(resultsPath, JSON.stringify(results, null, 2));
-    console.log(`Results saved to: ${resultsPath}\n`);
+  // Summary
+  console.log('\nâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•');
+  console.log('SUITE 2 RESULTS SUMMARY');
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
 
-  } catch (error) {
-    console.error('\nâœ— Test failed:', error instanceof Error ? error.message : String(error));
-    if (error instanceof Error && error.stack) {
-      console.error('\nStack trace:');
-      console.error(error.stack);
-    }
-    process.exit(1);
-  } finally {
-    if (device) {
-      console.log('â†’ Disconnecting...');
-      await device.disconnect();
-      console.log('âœ“ Disconnected');
+  let passCount = 0;
+  let failCount = 0;
+
+  results.forEach((result, idx) => {
+    const status = result.verified ? 'âœ“ PASS' : 'âœ— FAIL';
+    console.log(`${status} Test ${idx + 1}: ${result.testCase.description}`);
+    console.log(`     Name: "${result.testCase.name}" (${result.testCase.name.length} chars)`);
+
+    if (result.verified) {
+      console.log(`     Result: Successfully written and verified`);
+      passCount++;
+    } else if (result.error) {
+      console.log(`     Result: Error - ${result.error}`);
+      failCount++;
+    } else {
+      console.log(`     Result: Written but mismatch on read-back`);
+      console.log(`     Read back: "${result.readBack}"`);
+      failCount++;
     }
+    console.log();
+  });
+
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€');
+  console.log(`Total: ${results.length} tests`);
+  console.log(`Passed: ${passCount}`);
+  console.log(`Failed: ${failCount}`);
+  console.log('â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n');
+
+  const allPassed = failCount === 0;
+
+  if (allPassed) {
+    console.log('âœ“ ALL 18-CHARACTER MODE NAME TESTS PASSED');
+    console.log('  Device correctly supports mode names up to 18 characters');
+    console.log('  Protocol change validated successfully');
+  } else {
+    console.log('âœ— SOME 18-CHARACTER MODE NAME TESTS FAILED');
+    console.log(`  ${failCount} out of ${results.length} tests did not pass`);
+    console.log('  Device may not fully support 18-character names');
   }
+
+  console.log('â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\n');
+
+  // Save detailed results
+  const detailedResults = {
+    timestamp: new Date().toISOString(),
+    testSuite: '18-character-mode-names',
+    sourceSlot,
+    targetSlot,
+    totalTests: results.length,
+    passedTests: passCount,
+    failedTests: failCount,
+    testPassed: allPassed,
+    testCases: results.map(r => ({
+      description: r.testCase.description,
+      name: r.testCase.name,
+      nameLength: r.testCase.name.length,
+      expectedLength: r.testCase.expectedLength,
+      shouldSucceed: r.testCase.shouldSucceed,
+      written: r.written,
+      readBack: r.readBack,
+      readBackLength: r.readBack?.length ?? null,
+      verified: r.verified,
+      error: r.error
+    }))
+  };
+
+  const resultsPath = `/Users/orion/work/ol_dsp/modules/audio-control/tmp/custom-mode-write-verify-18char-${Date.now()}.json`;
+  writeFileSync(resultsPath, JSON.stringify(detailedResults, null, 2));
+  console.log(`Detailed results saved to: ${resultsPath}\n`);
+
+  return allPassed;
 }
 
 main().catch(console.error);
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/test-18-char-mode-name.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/test-18-char-mode-name.ts
new file mode 100755
index 0000000..da46705
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/test-18-char-mode-name.ts
@@ -0,0 +1,111 @@
+#!/usr/bin/env tsx
+/**
+ * Integration test to validate 18-character mode names work with actual device
+ * 
+ * This test:
+ * 1. Creates a mode with an 18-character name
+ * 2. Writes it to the device
+ * 3. Reads it back
+ * 4. Verifies the name persists correctly
+ */
+
+import { NodeMidiBackend } from '@/backends/NodeMidiBackend.js';
+import { MidiInterface } from '@/core/MidiInterface.js';
+import { DeviceManager } from '@/device/DeviceManager.js';
+import { CustomModeBuilder } from '@/builders/CustomModeBuilder.js';
+
+const DEVICE_NAME = 'LCXL3 1'; // Matches both 'LCXL3 1 MIDI Out' and 'LCXL3 1 MIDI In'
+const TEST_SLOT = 14; // Use slot 14 for testing to avoid overwriting user data
+
+async function main() {
+  console.log('=== 18-Character Mode Name Integration Test ===\n');
+
+  // Initialize MIDI backend
+  const backend = new NodeMidiBackend();
+  await backend.initialize();
+
+  const midi = new MidiInterface(backend);
+  await midi.initialize();
+
+  // Find device
+  const outputPorts = await midi.getOutputPorts();
+  const inputPorts = await midi.getInputPorts();
+  
+  const outputPort = outputPorts.find(p => p.name.includes(DEVICE_NAME));
+  const inputPort = inputPorts.find(p => p.name.includes(DEVICE_NAME));
+
+  if (!outputPort || !inputPort) {
+    console.error('âŒ Device not found. Please ensure Launch Control XL3 is connected.');
+    console.log('\nAvailable output ports:', outputPorts.map(p => p.name));
+    console.log('Available input ports:', inputPorts.map(p => p.name));
+    process.exit(1);
+  }
+
+  console.log(`âœ“ Found device: ${outputPort.name}`);
+
+  // Connect to device
+  await midi.openInput(inputPort.id);
+  await midi.openOutput(outputPort.id);
+
+  const deviceManager = new DeviceManager(midi);
+
+  try {
+    // Step 1: Create mode with 18-character name
+    const eighteenCharName = 'EXACTLY18CHARSLONG'; // Exactly 18 characters
+    console.log(`\n1. Creating mode with 18-character name: "${eighteenCharName}"`);
+    console.log(`   Length: ${eighteenCharName.length} characters`);
+
+    const mode = new CustomModeBuilder()
+      .name(eighteenCharName)
+      .addFader(1, { cc: 10, channel: 1 })
+      .addEncoder(1, 1, { cc: 13, channel: 1 })
+      .addEncoderLabel(1, 1, 'Test')
+      .build();
+
+    console.log(`âœ“ Mode created successfully`);
+
+    // Step 2: Write mode to slot 14
+    console.log(`\n2. Writing mode to slot ${TEST_SLOT}...`);
+    await deviceManager.writeCustomMode(TEST_SLOT, mode);
+    console.log(`âœ“ Mode written successfully`);
+
+    // Wait a bit for device to settle
+    await new Promise(resolve => setTimeout(resolve, 500));
+
+    // Step 3: Read back from slot 14
+    console.log(`\n3. Reading mode back from slot ${TEST_SLOT}...`);
+    const readMode = await deviceManager.readCustomMode(TEST_SLOT);
+    console.log(`âœ“ Mode read successfully`);
+
+    // Step 4: Verify the name
+    console.log(`\n4. Verifying mode name...`);
+    console.log(`   Expected: "${eighteenCharName}" (${eighteenCharName.length} chars)`);
+    console.log(`   Received: "${readMode.name}" (${readMode.name.length} chars)`);
+
+    if (readMode.name === eighteenCharName) {
+      console.log(`\nâœ… SUCCESS: 18-character mode name persisted correctly!`);
+      process.exit(0);
+    } else if (readMode.name.startsWith(eighteenCharName.substring(0, 8))) {
+      console.log(`\nâš ï¸  WARNING: Mode name was truncated to 8 characters`);
+      console.log(`   This suggests the device firmware may have an 8-character limit,`);
+      console.log(`   not the 18-character limit we expected.`);
+      process.exit(1);
+    } else {
+      console.log(`\nâŒ FAIL: Mode name mismatch`);
+      console.log(`   Expected: "${eighteenCharName}"`);
+      console.log(`   Got: "${readMode.name}"`);
+      process.exit(1);
+    }
+
+  } catch (error: any) {
+    console.error(`\nâŒ Test failed:`, error.message);
+    process.exit(1);
+  } finally {
+    await midi.cleanup();
+  }
+}
+
+main().catch(err => {
+  console.error('Fatal error:', err);
+  process.exit(1);
+});


---

_**Agent (<synthetic>)**_

Prompt is too long

