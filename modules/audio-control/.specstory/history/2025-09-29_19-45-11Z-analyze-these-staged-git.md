<!-- Generated by SpecStory -->

# Web MIDI Automation for Launch Control XL 3 (2025-09-29 19:45:11Z)

<!-- Claude Code Session 6713264f-2a8e-4a34-b4a5-0b9406078fb3 (2025-09-29_19-45-11Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-PROTOCOL-FIX-REMAINING.md b/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-PROTOCOL-FIX-REMAINING.md
new file mode 100644
index 0000000..d9664c5
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-PROTOCOL-FIX-REMAINING.md
@@ -0,0 +1,250 @@
+# Workplan: Remaining Protocol Fixes Required
+
+## Executive Summary
+
+**UPDATE (2025-09-29)**: Critical fixes have been implemented. The library now sends the full control structure (1500+ bytes instead of 30 bytes). All 48 controls are being sent with correct structure. Some slots still timeout on read-back which may be a device-specific issue.
+
+## Implementation Status
+
+✅ **FIXED**: Control field name mismatch - now accepts both 'id' and 'controlId'
+✅ **FIXED**: Removed incorrect 0x28 offset from all control IDs
+✅ **FIXED**: Control type mapping based on position
+✅ **FIXED**: Control structure now matches web editor format
+✅ **VERIFIED**: Write messages are now 1500+ bytes with all 48 controls
+
+## Critical Issues Found (2025-09-29)
+
+### 🚨 Issue 1: Control Data Not Being Sent
+
+**Problem**: The library sends ONLY the name (about 30 bytes), not the full control structure (should be ~800 bytes)
+
+**Root Cause**: Control filtering bug in `SysExParser.encodeCustomModeData()`:
+```typescript
+// This filters out ALL controls because they have 'id' not 'controlId'!
+const sortedControls = Object.values(modeData.controls)
+  .filter(control => control.controlId !== undefined)  // <-- BUG: Wrong field name
+```
+
+**Evidence**:
+- Test sends: `0xf0...0x45 0x01 0x01 0x20 0x10 0x2a [NAME] 0xf7` (only ~30 bytes)
+- Should send: Full 342-800 byte message with all control definitions
+
+**Fix Required**:
+1. Change filter to use correct field name (`id` or make consistent)
+2. OR add `controlId` mapping when converting from test format
+
+---
+
+### 🚨 Issue 2: Control ID Offset Bug
+
+**Problem**: Code adds incorrect 0x28 offset to control IDs
+
+**Location**: `SysExParser.encodeCustomModeData()` line ~587:
+```typescript
+rawData.push((control.controlId ?? 0) + 0x28); // WRONG! Should not add offset
+```
+
+**Fix Required**: Remove the `+ 0x28` offset. Control IDs should be used directly.
+
+---
+
+### 🚨 Issue 3: Control Type Mapping Still Incorrect
+
+**Problem**: Control types are being mapped incorrectly from string to number
+
+**Current Code**:
+```typescript
+const controlTypeNum = typeof controlType === 'string' ?
+  (controlType === 'knob' ? 0x05 : controlType === 'fader' ? 0x00 : controlType === 'button' ? 0x09 : 0x00) :
+  controlType;
+```
+
+**Should Be** (based on web editor capture):
+- Encoders row 1 (0-7): type 0x05
+- Encoders row 2 (8-15): type 0x09
+- Encoders row 3 (16-23): type 0x0D
+- Faders: type 0x00
+- Buttons row 1: type 0x19
+- Buttons row 2: type 0x25
+
+---
+
+### 🚨 Issue 4: Missing Control Structure Fields
+
+**Problem**: Control structure incomplete - missing required fields
+
+**Web Editor Format** (per control):
+```
+49 [ID] 02 [TYPE] 00 01 40 00 [CC] 7F 00
+```
+
+**Current Implementation**: Missing several fixed bytes and using wrong structure
+
+---
+
+## Implementation Tasks
+
+### Task 1: Fix Control Field Name Mismatch (CRITICAL)
+
+**File**: `src/core/SysExParser.ts`
+
+**Change**:
+```typescript
+// FROM:
+const sortedControls = Object.values(modeData.controls)
+  .filter(control => control.controlId !== undefined)
+
+// TO:
+const sortedControls = Object.values(modeData.controls)
+  .filter(control => control.id !== undefined || control.controlId !== undefined)
+  .map(control => ({
+    ...control,
+    controlId: control.controlId ?? control.id ?? 0
+  }))
+```
+
+### Task 2: Remove Control ID Offset (CRITICAL)
+
+**File**: `src/core/SysExParser.ts`
+
+**Change**:
+```typescript
+// FROM:
+rawData.push((control.controlId ?? 0) + 0x28);
+
+// TO:
+rawData.push(control.controlId ?? 0);
+```
+
+### Task 3: Fix Control Type Assignment (HIGH)
+
+**File**: `src/core/SysExParser.ts`
+
+**Replace entire type mapping with**:
+```typescript
+private static getControlType(control: any): number {
+  const index = control.index ?? 0;
+  const type = control.type ?? control.controlType;
+
+  if (type === 'encoder' || type === 'knob') {
+    if (index < 8) return 0x05;      // Top row
+    if (index < 16) return 0x09;     // Middle row
+    return 0x0D;                      // Bottom row
+  }
+  if (type === 'fader') return 0x00;
+  if (type === 'button') {
+    if (index < 8) return 0x19;      // First row
+    return 0x25;                      // Second row
+  }
+  return 0x00;
+}
+```
+
+### Task 4: Complete Control Definition Structure (HIGH)
+
+**File**: `src/core/SysExParser.ts`
+
+**Update control encoding to match web editor**:
+```typescript
+// For each control, write exactly 11 bytes:
+rawData.push(0x49);                          // Control marker
+rawData.push(this.getControlId(control));    // Control ID (0x10-0x3F)
+rawData.push(0x02);                          // Always 0x02
+rawData.push(this.getControlType(control));  // Type based on position
+rawData.push(0x00);                          // Always 0x00
+rawData.push(0x01);                          // Always 0x01
+rawData.push(0x40);                          // Always 0x40 (was 0x48)
+rawData.push(0x00);                          // Always 0x00
+rawData.push(control.cc ?? 0);               // CC number
+rawData.push(0x7F);                          // Max value
+rawData.push(0x00);                          // Reserved
+```
+
+### Task 5: Add Control Labels and Colors (MEDIUM)
+
+**Add after control definitions**:
+```typescript
+// Add control labels (0x69 markers)
+for (const control of sortedControls) {
+  if (control.name) {
+    rawData.push(0x69);
+    rawData.push(this.getControlId(control));
+    rawData.push(...Array.from(control.name).map(c => c.charCodeAt(0)));
+  }
+}
+
+// Add LED colors (0x60 markers)
+for (const control of sortedControls) {
+  rawData.push(0x60);
+  rawData.push(this.getControlId(control));
+  rawData.push(control.color ?? 0x0C);  // Default to red
+}
+```
+
+### Task 6: Fix Control ID Mapping (HIGH)
+
+**Implement proper control ID assignment**:
+```typescript
+private static getControlId(control: any): number {
+  const type = control.type ?? control.controlType;
+  const index = control.index ?? 0;
+
+  if (type === 'encoder' || type === 'knob') {
+    // Encoders: 0x10-0x27 (24 total)
+    return 0x10 + index;
+  } else if (type === 'fader') {
+    // Faders: 0x28-0x2F (8 total)
+    return 0x28 + index;
+  } else if (type === 'button') {
+    // Buttons: 0x30-0x3F (16 total)
+    return 0x30 + index;
+  }
+
+  return 0x10; // Default to first encoder
+}
+```
+
+## Verification Tests
+
+### Test 1: Message Length Verification
+- After fixes, write message should be 300+ bytes minimum
+- Should contain 48 control definitions (11 bytes each)
+
+### Test 2: Control Data Presence
+- Hex dump should show 0x49 markers for each control
+- Should see incrementing control IDs from 0x10 to 0x3F
+
+### Test 3: Round-Trip Success
+- Slot 1 should no longer timeout
+- Read-back data should contain control names and CC values
+
+## Success Criteria
+
+- [ ] Write messages are 300+ bytes (not 30)
+- [ ] All 48 controls are included in write
+- [ ] Control IDs use correct range (0x10-0x3F)
+- [ ] Control types match position-based assignment
+- [ ] Round-trip test passes for slot 1
+- [ ] Control names preserved in round-trip
+- [ ] CC values preserved in round-trip
+
+## Priority Order
+
+1. **Fix control field name** (Task 1) - Without this, NO controls are sent
+2. **Remove ID offset** (Task 2) - IDs are completely wrong with offset
+3. **Fix control structure** (Task 4) - Required for device to parse
+4. **Fix type mapping** (Task 3) - Required for proper control behavior
+5. **Fix ID mapping** (Task 6) - Required for correct control assignment
+6. **Add labels/colors** (Task 5) - Nice to have but not critical
+
+## Timeline
+
+- Tasks 1-2: 15 minutes (critical field fixes)
+- Tasks 3-4: 30 minutes (structure fixes)
+- Tasks 5-6: 30 minutes (complete implementation)
+- Testing: 30 minutes
+- Total: ~2 hours
+
+## Note on Previous Implementation Claims
+
+The previous implementation by the agents focused on creating NEW files (enhanced parsers, timing optimizations) but did NOT fix the core issues in the existing code paths that are actually being used by the tests. This workplan addresses the ACTUAL bugs in the ACTUAL code path.
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-PROTOCOL-FIX.md b/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-PROTOCOL-FIX.md
similarity index 100%
rename from modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-PROTOCOL-FIX.md
rename to modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-PROTOCOL-FIX.md
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
index e4cb808..b7372a9 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
@@ -862,18 +862,14 @@ export class SysExParser {
     for (const control of sortedControls) {
       // Write control structure: 11 bytes
       rawData.push(0x49); // Write control marker
-      rawData.push((control.controlId ?? 0) + 0x28); // Control ID with offset
+      rawData.push(this.getControlId(control)); // Control ID (no offset - direct mapping)
       rawData.push(0x02); // Definition type
-      // Convert control type to number if it's a string
-      const controlType = control.controlType ?? control.type ?? 0x00;
-      const controlTypeNum = typeof controlType === 'string' ?
-        (controlType === 'knob' ? 0x05 : controlType === 'fader' ? 0x00 : controlType === 'button' ? 0x09 : 0x00) :
-        controlType;
-      rawData.push(controlTypeNum); // Control type
-      rawData.push(control.midiChannel ?? control.channel ?? 0); // MIDI channel (0-15)
-      rawData.push(0x01); // Parameter 1
-      rawData.push(0x40); // Parameter 2
-      rawData.push(0x00); // Min value (always 0 in write)
+      // Get control type based on position and type
+      rawData.push(this.getControlType(control)); // Control type based on position
+      rawData.push(0x00); // Always 0x00 (not channel)
+      rawData.push(0x01); // Always 0x01
+      rawData.push(0x40); // Always 0x40 (was 0x48 in some versions)
+      rawData.push(0x00); // Always 0x00
       rawData.push(control.ccNumber ?? control.cc ?? 0); // CC number
       rawData.push(0x7F); // Max value (always 0x7F in write)
       rawData.push(0x00); // Terminator
@@ -883,7 +879,7 @@ export class SysExParser {
     if (customMode.labels && customMode.labels.size > 0) {
       for (const [controlId, label] of customMode.labels) {
         rawData.push(0x69); // Label marker
-        rawData.push(controlId + 0x28); // Control ID with offset
+        rawData.push(controlId); // Control ID (no offset)
         // Add label text
         for (let i = 0; i < label.length; i++) {
           rawData.push(label.charCodeAt(i));
@@ -894,7 +890,7 @@ export class SysExParser {
       for (const control of sortedControls) {
         const controlId = control.controlId ?? 0;
         rawData.push(0x69); // Label marker
-        rawData.push(controlId + 0x28); // Control ID with offset
+        rawData.push(controlId); // Control ID (no offset)
         const label = this.generateControlLabel(controlId);
         for (let i = 0; i < label.length; i++) {
           rawData.push(label.charCodeAt(i));
@@ -906,7 +902,7 @@ export class SysExParser {
     if (customMode.colors && customMode.colors.size > 0) {
       for (const [controlId, color] of customMode.colors) {
         rawData.push(0x60); // Color marker
-        rawData.push(controlId + 0x28); // Control ID with offset
+        rawData.push(controlId); // Control ID (no offset)
         rawData.push(color); // Color value
       }
     } else {
@@ -914,7 +910,7 @@ export class SysExParser {
       for (const control of sortedControls) {
         const controlId = control.controlId ?? 0;
         rawData.push(0x60); // Color marker
-        rawData.push(controlId + 0x28); // Control ID with offset
+        rawData.push(controlId); // Control ID (no offset)
       }
     }
 
@@ -1028,26 +1024,27 @@ export class SysExParser {
     rawData.push(...nameEncoded);
 
     // Sort controls by ID for consistency
+    // FIX: Accept both 'id' and 'controlId' fields to handle different formats
     const sortedControls = Object.values(modeData.controls)
-      .filter(control => control.controlId !== undefined)
-      .sort((a, b) => (a.controlId ?? 0) - (b.controlId ?? 0));
+      .filter((control: any) => control.id !== undefined || control.controlId !== undefined)
+      .map((control: any) => ({
+        ...control,
+        controlId: control.controlId ?? control.id ?? 0
+      }))
+      .sort((a: any, b: any) => (a.controlId ?? 0) - (b.controlId ?? 0));
 
     // Add control definitions with 0x49 marker and offset
     for (const control of sortedControls) {
       // Write control structure: 11 bytes
       rawData.push(0x49); // Write control marker
-      rawData.push((control.controlId ?? 0) + 0x28); // Control ID with offset
+      rawData.push(this.getControlId(control)); // Control ID (no offset - direct mapping)
       rawData.push(0x02); // Definition type
-      // Convert control type to number if it's a string
-      const controlType = control.controlType ?? control.type ?? 0x00;
-      const controlTypeNum = typeof controlType === 'string' ?
-        (controlType === 'knob' ? 0x05 : controlType === 'fader' ? 0x00 : controlType === 'button' ? 0x09 : 0x00) :
-        controlType;
-      rawData.push(controlTypeNum); // Control type
-      rawData.push(control.midiChannel ?? control.channel ?? 0); // MIDI channel (0-15)
-      rawData.push(0x01); // Parameter 1
-      rawData.push(0x40); // Parameter 2
-      rawData.push(0x00); // Min value (always 0 in write)
+      // Get control type based on position and type
+      rawData.push(this.getControlType(control)); // Control type based on position
+      rawData.push(0x00); // Always 0x00 (not channel)
+      rawData.push(0x01); // Always 0x01
+      rawData.push(0x40); // Always 0x40 (was 0x48 in some versions)
+      rawData.push(0x00); // Always 0x00
       rawData.push(control.ccNumber ?? control.cc ?? 0); // CC number
       rawData.push(0x7F); // Max value (always 0x7F in write)
       rawData.push(0x00); // Terminator
@@ -1055,12 +1052,11 @@ export class SysExParser {
 
     // Generate labels for controls with names
     for (const control of sortedControls) {
-      const controlId = control.controlId ?? 0;
       rawData.push(0x69); // Label marker
-      rawData.push(controlId + 0x28); // Control ID with offset
+      rawData.push(this.getControlId(control)); // Control ID (no offset)
 
       // Use control name if available, otherwise generate default label
-      const label = control.name || this.generateControlLabel(controlId);
+      const label = control.name || this.generateControlLabel(this.getControlId(control));
       for (let i = 0; i < label.length; i++) {
         rawData.push(label.charCodeAt(i));
       }
@@ -1068,13 +1064,12 @@ export class SysExParser {
 
     // Add color data for controls
     for (const control of sortedControls) {
-      const controlId = control.controlId ?? 0;
-      // Find the corresponding color for this control
-      const colorEntry = modeData.colors?.find(c => c.controlId === controlId);
-      const colorValue = colorEntry?.color ?? 0x0C; // Default color if not specified
+      const controlId = this.getControlId(control);
+      // Use control's color property directly or default
+      const colorValue = control.color ?? 0x0C; // Default color if not specified
 
       rawData.push(0x60); // Color marker
-      rawData.push(controlId + 0x28); // Control ID with offset
+      rawData.push(controlId); // Control ID (no offset)
       rawData.push(colorValue); // Actual color value
     }
 
@@ -1083,6 +1078,60 @@ export class SysExParser {
 
 
 
+  /**
+   * Get control ID based on control type and index
+   * Maps controls to their protocol ID range (0x10-0x3F)
+   */
+  private static getControlId(control: any): number {
+    const type = control.type ?? control.controlType;
+    const index = control.index ?? 0;
+
+    // Use explicit controlId if provided and in valid range
+    if (control.controlId !== undefined && control.controlId >= 0x10 && control.controlId <= 0x3F) {
+      return control.controlId;
+    }
+
+    // Map based on type and index
+    if (type === 'encoder' || type === 'knob') {
+      // Encoders: 0x10-0x27 (24 total, 3 rows of 8)
+      return 0x10 + Math.min(23, index);
+    } else if (type === 'fader') {
+      // Faders: 0x28-0x2F (8 total)
+      return 0x28 + Math.min(7, index);
+    } else if (type === 'button') {
+      // Buttons: 0x30-0x3F (16 total, 2 rows of 8)
+      return 0x30 + Math.min(15, index);
+    }
+
+    return 0x10; // Default to first encoder
+  }
+
+  /**
+   * Get control type byte based on control position and type
+   * Web editor analysis shows position-based type assignment
+   */
+  private static getControlType(control: any): number {
+    const type = control.type ?? control.controlType;
+    const index = control.index ?? 0;
+
+    if (type === 'encoder' || type === 'knob') {
+      // Encoders have different types per row
+      if (index < 8) return 0x05;      // Top row (0-7)
+      if (index < 16) return 0x09;     // Middle row (8-15)
+      return 0x0D;                      // Bottom row (16-23)
+    }
+    if (type === 'fader') {
+      return 0x00;  // All faders use type 0x00
+    }
+    if (type === 'button') {
+      // Buttons have different types per row
+      if (index < 8) return 0x19;      // First row (0-7)
+      return 0x25;                      // Second row (8-15)
+    }
+
+    return 0x00; // Default
+  }
+
   /**
    * Encode a name string with the correct Launch Control XL3 prefix
    * Phase 2 implementation: Uses 0x01 0x20 0x10 0x2A prefix as per web editor analysis
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-slot1-verification.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-slot1-verification.ts
new file mode 100644
index 0000000..2b48cad
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-slot1-verification.ts
@@ -0,0 +1,370 @@
+#!/usr/bin/env npx tsx
+/**
+ * Comprehensive Slot 1 Round-Trip Verification Test
+ *
+ * This test performs a complete read->write->read cycle on slot 1 to verify:
+ * 1. Can we read existing data from slot 1?
+ * 2. Can we write new custom mode data to slot 1?
+ * 3. Does the written data match what we read back?
+ * 4. Are control names and mode names preserved correctly?
+ */
+
+import { LaunchControlXL3 } from '../src/LaunchControlXL3.js';
+import { CustomMode } from '../src/types/CustomMode.js';
+import { Color } from '../src/types/index.js';
+
+// Color map for better readability
+const COLOR_MAP: { [key: number]: string } = {
+  0x0C: 'RED',
+  0x0D: 'RED_BLINK',
+  0x0E: 'RED_PULSE',
+  0x3C: 'GREEN',
+  0x3D: 'GREEN_BLINK',
+  0x3E: 'GREEN_PULSE',
+  0x3F: 'YELLOW',
+  0x00: 'OFF'
+};
+
+function colorToString(color: number): string {
+  return COLOR_MAP[color] || `0x${color.toString(16).padStart(2, '0').toUpperCase()}`;
+}
+
+async function testSlot1RoundTrip() {
+  console.log('=' .repeat(80));
+  console.log('SLOT 1 COMPREHENSIVE ROUND-TRIP VERIFICATION TEST');
+  console.log('=' .repeat(80));
+  console.log();
+
+  const device = new LaunchControlXL3();
+
+  try {
+    // Step 1: Connect to device
+    console.log('📡 Connecting to Launch Control XL3...');
+    await device.connect();
+    console.log('✅ Connected successfully\n');
+
+    // Step 2: Read existing data from slot 1
+    console.log('━'.repeat(60));
+    console.log('PHASE 1: READ EXISTING SLOT 1 DATA');
+    console.log('━'.repeat(60));
+
+    let originalMode: CustomMode | null = null;
+
+    try {
+      console.log('→ Reading current slot 1 configuration...');
+      originalMode = await device.readCustomMode(1);
+
+      if (originalMode) {
+        console.log('✅ Successfully read existing slot 1 data:');
+        console.log(`   Mode Name: "${originalMode.name}"`);
+        console.log(`   Name Length: ${originalMode.name.length} characters`);
+        console.log(`   Total Controls: ${originalMode.controls.length}`);
+
+        // Display first 5 controls as sample
+        console.log('\n   Sample Controls (first 5):');
+        for (let i = 0; i < Math.min(5, originalMode.controls.length); i++) {
+          const ctrl = originalMode.controls[i];
+          console.log(`     ${i + 1}. ${ctrl.name || 'unnamed'} - Type: ${ctrl.type}, CC: ${ctrl.cc}, Ch: ${ctrl.channel}`);
+        }
+
+        // Check for truncated names
+        const truncatedControls = originalMode.controls.filter(c =>
+          c.name && (c.name.endsWith('...') || c.name.length === 0)
+        );
+
+        if (truncatedControls.length > 0) {
+          console.log(`\n   ⚠️ WARNING: ${truncatedControls.length} controls have truncated/missing names`);
+        }
+      } else {
+        console.log('ℹ️ Slot 1 is empty or uninitialized');
+      }
+    } catch (readError: any) {
+      console.log(`❌ Failed to read slot 1: ${readError.message}`);
+      console.log('   (This is normal if the slot has never been written to)');
+    }
+
+    // Step 3: Create test data with specific patterns
+    console.log('\n' + '━'.repeat(60));
+    console.log('PHASE 2: WRITE TEST DATA TO SLOT 1');
+    console.log('━'.repeat(60));
+
+    const testMode: CustomMode = {
+      name: 'SLOT1_TEST_MODE',  // 15 chars, easy to verify
+      controls: [],
+      colors: []
+    };
+
+    // Create comprehensive test controls
+    // We'll use patterns that are easy to verify:
+    // - Encoders: CC 20-43 (24 encoders)
+    // - Faders: CC 50-57 (8 faders)
+    // - Buttons: CC 60-75 (16 buttons)
+
+    console.log('→ Creating test mode with comprehensive controls...');
+
+    // Add 24 encoders (3 rows of 8)
+    for (let row = 0; row < 3; row++) {
+      for (let col = 0; col < 8; col++) {
+        const index = row * 8 + col;
+        testMode.controls.push({
+          type: 'encoder',
+          index: index,
+          name: `ENC${row + 1}_${col + 1}`, // ENC1_1, ENC1_2, etc.
+          cc: 20 + index,
+          channel: 1,
+          minValue: 0,
+          maxValue: 127,
+          color: row === 0 ? 0x3C : row === 1 ? 0x3F : 0x0C // Green, Yellow, Red by row
+        });
+        testMode.colors.push(testMode.controls[index].color!);
+      }
+    }
+
+    // Add 8 faders
+    for (let i = 0; i < 8; i++) {
+      const index = 24 + i;
+      testMode.controls.push({
+        type: 'fader',
+        index: i,
+        name: `FADER_${i + 1}`,
+        cc: 50 + i,
+        channel: 1,
+        minValue: 0,
+        maxValue: 127,
+        color: 0x3F // Yellow for all faders
+      });
+      testMode.colors.push(0x3F);
+    }
+
+    // Add 16 buttons (2 rows of 8)
+    for (let row = 0; row < 2; row++) {
+      for (let col = 0; col < 8; col++) {
+        const index = 32 + (row * 8 + col);
+        const buttonIndex = row * 8 + col;
+        testMode.controls.push({
+          type: 'button',
+          index: buttonIndex,
+          name: `BTN${row + 1}_${col + 1}`,
+          cc: 60 + buttonIndex,
+          channel: 1,
+          minValue: 0,
+          maxValue: 127,
+          color: row === 0 ? 0x0C : 0x3C // Red for row 1, Green for row 2
+        });
+        testMode.colors.push(testMode.controls[index].color!);
+      }
+    }
+
+    console.log(`✅ Created test mode:`);
+    console.log(`   Name: "${testMode.name}"`);
+    console.log(`   Controls: ${testMode.controls.length} (24 encoders + 8 faders + 16 buttons)`);
+    console.log(`   Colors: ${testMode.colors.length}`);
+    console.log(`   CC Range: 20-75`);
+
+    // Step 4: Write the test mode
+    console.log('\n→ Writing test mode to slot 1...');
+    try {
+      await device.writeCustomMode(1, testMode);
+      console.log('✅ Write operation completed successfully');
+    } catch (writeError: any) {
+      console.error(`❌ Write failed: ${writeError.message}`);
+      throw writeError;
+    }
+
+    // Step 5: Wait for device to process
+    console.log('→ Waiting 2 seconds for device to process...');
+    await new Promise(resolve => setTimeout(resolve, 2000));
+
+    // Step 6: Read back and verify
+    console.log('\n' + '━'.repeat(60));
+    console.log('PHASE 3: READ BACK AND VERIFY');
+    console.log('━'.repeat(60));
+
+    console.log('→ Reading back from slot 1...');
+    let readBackMode: CustomMode | null = null;
+
+    try {
+      readBackMode = await device.readCustomMode(1);
+      console.log('✅ Read operation completed');
+    } catch (readError: any) {
+      console.error(`❌ Read-back failed: ${readError.message}`);
+      throw readError;
+    }
+
+    // Step 7: Detailed verification
+    console.log('\n' + '━'.repeat(60));
+    console.log('VERIFICATION RESULTS');
+    console.log('━'.repeat(60));
+
+    if (!readBackMode) {
+      console.error('❌ FAIL: No data returned from slot 1');
+      return false;
+    }
+
+    let verificationPassed = true;
+    const issues: string[] = [];
+
+    // Verify mode name
+    console.log('\n📝 Mode Name Verification:');
+    console.log(`   Written: "${testMode.name}" (${testMode.name.length} chars)`);
+    console.log(`   Read:    "${readBackMode.name}" (${readBackMode.name.length} chars)`);
+
+    if (readBackMode.name !== testMode.name) {
+      if (readBackMode.name.startsWith(testMode.name.substring(0, 3))) {
+        issues.push(`Mode name truncated: "${readBackMode.name}" vs "${testMode.name}"`);
+        console.log('   ⚠️ TRUNCATED - Name was cut short');
+      } else {
+        issues.push(`Mode name mismatch: "${readBackMode.name}" vs "${testMode.name}"`);
+        console.log('   ❌ MISMATCH - Completely different name');
+      }
+      verificationPassed = false;
+    } else {
+      console.log('   ✅ PASS - Name matches exactly');
+    }
+
+    // Verify control count
+    console.log('\n📊 Control Count:');
+    console.log(`   Written: ${testMode.controls.length} controls`);
+    console.log(`   Read:    ${readBackMode.controls.length} controls`);
+
+    if (readBackMode.controls.length !== testMode.controls.length) {
+      issues.push(`Control count mismatch: ${readBackMode.controls.length} vs ${testMode.controls.length}`);
+      console.log('   ❌ MISMATCH - Different number of controls');
+      verificationPassed = false;
+    } else {
+      console.log('   ✅ PASS - Control count matches');
+    }
+
+    // Verify individual controls
+    console.log('\n🎛️ Control Data Verification:');
+    const maxToCheck = Math.min(testMode.controls.length, readBackMode.controls.length);
+    let controlMismatches = 0;
+    let nameTruncations = 0;
+    let ccMismatches = 0;
+    let inactiveControls = 0;
+
+    for (let i = 0; i < maxToCheck; i++) {
+      const written = testMode.controls[i];
+      const read = readBackMode.controls[i];
+
+      // Check if control appears inactive (all zeros or undefined values)
+      if (!read.cc || read.cc === 0 || !read.name) {
+        inactiveControls++;
+        console.log(`   Control ${i + 1}: ⚠️ INACTIVE - Missing CC or name`);
+        continue;
+      }
+
+      // Check name
+      if (read.name !== written.name) {
+        if (read.name && written.name && read.name.startsWith(written.name.substring(0, 2))) {
+          nameTruncations++;
+        } else {
+          controlMismatches++;
+        }
+      }
+
+      // Check CC
+      if (read.cc !== written.cc) {
+        ccMismatches++;
+      }
+    }
+
+    console.log(`   Name truncations: ${nameTruncations}`);
+    console.log(`   CC mismatches: ${ccMismatches}`);
+    console.log(`   Inactive controls: ${inactiveControls}`);
+    console.log(`   Total issues: ${controlMismatches + nameTruncations + ccMismatches + inactiveControls}`);
+
+    if (nameTruncations > 0) {
+      issues.push(`${nameTruncations} control names truncated`);
+      console.log('   ⚠️ Control names are being truncated');
+    }
+
+    if (inactiveControls > 0) {
+      issues.push(`${inactiveControls} controls appear inactive`);
+      console.log('   ⚠️ Some controls are not active/configured');
+    }
+
+    if (ccMismatches > 0) {
+      issues.push(`${ccMismatches} CC values don't match`);
+      console.log('   ❌ CC assignments not preserved');
+    }
+
+    // Display sample of problematic controls
+    if (controlMismatches + nameTruncations + inactiveControls > 0) {
+      console.log('\n   Sample Problem Controls:');
+      let shown = 0;
+      for (let i = 0; i < maxToCheck && shown < 5; i++) {
+        const written = testMode.controls[i];
+        const read = readBackMode.controls[i];
+
+        if (read.name !== written.name || read.cc !== written.cc || !read.cc) {
+          console.log(`     ${i + 1}. Written: "${written.name}" CC:${written.cc}`);
+          console.log(`        Read:    "${read.name || 'MISSING'}" CC:${read.cc || 'NONE'}`);
+          shown++;
+        }
+      }
+    }
+
+    // Final summary
+    console.log('\n' + '═'.repeat(60));
+    console.log('FINAL SUMMARY');
+    console.log('═'.repeat(60));
+
+    if (verificationPassed && issues.length === 0) {
+      console.log('✅ SUCCESS: Round-trip verification PASSED');
+      console.log('   The library is working correctly!');
+    } else {
+      console.log('❌ ISSUES FOUND:');
+      issues.forEach(issue => console.log(`   • ${issue}`));
+
+      console.log('\n📋 DIAGNOSIS:');
+      if (nameTruncations > 0 || readBackMode.name !== testMode.name) {
+        console.log('   • String truncation suggests encoding/parsing issues');
+        console.log('   • The library may not be handling text fields correctly');
+      }
+      if (inactiveControls > 0) {
+        console.log('   • Inactive controls suggest incomplete data writes');
+        console.log('   • The SysEx format may not match device expectations');
+      }
+      if (ccMismatches > 0) {
+        console.log('   • CC mismatches indicate data corruption');
+        console.log('   • Binary data encoding may be incorrect');
+      }
+    }
+
+    return verificationPassed && issues.length === 0;
+
+  } catch (error: any) {
+    console.error('\n❌ Test failed with error:', error.message);
+    console.error(error.stack);
+    return false;
+  } finally {
+    // Cleanup
+    console.log('\n→ Disconnecting...');
+    try {
+      await device.disconnect();
+      console.log('✅ Disconnected');
+    } catch (e) {
+      console.log('⚠️ Disconnect failed (device may already be disconnected)');
+    }
+  }
+}
+
+// Run the test
+console.log('Launch Control XL3 - Slot 1 Round-Trip Verification\n');
+
+testSlot1RoundTrip().then(success => {
+  console.log('\n' + '='.repeat(60));
+  if (success) {
+    console.log('✅ TEST RESULT: LIBRARY IS WORKING CORRECTLY');
+    console.log('   The issue is likely in your client code');
+    process.exit(0);
+  } else {
+    console.log('⚠️ TEST RESULT: LIBRARY HAS ISSUES');
+    console.log('   The problems you\'re seeing are in the library');
+    process.exit(1);
+  }
+}).catch(error => {
+  console.error('Fatal error:', error);
+  process.exit(1);
+});
\ No newline at end of file


---

_**Agent (claude-sonnet-4-5-20250929)**_

docs(launch-control-xl3): update protocol fix documentation and add verification test

