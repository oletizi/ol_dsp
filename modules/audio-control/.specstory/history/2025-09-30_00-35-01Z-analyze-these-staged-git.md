<!-- Generated by SpecStory -->

# Launch Control XL3 Web Automation Implementation (2025-09-30 00:35:01Z)

<!-- Claude Code Session 8da8c1f7-7966-458f-b6b1-065785f1e743 (2025-09-30_00-35-01Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/DAW_PORT_PROTOCOL.md b/modules/audio-control/modules/launch-control-xl3/docs/DAW_PORT_PROTOCOL.md
index 74105e7..3b21139 100644
--- a/modules/audio-control/modules/launch-control-xl3/docs/DAW_PORT_PROTOCOL.md
+++ b/modules/audio-control/modules/launch-control-xl3/docs/DAW_PORT_PROTOCOL.md
@@ -25,28 +25,32 @@ The Novation Components web editor uses the DAW port to select slots before writ
 3. Device writes to the previously selected slot
 ```
 
-## DAW Port Slot Selection Protocol
+## DAW Port Slot Selection Protocol (Updated)
 
-### Message Sequence
-The complete protocol for selecting a slot consists of three MIDI messages sent to the DAW port:
+### Two-Phase Negotiation Protocol
 
-1. **Note On** - Start signal
-   - Note: 11
-   - Velocity: 127
-   - Channel: 15 (0x0F)
-   - Status byte: 0x9F
+**IMPORTANT UPDATE**: Analysis of web editor transcripts reveals a more complex bidirectional protocol:
 
-2. **Control Change** - Slot selection
-   - Controller: 30 (0x1E)
-   - Value: Physical slot number + 5
-   - Channel: 6 (0x05)
-   - Status byte: 0xB5
+#### Phase 1: Query Current Slot
+1. **Editor → Device**: Note On (channel 16, note 11, velocity 127)
+2. **Editor → Device**: CC (channel 8, controller 30, value 0) - Query request
+3. **Device → Editor**: Note On echo
+4. **Device → Editor**: CC (channel 7, controller 30, current_value) - Current slot response
+5. **Editor → Device**: Note Off (channel 16, note 11, velocity 0)
+6. **Device → Editor**: Note Off echo
 
-3. **Note Off** - End signal
-   - Note: 11
-   - Velocity: 0
-   - Channel: 15 (0x0F)
-   - Status byte: 0x9F (with velocity 0)
+#### Phase 2: Set Target Slot
+1. **Editor → Device**: Note On (channel 16, note 11, velocity 127)
+2. **Editor → Device**: CC (channel 7, controller 30, target_value) - Set slot
+3. **Editor → Device**: Note Off (channel 16, note 11, velocity 0)
+4. **Device → Editor**: Echoes all messages
+
+### Channel Usage (Corrected)
+- **Channel 16** (0x0F/15): Note On/Off messages
+- **Channel 8** (0x07/7): CC query messages (value = 0)
+- **Channel 7** (0x06/6): CC slot selection and device responses
+
+**Note**: Previous documentation incorrectly stated channel 6 for CC messages. The correct channels are 7 and 8.
 
 ### Slot Value Mapping
 The CC value maps to physical slots as follows:
@@ -58,86 +62,143 @@ The CC value maps to physical slots as follows:
 
 Formula: `CC_Value = Physical_Slot + 5` or `CC_Value = API_Slot + 6`
 
-## Implementation Example
+## Critical Discovery: SysEx Slot Encoding Pattern
 
-### Using easymidi
-```typescript
-import easymidi from 'easymidi';
-
-// Open DAW port
-const dawOutput = new easymidi.Output('LCXL3 1 DAW In');
-
-// Select physical slot 1 (API slot 0)
-function selectSlot(apiSlot: number) {
-  const physicalSlot = apiSlot + 1;
-  const ccValue = physicalSlot + 5;
-
-  // Note On
-  dawOutput.send('noteon', {
-    note: 11,
-    velocity: 127,
-    channel: 15
-  });
-
-  // CC for slot selection
-  dawOutput.send('cc', {
-    controller: 30,
-    value: ccValue,
-    channel: 6
-  });
-
-  // Note Off
-  dawOutput.send('noteon', {
-    note: 11,
-    velocity: 0,  // velocity 0 = Note Off
-    channel: 15
-  });
-}
+**NEW FINDING**: The web editor uses a unique slot encoding in SysEx commands:
+
+| Physical Slot | DAW CC Value | SysEx Bytes | Interpretation |
+|--------------|--------------|-------------|----------------|
+| Slot 1 | 6 | `45 00 00` | Write cmd, slot 0, flag 0 |
+| Slot 2 | 7 | `45 00 01` | Write cmd, slot 0, flag 1 |
+| Slot 3 | 8 | `45 00 02` | Write cmd, slot 0, flag 2 |
+
+The web editor **always uses slot byte 00** but varies the third byte (flag) to indicate the target slot!
+
+## Implementation Status
+
+### Architectural Changes (Completed)
+The slot selection logic has been properly moved from the MIDI backend layer to the protocol layer:
+
+```
+┌─────────────────────────────┐
+│     LaunchControlXL3        │  Application Layer
+└──────────┬──────────────────┘
+           │
+┌──────────▼──────────────────┐
+│     DeviceManager           │  Protocol Layer
+│   (DawPortController)       │  ← Slot selection logic here
+└──────────┬──────────────────┘
+           │
+┌──────────▼──────────────────┐
+│     MidiInterface           │  Interface Layer
+│  (DAW port management)      │
+└──────────┬──────────────────┘
+           │
+┌──────────▼──────────────────┐
+│   MIDI Backend              │  Transport Layer
+│ (EasyMidi/WebMidi)          │  ← No device-specific logic
+└─────────────────────────────┘
 ```
 
-### Raw MIDI Bytes
+### Implementation Example (Updated)
+
 ```typescript
-// Select physical slot 2 (API slot 1)
-const messages = [
-  [0x9F, 11, 127],  // Note On, channel 15
-  [0xB5, 30, 7],    // CC 30, value 7, channel 5 (6 in 1-based)
-  [0x9F, 11, 0]     // Note Off, channel 15
-];
+// DawPortController with two-phase protocol
+class DawPortControllerImpl {
+  async selectSlot(slot: number): Promise<void> {
+    const physicalSlot = slot + 1;
+    const ccValue = physicalSlot + 5;
+
+    // Phase 1: Query current slot
+    await this.sendMessage([0x9F, 11, 127]);  // Note On ch16
+    await this.sendMessage([0xB7, 30, 0]);    // CC ch8, query
+    // Wait for device response (CC ch7)...
+    await this.sendMessage([0x9F, 11, 0]);    // Note Off ch16
+
+    // Small delay between phases
+    await new Promise(resolve => setTimeout(resolve, 10));
+
+    // Phase 2: Set target slot
+    await this.sendMessage([0x9F, 11, 127]);  // Note On ch16
+    await this.sendMessage([0xB6, 30, ccValue]); // CC ch7, set slot
+    await this.sendMessage([0x9F, 11, 0]);    // Note Off ch16
+
+    // Give device time to process
+    await new Promise(resolve => setTimeout(resolve, 50));
+  }
+}
 ```
 
 ## Complete Read/Write Flow
 
 ### Writing to a Specific Slot
-1. Send slot selection messages to DAW port
-2. Wait ~50ms for device to process
-3. Send SysEx write command to MIDI port (slot byte can be 0x00)
+1. Send two-phase slot selection protocol to DAW port
+2. Wait for device to process (~50ms)
+3. Send SysEx write command to MIDI port
+   - Use slot byte 0x00
+   - Use flag byte to indicate actual slot (0x00 for slot 1, 0x01 for slot 2, etc.)
 4. Device writes to the selected slot
 
 ### Reading from a Specific Slot
-1. Send slot selection messages to DAW port (optional - device may remember)
+1. Send two-phase slot selection protocol to DAW port
 2. Send SysEx read command to MIDI port
 3. Device returns data from the selected slot
 
-## Web Editor Behavior
+## Web Editor Behavior (Detailed Analysis)
+
+Based on captured transcripts, the web editor:
+
+1. **Slot Selection Dialog**: User selects target slot
+2. **Phase 1 - Query**:
+   - Sends Note On ch16 + CC ch8 value 0
+   - Receives current slot from device (CC ch7)
+3. **Phase 2 - Set**:
+   - Sends Note On ch16 + CC ch7 with target slot value
+4. **SysEx Write**:
+   - Always uses slot byte 0x00
+   - Uses flag byte (third byte) to encode actual slot
+   - Sends 342-byte payload for 24 encoders
+
+Example transcript for writing to Slot 1:
+```
+17:14:59.055  To DAW    Note On  16  B-2  127
+17:14:59.056  To DAW    Control  8   30   0     # Query
+17:14:59.061  From DAW  Control  7   30   7     # Device reports slot 2
+17:14:59.084  To DAW    Note Off 16  B-2  0
+17:15:01.531  To DAW    Note On  16  B-2  127
+17:15:01.531  To DAW    Control  7   30   6     # Set slot 1
+17:15:01.531  To DAW    Note Off 16  B-2  0
+17:15:01.538  To MIDI   SysEx    ... 45 00 00 ... # Write with flag 00
+```
+
+## Testing Results
 
-The Novation Components web editor follows this exact protocol:
-1. When user clicks "Send to Launch Control XL 3", a slot selection dialog appears
-2. When user selects a slot and clicks "Overwrite Custom Mode":
-   - Sends the 3-message sequence to DAW port
-   - Sends SysEx write command with only 24 encoders (342 bytes)
-   - Slot byte in SysEx is always 0x00
+### Current Implementation Status
+- ✅ Architectural refactoring complete (slot selection at protocol layer)
+- ✅ Two-phase negotiation protocol implemented
+- ✅ Correct channels used (16, 8, 7)
+- ✅ DAW port messages confirmed being sent
+- ❌ Device not responding to slot selection
+- ❌ SysEx encoding doesn't match web editor pattern
+
+### Round-Trip Test Observations
+The test shows DAW port messages are sent correctly but device still reads wrong slot:
+- Write "SLOT0_TEST_MODE" to slot 0
+- Read back gets "Default Custom M!" (from different slot)
 
 ## Important Notes
 
-1. **Slot State Persistence**: The device appears to remember the last selected slot
-2. **Default Behavior**: Without DAW port selection, writes may go to slot 2 by default
-3. **Acknowledgment**: The device sends a 12-byte acknowledgment after successful write:
-   ```
-   F0 00 20 29 02 15 05 00 15 00 07 F7
-   ```
-   The second-to-last byte (0x07) appears to echo status information
+1. **Bidirectional Communication**: Device responds to queries - implementation needs to handle responses
+2. **SysEx Flag Byte**: The third byte after command 0x45 determines actual slot, not the slot byte
+3. **Timing Critical**: Small delays needed between protocol phases
+4. **Channel Confusion**: Monitor may report channels differently than MIDI spec (0-based vs 1-based)
+
+## Next Steps
 
-4. **Backwards Compatibility**: Libraries that don't use the DAW port will have unpredictable slot behavior
+1. **Fix SysEx Encoding**: Implement slot=0 with flag byte pattern
+2. **Add Response Handling**: DawPortController needs to process device responses
+3. **Verify Timing**: Match web editor's timing between messages
+4. **Test All Slots**: Comprehensive testing with all 15 slots
 
 ## Testing Tools
 
@@ -145,9 +206,12 @@ Several utilities are available for testing and debugging:
 - `utils/test-daw-port-monitor.ts` - Monitor DAW port messages
 - `utils/test-slot-selection.ts` - Test slot selection via DAW port
 - `utils/test-daw-port-integration.ts` - Full integration test with library
+- `utils/test-slot-0-round-trip.ts` - Round-trip test for slot 0
 
 ## References
 
 - Discovered through reverse engineering the Novation Components web editor
 - Confirmed via Playwright automation and MIDI monitoring
-- Tested with Launch Control XL3 firmware v1.0.10.84
\ No newline at end of file
+- Tested with Launch Control XL3 firmware v1.0.10.84
+- Web editor transcripts analyzed for slots 1, 2, and 3
+- Implementation: `src/core/DawPortController.ts`, `src/device/DeviceManager.ts`
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/DawPortController.ts b/modules/audio-control/modules/launch-control-xl3/src/core/DawPortController.ts
index 97ff767..95f4874 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/DawPortController.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/DawPortController.ts
@@ -4,6 +4,17 @@
  * Handles out-of-band communication via the DAW port for:
  * - Slot selection before writing custom modes
  * - Mode switching and other control messages
+ *
+ * Protocol discovered from web editor:
+ * 1. Send Note On (ch16, note 11, vel 127)
+ * 2. Send CC query (ch8, controller 30, value 0) to request current slot
+ * 3. Device responds with current slot via CC (ch7, controller 30, value)
+ * 4. Send Note Off
+ * 5. Send Note On again
+ * 6. Send CC selection (ch7, controller 30, target slot value)
+ * 7. Send Note Off
+ *
+ * Slot values: Slot 1 = 6, Slot 2 = 7, Slot 3 = 8, etc.
  */
 
 export interface DawPortController {
@@ -13,7 +24,8 @@ export interface DawPortController {
 
 export class DawPortControllerImpl implements DawPortController {
   constructor(
-    private sendMessage: (message: number[]) => Promise<void>
+    private sendMessage: (message: number[]) => Promise<void>,
+    private waitForMessage?: (predicate: (data: number[]) => boolean, timeout: number) => Promise<number[]>
   ) {}
 
   /**
@@ -25,23 +37,60 @@ export class DawPortControllerImpl implements DawPortController {
       throw new Error(`Invalid slot: ${slot}. Must be 0-14`);
     }
 
-    // The web editor sends:
-    // 1. Note On (note 11, velocity 127, channel 15)
-    // 2. CC 30 on channel 6, value = physical slot + 5
-    // 3. Note Off (note 11, velocity 0, channel 15)
-
     // Physical slot is 1-based, so add 1 to the 0-based slot
     const physicalSlot = slot + 1;
     const ccValue = physicalSlot + 5; // Slot 1 = CC value 6, Slot 2 = CC value 7, etc.
 
-    // Note On: note 11, velocity 127, channel 15
-    await this.sendMessage([0x9F, 11, 127]); // 0x9F = Note On channel 15
+    console.log(`[DawPortController] Selecting slot ${slot} (physical ${physicalSlot}, CC value ${ccValue})`);
+
+    // Phase 1: Query current slot
+    // Note On: note 11, velocity 127, channel 16
+    console.log('[DawPortController] Phase 1: Sending Note On ch16');
+    await this.sendMessage([0x9F, 11, 127]); // 0x9F = Note On channel 16 (15 in 0-based)
 
-    // CC: controller 30, value, channel 6
-    await this.sendMessage([0xB5, 30, ccValue]); // 0xB5 = CC channel 5 (0-based)
+    // CC Query: controller 30, value 0, channel 8
+    console.log('[DawPortController] Phase 1: Sending CC query on ch8');
+    await this.sendMessage([0xB7, 30, 0]); // 0xB7 = CC channel 8 (7 in 0-based)
 
-    // Note Off: note 11, velocity 0, channel 15
-    await this.sendMessage([0x9F, 11, 0]); // Velocity 0 = Note Off
+    // Wait for device response if we have a wait function
+    if (this.waitForMessage) {
+      try {
+        console.log('[DawPortController] Waiting for device CC response...');
+        const response = await this.waitForMessage(
+          (data) => {
+            // Looking for CC on channel 7, controller 30
+            return data.length === 3 &&
+                   data[0] === 0xB6 && // CC channel 7
+                   data[1] === 30;
+          },
+          100 // 100ms timeout
+        );
+        const currentSlot = response[2] - 5; // Convert CC value back to 0-based slot
+        console.log(`[DawPortController] Device reports current slot: ${currentSlot}`);
+      } catch (error) {
+        console.log('[DawPortController] No response from device (might not be in interactive mode)');
+      }
+    }
+
+    // Note Off: note 11, velocity 0, channel 16
+    console.log('[DawPortController] Phase 1: Sending Note Off ch16');
+    await this.sendMessage([0x9F, 11, 0]);
+
+    // Small delay between phases
+    await new Promise(resolve => setTimeout(resolve, 10));
+
+    // Phase 2: Set target slot
+    // Note On again
+    console.log('[DawPortController] Phase 2: Sending Note On ch16');
+    await this.sendMessage([0x9F, 11, 127]);
+
+    // CC Selection: controller 30, target value, channel 7
+    console.log(`[DawPortController] Phase 2: Sending CC selection on ch7, value ${ccValue}`);
+    await this.sendMessage([0xB6, 30, ccValue]); // 0xB6 = CC channel 7 (6 in 0-based)
+
+    // Note Off
+    console.log('[DawPortController] Phase 2: Sending Note Off ch16');
+    await this.sendMessage([0x9F, 11, 0]);
 
     // Give the device time to process the selection
     await new Promise(resolve => setTimeout(resolve, 50));
diff --git a/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts b/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
index d557199..0550f89 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
@@ -786,8 +786,8 @@ export class DeviceManager extends EventEmitter {
   private async initializeDawPort(): Promise<void> {
     try {
       // Try to open DAW output port for slot selection
-      const deviceName = this.deviceInfo?.name || 'Launch Control XL';
-      await this.midi.openDawOutput(`${deviceName} DAW In`);
+      // Use the correct port name pattern: "LCXL3 1 DAW In"
+      await this.midi.openDawOutput('LCXL3 1 DAW In');
 
       // Create DAW port controller
       this.dawPortController = new DawPortControllerImpl(
diff --git a/modules/audio-control/modules/launch-control-xl3/utils/test-slot-0-round-trip.ts b/modules/audio-control/modules/launch-control-xl3/utils/test-slot-0-round-trip.ts
new file mode 100644
index 0000000..ee98f40
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/utils/test-slot-0-round-trip.ts
@@ -0,0 +1,156 @@
+#!/usr/bin/env npx tsx
+
+/**
+ * Focused round-trip test for physical slot 1 (API slot 0)
+ * Verifies that data written to slot 0 can be read back correctly
+ */
+
+import { LaunchControlXL3 } from '../src/LaunchControlXL3.js';
+import { CustomMode } from '../src/types/CustomMode.js';
+import { ControlChange } from '../src/types/ControlChange.js';
+import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';
+
+async function testSlot0RoundTrip(): Promise<void> {
+  console.log('Physical Slot 1 (API Slot 0) Round-Trip Test');
+  console.log('=============================================\n');
+
+  const backend = new EasyMidiBackend();
+  const device = new LaunchControlXL3({
+    midiBackend: backend,
+    enableLedControl: false,
+    enableCustomModes: true
+  });
+
+  try {
+    // Connect to device
+    console.log('→ Connecting to device...');
+    await device.connect();
+    console.log('✓ Connected\n');
+
+    // Create a unique test mode with specific values
+    const testMode: CustomMode = {
+      name: 'SLOT0_TEST_MODE',
+      controls: [],
+      colors: [] // Initialize colors array
+    };
+
+    // Create 48 controls with unique, verifiable values
+    for (let i = 0; i < 48; i++) {
+      const control: ControlChange = {
+        name: `TEST_CTRL_${i}`,
+        type: i < 8 ? 'encoder' : i < 24 ? 'fader' : 'button',
+        channel: i % 16, // Channels 0-15 (0-based)
+        cc: 20 + i, // CC 20-67
+        minValue: 0,
+        maxValue: 127,
+        defaultValue: i, // Use index as default value for easy verification
+        color: i % 4 // Cycle through 4 colors
+      };
+      testMode.controls.push(control);
+
+      // Also add to colors array (for button LEDs)
+      testMode.colors.push(i % 4);
+    }
+
+    console.log('Test Mode Configuration:');
+    console.log('========================');
+    console.log(`Name: ${testMode.name}`);
+    console.log(`Controls: ${testMode.controls.length}`);
+    console.log(`First control: ${testMode.controls[0].name} (CC ${testMode.controls[0].cc}, Channel ${testMode.controls[0].channel + 1})`);
+    console.log(`Last control: ${testMode.controls[47].name} (CC ${testMode.controls[47].cc}, Channel ${testMode.controls[47].channel + 1})`);
+    console.log();
+
+    // Write to slot 0
+    console.log('→ Writing custom mode to slot 0...');
+    await device.writeCustomMode(0, testMode);
+    console.log('✓ Write completed\n');
+
+    // Wait a bit for device to process
+    await new Promise(resolve => setTimeout(resolve, 1000));
+
+    // Read back from slot 0
+    console.log('→ Reading back from slot 0...');
+    const readMode = await device.readCustomMode(0);
+    console.log('✓ Read successful\n');
+
+    // Detailed verification
+    console.log('Verification:');
+    console.log('-------------');
+
+    let allMatch = true;
+
+    // Check name
+    const nameMatch = readMode.name === testMode.name;
+    console.log(`Name: ${nameMatch ? '✓' : '✗'} "${readMode.name}" ${nameMatch ? '==' : '!='} "${testMode.name}"`);
+    if (!nameMatch) allMatch = false;
+
+    // Check control count
+    const countMatch = readMode.controls.length === testMode.controls.length;
+    console.log(`Control count: ${countMatch ? '✓' : '✗'} ${readMode.controls.length} ${countMatch ? '==' : '!='} ${testMode.controls.length}`);
+    if (!countMatch) allMatch = false;
+
+    // Check each control in detail
+    let mismatchCount = 0;
+    const maxToShow = 5;
+    for (let i = 0; i < Math.min(readMode.controls.length, testMode.controls.length); i++) {
+      const readCtrl = readMode.controls[i];
+      const testCtrl = testMode.controls[i];
+
+      const match =
+        readCtrl.name === testCtrl.name &&
+        readCtrl.cc === testCtrl.cc &&
+        readCtrl.channel === testCtrl.channel &&
+        readCtrl.type === testCtrl.type &&
+        (readCtrl.defaultValue ?? readCtrl.value) === testCtrl.defaultValue &&
+        readCtrl.color === testCtrl.color;
+
+      if (!match) {
+        mismatchCount++;
+        if (mismatchCount <= maxToShow) {
+          console.log(`\nControl ${i}: ✗`);
+          console.log(`  Name: "${readCtrl.name}" vs "${testCtrl.name}"`);
+          console.log(`  CC: ${readCtrl.cc} vs ${testCtrl.cc}`);
+          console.log(`  Channel: ${readCtrl.channel} vs ${testCtrl.channel}`);
+          console.log(`  Type: ${readCtrl.type} vs ${testCtrl.type}`);
+          console.log(`  Default: ${readCtrl.defaultValue ?? readCtrl.value} vs ${testCtrl.defaultValue}`);
+          console.log(`  Color: ${readCtrl.color} vs ${testCtrl.color}`);
+        }
+        allMatch = false;
+      }
+    }
+
+    if (mismatchCount > maxToShow) {
+      console.log(`\n... and ${mismatchCount - maxToShow} more mismatches`);
+    }
+
+    if (mismatchCount === 0 && readMode.controls.length === testMode.controls.length) {
+      console.log('\n✓ All 48 controls match perfectly!');
+    }
+
+    // Final result
+    console.log('\n' + '='.repeat(50));
+    if (allMatch) {
+      console.log('✅ SUCCESS: Physical Slot 1 Round-Trip Test PASSED');
+      console.log('Data written to slot 0 was read back correctly!');
+    } else {
+      console.log('❌ FAILURE: Physical Slot 1 Round-Trip Test FAILED');
+      console.log('Data read from slot 0 does not match what was written.');
+
+      // Debug: Show raw data sizes if available
+      if ((readMode as any).rawData && (testMode as any).rawData) {
+        console.log(`\nDebug: Raw data size - Read: ${(readMode as any).rawData.length}, Expected: ~600 bytes`);
+      }
+    }
+    console.log('='.repeat(50));
+
+  } catch (error) {
+    console.error('❌ Test failed with error:', error);
+  } finally {
+    console.log('\n→ Disconnecting...');
+    await device.disconnect();
+    console.log('✓ Disconnected');
+  }
+}
+
+// Run the test
+testSlot0RoundTrip().catch(console.error);
\ No newline at end of file


---

_**Agent (claude-sonnet-4-5-20250929)**_

feat(launch-control-xl3): implement two-phase DAW port protocol for slot selection

