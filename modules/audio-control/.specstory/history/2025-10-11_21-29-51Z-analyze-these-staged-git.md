<!-- Generated by SpecStory -->

# MIDI Controller SysEx Parser Bug Fix Verification (2025-10-11 21:29:51Z)

<!-- Claude Code Session 1ff56f98-b86e-4dab-9096-724651ef7c9f (2025-10-11_21-29-51Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/remaining-failures.md b/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/remaining-failures.md
new file mode 100644
index 0000000..e03b2a3
--- /dev/null
+++ b/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/remaining-failures.md
@@ -0,0 +1,204 @@
+# Remaining Test Failures - Summary
+
+**Status after Phase 1 & 2:** 42 failures out of 263 tests (down from 48 failures out of 257 tests)
+
+**Progress:** ✅ Fixed 6 test failures, added 6 new passing tests from DawPortController rewrite
+
+---
+
+## Root Cause Analysis
+
+### Primary Issue: Missing `page` Parameter in Test Calls
+
+**Problem:** `SysExParser.buildCustomModeWriteRequest()` requires 3 parameters:
+```typescript
+buildCustomModeWriteRequest(slot: number, page: number, modeData: CustomModeMessage)
+```
+
+**But tests are calling it with only 2 parameters:**
+```typescript
+buildCustomModeWriteRequest(slot, modeData)  // ❌ Missing page parameter
+```
+
+**Result:** TypeScript interprets `modeData` as `page` (number), and actual `modeData` becomes `undefined`, causing:
+```
+TypeError: Cannot read properties of undefined (reading 'controls')
+```
+
+---
+
+## Breakdown of 42 Remaining Failures
+
+### 1. Import Path Errors (2 failures)
+- `test/unit/ControlMapper.test.ts` - Bad import: `@/src/mapping/ControlMapper.js` (should be `@/mapping/ControlMapper`)
+- `test/unit/SysExParser.test.ts` - Bad import: `@/test/helpers/test-utils` (doesn't exist)
+
+### 2. SysExParser buildCustomModeWriteRequest Tests (19 failures)
+**All caused by missing `page` parameter:**
+
+- `buildCustomModeWriteRequest - MIDI Protocol Validation` (7 tests)
+  - Lines 404-470: All call `buildCustomModeWriteRequest(0, modeData)` instead of `buildCustomModeWriteRequest(0, 0, modeData)`
+
+- `Message Structure` (2 tests)
+  - Lines 546-591: Missing page parameter
+
+- `Mode Name Encoding` (2 tests)
+  - Lines 595-634: Missing page parameter
+
+- `Control Encoding` (3 tests)
+  - Lines 638-760: Missing page parameter
+
+- `Label and Color Data` (3 tests)
+  - Lines 764-858: Missing page parameter
+
+- `Complete Message Validation` (2 tests)
+  - Lines 862-939: Missing page parameter
+
+**Fix:** Add page parameter (usually `0` for page 0) to all calls:
+```typescript
+// Before:
+const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+// After:
+const message = SysExParser.buildCustomModeWriteRequest(0, 0, modeData);  // page 0
+```
+
+### 3. SysExParser buildCustomModeReadRequest Tests (2 failures)
+- Line ~237: Expected page count of 3, got 0
+- Line ~241: Error message mismatch - "slot must be 0-15" vs "Custom mode slot must be 0-14"
+
+### 4. SysExParser Mode Name Parsing (2 failures)
+**Still including marker byte in name:**
+- Line 987: "RT TestI" instead of "RT Test"
+- Line 1007: "TestI!@" instead of "Test"
+
+**Note:** Phase 1C fixed one similar test, but these two are still failing. May need different parsing path.
+
+### 5. DawPortController Test (1 failure)
+- Line 129: Test expects 5th call but only 3 calls made
+- Test: "should calculate CC value correctly for all slots"
+- Issue: Loop mock setup problem - needs different mock for each iteration
+
+### 6. CustomModeManager Tests (13 failures)
+
+**Property access issues (4 tests):**
+- Tests expect properties that don't exist on parsed mode
+- Even after adding aliases in Phase 1A, some properties still undefined
+- Lines 110, 128, 174, 232
+
+**Write mode format issues (1 test):**
+- Line 281: writeMode receives wrong format (colors empty, controls malformed)
+
+**LED validation (1 test):**
+- Line 460: validateMode should throw for invalid LED behaviour, but doesn't
+
+**Default mode LEDs (1 test):**
+- Line 529: createDefaultMode should include `leds` property, but doesn't
+
+**Caching behavior (3 tests):**
+- Line 573: Cache not working - reads device twice instead of using cache
+- Line 605: TypeError accessing response.name (undefined)
+- Line 644: Cache events not emitted
+
+**Unknown controls (1 test):**
+- Line 835: Should skip unknown controls but creates `control_2457` entry
+
+**Cache disconnection (1 test):**
+- Line 902: `cache:cleared` event not emitted on device disconnection
+
+**Cleanup resources (1 test):**
+- Line 915: getCachedModes() returns empty Map, test expects data
+
+### 7. RealDeviceFixtures Test (1 failure)
+- Line 59: No controls parsed from real device fixture
+- Likely cascading from CustomModeManager property issues
+
+---
+
+## Recommended Fixes
+
+### Quick Wins (Manual Edits - 10 minutes)
+
+1. **Fix import paths** (2 tests):
+   ```bash
+   # test/unit/ControlMapper.test.ts line ~5
+   @/src/mapping/ControlMapper.js  →  @/mapping/ControlMapper
+
+   # test/unit/SysExParser.test.ts line ~7
+   @/test/helpers/test-utils  →  Remove or create proper helper
+   ```
+
+2. **Add page parameter** (19 tests):
+   ```typescript
+   // Find/replace in test/core/SysExParser.test.ts
+   buildCustomModeWriteRequest(0, modeData)  →  buildCustomModeWriteRequest(0, 0, modeData)
+   buildCustomModeWriteRequest(slot, modeData)  →  buildCustomModeWriteRequest(slot, 0, modeData)
+   ```
+
+3. **Fix DawPortController loop mock** (1 test):
+   ```typescript
+   // Line ~66-80 in test/core/DawPortController.test.ts
+   for (const { slot, ccValue } of expectedMappings) {
+     sendMessage.mockClear();
+     waitForMessage.mockReset();
+
+     // Need fresh mocks for EACH iteration
+     waitForMessage
+       .mockResolvedValueOnce([0xB6, 30, 6])
+       .mockResolvedValueOnce([0x9F, 11, 0])
+       .mockResolvedValueOnce([0x9F, 11, 0]);
+
+     await controller.selectSlot(slot);
+   }
+   ```
+
+### Medium Complexity (TypeScript Agent - 30 minutes)
+
+4. **CustomModeManager property fixes**:
+   - Investigate why aliases aren't working in parseCustomModeResponse
+   - Ensure control objects have all expected properties
+   - Add leds Map to createDefaultMode()
+
+5. **Mode name parsing edge cases**:
+   - Fix remaining marker byte inclusion issues
+   - May need to handle different response formats
+
+### Lower Priority (Can Skip for Release)
+
+6. **Caching enhancements**:
+   - Implement persistent cache if tests require it
+   - Add cache:cleared event emission on disconnect
+   - Fix cache behavior to actually cache
+
+7. **Validation improvements**:
+   - Add LED behaviour validation
+   - Better error messages for validation failures
+
+---
+
+## Summary
+
+**Immediate action items to get tests passing:**
+1. ✅ Fix 21 tests by adding `page` parameter to buildCustomModeWriteRequest calls (~5 min)
+2. ✅ Fix 2 import path errors (~2 min)
+3. ✅ Fix 1 DawPortController mock setup (~3 min)
+4. ⚠️ Investigate 13 CustomModeManager failures (~30-60 min)
+5. ⚠️ Debug 2 mode name parsing edge cases (~15 min)
+6. ⚠️ Fix 1 RealDeviceFixtures test (likely auto-fixes after #4)
+
+**Estimated time to all tests passing:**
+- Quick fixes (#1-3): 10 minutes
+- CustomModeManager investigation: 30-60 minutes
+- **Total: ~40-70 minutes**
+
+**Alternative: Release with known test failures**
+- 42 failures out of 263 tests = 84% pass rate
+- Core functionality (parser fix) is working
+- Most failures are test infrastructure issues, not actual bugs
+- Could ship as alpha/beta with known issues documented
+
+---
+
+**Date:** 2025-10-11
+**Branch:** chore/fix-typecheck-and-tests-for-release
+**Workplan:** docs/1.0/test-failures-post-pr34/implementation/workplan.md
diff --git a/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/workplan.md b/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/workplan.md
new file mode 100644
index 0000000..7fd395f
--- /dev/null
+++ b/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/workplan.md
@@ -0,0 +1,508 @@
+# Workplan: Fix Test Failures After PR #34 (Parser Bug Fix)
+
+**Version:** 1.0
+**Created:** 2025-10-11
+**Status:** In Progress
+**Related Issue:** Post-PR#34 test failures
+**Branch:** `chore/fix-typecheck-and-tests-for-release`
+
+---
+
+## Problem Statement
+
+After merging PR #34 (parser bug fix for issue #32), 48 tests are failing in the launch-control-xl3 module. These failures are blocking the release process since we've fixed `scripts/publish-modules.ts` to properly block on test failures.
+
+### Failure Context
+
+```
+Test Files  6 failed | 4 passed (10)
+Tests       48 failed | 209 passed (257)
+```
+
+The failures occurred after:
+1. Fixing SysExParser to remove incorrect 0x40 byte parsing (#32)
+2. Updating DawPortController to use bidirectional protocol
+3. Refactoring CustomModeManager property names
+
+---
+
+## Analysis
+
+### Root Causes Identified
+
+#### 1. **SysExParser buildCustomModeWriteRequest Tests (19 failures)**
+
+**Error:** `Cannot read properties of undefined (reading 'controls')`
+
+**Root Cause:**
+- Tests pass `CustomMode` format:
+  ```typescript
+  {
+    name: "Test Mode",
+    controls: {
+      SEND_A1: { channel: 1, cc: 100, ... },
+      SEND_B2: { channel: 2, cc: 101, ... }
+    }
+  }
+  ```
+
+- Function expects `CustomModeMessage` format:
+  ```typescript
+  {
+    name: "Test Mode",
+    controls: [ // Array, not object
+      { controlId: 0x10, channel: 1, ccNumber: 100, ... },
+      { controlId: 0x19, channel: 2, ccNumber: 101, ... }
+    ],
+    colors: [...],
+    labels: Map(...)
+  }
+  ```
+
+**Location:**
+- `test/core/SysExParser.test.ts` lines 750-920
+
+#### 2. **CustomModeManager Missing Methods (4 failures)**
+
+**Error:** `customModeManager.clearCache is not a function`
+
+**Root Cause:**
+- Tests expect public methods that don't exist:
+  - `clearCache()`
+  - `getCachedModes()`
+- Caching exists internally (`pendingOperations` Map) but isn't exposed
+
+**Location:**
+- `test/unit/CustomModeManager.test.ts` lines 621, 660, 646, 914
+
+#### 3. **CustomModeManager Property Name Mismatch (6 failures)**
+
+**Error:** `expected undefined to be 5` (accessing control.channel)
+
+**Root Cause:**
+- Tests expect properties: `channel`, `cc`, `behaviour`, `min`, `max`
+- Code provides: `midiChannel`, `ccNumber`, `behavior`, `minValue`, `maxValue`
+- Partial mapping exists in `CustomModeManager.ts:204-212` but incomplete
+
+**Evidence:**
+```typescript
+// Line 204-212 (incomplete mapping)
+mode.controls[controlId] = {
+  name: label,
+  type: this.getControlType(control.controlId),
+  midiChannel: control.midiChannel,  // Should also map to 'channel'
+  ccNumber: control.ccNumber,         // Should also map to 'cc'
+  minValue: control.minValue,         // Should also map to 'min'
+  maxValue: control.maxValue,         // Should also map to 'max'
+  behavior: control.behavior,         // Should also map to 'behaviour'
+};
+```
+
+**Location:**
+- `test/unit/CustomModeManager.test.ts` lines 110, 128, 174, 232, 281, 835
+
+#### 4. **DawPortController Protocol Change (3 failures)**
+
+**Error:**
+- `expected 7 to be 5` (MIDI channel mismatch)
+- `expected 0 to be greater than or equal to 45` (timing assertion)
+
+**Root Cause:**
+- Old implementation (what tests expect):
+  ```typescript
+  // 3-message sequence, channel 5
+  [0x9F, 11, 127]  // Note On ch16
+  [0xB5, 30, ccValue]  // CC ch5
+  [0x9F, 11, 0]    // Note Off ch16
+  ```
+
+- New implementation (what code does):
+  ```typescript
+  // 6-9 message bidirectional, channels 7/8
+  Phase 1 (Query):
+    [0x9F, 11, 127]   // Note On ch16
+    [0xB7, 30, 0]     // CC query ch8
+    Wait for [0xB6, 30, X]  // Response ch7
+    [0x9F, 11, 0]     // Note Off ch16
+
+  Phase 2 (Set - conditional):
+    [0x9F, 11, 127]   // Note On ch16
+    [0xB6, 30, ccValue]  // CC set ch7
+    [0x9F, 11, 0]     // Note Off ch16
+  ```
+
+**Location:**
+- `test/core/DawPortController.test.ts` lines 23, 35, 44, 71, 89, 105
+
+#### 5. **SysExParser Mode Name Parsing (2 failures)**
+
+**Error:** `expected 'RT TestI' to be 'RT Test'`
+
+**Root Cause:**
+- Parser reads one extra byte after mode name
+- Mode name: `0x52 0x54 0x20 0x54 0x65 0x73 0x74` = "RT Test" (7 bytes)
+- Control marker: `0x49` = byte after name
+- Parser includes 0x49 (ASCII 'I') in the name string
+
+**Location:**
+- `test/core/SysExParser.test.ts` lines 987, 1007
+- Bug in `src/core/SysExParser.ts` approximately lines 500-550 (mode name extraction logic)
+
+#### 6. **Real Device Fixture Parsing (1 failure)**
+
+**Error:** `expected 0 to be greater than 0` (no controls parsed)
+
+**Root Cause:**
+- Same as category #3 - property name mismatch prevents controls from being recognized
+
+**Location:**
+- `test/unit/RealDeviceFixtures.test.ts` line 59
+
+---
+
+## Implementation Plan
+
+### Phase 1: Source Code Fixes (Parallel Execution)
+
+**Execute in parallel with 3 typescript-pro agents:**
+
+#### Task 1A: Fix CustomModeManager Property Mapping
+**Agent:** typescript-pro
+**File:** `modules/launch-control-xl3/src/modes/CustomModeManager.ts`
+**Lines:** 204-212
+
+**Change:**
+```typescript
+// Current (incomplete):
+mode.controls[controlId] = {
+  name: label,
+  type: this.getControlType(control.controlId),
+  midiChannel: control.midiChannel,
+  ccNumber: control.ccNumber,
+  minValue: control.minValue,
+  maxValue: control.maxValue,
+  behavior: control.behavior as ControlBehaviour,
+};
+
+// Fixed (add legacy aliases):
+mode.controls[controlId] = {
+  name: label,
+  type: this.getControlType(control.controlId),
+  // Primary names
+  midiChannel: control.midiChannel,
+  ccNumber: control.ccNumber,
+  minValue: control.minValue,
+  maxValue: control.maxValue,
+  behavior: control.behavior as ControlBehaviour,
+  // Legacy aliases for backward compatibility
+  channel: control.midiChannel,
+  cc: control.ccNumber,
+  min: control.minValue,
+  max: control.maxValue,
+  behaviour: control.behavior as ControlBehaviour,
+};
+```
+
+**Also update:** `createDefaultMode()` method (lines 356-403) to include both property names.
+
+#### Task 1B: Add Missing Public Methods
+**Agent:** typescript-pro
+**File:** `modules/launch-control-xl3/src/modes/CustomModeManager.ts`
+**Lines:** Add after line 482 (before closing brace)
+
+**Add methods:**
+```typescript
+/**
+ * Clear the pending operations cache
+ */
+clearCache(): void {
+  this.pendingOperations.clear();
+}
+
+/**
+ * Get all cached modes
+ * @returns Map of slot numbers to cached CustomMode objects
+ */
+getCachedModes(): Map<number, CustomMode> {
+  // Convert pending operations to resolved modes
+  // For now, return empty map as we don't persist cache beyond pendingOperations
+  return new Map();
+}
+```
+
+**Note:** The current implementation uses `pendingOperations` for in-flight requests only, not as a persistent cache. Consider if persistent caching is needed or if tests should be updated.
+
+#### Task 1C: Fix SysExParser Mode Name Parsing
+**Agent:** typescript-pro
+**File:** `modules/launch-control-xl3/src/core/SysExParser.ts`
+**Lines:** Approximately 500-550 (mode name extraction)
+
+**Issue:** Parser reads past mode name into control marker byte (0x49).
+
+**Fix:** Locate mode name extraction logic and ensure it stops reading when it hits:
+- Control marker byte (0x48 or 0x49)
+- Label marker byte (0x69)
+- Color marker byte (0x60)
+- End of message (0xF7)
+
+**Example fix pattern:**
+```typescript
+// Find mode name length
+let nameLength = 0;
+for (let i = nameStartIndex; i < data.length; i++) {
+  const byte = data[i];
+  // Stop at any marker byte or end of message
+  if (byte === 0x48 || byte === 0x49 || byte === 0x69 ||
+      byte === 0x60 || byte === 0xF7 || byte === undefined) {
+    break;
+  }
+  nameLength++;
+}
+
+// Extract name
+const nameBytes = data.slice(nameStartIndex, nameStartIndex + nameLength);
+const name = String.fromCharCode(...nameBytes);
+```
+
+---
+
+### Phase 2: Test Updates (Sequential After Phase 1)
+
+#### Task 2A: Update SysExParser Tests
+**Agent:** test-automator
+**File:** `test/core/SysExParser.test.ts`
+**Lines:** 750-920 (buildCustomModeWriteRequest tests)
+
+**Changes Needed:**
+
+1. Add helper function to convert CustomMode → CustomModeMessage:
+```typescript
+function convertToCustomModeMessage(mode: CustomMode, slot: number): CustomModeMessage {
+  const controls: ControlMapping[] = [];
+  const colors: ColorMapping[] = [];
+  const labels = new Map<number, string>();
+
+  for (const [key, control] of Object.entries(mode.controls)) {
+    const controlId = CONTROL_IDS[key as keyof typeof CONTROL_IDS];
+    if (controlId !== undefined) {
+      controls.push({
+        controlId,
+        channel: control.channel || control.midiChannel,
+        ccNumber: control.cc || control.ccNumber,
+        minValue: control.min || control.minValue,
+        maxValue: control.max || control.maxValue,
+        behaviour: control.behaviour || control.behavior,
+      });
+
+      if (control.name) {
+        labels.set(controlId, control.name);
+      }
+    }
+  }
+
+  if (mode.leds) {
+    for (const [controlName, ledConfig] of mode.leds.entries()) {
+      const controlId = CONTROL_IDS[controlName as keyof typeof CONTROL_IDS];
+      if (controlId !== undefined) {
+        colors.push({
+          controlId,
+          color: ledConfig.color,
+          behaviour: ledConfig.behaviour,
+        });
+      }
+    }
+  }
+
+  return {
+    type: 'custom_mode_write',
+    manufacturerId: [0x00, 0x20, 0x29],
+    slot,
+    name: mode.name,
+    controls,
+    colors,
+    labels,
+    data: [],
+  };
+}
+```
+
+2. Update all failing tests to use converter:
+```typescript
+// Before:
+const result = SysExParser.buildCustomModeWriteRequest(slot, page, mode);
+
+// After:
+const modeMessage = convertToCustomModeMessage(mode, slot);
+const result = SysExParser.buildCustomModeWriteRequest(slot, page, modeMessage);
+```
+
+#### Task 2B: Rewrite DawPortController Tests
+**Agent:** test-automator
+**File:** `test/core/DawPortController.test.ts`
+**Lines:** Entire file (rewrite for new protocol)
+
+**Changes Needed:**
+
+1. **Remove timing assertions** (lines 83-90) - async operations don't have fixed delays
+
+2. **Update channel expectations:**
+   - Change from channel 5 (0xB5) to channels 7/8 (0xB6/0xB7)
+   - Tests should expect bidirectional protocol
+
+3. **Add waitForMessage mock support:**
+```typescript
+let sendMessage: ReturnType<typeof vi.fn>;
+let waitForMessage: ReturnType<typeof vi.fn>;
+let controller: DawPortControllerImpl;
+
+beforeEach(() => {
+  sendMessage = vi.fn().mockResolvedValue(undefined);
+  waitForMessage = vi.fn()
+    .mockResolvedValueOnce([0xB6, 30, 6])  // Phase 1 response
+    .mockResolvedValueOnce([0x9F, 11, 0])  // Phase 1 Note Off echo
+    .mockResolvedValueOnce([0x9F, 11, 0]); // Phase 2 Note Off echo
+
+  controller = new DawPortControllerImpl(sendMessage, waitForMessage);
+});
+```
+
+4. **Update test expectations for Phase 1 + Phase 2:**
+```typescript
+it('should send correct message sequence for slot 0', async () => {
+  await controller.selectSlot(0);
+
+  // Should have 6+ calls (Phase 1: 3, Phase 2: 3)
+  expect(sendMessage.mock.calls.length).toBeGreaterThanOrEqual(6);
+
+  // Phase 1: Query
+  expect(sendMessage).toHaveBeenNthCalledWith(1, [0x9F, 11, 127]);  // Note On ch16
+  expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB7, 30, 0]);    // CC query ch8
+  expect(sendMessage).toHaveBeenNthCalledWith(3, [0x9F, 11, 0]);    // Note Off ch16
+
+  // Phase 2: Set (if different slot)
+  // Assertions depend on waitForMessage mock response
+});
+```
+
+5. **Add test for conditional Phase 2:**
+```typescript
+it('should skip Phase 2 if already on target slot', async () => {
+  // Mock device response showing already on slot 0
+  waitForMessage.mockResolvedValueOnce([0xB6, 30, 6]);
+
+  await controller.selectSlot(0);
+
+  // Should only have Phase 1 (3 messages)
+  expect(sendMessage).toHaveBeenCalledTimes(3);
+});
+```
+
+---
+
+### Phase 3: Validation
+
+1. **Run full test suite:**
+   ```bash
+   pnpm test
+   ```
+
+2. **Verify test count:**
+   - Should see: `Test Files 10 passed | Tests 257 passed`
+   - No failures
+
+3. **Run typecheck:**
+   ```bash
+   pnpm typecheck
+   ```
+
+4. **Optional: Test with real device**
+   - If hardware is available, run backup utility:
+     ```bash
+     npm run backup
+     ```
+
+---
+
+## Files to Modify
+
+### Source Files (Phase 1)
+- `modules/launch-control-xl3/src/modes/CustomModeManager.ts`
+  - Lines 204-212: Add property aliases
+  - Lines 356-403: Update `createDefaultMode()`
+  - After line 482: Add `clearCache()` and `getCachedModes()`
+
+- `modules/launch-control-xl3/src/core/SysExParser.ts`
+  - Lines ~500-550: Fix mode name boundary detection
+
+### Test Files (Phase 2)
+- `test/core/SysExParser.test.ts` (19 tests)
+- `test/unit/CustomModeManager.test.ts` (22 tests - will auto-fix after Phase 1)
+- `test/core/DawPortController.test.ts` (3 tests - complete rewrite)
+- `test/unit/RealDeviceFixtures.test.ts` (1 test - will auto-fix after Phase 1)
+
+---
+
+## Execution Timeline
+
+### Phase 1: Parallel Source Fixes
+- **Duration:** 30-45 minutes
+- **Agents:** 3 typescript-pro agents running in parallel
+- **Blocker:** None (independent changes)
+
+### Phase 2: Sequential Test Updates
+- **Duration:** 60-90 minutes
+- **Agents:** 1 test-automator agent
+- **Blocker:** Must complete Phase 1 first
+
+### Phase 3: Validation
+- **Duration:** 15 minutes
+- **Blocker:** Must complete Phase 2 first
+
+**Total Estimated Time:** 2-3 hours
+
+---
+
+## Success Criteria
+
+- [ ] All 257 tests passing
+- [ ] No test files failing
+- [ ] `pnpm typecheck` passes
+- [ ] No regressions in existing functionality
+- [ ] Real device backup utility works (if tested)
+
+---
+
+## Notes
+
+### Why Tests Failed After PR #34
+
+PR #34 fixed a parser bug (issue #32) where 0x40 bytes inside control data were being misinterpreted as control markers. The fix removed 64 lines of incorrect parsing logic, which caused:
+
+1. **Parsing format changes:** SysExParser now correctly skips 0x40 data bytes
+2. **Protocol evolution:** DawPortController was updated to use bidirectional query/response
+3. **Property name updates:** CustomModeManager was refactored for clarity
+
+Tests were not updated alongside these changes, leading to the 48 failures.
+
+### Design Decisions
+
+1. **Property Aliases:** We're adding both property names (e.g., `channel` and `midiChannel`) for backward compatibility rather than breaking API changes.
+
+2. **Cache Methods:** Adding minimal implementations of `clearCache()` and `getCachedModes()` to satisfy tests. Full persistent caching can be added later if needed.
+
+3. **DawPortController Tests:** Complete rewrite is cleaner than trying to adapt old tests to new protocol. The bidirectional protocol is fundamentally different.
+
+---
+
+## References
+
+- **Issue #32:** Parser bug fix workplan at `docs/1.0/issues/32/implementation/workplan.md`
+- **PR #34:** Merged fix for issue #32
+- **PROTOCOL.md:** Device protocol documentation (updated in PR #34)
+- **Test Output:** Full test failure log in conversation context
+
+---
+
+**Document Version:** 1.0
+**Last Updated:** 2025-10-11
+**Status:** Ready for implementation
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
index be38155..aa00e0f 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
@@ -348,6 +348,9 @@ export class SysExParser {
   /**
    * Phase 1 Fix: Enhanced name parsing with factory fallback handling
    * Handles both custom names and factory format fallbacks (06 20 1F pattern)
+   *
+   * BUGFIX (2025-10-11): Stop reading at marker byte boundaries (0x48, 0x49, 0x60, 0x69, 0xF7)
+   * to prevent including control/label/color markers in mode name.
    */
   private static parseName(data: number[]): string | undefined {
     let nameStart = -1;
@@ -409,18 +412,30 @@ export class SysExParser {
         }
       } else {
         // Fall back to terminator-based parsing for formats without length
+        // BUGFIX: Check for marker bytes BEFORE adding to nameBytes
         for (let i = nameStart; i < data.length; i++) {
           const byte = data[i];
 
           if (byte === undefined) break;
 
-          // Stop at control structure patterns
-          if (byte === 0x49 && i < data.length - 2) {
-            const next1 = data[i + 1];
-            const next2 = data[i + 2];
-            if (next1 === 0x21 && next2 === 0x00) {
-              break;
-            }
+          // Stop at control marker bytes (0x48, 0x49)
+          if (byte === 0x48 || byte === 0x49) {
+            break;
+          }
+
+          // Stop at label marker byte (0x69)
+          if (byte === 0x69) {
+            break;
+          }
+
+          // Stop at color marker byte (0x60)
+          if (byte === 0x60) {
+            break;
+          }
+
+          // Stop at end of message (0xF7)
+          if (byte === 0xF7) {
+            break;
           }
 
           // Stop at terminator 0x21 (!)
diff --git a/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts b/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts
index 31e331b..291a993 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts
@@ -204,11 +204,18 @@ export class CustomModeManager extends EventEmitter {
         mode.controls[controlId] = {
           name: label,
           type: this.getControlType(control.controlId),
+          // Primary property names
           midiChannel: control.midiChannel,
           ccNumber: control.ccNumber,
           minValue: control.minValue,
           maxValue: control.maxValue,
           behavior: control.behavior as ControlBehaviour,
+          // Legacy aliases for backward compatibility
+          channel: control.midiChannel,
+          cc: control.ccNumber,
+          min: control.minValue,
+          max: control.maxValue,
+          behaviour: control.behavior as ControlBehaviour,
         };
       }
     }
@@ -355,6 +362,13 @@ export class CustomModeManager extends EventEmitter {
       const key = `SEND_A${i + 1}`;
       mode.controls[key] = {
         type: 'knob',
+        // Primary property names
+        midiChannel: 0,
+        ccNumber: 13 + i,
+        minValue: 0,
+        maxValue: 127,
+        behavior: 'absolute',
+        // Legacy aliases for backward compatibility
         channel: 0,
         cc: 13 + i,
         min: 0,
@@ -368,6 +382,13 @@ export class CustomModeManager extends EventEmitter {
       const key = `SEND_B${i + 1}`;
       mode.controls[key] = {
         type: 'knob',
+        // Primary property names
+        midiChannel: 0,
+        ccNumber: 29 + i,
+        minValue: 0,
+        maxValue: 127,
+        behavior: 'absolute',
+        // Legacy aliases for backward compatibility
         channel: 0,
         cc: 29 + i,
         min: 0,
@@ -381,6 +402,13 @@ export class CustomModeManager extends EventEmitter {
       const key = `PAN${i + 1}`;
       mode.controls[key] = {
         type: 'knob',
+        // Primary property names
+        midiChannel: 0,
+        ccNumber: 49 + i,
+        minValue: 0,
+        maxValue: 127,
+        behavior: 'absolute',
+        // Legacy aliases for backward compatibility
         channel: 0,
         cc: 49 + i,
         min: 0,
@@ -394,6 +422,13 @@ export class CustomModeManager extends EventEmitter {
       const key = `FADER${i + 1}`;
       mode.controls[key] = {
         type: 'fader',
+        // Primary property names
+        midiChannel: 0,
+        ccNumber: 77 + i,
+        minValue: 0,
+        maxValue: 127,
+        behavior: 'absolute',
+        // Legacy aliases for backward compatibility
         channel: 0,
         cc: 77 + i,
         min: 0,
@@ -479,6 +514,24 @@ export class CustomModeManager extends EventEmitter {
     this.pendingOperations.clear();
     this.removeAllListeners();
   }
+
+  /**
+   * Clear the pending operations cache
+   */
+  clearCache(): void {
+    this.pendingOperations.clear();
+  }
+
+  /**
+   * Get all cached modes
+   * Note: Current implementation doesn't maintain persistent cache beyond pending operations
+   * @returns Map of slot numbers to cached CustomMode objects
+   */
+  getCachedModes(): Map<number, CustomMode> {
+    // For now, return empty map as we don't persist cache beyond pendingOperations
+    // Future enhancement: Add persistent caching if needed
+    return new Map();
+  }
 }
 
-export default CustomModeManager;
\ No newline at end of file
+export default CustomModeManager;
diff --git a/modules/audio-control/modules/launch-control-xl3/test/core/DawPortController.test.ts b/modules/audio-control/modules/launch-control-xl3/test/core/DawPortController.test.ts
index 4cc30c2..8388b36 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/core/DawPortController.test.ts
+++ b/modules/audio-control/modules/launch-control-xl3/test/core/DawPortController.test.ts
@@ -3,45 +3,95 @@ import { DawPortControllerImpl } from '../../src/core/DawPortController';
 
 describe('DawPortController', () => {
   let sendMessage: ReturnType<typeof vi.fn>;
+  let waitForMessage: ReturnType<typeof vi.fn>;
   let controller: DawPortControllerImpl;
 
   beforeEach(() => {
     sendMessage = vi.fn().mockResolvedValue(undefined);
-    controller = new DawPortControllerImpl(sendMessage);
+
+    // Default mock for waitForMessage - simulates device responses
+    waitForMessage = vi.fn()
+      .mockResolvedValueOnce([0xB6, 30, 6])   // Phase 1 CC response (slot 0)
+      .mockResolvedValueOnce([0x9F, 11, 0])   // Phase 1 Note Off echo
+      .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 2 Note Off echo (if needed)
+
+    controller = new DawPortControllerImpl(sendMessage, waitForMessage);
   });
 
   describe('selectSlot', () => {
-    it('should send correct message sequence for slot 0 (physical slot 1)', async () => {
+    it('should send correct bidirectional message sequence when changing slots', async () => {
+      // Mock device reporting different slot, forcing Phase 2
+      waitForMessage.mockReset();
+      waitForMessage
+        .mockResolvedValueOnce([0xB6, 30, 7])   // Device says slot 1
+        .mockResolvedValueOnce([0x9F, 11, 0])   // Phase 1 Note Off echo
+        .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 2 Note Off echo
+
       await controller.selectSlot(0);
 
-      expect(sendMessage).toHaveBeenCalledTimes(3);
+      // Should have 6 messages (Phase 1: 3, Phase 2: 3)
+      expect(sendMessage).toHaveBeenCalledTimes(6);
 
-      // Note On: channel 15 (0x9F), note 11, velocity 127
-      expect(sendMessage).toHaveBeenNthCalledWith(1, [0x9F, 11, 127]);
+      // Phase 1: Query current slot
+      expect(sendMessage).toHaveBeenNthCalledWith(1, [0x9F, 11, 127]);  // Note On ch16
+      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB7, 30, 0]);    // CC query ch8
+      expect(sendMessage).toHaveBeenNthCalledWith(3, [0x9F, 11, 0]);    // Note Off ch16
 
-      // CC: channel 5 (0xB5), controller 30, value 6 (slot 0 + 1 + 5)
-      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, 6]);
+      // Phase 2: Set target slot (because device was on slot 1, not 0)
+      expect(sendMessage).toHaveBeenNthCalledWith(4, [0x9F, 11, 127]);  // Note On ch16
+      expect(sendMessage).toHaveBeenNthCalledWith(5, [0xB6, 30, 6]);    // CC set ch7, value 6 (slot 0)
+      expect(sendMessage).toHaveBeenNthCalledWith(6, [0x9F, 11, 0]);    // Note Off ch16
+    });
 
-      // Note Off: channel 15 (0x9F), note 11, velocity 0
-      expect(sendMessage).toHaveBeenNthCalledWith(3, [0x9F, 11, 0]);
+    it('should skip Phase 2 if already on target slot', async () => {
+      // Mock device reporting correct slot
+      waitForMessage.mockReset();
+      waitForMessage
+        .mockResolvedValueOnce([0xB6, 30, 6])   // Device already on slot 0
+        .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 1 Note Off echo
+
+      await controller.selectSlot(0);
+
+      // Should only have Phase 1 (3 messages)
+      expect(sendMessage).toHaveBeenCalledTimes(3);
+
+      // Verify no Phase 2 CC set message sent
+      const ccSetCalls = sendMessage.mock.calls.filter(
+        call => call[0][0] === 0xB6 && call[0][1] === 30 && call[0][2] !== 0
+      );
+      expect(ccSetCalls).toHaveLength(0);
     });
 
-    it('should send correct message sequence for slot 1 (physical slot 2)', async () => {
+    it('should send correct bidirectional sequence for slot 1', async () => {
+      // Mock device on different slot to force Phase 2
+      waitForMessage.mockReset();
+      waitForMessage
+        .mockResolvedValueOnce([0xB6, 30, 6])   // Device says slot 0
+        .mockResolvedValueOnce([0x9F, 11, 0])   // Phase 1 Note Off echo
+        .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 2 Note Off echo
+
       await controller.selectSlot(1);
 
-      expect(sendMessage).toHaveBeenCalledTimes(3);
+      expect(sendMessage).toHaveBeenCalledTimes(6);
 
-      // CC value should be 7 (slot 1 + 1 + 5)
-      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, 7]);
+      // CC set value should be 7 (slot 1 + 6)
+      expect(sendMessage).toHaveBeenNthCalledWith(5, [0xB6, 30, 7]);
     });
 
-    it('should send correct message sequence for slot 14 (physical slot 15)', async () => {
+    it('should send correct bidirectional sequence for slot 14', async () => {
+      // Mock device on different slot to force Phase 2
+      waitForMessage.mockReset();
+      waitForMessage
+        .mockResolvedValueOnce([0xB6, 30, 6])   // Device says slot 0
+        .mockResolvedValueOnce([0x9F, 11, 0])   // Phase 1 Note Off echo
+        .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 2 Note Off echo
+
       await controller.selectSlot(14);
 
-      expect(sendMessage).toHaveBeenCalledTimes(3);
+      expect(sendMessage).toHaveBeenCalledTimes(6);
 
-      // CC value should be 20 (slot 14 + 1 + 5)
-      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, 20]);
+      // CC set value should be 20 (slot 14 + 6)
+      expect(sendMessage).toHaveBeenNthCalledWith(5, [0xB6, 30, 20]);
     });
 
     it('should calculate CC value correctly for all slots', async () => {
@@ -65,10 +115,18 @@ describe('DawPortController', () => {
 
       for (const { slot, ccValue } of expectedMappings) {
         sendMessage.mockClear();
+        waitForMessage.mockReset();
+
+        // Force Phase 2 by reporting different slot
+        waitForMessage
+          .mockResolvedValueOnce([0xB6, 30, 6])   // Device on slot 0
+          .mockResolvedValueOnce([0x9F, 11, 0])   // Phase 1 Note Off echo
+          .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 2 Note Off echo
+
         await controller.selectSlot(slot);
 
-        // Check the CC message (2nd call)
-        expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB5, 30, ccValue]);
+        // Check the CC set message (5th call in Phase 2)
+        expect(sendMessage).toHaveBeenNthCalledWith(5, [0xB6, 30, ccValue]);
       }
     });
 
@@ -80,33 +138,98 @@ describe('DawPortController', () => {
       await expect(controller.selectSlot(15)).rejects.toThrow('Invalid slot: 15. Must be 0-14');
     });
 
-    it('should add delay after sending messages', async () => {
+    it('should complete slot selection within reasonable time', async () => {
       const start = Date.now();
       await controller.selectSlot(0);
       const duration = Date.now() - start;
 
-      // Should have at least 50ms delay
-      expect(duration).toBeGreaterThanOrEqual(45); // Allow some margin
+      // Should complete in under 1 second (generous timeout)
+      expect(duration).toBeLessThan(1000);
     });
 
     it('should use correct MIDI channels', async () => {
+      // Force Phase 2 by mocking different slot
+      waitForMessage.mockReset();
+      waitForMessage
+        .mockResolvedValueOnce([0xB6, 30, 7])   // Device on slot 1
+        .mockResolvedValueOnce([0x9F, 11, 0])   // Phase 1 Note Off echo
+        .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 2 Note Off echo
+
+      await controller.selectSlot(0);
+
+      const calls = sendMessage.mock.calls;
+
+      // Note messages on channel 16 (0x9F = 0x90 | 0x0F)
+      const noteOnCalls = calls.filter(c => (c[0][0] & 0xF0) === 0x90);
+      noteOnCalls.forEach(call => {
+        expect(call[0][0] & 0x0F).toBe(0x0F); // Channel 16 (15 in 0-based)
+      });
+
+      // CC query on channel 8 (0xB7 = 0xB0 | 0x07)
+      const ccQuery = calls.find(c => c[0][0] === 0xB7 && c[0][1] === 30 && c[0][2] === 0);
+      expect(ccQuery).toBeDefined();
+
+      // CC set on channel 7 (0xB6 = 0xB0 | 0x06)
+      const ccSet = calls.find(c => c[0][0] === 0xB6 && c[0][1] === 30 && c[0][2] === 6);
+      expect(ccSet).toBeDefined();
+    });
+
+    it('should handle missing waitForMessage gracefully', async () => {
+      // Create controller without waitForMessage
+      const controllerNoWait = new DawPortControllerImpl(sendMessage);
+
+      await controllerNoWait.selectSlot(0);
+
+      // Should still send all messages (assumes Phase 2 needed)
+      expect(sendMessage).toHaveBeenCalledTimes(6);
+
+      // Phase 1 messages
+      expect(sendMessage).toHaveBeenNthCalledWith(1, [0x9F, 11, 127]);
+      expect(sendMessage).toHaveBeenNthCalledWith(2, [0xB7, 30, 0]);
+      expect(sendMessage).toHaveBeenNthCalledWith(3, [0x9F, 11, 0]);
+
+      // Phase 2 messages (sent because we can't detect current slot)
+      expect(sendMessage).toHaveBeenNthCalledWith(4, [0x9F, 11, 127]);
+      expect(sendMessage).toHaveBeenNthCalledWith(5, [0xB6, 30, 6]);
+      expect(sendMessage).toHaveBeenNthCalledWith(6, [0x9F, 11, 0]);
+    });
+
+    it('should handle waitForMessage timeout gracefully', async () => {
+      // Mock waitForMessage to timeout (throw)
+      waitForMessage.mockReset();
+      waitForMessage.mockRejectedValue(new Error('Timeout'));
+
+      await controller.selectSlot(0);
+
+      // Should complete successfully and send all messages
+      expect(sendMessage).toHaveBeenCalledTimes(6);
+    });
+
+    it('should verify device response channel and controller', async () => {
+      waitForMessage.mockReset();
+
+      // First call returns valid response
+      waitForMessage
+        .mockResolvedValueOnce([0xB6, 30, 8])   // Slot 2
+        .mockResolvedValueOnce([0x9F, 11, 0])   // Phase 1 Note Off
+        .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 2 Note Off
+
       await controller.selectSlot(0);
 
-      const [noteOn] = sendMessage.mock.calls[0][0];
-      const [cc] = sendMessage.mock.calls[1][0];
-      const [noteOff] = sendMessage.mock.calls[2][0];
+      // Verify the predicate checks for correct channel and controller
+      const predicateCall = waitForMessage.mock.calls[0][0];
+
+      // Test predicate with correct message
+      expect(predicateCall([0xB6, 30, 8])).toBe(true);  // CC ch7, controller 30
 
-      // Note messages on channel 15 (0x9F = 0x90 | 0x0F)
-      expect(noteOn & 0xF0).toBe(0x90); // Note On status
-      expect(noteOn & 0x0F).toBe(0x0F); // Channel 15
+      // Test predicate with wrong channel
+      expect(predicateCall([0xB5, 30, 8])).toBe(false); // Wrong channel
 
-      // CC on channel 5 (0xB5 = 0xB0 | 0x05)
-      expect(cc & 0xF0).toBe(0xB0); // CC status
-      expect(cc & 0x0F).toBe(0x05); // Channel 5 (6 in 1-based)
+      // Test predicate with wrong controller
+      expect(predicateCall([0xB6, 31, 8])).toBe(false); // Wrong controller
 
-      // Note Off is Note On with velocity 0
-      expect(noteOff & 0xF0).toBe(0x90);
-      expect(noteOff & 0x0F).toBe(0x0F);
+      // Test predicate with wrong message type
+      expect(predicateCall([0x9F, 30, 8])).toBe(false); // Note On instead of CC
     });
   });
 
@@ -134,6 +257,17 @@ describe('DawPortController', () => {
 
       expect(ccMessages).toHaveLength(0);
     });
+
+    it('should use channel 16 for note messages', async () => {
+      await controller.sendNoteNotification();
+
+      const calls = sendMessage.mock.calls;
+
+      // Both messages should be on channel 16
+      calls.forEach(([msg]) => {
+        expect(msg[0] & 0x0F).toBe(0x0F); // Channel 16 (15 in 0-based)
+      });
+    });
   });
 
   describe('error handling', () => {
@@ -154,5 +288,25 @@ describe('DawPortController', () => {
       // First message should have been sent
       expect(sendMessage).toHaveBeenCalledTimes(2);
     });
+
+    it('should handle errors during Phase 2', async () => {
+      // Phase 1 succeeds, Phase 2 fails
+      waitForMessage.mockReset();
+      waitForMessage
+        .mockResolvedValueOnce([0xB6, 30, 7])   // Device on slot 1
+        .mockResolvedValueOnce([0x9F, 11, 0]);  // Phase 1 Note Off
+
+      sendMessage
+        .mockResolvedValueOnce(undefined)  // Phase 1: Note On
+        .mockResolvedValueOnce(undefined)  // Phase 1: CC query
+        .mockResolvedValueOnce(undefined)  // Phase 1: Note Off
+        .mockResolvedValueOnce(undefined)  // Phase 2: Note On
+        .mockRejectedValueOnce(new Error('Phase 2 failed')); // Phase 2: CC set fails
+
+      await expect(controller.selectSlot(0)).rejects.toThrow('Phase 2 failed');
+
+      // Should have attempted 5 messages before failing
+      expect(sendMessage).toHaveBeenCalledTimes(5);
+    });
   });
-});
\ No newline at end of file
+});
diff --git a/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts b/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
index 596c873..e16c1cb 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
+++ b/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
@@ -9,6 +9,66 @@ import {
   SysExMessageType,
   DEVICE_FAMILY
 } from '@/core/SysExParser';
+import { CONTROL_IDS } from '@/modes/CustomModeManager';
+
+/**
+ * Convert CustomMode format to CustomModeMessage format for testing
+ *
+ * Takes object-based controls (e.g., { SEND_A1: {...}, SEND_B2: {...} })
+ * and converts to array-based format with controlId properties that
+ * buildCustomModeWriteRequest expects.
+ */
+function convertToCustomModeMessage(mode: any, slot: number): any {
+  const controls: any[] = [];
+  const colors: any[] = [];
+  const labels = new Map<number, string>();
+
+  // Convert object-based controls to array-based
+  if (mode.controls) {
+    for (const [key, control] of Object.entries(mode.controls)) {
+      const controlId = (CONTROL_IDS as any)[key];
+      if (controlId !== undefined) {
+        controls.push({
+          controlId,
+          channel: (control as any).channel ?? (control as any).midiChannel,
+          ccNumber: (control as any).cc ?? (control as any).ccNumber,
+          minValue: (control as any).min ?? (control as any).minValue ?? 0,
+          maxValue: (control as any).max ?? (control as any).maxValue ?? 127,
+          behaviour: (control as any).behaviour ?? (control as any).behavior ?? 'absolute',
+        });
+
+        if ((control as any).name) {
+          labels.set(controlId, (control as any).name);
+        }
+      }
+    }
+  }
+
+  // Convert LED mappings to colors array
+  if (mode.leds) {
+    for (const [controlName, ledConfig] of mode.leds.entries()) {
+      const controlId = (CONTROL_IDS as any)[controlName];
+      if (controlId !== undefined) {
+        colors.push({
+          controlId,
+          color: (ledConfig as any).color,
+          behaviour: (ledConfig as any).behaviour ?? 'static',
+        });
+      }
+    }
+  }
+
+  return {
+    type: 'custom_mode_write',
+    manufacturerId: [0x00, 0x20, 0x29],
+    slot,
+    name: mode.name,
+    controls,
+    colors,
+    labels,
+    data: [],
+  };
+}
 
 describe('SysExParser', () => {
   describe('parse', () => {
@@ -545,7 +605,7 @@ describe('SysExParser', () => {
     describe('Message Structure', () => {
       it('should create a properly formatted SysEx message with correct header and footer', () => {
         const slot = 0;
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot,
@@ -574,7 +634,7 @@ describe('SysExParser', () => {
       });
 
       it('should include the data header (00 20 08) after the protocol header', () => {
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -594,7 +654,7 @@ describe('SysExParser', () => {
     describe('Mode Name Encoding', () => {
       it('should encode the mode name as ASCII after the data header', () => {
         const modeName = 'CHANNEVE';
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -614,7 +674,7 @@ describe('SysExParser', () => {
       });
 
       it('should limit mode name to 8 characters maximum', () => {
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -636,7 +696,7 @@ describe('SysExParser', () => {
 
     describe('Control Encoding', () => {
       it('should encode controls with 0x49 marker and correct structure', () => {
-        const control: ControlMapping = {
+        const control: any = {
           controlId: 0x00, // Fader 1
           name: 'Volume',
           midiChannel: 0,
@@ -646,7 +706,7 @@ describe('SysExParser', () => {
           behaviour: 'absolute'
         };
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -681,14 +741,14 @@ describe('SysExParser', () => {
       });
 
       it('should apply correct control ID offset (+0x28) for all controls', () => {
-        const controls: ControlMapping[] = [
+        const controls: any[] = [
           { controlId: 0x00, ccNumber: 1 }, // Fader 1
           { controlId: 0x10, ccNumber: 2 }, // Top encoder 1
           { controlId: 0x18, ccNumber: 3 }, // Mid encoder 1
           { controlId: 0x20, ccNumber: 4 }, // Bot encoder 1
         ];
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -722,14 +782,14 @@ describe('SysExParser', () => {
       });
 
       it('should use correct control type values based on hardware position', () => {
-        const controls: ControlMapping[] = [
+        const controls: any[] = [
           { controlId: 0x00 }, // Fader - should use type 0x00
           { controlId: 0x10 }, // Top encoder - should use type 0x05
           { controlId: 0x18 }, // Mid encoder - should use type 0x09
           { controlId: 0x20 }, // Bot encoder - should use type 0x0D
         ];
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -762,13 +822,13 @@ describe('SysExParser', () => {
 
     describe('Label and Color Data', () => {
       it('should include label data with 0x69 marker and control names', () => {
-        const control: ControlMapping = {
+        const control: any = {
           controlId: 0x00,
           name: 'Volume',
           ccNumber: 77
         };
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -796,13 +856,13 @@ describe('SysExParser', () => {
       });
 
       it('should include color data with 0x60 marker', () => {
-        const control: ControlMapping = {
+        const control: any = {
           controlId: 0x00,
           name: 'Vol',
           ccNumber: 77
         };
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -826,7 +886,7 @@ describe('SysExParser', () => {
       });
 
       it('should include labels and colors for all controls', () => {
-        const controls: ControlMapping[] = [
+        const controls: any[] = [
           { controlId: 0x00, name: 'Vol1', ccNumber: 1 },
           { controlId: 0x01, name: 'Vol2', ccNumber: 2 },
         ];
@@ -836,7 +896,7 @@ describe('SysExParser', () => {
           { controlId: 0x01, color: 0x0D },
         ];
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -861,7 +921,7 @@ describe('SysExParser', () => {
     describe('Complete Message Validation', () => {
       it('should generate a message matching the CHANNEVE example structure', () => {
         // Create controls matching the CHANNEVE example from MIDI-PROTOCOL.md
-        const controls: ControlMapping[] = [
+        const controls: any[] = [
           { controlId: 0x10, name: 'Mic Gain', midiChannel: 0, ccNumber: 13 }, // Top encoder 1
           { controlId: 0x11, name: 'Reverb', midiChannel: 0, ccNumber: 14 },   // Top encoder 2
         ];
@@ -871,7 +931,7 @@ describe('SysExParser', () => {
           { controlId: 0x11, color: 0x60 },
         ];
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -905,14 +965,14 @@ describe('SysExParser', () => {
 
       it('should fail if current implementation is incorrect', () => {
         // This test documents known issues with the current implementation
-        const control: ControlMapping = {
+        const control: any = {
           controlId: 0x00,
           name: 'TestControl',
           midiChannel: 5,
           ccNumber: 64
         };
 
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -941,7 +1001,7 @@ describe('SysExParser', () => {
 
     describe('Error Handling', () => {
       it('should throw error for invalid slot numbers', () => {
-        const modeData: CustomModeMessage = {
+        const modeData: any = {
           type: 'custom_mode_response',
           manufacturerId: [0x00, 0x20, 0x29],
           slot: 0,
@@ -1050,4 +1110,4 @@ describe('SysExParser', () => {
       expect(control.ccNumber).toBe(0x28); // Based on the test data: 0x40 0x28
     });
   });
-});
\ No newline at end of file
+});


---

_**Agent (claude-sonnet-4-5-20250929)**_

docs(audio-control): add test failure analysis and workplan for post-PR34 fixes

