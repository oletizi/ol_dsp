<!-- Generated by SpecStory -->

# MIDI Test File Relocation and Cleanup (2025-09-28 19:03:02Z)

<!-- Claude Code Session 627efbc8-7489-4fc3-b0ba-367f6d34e11b (2025-09-28_19-03-02Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/backends/NodeMidiBackend.ts b/modules/audio-control/modules/launch-control-xl3/src/core/backends/NodeMidiBackend.ts
deleted file mode 100644
index 9b2f394..0000000
--- a/modules/audio-control/modules/launch-control-xl3/src/core/backends/NodeMidiBackend.ts
+++ /dev/null
@@ -1,256 +0,0 @@
-/**
- * Node.js MIDI backend using node-midi
- */
-
-import { createRequire } from 'module';
-import type {
-  MidiBackendInterface,
-  MidiPortInfo,
-  MidiInputPort,
-  MidiOutputPort,
-  MidiPort,
-  MidiMessage
-} from '../MidiInterface.js';
-
-// Create require function for ESM compatibility
-const require = createRequire(import.meta.url);
-
-/**
- * Node MIDI backend implementation
- */
-export class NodeMidiBackend implements MidiBackendInterface {
-  private midi: any;
-  private inputs: Map<string, any> = new Map();
-  private outputs: Map<string, any> = new Map();
-  private isInitialized = false;
-
-  async initialize(): Promise<void> {
-    if (this.isInitialized) return;
-
-    try {
-      // Use require for native module
-      this.midi = require('midi');
-      this.isInitialized = true;
-    } catch (error: any) {
-      console.error('Failed to load midi:', error);
-      throw new Error('node-midi not available. Install with: npm install midi');
-    }
-  }
-
-  async getInputPorts(): Promise<MidiPortInfo[]> {
-    if (!this.isInitialized) {
-      throw new Error('Backend not initialized');
-    }
-
-    const input = new this.midi.Input();
-    const ports: MidiPortInfo[] = [];
-    const count = input.getPortCount();
-
-    for (let i = 0; i < count; i++) {
-      const name = input.getPortName(i);
-      ports.push({
-        id: `input-${i}`,
-        name
-      });
-    }
-
-    input.closePort();
-    return ports;
-  }
-
-  async getOutputPorts(): Promise<MidiPortInfo[]> {
-    if (!this.isInitialized) {
-      throw new Error('Backend not initialized');
-    }
-
-    const output = new this.midi.Output();
-    const ports: MidiPortInfo[] = [];
-    const count = output.getPortCount();
-
-    for (let i = 0; i < count; i++) {
-      const name = output.getPortName(i);
-      ports.push({
-        id: `output-${i}`,
-        name
-      });
-    }
-
-    output.closePort();
-    return ports;
-  }
-
-  async openInput(portId: string): Promise<MidiInputPort> {
-    if (!this.isInitialized) {
-      throw new Error('Backend not initialized');
-    }
-
-    // console.log(`[NodeMidiBackend] Opening input port: ${portId}`);
-
-    // Check if portId is an index or a name
-    let index: number;
-    const input = new this.midi.Input();
-
-    if (portId.startsWith('input-')) {
-      // It's our ID format
-      index = parseInt(portId.replace('input-', ''));
-
-      // Validate index
-      const count = input.getPortCount();
-      if (index < 0 || index >= count) {
-        input.closePort();
-        throw new Error(`Invalid input port index: ${index} (available: 0-${count-1})`);
-      }
-    } else {
-      // Try to find port by name
-      index = -1;
-      const count = input.getPortCount();
-      for (let i = 0; i < count; i++) {
-        if (input.getPortName(i).includes(portId)) {
-          index = i;
-          break;
-        }
-      }
-      if (index === -1) {
-        input.closePort();
-        throw new Error(`Input port not found: ${portId}`);
-      }
-    }
-
-    // Get port name BEFORE opening (node-midi limitation)
-    const portName = input.getPortName(index);
-
-    const port: MidiInputPort = {
-      id: portId,
-      name: portName || `Input ${index}`,
-      type: 'input',
-      close: async () => {
-        input.closePort();
-        this.inputs.delete(portId);
-      },
-      onMessage: undefined
-    };
-
-    // CRITICAL FIX: Enable SysEx message reception
-    // By default, node-midi ignores SysEx messages
-    input.ignoreTypes(false, false, false); // Don't ignore SysEx, timing, active sensing
-
-    // Set up message handler
-    input.on('message', (_deltaTime: number, message: number[]) => {
-      if (port.onMessage) {
-        port.onMessage({
-          timestamp: Date.now(),
-          data: message
-        });
-      }
-    });
-
-    // Open the port
-    // console.log(`[NodeMidiBackend] Opening input port at index ${index}`);
-    input.openPort(index);
-    // console.log(`[NodeMidiBackend] Input port opened successfully`);
-    this.inputs.set(portId, input);
-
-    return port;
-  }
-
-  async openOutput(portId: string): Promise<MidiOutputPort> {
-    if (!this.isInitialized) {
-      throw new Error('Backend not initialized');
-    }
-
-    // console.log(`[NodeMidiBackend] Opening output port: ${portId}`);
-
-    // Check if portId is an index or a name
-    let index: number;
-    const output = new this.midi.Output();
-
-    if (portId.startsWith('output-')) {
-      // It's our ID format
-      index = parseInt(portId.replace('output-', ''));
-
-      // Validate index
-      const count = output.getPortCount();
-      if (index < 0 || index >= count) {
-        output.closePort();
-        throw new Error(`Invalid output port index: ${index} (available: 0-${count-1})`);
-      }
-    } else {
-      // Try to find port by name
-      index = -1;
-      const count = output.getPortCount();
-      for (let i = 0; i < count; i++) {
-        if (output.getPortName(i).includes(portId)) {
-          index = i;
-          break;
-        }
-      }
-      if (index === -1) {
-        output.closePort();
-        throw new Error(`Output port not found: ${portId}`);
-      }
-    }
-
-    // Get port name BEFORE opening (node-midi limitation)
-    // console.log(`[NodeMidiBackend] Getting port name at index ${index}`);
-    const portName = output.getPortName(index);
-    // console.log(`[NodeMidiBackend] Port name: ${portName}`);
-
-    // Open the port
-    // console.log(`[NodeMidiBackend] Opening port at index ${index}`);
-    output.openPort(index);
-    // console.log(`[NodeMidiBackend] Port opened successfully`);
-    this.outputs.set(portId, output);
-
-    const port: MidiOutputPort = {
-      id: portId,
-      name: portName || `Output ${index}`,
-      type: 'output',
-      close: async () => {
-        output.closePort();
-        this.outputs.delete(portId);
-      }
-    };
-
-    return port;
-  }
-
-  async sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
-    // console.log(`[NodeMidiBackend] sendMessage called with port.id: ${port.id}`);
-    const output = this.outputs.get(port.id);
-    if (!output) {
-      throw new Error('Output port not open');
-    }
-
-    // Convert to array if needed
-    // console.log(`[NodeMidiBackend] Message data:`, message.data);
-    const data = Array.isArray(message.data) ? message.data : Array.from(message.data);
-    // console.log(`[NodeMidiBackend] Sending message:`, data);
-
-    try {
-      output.sendMessage(data);
-      // console.log(`[NodeMidiBackend] Message sent successfully`);
-    } catch (error) {
-      console.error(`[NodeMidiBackend] Error sending message:`, error);
-      throw error;
-    }
-  }
-
-  async closePort(port: MidiPort): Promise<void> {
-    await port.close();
-  }
-
-  async cleanup(): Promise<void> {
-    // Close all open ports
-    for (const [_id, input] of this.inputs.entries()) {
-      input.closePort();
-    }
-    this.inputs.clear();
-
-    for (const [_id, output] of this.outputs.entries()) {
-      output.closePort();
-    }
-    this.outputs.clear();
-
-    this.isInitialized = false;
-  }
-}
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/LaunchControlXL3.handshake.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/LaunchControlXL3.handshake.test.ts
new file mode 100644
index 0000000..0fdd015
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/LaunchControlXL3.handshake.test.ts
@@ -0,0 +1,267 @@
+/**
+ * LaunchControlXL3 Handshake Integration Tests
+ *
+ * Tests that the controller properly facilitates the device handshake
+ * according to the MIDI-PROTOCOL.md specification.
+ */
+
+import { describe, it, expect, beforeEach, vi, afterEach } from 'vitest';
+import { LaunchControlXL3 } from '@/LaunchControlXL3.js';
+import type { MidiBackendInterface, MidiMessage, MidiPortInfo, MidiInputPort, MidiOutputPort } from '@/core/MidiInterface.js';
+import { NoOpLogger } from '@/core/Logger.js';
+
+describe('LaunchControlXL3 - Device Handshake', () => {
+  let controller: LaunchControlXL3;
+  let mockBackend: MockMidiBackend;
+
+  beforeEach(() => {
+    mockBackend = new MockMidiBackend();
+    controller = new LaunchControlXL3({
+      midiBackend: mockBackend,
+      logger: new NoOpLogger(),
+    });
+  });
+
+  afterEach(async () => {
+    await controller.cleanup();
+    vi.clearAllMocks();
+  });
+
+  describe('Device Inquiry Handshake', () => {
+    it('should send device inquiry message when connecting', async () => {
+      const sendSpy = vi.spyOn(mockBackend, 'sendMessage');
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(sendSpy).toHaveBeenCalled();
+      });
+
+      const deviceInquiryMessage = [0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7];
+      const calls = sendSpy.mock.calls;
+      const inquirySent = calls.some(call => {
+        const message = call[1];
+        return arraysEqual(Array.from(message.data), deviceInquiryMessage);
+      });
+
+      expect(inquirySent).toBe(true);
+
+      mockBackend.simulateDeviceResponse();
+      await connectionPromise;
+    });
+
+    it('should accept valid device inquiry response', async () => {
+      const validResponse: number[] = [
+        0xF0, 0x7E, 0x00, 0x06, 0x02,
+        0x00, 0x20, 0x29,
+        0x48, 0x01,
+        0x00, 0x00,
+        0x01, 0x00, 0x0A, 0x54,
+        0xF7
+      ];
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(mockBackend.inputPort).toBeDefined();
+      });
+
+      mockBackend.simulateIncomingMessage({
+        timestamp: Date.now(),
+        data: validResponse,
+        type: 'sysex',
+      });
+
+      await expect(connectionPromise).resolves.not.toThrow();
+      expect(controller.isConnected()).toBe(true);
+    });
+
+    it('should validate manufacturer ID in response', async () => {
+      const invalidResponse: number[] = [
+        0xF0, 0x7E, 0x00, 0x06, 0x02,
+        0xFF, 0xFF, 0xFF,
+        0x48, 0x01,
+        0x00, 0x00,
+        0x01, 0x00, 0x0A, 0x54,
+        0xF7
+      ];
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(mockBackend.inputPort).toBeDefined();
+      });
+
+      mockBackend.simulateIncomingMessage({
+        timestamp: Date.now(),
+        data: invalidResponse,
+        type: 'sysex',
+      });
+
+      await expect(connectionPromise).rejects.toThrow();
+    });
+
+    it('should timeout if no response received', async () => {
+      controller = new LaunchControlXL3({
+        midiBackend: mockBackend,
+        logger: new NoOpLogger(),
+      });
+
+      mockBackend.shouldRespondToInquiry = false;
+
+      const connectionPromise = controller.connect();
+
+      await expect(connectionPromise).rejects.toThrow(/timeout/i);
+    }, 10000);
+
+    it('should emit device:connected event after successful handshake', async () => {
+      const connectedHandler = vi.fn();
+      controller.on('device:connected', connectedHandler);
+
+      const connectionPromise = controller.connect();
+
+      await vi.waitFor(() => {
+        expect(mockBackend.inputPort).toBeDefined();
+      });
+
+      mockBackend.simulateDeviceResponse();
+      await connectionPromise;
+
+      expect(connectedHandler).toHaveBeenCalled();
+      expect(connectedHandler.mock.calls[0][0]).toMatchObject({
+        manufacturerId: expect.any(String),
+        deviceFamily: expect.any(Number),
+        modelNumber: expect.any(Number),
+        firmwareVersion: expect.any(String),
+      });
+    });
+
+    it('should emit device:error event if handshake fails', async () => {
+      const errorHandler = vi.fn();
+      controller.on('device:error', errorHandler);
+
+      mockBackend.shouldRespondToInquiry = false;
+
+      const connectionPromise = controller.connect();
+
+      await expect(connectionPromise).rejects.toThrow();
+      expect(errorHandler).toHaveBeenCalled();
+      expect(errorHandler.mock.calls[0][0]).toBeInstanceOf(Error);
+    });
+
+    it('should not proceed with connection if handshake fails', async () => {
+      mockBackend.shouldRespondToInquiry = false;
+
+      await expect(controller.connect()).rejects.toThrow();
+      expect(controller.isConnected()).toBe(false);
+    });
+  });
+});
+
+function arraysEqual(a: number[], b: number[]): boolean {
+  if (a.length !== b.length) return false;
+  return a.every((val, idx) => val === b[idx]);
+}
+
+class MockMidiBackend implements MidiBackendInterface {
+  inputPort?: MidiInputPort;
+  outputPort?: MidiOutputPort;
+  shouldRespondToInquiry = true;
+  private initCount = 0;
+
+  async initialize(): Promise<void> {
+    this.initCount++;
+  }
+
+  async getInputPorts(): Promise<MidiPortInfo[]> {
+    return [
+      { id: 'test-input', name: 'Launch Control XL' },
+    ];
+  }
+
+  async getOutputPorts(): Promise<MidiPortInfo[]> {
+    return [
+      { id: 'test-output', name: 'Launch Control XL' },
+    ];
+  }
+
+  async openInput(portId: string): Promise<MidiInputPort> {
+    this.inputPort = {
+      id: portId,
+      name: 'Launch Control XL',
+      type: 'input',
+      onMessage: undefined,
+      close: async () => {
+        this.inputPort = undefined;
+      },
+    };
+    return this.inputPort;
+  }
+
+  async openOutput(portId: string): Promise<MidiOutputPort> {
+    this.outputPort = {
+      id: portId,
+      name: 'Launch Control XL',
+      type: 'output',
+      close: async () => {
+        this.outputPort = undefined;
+      },
+    };
+    return this.outputPort;
+  }
+
+  async sendMessage(_port: MidiOutputPort, message: MidiMessage): Promise<void> {
+    const data = Array.from(message.data);
+
+    if (this.shouldRespondToInquiry && this.isDeviceInquiry(data)) {
+      setTimeout(() => {
+        this.simulateDeviceResponse();
+      }, 10);
+    }
+  }
+
+  private isDeviceInquiry(data: number[]): boolean {
+    const inquiryPattern = [0xF0, 0x7E, 0x00, 0x06, 0x01, 0xF7];
+    return arraysEqual(data, inquiryPattern);
+  }
+
+  simulateDeviceResponse(): void {
+    if (!this.inputPort || !this.inputPort.onMessage) {
+      return;
+    }
+
+    const response: number[] = [
+      0xF0, 0x7E, 0x00, 0x06, 0x02,
+      0x00, 0x20, 0x29,
+      0x48, 0x01,
+      0x00, 0x00,
+      0x01, 0x00, 0x0A, 0x54,
+      0xF7
+    ];
+
+    this.inputPort.onMessage({
+      timestamp: Date.now(),
+      data: response,
+      type: 'sysex',
+    });
+  }
+
+  simulateIncomingMessage(message: MidiMessage): void {
+    if (this.inputPort && this.inputPort.onMessage) {
+      this.inputPort.onMessage(message);
+    }
+  }
+
+  async closePort(port: { close: () => Promise<void> }): Promise<void> {
+    await port.close();
+  }
+
+  async cleanup(): Promise<void> {
+    if (this.inputPort) {
+      await this.inputPort.close();
+    }
+    if (this.outputPort) {
+      await this.outputPort.close();
+    }
+  }
+}
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

test(launch-control-xl3): add handshake integration tests, remove NodeMidiBackend

