<!-- Generated by SpecStory -->

# SysEx Send Fix: MIDI Protocol Workplan (2025-09-29 05:01:28Z)

<!-- Claude Code Session cf38138a-6aa5-499c-958f-2dd647d896ce (2025-09-29_05-01-28Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/PROTOCOL-SUMMARY.md b/modules/audio-control/PROTOCOL-SUMMARY.md
deleted file mode 100644
index 1ee602d..0000000
--- a/modules/audio-control/PROTOCOL-SUMMARY.md
+++ /dev/null
@@ -1,107 +0,0 @@
-# Launch Control XL 3 Protocol Analysis Summary
-
-## Complete Protocol Capture Results
-
-### ‚úÖ Phase 1: LED Control & Control Mapping
-- **Encoders**: 24 total (3 rows x 8), each with ring LEDs
-  - Row 1: CC 21, 85, 22, 19, 18, 17, 16, 23
-  - Row 2: CC 24, 15, 25, 14, 49, 50, 51, 26
-  - Row 3: CC 29-34, 27-28
-- **Sliders**: 8 total, CC 71-78 (no LEDs)
-- **Buttons**: 16 total (2 rows x 8), can send CC or Note messages
-- **LED Behavior**: Encoder LEDs respond automatically to CC values
-
-### ‚úÖ Phase 2: Device Initialization
-- Device sends serial number 3 times: `F0 00 20 29 00 42 02 [LX280935400469] F7`
-- Device sends identity reply 3 times: `F0 7E 00 06 02 00 20 29 48 01 00 00 01 00 0A 54 F7`
-- No host acknowledgment required
-- No LED initialization commands (hardware default state)
-
-### ‚úÖ Phase 3: Template Switching
-- **No MIDI messages** sent when switching templates on device
-- Device maintains internal state for 16 custom mode slots
-- Host must query device to know current template
-
-### ‚úÖ Phase 4: Real-time Feedback
-- Device sends CC messages when controls are manipulated
-- Different templates can use different MIDI channels (e.g., channel 16)
-- Bidirectional SysEx for reading/writing custom modes confirmed
-
-## Key Protocol Discoveries
-
-### Custom Mode Read/Write Protocol
-
-**Read Request:**
-```
-F0 00 20 29 02 15 05 00 15 [SLOT] 06 F7
-```
-
-**Read Response / Write Command:**
-```
-F0 00 20 29 02 15 05 00 10 [SLOT] 06 20 10 [DATA...] F7
-```
-
-### Control Definition Format
-```
-48 [ID] 02 [TYPE] [PARAMS] 48 00 [CC] 7F
-```
-- Control types: 05 (button), 09 (encoder), 0D, 19, 25 (various)
-- Each control has ID, type, CC number, and range
-
-## Implementation Guidelines
-
-### To Build a Web Application
-
-1. **Connection**:
-   - Request Web MIDI access with SysEx enabled
-   - Look for "LCXL3 1 MIDI In/Out" ports
-   - Listen for initialization messages to confirm device
-
-2. **Reading Custom Modes**:
-   - Send: `F0 00 20 29 02 15 05 00 15 [SLOT] 06 F7`
-   - Parse response for mode name and control mappings
-   - Decode using 7-bit to 8-bit conversion if needed
-
-3. **Writing Custom Modes**:
-   - Format control data with proper structure
-   - Send: `F0 00 20 29 02 15 05 00 10 [SLOT] 06 20 10 [DATA] F7`
-   - Split large messages if needed
-
-4. **Real-time Control**:
-   - Listen for CC messages on channels 1-16
-   - Map CC numbers to physical controls
-   - Update UI based on CC values
-
-5. **LED Control**:
-   - Encoder LEDs update automatically with CC values
-   - Button LEDs may require Note messages or specific modes
-   - No direct LED control protocol discovered
-
-## What's NOT Supported
-
-- Direct LED color control via SysEx
-- Template change notifications from device
-- Motorized fader feedback
-- Display/screen updates (device has no display)
-
-## Next Steps for Implementation
-
-1. Implement the TypeScript client using the discovered protocol
-2. Create UI for custom mode editor
-3. Add import/export for mode configurations
-4. Test with various DAWs for compatibility
-5. Consider adding LED control exploration in Note mode
-
-## Files Created
-
-- `/modules/audio-control/LAUNCH-CONTROL-PROTOCOL.md` - Complete protocol documentation
-- `/modules/audio-control/CONTROL-MAPPINGS.md` - Physical control to MIDI mappings
-- `/modules/audio-control/src/launch-control-xl3/` - TypeScript implementation
-  - `types.ts` - Type definitions
-  - `midimunge.ts` - 7-bit encoding/decoding
-  - `client.ts` - Web MIDI client
-  - `index.ts` - Module exports
-
-## Protocol Status: COMPLETE ‚úÖ
-
-All major protocol elements have been successfully reverse-engineered and documented. The Launch Control XL 3 can now be fully controlled via Web MIDI API.
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-SYSEX-SEND-FIX.md b/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-SYSEX-SEND-FIX.md
new file mode 100644
index 0000000..0e3a308
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/docs/WORKPLAN-SYSEX-SEND-FIX.md
@@ -0,0 +1,220 @@
+# SysEx Send Fix Workplan
+
+Based on comprehensive analysis of the failing unit tests for the `SysExParser.buildCustomModeWriteRequest` function, this workplan provides a detailed roadmap to fix critical issues in the launch-control-xl3 module that prevent proper communication with the device.
+
+## Executive Summary
+
+The current `buildCustomModeWriteRequest` function has three major issues causing device communication failures:
+
+1. **Generic Label Generation**: The function generates generic labels like "Fader 1" instead of using user-configured control names from the `name` field
+2. **Incorrect Byte Positioning**: Color markers are positioned incorrectly, causing corruption (0x65 instead of expected 0x60)
+3. **Protocol Specification Mismatch**: The message structure doesn't fully comply with the MIDI-PROTOCOL.md specification requirements
+
+These issues result in corrupted data being sent to the device, causing slots to end up empty after write operations.
+
+## Root Cause Analysis
+
+### Issue 1: Generic Label Generation ‚úÖ FIXED
+**Location**: `SysExParser.encodeCustomModeData()` method, lines 891-894
+**Problem**: The function calls `generateControlLabel(controlId)` which produces generic labels like "Fader 1", "Top 1", etc., instead of using the actual `control.name` field from the input data.
+
+**Test Evidence**:
+- Test "should use actual control names in labels, not generic ones" (lines 429-455)
+- Test expects "MyVolume" but gets "Fader 1"
+
+**Solution Implemented**: Modified to use `control.name` when available, falling back to `generateControlLabel()` for unnamed controls.
+
+### Issue 2: Incorrect Color Marker Positioning üöß IN PROGRESS
+**Location**: `SysExParser.encodeCustomModeData()` method, lines 897-902
+**Problem**: The color markers (0x60) are being positioned incorrectly due to improper offset calculations, resulting in corrupted byte values.
+
+**Test Evidence**:
+- Test "should include color data with 0x60 marker"
+- Expected 0x60 but receiving 0x65 (offset corruption)
+
+### Issue 3: Message Structure Compliance
+**Location**: Multiple locations in `buildCustomModeWriteRequest()` and `encodeCustomModeData()`
+**Problem**: The generated message structure doesn't fully match the protocol specification for control definitions, label sections, and color sections.
+
+**Test Evidence**:
+- Test "should encode control with 0x49 marker and +0x28 offset as per protocol"
+- Test "should include label markers (0x69) for controls with names"
+
+## Detailed Implementation Plan
+
+### Phase 1: Fix Label Generation ‚úÖ COMPLETED
+
+**Objective**: Replace generic label generation with actual control names
+
+**Implementation Completed**:
+```typescript
+// Use actual control name if available, otherwise generate generic label
+const labelText = control.name && control.name.trim() !== ''
+  ? control.name.substring(0, 12) // Truncate to max 12 chars for device compatibility
+  : this.generateControlLabel(controlId);
+```
+
+**Result**: Test "should use actual control names in labels, not generic ones" now passes
+
+### Phase 2: Fix Color Marker Positioning üöß IN PROGRESS
+
+**Objective**: Correct the byte positioning of color markers to prevent corruption
+
+**Changes Required**:
+1. **Review offset calculations in color section (lines 897-902)**:
+   - Verify the 0x28 offset is applied correctly
+   - Ensure no buffer overflows or incorrect indexing
+   - Check that color marker 0x60 is written at the correct position
+
+2. **Add proper validation**:
+   - Validate control ID ranges before applying offsets
+   - Add bounds checking for array operations
+   - Ensure color data is written in the correct sequence
+
+**Current Status**: Debugging why 0x65 appears instead of 0x60
+
+### Phase 3: Protocol Compliance Enhancement (Medium Priority)
+
+**Objective**: Ensure full compliance with MIDI protocol specification
+
+**Changes Required**:
+1. **Control Definition Structure**:
+   - Verify 11-byte control format: `49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00`
+   - Ensure proper control type mapping based on hardware position
+   - Validate channel and CC number encoding
+
+2. **Label Section Structure**:
+   - Implement proper label marker format: `69 [ID+0x28] [ASCII_TEXT...]`
+   - Ensure labels are null-terminated or properly delimited
+   - Handle variable-length label encoding
+
+3. **Color Section Structure**:
+   - Implement proper color marker format: `60 [ID+0x28] [COLOR_VALUE]`
+   - Ensure color values are within valid range (0-127)
+   - Add proper section termination
+
+### Phase 4: Message Length and Structure Validation (Medium Priority)
+
+**Objective**: Ensure generated messages meet expected length and structure requirements
+
+**Changes Required**:
+1. **Message Length Validation**:
+   - Add checks for minimum message length (100+ bytes for complete modes)
+   - Ensure all required sections are included
+   - Validate total message size doesn't exceed device limits
+
+2. **Section Ordering**:
+   - Verify correct order: Header ‚Üí Data Header ‚Üí Name ‚Üí Controls ‚Üí Labels ‚Üí Colors ‚Üí Footer
+   - Ensure proper section boundaries and transitions
+   - Add section markers where required
+
+## Task Breakdown with Priorities
+
+### High Priority Tasks
+- [x] **Task 1.1**: Fix label generation to use `control.name` field (COMPLETED)
+- [x] **Task 1.2**: Add fallback logic for missing control names (COMPLETED)
+- [ ] **Task 2.1**: Debug and fix color marker positioning issues (IN PROGRESS)
+- [ ] **Task 2.2**: Add validation for offset calculations
+
+### Medium Priority Tasks
+- [ ] **Task 3.1**: Verify control definition format compliance
+- [ ] **Task 3.2**: Implement proper label section structure
+- [ ] **Task 3.3**: Fix color section structure and encoding
+- [ ] **Task 4.1**: Add message length validation
+- [ ] **Task 4.2**: Verify section ordering and boundaries
+
+### Low Priority Tasks
+- [ ] **Task 5.1**: Add comprehensive error messages for debugging
+- [ ] **Task 5.2**: Optimize encoding performance
+- [ ] **Task 5.3**: Add protocol documentation updates
+
+**Total Estimated Effort**: 33 hours
+
+## Validation and Testing Strategy
+
+### Unit Test Validation
+1. **Existing Tests**: All failing tests in `SysExParser.test.ts` must pass
+2. **New Tests**: Add tests for edge cases and error conditions
+3. **Integration Tests**: Test with actual device communication
+
+### Test Results Status
+- ‚úÖ "should use actual control names in labels, not generic ones" - PASSING
+- ‚ùå "should include label data with 0x69 marker and control names" - FAILING
+- ‚ùå "should include color data with 0x60 marker" - FAILING (gets 0x65)
+- ‚ùå "should fail if current implementation is incorrect" - FAILING
+
+### Validation Criteria
+- [x] Control names are used instead of generic labels
+- [ ] Color markers (0x60) appear at correct byte positions
+- [ ] Message structure matches MIDI protocol specification
+- [ ] Message length is appropriate for data complexity
+- [ ] No data corruption or offset errors
+- [ ] All unit tests pass
+
+## Risk Assessment and Mitigation
+
+### High Risks
+1. **Device Communication Failure**: Current bugs cause slots to be empty
+   - **Mitigation**: Comprehensive testing with actual device
+   - **Rollback Plan**: Keep current working read functionality intact
+
+2. **Protocol Breaking Changes**: Fixes might break existing functionality
+   - **Mitigation**: Incremental changes with continuous testing
+   - **Rollback Plan**: Git branches for each phase
+
+### Medium Risks
+1. **Performance Impact**: More complex encoding might slow down operations
+   - **Mitigation**: Profile encoding performance during implementation
+   - **Acceptable Threshold**: <50ms for typical mode encoding
+
+2. **Backward Compatibility**: Changes might affect other device models
+   - **Mitigation**: Maintain device-specific code paths
+   - **Testing**: Verify other Launch Control variants still work
+
+## Progress Tracking
+
+### Phase 1: Label Generation Fix ‚úÖ COMPLETED
+- [x] **1.1**: Analyze current label generation logic
+- [x] **1.2**: Implement control.name usage in encodeCustomModeData()
+- [x] **1.3**: Add fallback logic for missing names
+- [x] **1.4**: Test with "should use actual control names" test case
+- [x] **1.5**: Verify no regression in other label tests
+
+### Phase 2: Color Marker Fix üöß IN PROGRESS
+- [x] **2.1**: Debug color marker positioning issue
+- [ ] **2.2**: Fix offset calculations in color section
+- [ ] **2.3**: Add bounds checking and validation
+- [ ] **2.4**: Test with "should include color markers (0x60)" test case
+- [ ] **2.5**: Verify color values are correct (0x60 not 0x65)
+
+### Phase 3: Protocol Compliance
+- [ ] **3.1**: Review protocol specification requirements
+- [ ] **3.2**: Fix control definition format
+- [ ] **3.3**: Fix label section structure
+- [ ] **3.4**: Fix color section structure
+- [ ] **3.5**: Test all protocol validation test cases
+
+### Phase 4: Final Validation
+- [ ] **4.1**: Run complete test suite
+- [ ] **4.2**: Test with actual device hardware
+- [ ] **4.3**: Verify message lengths are appropriate
+- [ ] **4.4**: Performance testing and optimization
+- [ ] **4.5**: Documentation updates and code review
+
+### Completion Criteria
+- [ ] All unit tests in SysExParser.test.ts pass
+- [ ] Device successfully receives and applies custom mode data
+- [ ] Control names appear correctly on device
+- [ ] No corruption in slot data after write operations
+- [ ] Message structure fully compliant with MIDI protocol
+- [ ] Performance acceptable (<50ms encoding time)
+- [ ] Code review approved
+- [ ] Documentation updated
+
+---
+
+**Current Status**: Phase 1 completed successfully. Phase 2 in progress - debugging color marker positioning issue.
+
+**Next Steps**: Continue debugging why color marker shows 0x65 instead of 0x60, likely an issue with how the color section offset is calculated or how the marker byte is written.
+
+**Estimated Timeline**: 2-3 weeks for complete implementation and testing, assuming 15-20 hours per week availability.
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/WORKPLAN-CUSTOM-MODE-FETCH.md b/modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-CUSTOM-MODE-FETCH.md
similarity index 100%
rename from modules/audio-control/modules/launch-control-xl3/WORKPLAN-CUSTOM-MODE-FETCH.md
rename to modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-CUSTOM-MODE-FETCH.md
diff --git a/modules/audio-control/modules/launch-control-xl3/WORKPLAN-HANDSHAKE-FIX.md b/modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-HANDSHAKE-FIX.md
similarity index 100%
rename from modules/audio-control/modules/launch-control-xl3/WORKPLAN-HANDSHAKE-FIX.md
rename to modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-HANDSHAKE-FIX.md
diff --git a/modules/audio-control/modules/launch-control-xl3/WORKPLAN-UNIT-TEST-FIX.md b/modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-UNIT-TEST-FIX.md
similarity index 100%
rename from modules/audio-control/modules/launch-control-xl3/WORKPLAN-UNIT-TEST-FIX.md
rename to modules/audio-control/modules/launch-control-xl3/docs/completed/WORKPLAN-UNIT-TEST-FIX.md
diff --git a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
index ce0259e..c3fd1ec 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/core/SysExParser.ts
@@ -884,11 +884,13 @@ export class SysExParser {
     // Add label data for each control (recommended for usability)
     for (const control of sortedControls) {
       const controlId = control.controlId ?? 0;
-      rawData.push(0x69); // Label marker
+      rawData.push(0x68); // Label marker
       rawData.push(controlId + 0x28); // Control ID with offset
 
-      // Add a simple label based on control type and ID
-      const labelText = this.generateControlLabel(controlId);
+      // Use actual control name if available, otherwise generate generic label
+      const labelText = control.name && control.name.trim() !== ''
+        ? control.name.substring(0, 12) // Truncate to max 12 chars for device compatibility
+        : this.generateControlLabel(controlId);
       for (let i = 0; i < labelText.length; i++) {
         rawData.push(labelText.charCodeAt(i));
       }
@@ -897,8 +899,14 @@ export class SysExParser {
     // Add color data for each control (required for device acceptance)
     for (const control of sortedControls) {
       const controlId = control.controlId ?? 0;
+
+      // Find the corresponding color for this control
+      const colorEntry = modeData.colors?.find(c => c.controlId === controlId);
+      const colorValue = colorEntry?.color ?? 0x0C; // Default color if not specified
+
       rawData.push(0x60); // Color marker
       rawData.push(controlId + 0x28); // Control ID with offset
+      rawData.push(colorValue); // Actual color value
     }
 
     return rawData;
diff --git a/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts b/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
index 71df572..35ad438 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
+++ b/modules/audio-control/modules/launch-control-xl3/test/core/SysExParser.test.ts
@@ -339,4 +339,639 @@ describe('SysExParser', () => {
       expect(() => SysExParser.validateCustomModeData(invalidColor as any)).toThrow('Color value must be 0-127');
     });
   });
+
+  describe('buildCustomModeWriteRequest - MIDI Protocol Validation', () => {
+    it('should create message with correct header according to MIDI-PROTOCOL.md', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [],
+        colors: [],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, modeData as any);
+
+      // Check SysEx boundaries
+      expect(message[0]).toBe(0xF0);
+      expect(message[message.length - 1]).toBe(0xF7);
+
+      // Check header matches MIDI-PROTOCOL.md specification
+      expect(message.slice(1, 10)).toEqual([
+        0x00, 0x20, 0x29, // Manufacturer ID
+        0x02,             // Device ID
+        0x15,             // Command
+        0x05,             // Sub-command
+        0x00,             // Reserved
+        0x45,             // Write operation
+        0x00              // Slot
+      ]);
+    });
+
+    it('should include data header (00 20 08) after protocol header', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [],
+        colors: [],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, modeData as any);
+
+      // Data header should be at position 10
+      expect(message.slice(10, 13)).toEqual([0x00, 0x20, 0x08]);
+    });
+
+    it('should encode control with 0x49 marker and +0x28 offset as per protocol', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00, // Fader 1
+          name: 'Volume',
+          midiChannel: 0,
+          ccNumber: 77,
+          minValue: 0,
+          maxValue: 127
+        }],
+        colors: [],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, modeData as any);
+
+      // Find control definition (after header + data header + name)
+      // Header(10) + DataHeader(3) + Name(4) = 17
+      const controlDef = message.slice(17, 28);
+
+      // Verify control format matches protocol:
+      // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+      expect(controlDef[0]).toBe(0x49);        // Write marker
+      expect(controlDef[1]).toBe(0x28);        // ID 0x00 + 0x28
+      expect(controlDef[2]).toBe(0x02);        // Definition type
+      expect(controlDef[3]).toBe(0x00);        // Control type for fader
+      expect(controlDef[4]).toBe(0x00);        // Channel
+      expect(controlDef[5]).toBe(0x01);        // Fixed param
+      expect(controlDef[6]).toBe(0x40);        // Behavior
+      expect(controlDef[7]).toBe(0x00);        // Min (always 0x00)
+      expect(controlDef[8]).toBe(77);          // CC number
+      expect(controlDef[9]).toBe(0x7F);        // Max (always 0x7F)
+      expect(controlDef[10]).toBe(0x00);       // Terminator
+    });
+
+    it('should use actual control names in labels, not generic ones', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00,
+          name: 'MyVolume', // Specific name
+          ccNumber: 77
+        }],
+        colors: [{
+          controlId: 0x00,
+          color: 0x0C
+        }],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, modeData as any);
+      const messageStr = message.map(b => String.fromCharCode(b)).join('');
+
+      // Should contain the actual control name
+      expect(messageStr).toContain('MyVolume');
+
+      // Should NOT contain generic label
+      expect(messageStr).not.toContain('Fader 1');
+    });
+
+    it('should include label markers (0x69) for controls with names', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00,
+          name: 'Vol',
+          ccNumber: 77
+        }],
+        colors: [{
+          controlId: 0x00,
+          color: 0x0C
+        }],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, modeData as any);
+
+      // Should contain label marker
+      expect(message).toContain(0x69);
+
+      // Find label section and verify structure
+      const labelIdx = message.indexOf(0x69);
+      expect(labelIdx).toBeGreaterThan(0);
+      expect(message[labelIdx + 1]).toBe(0x28); // Control ID with offset
+    });
+
+    it('should include color markers (0x60) for all controls', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TEST',
+        controls: [{
+          controlId: 0x00,
+          name: 'Vol',
+          ccNumber: 77
+        }],
+        colors: [{
+          controlId: 0x00,
+          color: 0x0C
+        }],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, modeData as any);
+
+      // Should contain color marker
+      expect(message).toContain(0x60);
+
+      // Find color section and verify structure
+      const colorIdx = message.indexOf(0x60);
+      expect(colorIdx).toBeGreaterThan(0);
+      expect(message[colorIdx + 1]).toBe(0x28); // Control ID with offset
+    });
+
+    it('should generate message of appropriate length for complete data', () => {
+      const modeData = {
+        type: 'custom_mode_response',
+        manufacturerId: [0x00, 0x20, 0x29],
+        slot: 0,
+        name: 'TESTMODE',
+        controls: [
+          { controlId: 0x00, name: 'Volume1', ccNumber: 1 },
+          { controlId: 0x01, name: 'Volume2', ccNumber: 2 },
+          { controlId: 0x10, name: 'Send1', ccNumber: 13 },
+          { controlId: 0x11, name: 'Send2', ccNumber: 14 },
+        ],
+        colors: [
+          { controlId: 0x00, color: 0x0C },
+          { controlId: 0x01, color: 0x0C },
+          { controlId: 0x10, color: 0x3C },
+          { controlId: 0x11, color: 0x3C },
+        ],
+        data: []
+      };
+
+      const message = SysExParser.buildCustomModeWriteRequest(0, modeData as any);
+
+      // According to MIDI-PROTOCOL.md, complete messages are 400-500+ bytes
+      // With 4 controls, labels, and colors, should be substantial
+      expect(message.length).toBeGreaterThan(100);
+    });
+  });
+
+  describe('buildCustomModeWriteRequest', () => {
+    describe('Message Structure', () => {
+      it('should create a properly formatted SysEx message with correct header and footer', () => {
+        const slot = 0;
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot,
+          name: 'TEST',
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(slot, modeData);
+
+        // Check SysEx start and end
+        expect(message[0]).toBe(0xF0); // SysEx start
+        expect(message[message.length - 1]).toBe(0xF7); // SysEx end
+
+        // Check header according to MIDI-PROTOCOL.md
+        expect(message.slice(1, 10)).toEqual([
+          0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+          0x02,             // Device ID (Launch Control XL 3)
+          0x15,             // Command (Custom mode)
+          0x05,             // Sub-command
+          0x00,             // Reserved
+          0x45,             // Write operation
+          slot              // Slot number
+        ]);
+      });
+
+      it('should include the data header (00 20 08) after the protocol header', () => {
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Data should start at position 10 (after header)
+        expect(message.slice(10, 13)).toEqual([0x00, 0x20, 0x08]);
+      });
+    });
+
+    describe('Mode Name Encoding', () => {
+      it('should encode the mode name as ASCII after the data header', () => {
+        const modeName = 'CHANNEVE';
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: modeName,
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Mode name should be at position 13 (after header + data header)
+        const nameBytes = message.slice(13, 13 + modeName.length);
+        const decodedName = String.fromCharCode(...nameBytes);
+
+        expect(decodedName).toBe('CHANNEVE');
+      });
+
+      it('should limit mode name to 8 characters maximum', () => {
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'VERYLONGMODENAME', // 16 characters
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Check that only 8 characters are encoded
+        const nameBytes = message.slice(13, 21);
+        const decodedName = String.fromCharCode(...nameBytes);
+
+        expect(decodedName).toBe('VERYLONG');
+      });
+    });
+
+    describe('Control Encoding', () => {
+      it('should encode controls with 0x49 marker and correct structure', () => {
+        const control: ControlMapping = {
+          controlId: 0x00, // Fader 1
+          name: 'Volume',
+          midiChannel: 0,
+          ccNumber: 77,
+          minValue: 0,
+          maxValue: 127,
+          behaviour: 'absolute'
+        };
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [control],
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Find the control definition (should start after header + data header + name)
+        // Header(10) + DataHeader(3) + Name(4) = 17
+        const controlStart = 17;
+        const controlDef = message.slice(controlStart, controlStart + 11);
+
+        // According to MIDI-PROTOCOL.md, control format for WRITE should be:
+        // 49 [ID+0x28] 02 [TYPE] [CH] 01 40 00 [CC] 7F 00
+        expect(controlDef).toEqual([
+          0x49,        // Write control marker
+          0x28,        // Control ID 0x00 + 0x28 offset
+          0x02,        // Definition type
+          0x00,        // Control type (0x00 for faders)
+          0x00,        // MIDI channel (0-based)
+          0x01,        // Fixed parameter 1
+          0x40,        // Behavior parameter
+          0x00,        // Min (always 0x00 in write)
+          77,          // CC number
+          0x7F,        // Max (always 0x7F in write)
+          0x00         // Terminator
+        ]);
+      });
+
+      it('should apply correct control ID offset (+0x28) for all controls', () => {
+        const controls: ControlMapping[] = [
+          { controlId: 0x00, ccNumber: 1 }, // Fader 1
+          { controlId: 0x10, ccNumber: 2 }, // Top encoder 1
+          { controlId: 0x18, ccNumber: 3 }, // Mid encoder 1
+          { controlId: 0x20, ccNumber: 4 }, // Bot encoder 1
+        ];
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls,
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Check each control has the correct offset applied
+        let position = 17; // After header + data header + name
+
+        // Control 0x00 should become 0x28
+        expect(message[position + 1]).toBe(0x28);
+        position += 11;
+
+        // Control 0x10 should become 0x38
+        expect(message[position + 1]).toBe(0x38);
+        position += 11;
+
+        // Control 0x18 should become 0x40
+        expect(message[position + 1]).toBe(0x40);
+        position += 11;
+
+        // Control 0x20 should become 0x48
+        expect(message[position + 1]).toBe(0x48);
+      });
+
+      it('should use correct control type values based on hardware position', () => {
+        const controls: ControlMapping[] = [
+          { controlId: 0x00 }, // Fader - should use type 0x00
+          { controlId: 0x10 }, // Top encoder - should use type 0x05
+          { controlId: 0x18 }, // Mid encoder - should use type 0x09
+          { controlId: 0x20 }, // Bot encoder - should use type 0x0D
+        ];
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls,
+          colors: [],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        let position = 17; // After header + data header + name
+
+        // Check control types
+        expect(message[position + 3]).toBe(0x00); // Fader type
+        position += 11;
+
+        expect(message[position + 3]).toBe(0x05); // Top encoder type
+        position += 11;
+
+        expect(message[position + 3]).toBe(0x09); // Mid encoder type
+        position += 11;
+
+        expect(message[position + 3]).toBe(0x0D); // Bot encoder type
+      });
+    });
+
+    describe('Label and Color Data', () => {
+      it('should include label data with 0x69 marker and control names', () => {
+        const control: ControlMapping = {
+          controlId: 0x00,
+          name: 'Volume',
+          ccNumber: 77
+        };
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [control],
+          colors: [{ controlId: 0x00, color: 0x0C }],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Find label section (after control definition)
+        // Header(10) + DataHeader(3) + Name(4) + Control(11) = 28
+        const labelStart = 28;
+
+        // Label format should be: 69 [ID+0x28] [ASCII_TEXT...]
+        expect(message[labelStart]).toBe(0x69); // Label marker
+        expect(message[labelStart + 1]).toBe(0x28); // Control ID with offset
+
+        // Check that the name is encoded
+        const labelText = message.slice(labelStart + 2, labelStart + 2 + 6);
+        const decodedLabel = String.fromCharCode(...labelText);
+        expect(decodedLabel).toBe('Volume');
+      });
+
+      it('should include color data with 0x60 marker', () => {
+        const control: ControlMapping = {
+          controlId: 0x00,
+          name: 'Vol',
+          ccNumber: 77
+        };
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [control],
+          colors: [{ controlId: 0x00, color: 0x0C }],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Find color section (after control + label)
+        // Header(10) + DataHeader(3) + Name(4) + Control(11) + Label(2 + 3) = 33
+        const colorStart = 33;
+
+        // Color format should be: 60 [ID+0x28]
+        expect(message[colorStart]).toBe(0x60); // Color marker
+        expect(message[colorStart + 1]).toBe(0x28); // Control ID with offset
+      });
+
+      it('should include labels and colors for all controls', () => {
+        const controls: ControlMapping[] = [
+          { controlId: 0x00, name: 'Vol1', ccNumber: 1 },
+          { controlId: 0x01, name: 'Vol2', ccNumber: 2 },
+        ];
+
+        const colors = [
+          { controlId: 0x00, color: 0x0C },
+          { controlId: 0x01, color: 0x0D },
+        ];
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls,
+          colors,
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Message should contain both label markers (0x69)
+        const labelMarkers = message.filter(byte => byte === 0x69);
+        expect(labelMarkers.length).toBe(2);
+
+        // Message should contain both color markers (0x60)
+        const colorMarkers = message.filter(byte => byte === 0x60);
+        expect(colorMarkers.length).toBe(2);
+      });
+    });
+
+    describe('Complete Message Validation', () => {
+      it('should generate a message matching the CHANNEVE example structure', () => {
+        // Create controls matching the CHANNEVE example from MIDI-PROTOCOL.md
+        const controls: ControlMapping[] = [
+          { controlId: 0x10, name: 'Mic Gain', midiChannel: 0, ccNumber: 13 }, // Top encoder 1
+          { controlId: 0x11, name: 'Reverb', midiChannel: 0, ccNumber: 14 },   // Top encoder 2
+        ];
+
+        const colors = [
+          { controlId: 0x10, color: 0x60 },
+          { controlId: 0x11, color: 0x60 },
+        ];
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'CHANNEVE',
+          controls,
+          colors,
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Verify key parts of the message structure
+        expect(message[0]).toBe(0xF0); // Start
+        expect(message.slice(1, 10)).toEqual([0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00]); // Header
+        expect(message.slice(10, 13)).toEqual([0x00, 0x20, 0x08]); // Data header
+
+        // Mode name
+        const nameBytes = message.slice(13, 21);
+        expect(String.fromCharCode(...nameBytes)).toBe('CHANNEVE');
+
+        // First control should have 0x49 marker
+        expect(message[21]).toBe(0x49);
+
+        // Message should end with 0xF7
+        expect(message[message.length - 1]).toBe(0xF7);
+
+        // Message should be substantial (400+ bytes for complete data)
+        // Note: Current implementation may be shorter, which is the bug
+        expect(message.length).toBeGreaterThan(50); // At minimum
+      });
+
+      it('should fail if current implementation is incorrect', () => {
+        // This test documents known issues with the current implementation
+        const control: ControlMapping = {
+          controlId: 0x00,
+          name: 'TestControl',
+          midiChannel: 5,
+          ccNumber: 64
+        };
+
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TESTMODE',
+          controls: [control],
+          colors: [{ controlId: 0x00, color: 0x0C }],
+          data: []
+        };
+
+        const message = SysExParser.buildCustomModeWriteRequest(0, modeData);
+
+        // Check if the implementation correctly:
+        // 1. Uses control names (not generic labels)
+        const messageStr = message.map(b => String.fromCharCode(b)).join('');
+        expect(messageStr).toContain('TestControl'); // Should use actual name
+
+        // 2. Has proper message length (should be 100+ bytes for even simple modes)
+        expect(message.length).toBeGreaterThan(100);
+
+        // 3. Includes all required sections
+        expect(message).toContain(0x49); // Control marker
+        expect(message).toContain(0x69); // Label marker
+        expect(message).toContain(0x60); // Color marker
+      });
+    });
+
+    describe('Error Handling', () => {
+      it('should throw error for invalid slot numbers', () => {
+        const modeData: CustomModeMessage = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: [],
+          colors: [],
+          data: []
+        };
+
+        expect(() => SysExParser.buildCustomModeWriteRequest(-1, modeData)).toThrow();
+        expect(() => SysExParser.buildCustomModeWriteRequest(16, modeData)).toThrow();
+      });
+
+      it('should throw error if controls array is missing', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          colors: []
+          // controls missing
+        };
+
+        expect(() => SysExParser.buildCustomModeWriteRequest(0, modeData)).toThrow('controls array');
+      });
+
+      it('should throw error if colors array is missing', () => {
+        const modeData: any = {
+          type: 'custom_mode_response',
+          manufacturerId: [0x00, 0x20, 0x29],
+          slot: 0,
+          name: 'TEST',
+          controls: []
+          // colors missing
+        };
+
+        expect(() => SysExParser.buildCustomModeWriteRequest(0, modeData)).toThrow('colors array');
+      });
+    });
+  });
 });
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

docs(launch-control-xl3): reorganize workplan documentation and update SysEx parser implementation

