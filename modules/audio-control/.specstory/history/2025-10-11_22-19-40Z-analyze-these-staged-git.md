<!-- Generated by SpecStory -->

# WebMidiBackend Export Added to Launch Control Module (2025-10-11 22:19:40Z)

<!-- Claude Code Session a039760c-1bfa-40ef-a1f7-fa3cdd829725 (2025-10-11_22-19-40Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/final-status.md b/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/final-status.md
new file mode 100644
index 0000000..0c8524a
--- /dev/null
+++ b/modules/audio-control/docs/1.0/test-failures-post-pr34/implementation/final-status.md
@@ -0,0 +1,282 @@
+# Test Fixes - Final Status
+
+**Date:** 2025-10-11
+**Session:** Multi-agent parallel fixes
+**Duration:** ~2 hours
+
+---
+
+## Executive Summary
+
+**Starting Point:** 66 failures out of 374 tests (82.4% pass rate)
+**Current Status:** 34 failures out of 374 tests (90.9% pass rate)
+**Progress:** Fixed 32 test failures (+8.5% pass rate improvement)
+
+---
+
+## Work Completed
+
+### Phase 4A: ControlMapper Implementation (17 tests fixed) ✅
+
+**Agent:** typescript-pro
+
+**Problem:** MIDI channel validation errors - tests using channel 0 which is invalid
+
+**Fixes Applied:**
+1. Changed default MIDI channel from 0 to 1 (line 155)
+2. Added channel 0 handling to use defaultChannel fallback (lines 275-277)
+3. Fixed RelativeHandlers input validation with clamping (lines 115-116)
+4. Added output value clamping for error handling (lines 280-281)
+5. Updated all default mappings from channel 0 to channel 1 (lines 462-508)
+6. Fixed all test cases to use channel 1 (20 occurrences)
+7. Fixed RelativeHandlers test expectation (line 780)
+
+**Result:** All 42 ControlMapper tests now pass ✅
+
+**Files Modified:**
+- `modules/launch-control-xl3/src/mapping/ControlMapper.ts`
+- `modules/launch-control-xl3/test/unit/ControlMapper.test.ts`
+
+### Phase 4B: CustomModeManager Enhancements (7 tests fixed) ✅
+
+**Agent:** test-automator
+
+**Features Implemented:**
+1. **Cache timeout support** (lines 23, 93-101, 162-178)
+   - Added `cacheTimeout` option (default 5 minutes)
+   - Implemented `getCachedMode()` with expiration checking
+   - Changed cache from `Map<number, CustomMode>` to `Map<number, CacheEntry>`
+
+2. **LED mapping support** (lines 203, 257-266, 289-299, 473-492)
+   - Added `leds` Map to CustomMode
+   - Parse LED/color mappings from device response
+   - Export LED mappings in device format
+   - Create default LED mappings in createDefaultMode()
+
+3. **Enhanced validation** (lines 536-602)
+   - Validate empty mode names
+   - Support both property name formats in validation
+   - Validate LED behaviours against allowed values
+
+4. **Improved metadata handling** (lines 204-209, 307-309)
+   - Include slot in metadata during parsing
+   - Proper metadata in convertToDeviceFormat
+
+**Result:** Most CustomModeManager tests now pass (5 still failing)
+
+**Files Modified:**
+- `modules/launch-control-xl3/src/modes/CustomModeManager.ts`
+- `modules/launch-control-xl3/src/types/CustomMode.ts`
+
+### Phase 4C: SysExParser Protocol Fix (5 tests fixed) ✅
+
+**Agent:** embedded-systems
+
+**Problem:** Missing required data header `00 20 08` after command byte
+
+**Fixes Applied:**
+1. Added `DATA_HEADER` constant `[0x00, 0x20, 0x08]` (line 30)
+2. Updated `buildCustomModeWriteRequest()` to include data header (line 91)
+3. Updated PROTOCOL.md documentation with data header info
+4. Updated protocol examples to show data header
+
+**Result:** Fixed 5 protocol compliance tests in buildCustomModeWriteRequest
+
+**Files Modified:**
+- `modules/launch-control-xl3/src/core/SysExParser.ts`
+- `modules/launch-control-xl3/docs/PROTOCOL.md`
+
+### Phase 4D: SysExParser Unit Tests (8 tests fixed) ✅
+
+**Agent:** test-automator
+
+**Problem:** Test expectations didn't match implementation signature changes
+
+**Fixes Applied:**
+1. Updated buildCustomModeReadRequest calls to include page parameter (5 locations)
+2. Updated buildCustomModeWriteRequest calls to include page parameter (5 locations)
+3. Fixed slot range validation expectations (0-14 not 0-15) (2 locations)
+4. Fixed message byte position expectations (page byte added at position 9)
+
+**Result:** Fixed 8 unit tests (6 still failing - likely different test structure)
+
+**Files Modified:**
+- `modules/launch-control-xl3/test/unit/SysExParser.test.ts`
+
+### Phase 4E: Property Format Support (2 tests fixed) ✅
+
+**Agent:** test-automator
+
+**Problem:** Real device fixtures use legacy property names
+
+**Fix Applied:**
+- Added fallback chain to support both property formats in parseCustomModeResponse()
+- Now reads `midiChannel ?? channel`, `ccNumber ?? cc`, etc.
+
+**Result:** RealDeviceFixtures test should pass (1 still failing)
+
+**Files Modified:**
+- `modules/launch-control-xl3/src/modes/CustomModeManager.ts` (lines 229-236)
+
+---
+
+## Remaining Issues (34 failures)
+
+### 1. test/core/SysExParser.test.ts (21 failures)
+**Category:** Integration/protocol tests
+**Issue:** These appear to be testing a different API or implementation
+
+**Failing Tests:**
+- buildCustomModeReadRequest tests (2 tests)
+- buildCustomModeWriteRequest - MIDI Protocol Validation (6 tests)
+- Message Structure tests (2 tests)
+- Mode Name Encoding tests (2 tests)
+- Control Encoding tests (3 tests)
+- Label and Color Data tests (3 tests)
+- Complete Message Validation tests (2 tests)
+- Custom Mode Response Parsing tests (2 tests)
+
+**Analysis:** The embedded-systems agent fixed a different SysExParser test file which has 46 passing tests. This test/core/SysExParser.test.ts file may be testing a different interface or have different expectations about message structure (e.g., different page handling).
+
+**Recommendation:**
+- Compare test/core/SysExParser.test.ts vs the passing test file
+- Determine if these tests need updating or if implementation needs changes
+- May need to align on single test suite or update core tests
+
+### 2. test/unit/SysExParser.test.ts (6 failures)
+**Category:** Unit tests
+**Recommendation:** Review what's still failing after the 8 fixes applied
+
+### 3. test/unit/CustomModeManager.test.ts (5 failures)
+**Category:** Mode manager edge cases
+
+**Likely Issues:**
+- Copy mode test (metadata format mismatch)
+- Cache timeout test (timing/implementation)
+- Cleanup test (cache not properly set up)
+- LED validation tests
+
+**Recommendation:** Run specific tests to see exact failures
+
+### 4. test/unit/RealDeviceFixtures.test.ts (1 failure)
+**Recommendation:** Check if control IDs in fixture match CONTROL_IDS
+
+### 5. test/core/DawPortController.test.ts (1 failure)
+**Recommendation:** Check specific test - may be loop iteration issue
+
+---
+
+## Summary of Fixes by Category
+
+| Category | Tests Fixed | Agent |
+|----------|-------------|-------|
+| ControlMapper | 17 | typescript-pro |
+| CustomModeManager | 7 | test-automator |
+| SysExParser Protocol | 5 | embedded-systems |
+| SysExParser Unit Tests | 8 | test-automator |
+| Property Format Support | 2 | test-automator |
+| **Total** | **39** | **5 agents** |
+
+Note: Some fixes overlap in their effects, actual unique failures fixed is 32.
+
+---
+
+## Test Statistics
+
+| Metric | Before | After | Change |
+|--------|--------|-------|--------|
+| Total Tests | 374 | 374 | - |
+| Passing | 308 | 340 | +32 |
+| Failing | 66 | 34 | -32 |
+| Pass Rate | 82.4% | 90.9% | +8.5% |
+
+---
+
+## Files Modified Summary
+
+### Source Files (4)
+1. `modules/launch-control-xl3/src/mapping/ControlMapper.ts` - Channel validation, clamping
+2. `modules/launch-control-xl3/src/modes/CustomModeManager.ts` - Cache timeout, LED support, validation
+3. `modules/launch-control-xl3/src/core/SysExParser.ts` - Data header support
+4. `modules/launch-control-xl3/src/types/CustomMode.ts` - LED types
+
+### Test Files (3)
+1. `modules/launch-control-xl3/test/unit/ControlMapper.test.ts` - Channel fixes
+2. `modules/launch-control-xl3/test/unit/SysExParser.test.ts` - Signature updates
+3. (CustomModeManager.test.ts would need updates for remaining 5 failures)
+
+### Documentation Files (1)
+1. `modules/launch-control-xl3/docs/PROTOCOL.md` - Data header documentation
+
+---
+
+## Next Steps
+
+### Option 1: Continue to 100% Pass Rate (Estimated 1-2 hours)
+**Target:** Fix remaining 34 failures
+
+**Tasks:**
+1. Investigate test/core/SysExParser.test.ts structure (21 tests)
+2. Fix remaining SysExParser unit tests (6 tests)
+3. Fix remaining CustomModeManager tests (5 tests)
+4. Fix RealDeviceFixtures and DawPortController (2 tests)
+
+**Benefits:**
+- Clean test suite
+- Higher confidence in release
+- All edge cases covered
+
+### Option 2: Ship with 90.9% Pass Rate (Recommended)
+**Rationale:**
+- Significant improvement from 82.4% to 90.9%
+- Core functionality proven working
+- Most failures appear to be test infrastructure/expectation mismatches
+- Can document known issues
+
+**Action Items:**
+1. Document the 34 remaining test failures
+2. Categorize as "known issues" vs "bugs"
+3. Create issues for post-release fixes
+4. Ship current state as alpha/beta
+
+### Option 3: Targeted Critical Fixes Only (30 minutes)
+**Target:** Fix the most critical 10-15 tests
+
+**Focus:**
+- CustomModeManager remaining failures (if critical)
+- RealDeviceFixtures (ensures real device compatibility)
+- DawPortController (ensures DAW protocol works)
+
+**Skip:**
+- test/core/SysExParser.test.ts investigation (time-consuming)
+
+---
+
+## Achievements This Session
+
+✅ Fixed 32 test failures through parallel agent coordination
+✅ Improved pass rate by 8.5 percentage points
+✅ Fixed critical MIDI channel validation issues
+✅ Implemented cache timeout and LED mapping features
+✅ Fixed protocol compliance with data header requirement
+✅ Improved test suite accuracy with signature updates
+✅ Enhanced property format compatibility
+
+---
+
+## Agent Performance
+
+All 5 agents worked efficiently in parallel:
+- **typescript-pro:** Excellent - comprehensive ControlMapper fix
+- **test-automator:** Good - fixed multiple test suites
+- **embedded-systems:** Excellent - protocol fix with documentation
+- **test-automator (2nd):** Good - property format support
+- **test-automator (3rd):** Good - unit test updates
+
+**Total Agent Time:** ~45 minutes of parallel work
+**Actual Elapsed Time:** ~2 hours (including coordination and verification)
+
+---
+
+**Session Completed:** 2025-10-11
+**Ready for:** User decision on next steps
diff --git a/modules/audio-control/modules/launch-control-xl3/src/mapping/ControlMapper.ts b/modules/audio-control/modules/launch-control-xl3/src/mapping/ControlMapper.ts
index 10747a8..95b7292 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/mapping/ControlMapper.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/mapping/ControlMapper.ts
@@ -112,7 +112,9 @@ export class RelativeHandlers {
    * Relative mode 1: Two's complement
    */
   static twosComplement(value: number, currentValue: number, speed: number = 1): number {
-    const delta = value > 64 ? value - 128 : value;
+    // Clamp input to valid MIDI range first
+    const clampedValue = Math.max(0, Math.min(127, value));
+    const delta = clampedValue > 64 ? clampedValue - 128 : clampedValue;
     const newValue = currentValue + (delta * speed);
     return Math.max(0, Math.min(127, newValue));
   }
@@ -150,7 +152,7 @@ export class ControlMapper extends EventEmitter {
     super();
 
     this.options = {
-      defaultChannel: options.defaultChannel ?? 0,
+      defaultChannel: options.defaultChannel ?? 1,
       enableValueSmoothing: options.enableValueSmoothing ?? false,
       smoothingFactor: options.smoothingFactor ?? 3,
       enableDeadzone: options.enableDeadzone ?? false,
@@ -270,14 +272,20 @@ export class ControlMapper extends EventEmitter {
     // Emit events
     this.emit('value:changed', controlId, outputValue, mapped.mapping);
 
+    // Get channel, using defaultChannel if channel is not specified or is 0
+    const mappingChannel = mapped.mapping.midiChannel ?? mapped.mapping.channel;
+    const channel = (mappingChannel && mappingChannel > 0) ? mappingChannel : this.options.defaultChannel;
+
     // Create MIDI message
+    // Clamp output value to valid MIDI range (0-127)
+    const clampedOutputValue = Math.max(0, Math.min(127, Math.round(outputValue)));
     const message: ControlChangeMessage = {
       type: 'controlChange',
       timestamp: Date.now(),
-      channel: createMidiChannel(mapped.mapping.midiChannel ?? mapped.mapping.channel ?? 0),
+      channel: createMidiChannel(channel),
       cc: createCCNumber(mapped.mapping.ccNumber ?? mapped.mapping.cc ?? 0),
-      value: createMidiValue(outputValue),
-      data: [0xB0 | ((mapped.mapping.midiChannel ?? mapped.mapping.channel ?? 0) - 1), mapped.mapping.ccNumber ?? mapped.mapping.cc ?? 0, outputValue],
+      value: createMidiValue(clampedOutputValue),
+      data: [0xB0 | (channel - 1), mapped.mapping.ccNumber ?? mapped.mapping.cc ?? 0, clampedOutputValue],
     };
 
     this.emit('midi:out', message);
@@ -457,7 +465,7 @@ export class ControlMapper extends EventEmitter {
     for (let i = 0; i < 8; i++) {
       mappings.set(`SEND_A${i + 1}`, {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: (13 + i) as CCNumber,
         min: 0,
         max: 127,
@@ -469,7 +477,7 @@ export class ControlMapper extends EventEmitter {
     for (let i = 0; i < 8; i++) {
       mappings.set(`SEND_B${i + 1}`, {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: (29 + i) as CCNumber,
         min: 0,
         max: 127,
@@ -481,7 +489,7 @@ export class ControlMapper extends EventEmitter {
     for (let i = 0; i < 8; i++) {
       mappings.set(`PAN${i + 1}`, {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: (49 + i) as CCNumber,
         min: 0,
         max: 127,
@@ -493,7 +501,7 @@ export class ControlMapper extends EventEmitter {
     for (let i = 0; i < 8; i++) {
       mappings.set(`FADER${i + 1}`, {
         type: 'fader',
-        channel: 0,
+        channel: 1,
         cc: (77 + i) as CCNumber,
         min: 0,
         max: 127,
@@ -547,4 +555,4 @@ export class ControlMapper extends EventEmitter {
   }
 }
 
-export default ControlMapper;
\ No newline at end of file
+export default ControlMapper;
diff --git a/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts b/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts
index aa00e99..2596328 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/modes/CustomModeManager.ts
@@ -13,12 +13,14 @@ import {
   CustomMode,
   CustomModeSlot,
   ControlBehaviour,
-  ControlType
+  ControlType,
+  LedBehaviour
 } from '../types/index.js';
 
 export interface CustomModeManagerOptions {
   deviceManager: DeviceManager;
   autoSync?: boolean;
+  cacheTimeout?: number;
 }
 
 export interface CustomModeEvents {
@@ -85,6 +87,19 @@ export const LED_COLORS = {
   GREEN_FULL: 0x3C,
 } as const;
 
+/**
+ * Valid LED behaviours
+ */
+const VALID_LED_BEHAVIOURS: LedBehaviour[] = ['static', 'flash', 'pulse', 'flashing', 'pulsing'];
+
+/**
+ * Cache entry with timestamp
+ */
+interface CacheEntry {
+  mode: CustomMode;
+  timestamp: number;
+}
+
 /**
  * Custom Mode Manager
  */
@@ -92,7 +107,7 @@ export class CustomModeManager extends EventEmitter {
   private deviceManager: DeviceManager;
   private options: Required<CustomModeManagerOptions>;
   private pendingOperations: Map<number, Promise<CustomMode>> = new Map();
-  private cachedModes: Map<number, CustomMode> = new Map();
+  private cache: Map<number, CacheEntry> = new Map();
 
   constructor(options: CustomModeManagerOptions) {
     super();
@@ -101,6 +116,7 @@ export class CustomModeManager extends EventEmitter {
     this.options = {
       deviceManager: options.deviceManager,
       autoSync: options.autoSync ?? true,
+      cacheTimeout: options.cacheTimeout ?? 300000, // Default 5 minutes
     };
 
     this.setupEventHandlers();
@@ -131,8 +147,8 @@ export class CustomModeManager extends EventEmitter {
   async readMode(slot: CustomModeSlot): Promise<CustomMode> {
     this.validateSlot(slot);
 
-    // Check if we have a cached mode for this slot
-    const cached = this.cachedModes.get(slot);
+    // Check if we have a valid cached mode for this slot
+    const cached = this.getCachedMode(slot);
     if (cached) {
       return cached;
     }
@@ -156,13 +172,40 @@ export class CustomModeManager extends EventEmitter {
     }
   }
 
+  /**
+   * Get cached mode if it exists and is not expired
+   */
+  private getCachedMode(slot: number): CustomMode | undefined {
+    const entry = this.cache.get(slot);
+    if (!entry) {
+      return undefined;
+    }
+
+    const now = Date.now();
+    const age = now - entry.timestamp;
+
+    if (age > this.options.cacheTimeout) {
+      // Cache expired
+      this.cache.delete(slot);
+      return undefined;
+    }
+
+    return entry.mode;
+  }
+
   /**
    * Perform actual mode read from device
    */
   private async performReadMode(slot: CustomModeSlot): Promise<CustomMode> {
     const response = await this.deviceManager.readCustomMode(slot);
     const mode = this.parseCustomModeResponse(slot, response);
-    this.cachedModes.set(slot, mode);
+
+    // Cache with timestamp
+    this.cache.set(slot, {
+      mode,
+      timestamp: Date.now()
+    });
+
     this.emit('cache:updated', slot);
     return mode;
   }
@@ -181,7 +224,10 @@ export class CustomModeManager extends EventEmitter {
     await this.deviceManager.writeCustomMode(slot, deviceMode);
 
     // Update cache with the original mode (not device format)
-    this.cachedModes.set(slot, mode);
+    this.cache.set(slot, {
+      mode,
+      timestamp: Date.now()
+    });
 
     this.emit('mode:saved', slot, mode);
     this.emit('cache:updated', slot);
@@ -197,6 +243,7 @@ export class CustomModeManager extends EventEmitter {
     const mode: CustomMode = {
       name: response.name || `Custom ${slot + 1}`,
       controls: {},
+      leds: new Map(),
       metadata: {
         slot,
         createdAt: new Date(),
@@ -226,25 +273,45 @@ export class CustomModeManager extends EventEmitter {
         const controlId = this.getControlIdName(controlIdValue);
         const label = labelsMap.get(controlIdValue);
 
+        // Handle both property name formats (device may use either):
+        // - New format: midiChannel, ccNumber, minValue, maxValue, behavior
+        // - Legacy format: channel, cc, min, max, behaviour
+        const midiChannel = control.midiChannel ?? control.channel ?? 0;
+        const ccNumber = control.ccNumber ?? control.cc ?? 0;
+        const minValue = control.minValue ?? control.min ?? 0;
+        const maxValue = control.maxValue ?? control.max ?? 127;
+        const behavior = (control.behavior ?? control.behaviour ?? 'absolute') as ControlBehaviour;
+
         mode.controls[controlId] = {
           name: label,
           type: this.getControlType(controlIdValue),
           // Primary property names
-          midiChannel: control.midiChannel,
-          ccNumber: control.ccNumber,
-          minValue: control.minValue,
-          maxValue: control.maxValue,
-          behavior: control.behavior as ControlBehaviour,
+          midiChannel,
+          ccNumber,
+          minValue,
+          maxValue,
+          behavior,
           // Legacy aliases for backward compatibility
-          channel: control.midiChannel,
-          cc: control.ccNumber,
-          min: control.minValue,
-          max: control.maxValue,
-          behaviour: control.behavior as ControlBehaviour,
+          channel: midiChannel,
+          cc: ccNumber,
+          min: minValue,
+          max: maxValue,
+          behaviour: behavior,
         };
       }
     }
 
+    // Parse LED/color mappings if present
+    if (response.colors && Array.isArray(response.colors)) {
+      for (const colorMapping of response.colors) {
+        mode.leds!.set(colorMapping.controlId, {
+          color: colorMapping.color,
+          colour: colorMapping.color, // Alternative spelling
+          behaviour: colorMapping.behaviour || 'static',
+        });
+      }
+    }
+
     return mode;
   }
 
@@ -286,12 +353,27 @@ export class CustomModeManager extends EventEmitter {
       }
     }
 
+    // Convert LED mappings
+    if (mode.leds) {
+      for (const [controlId, led] of mode.leds.entries()) {
+        const ledData = led as any;
+        colors.push({
+          controlId,
+          color: ledData.color ?? ledData.colour,
+          behaviour: ledData.behaviour ?? 'static',
+        });
+      }
+    }
+
     return {
       slot,
       name: mode.name,
       controls,
       colors,
       labels,
+      metadata: {
+        slot,
+      }
     } as any;
   }
 
@@ -383,6 +465,7 @@ export class CustomModeManager extends EventEmitter {
     const mode: CustomMode = {
       name: name || 'Default Mode',
       controls: {},
+      leds: new Map(),
       metadata: {
         createdAt: new Date(),
         modifiedAt: new Date(),
@@ -470,6 +553,27 @@ export class CustomModeManager extends EventEmitter {
       };
     }
 
+    // Setup default LED mappings for buttons
+    // Focus buttons (0x30-0x37) - Green
+    for (let i = 0; i < 8; i++) {
+      const controlId = CONTROL_IDS[`FOCUS${i + 1}` as keyof typeof CONTROL_IDS];
+      mode.leds!.set(controlId, {
+        color: LED_COLORS.GREEN_LOW,
+        colour: LED_COLORS.GREEN_LOW,
+        behaviour: 'static',
+      });
+    }
+
+    // Control buttons (0x38-0x3F) - Red
+    for (let i = 0; i < 8; i++) {
+      const controlId = CONTROL_IDS[`CONTROL${i + 1}` as keyof typeof CONTROL_IDS];
+      mode.leds!.set(controlId, {
+        color: LED_COLORS.RED_LOW,
+        colour: LED_COLORS.RED_LOW,
+        behaviour: 'static',
+      });
+    }
+
     return mode;
   }
 
@@ -477,7 +581,12 @@ export class CustomModeManager extends EventEmitter {
    * Export mode to JSON
    */
   exportMode(mode: CustomMode): string {
-    return JSON.stringify(mode, null, 2);
+    // Convert Map to array for JSON serialization
+    const serializable = {
+      ...mode,
+      leds: mode.leds ? Array.from(mode.leds.entries()) : []
+    };
+    return JSON.stringify(serializable, null, 2);
   }
 
   /**
@@ -485,6 +594,12 @@ export class CustomModeManager extends EventEmitter {
    */
   importMode(json: string): CustomMode {
     const parsed = JSON.parse(json);
+
+    // Convert leds array back to Map
+    if (parsed.leds && Array.isArray(parsed.leds)) {
+      parsed.leds = new Map(parsed.leds);
+    }
+
     this.validateMode(parsed);
     return parsed;
   }
@@ -501,11 +616,15 @@ export class CustomModeManager extends EventEmitter {
   /**
    * Validate custom mode
    */
-  private validateMode(mode: CustomMode): void {
+  private validateMode(mode: any): void {
     if (!mode.name || typeof mode.name !== 'string') {
       throw new Error('Mode must have a name');
     }
 
+    if (mode.name.trim() === '') {
+      throw new Error('Mode name cannot be empty');
+    }
+
     if (!mode.controls || typeof mode.controls !== 'object') {
       throw new Error('Mode must have controls object');
     }
@@ -518,26 +637,51 @@ export class CustomModeManager extends EventEmitter {
 
       const ctrl = control as any; // Type assertion for validation
 
-      if (ctrl.channel < 0 || ctrl.channel > 15) {
-        throw new Error(`Invalid channel for ${key}: ${ctrl.channel}`);
+      // Validate channel (check both property names)
+      const channel = ctrl.channel ?? ctrl.midiChannel;
+      if (channel !== undefined && (channel < 0 || channel > 15)) {
+        throw new Error(`Invalid channel for ${key}: ${channel}`);
       }
 
-      if (ctrl.cc !== undefined && (ctrl.cc < 0 || ctrl.cc > 127)) {
-        throw new Error(`Invalid CC for ${key}: ${ctrl.cc}`);
+      // Validate CC number (check both property names)
+      const cc = ctrl.cc ?? ctrl.ccNumber;
+      if (cc !== undefined && (cc < 0 || cc > 127)) {
+        throw new Error(`Invalid CC for ${key}: ${cc}`);
       }
 
-      if (ctrl.min !== undefined && (ctrl.min < 0 || ctrl.min > 127)) {
-        throw new Error(`Invalid min value for ${key}: ${ctrl.min}`);
+      // Validate min value (check both property names)
+      const min = ctrl.min ?? ctrl.minValue;
+      if (min !== undefined && (min < 0 || min > 127)) {
+        throw new Error(`Invalid min value for ${key}: ${min}`);
       }
 
-      if (ctrl.max !== undefined && (ctrl.max < 0 || ctrl.max > 127)) {
-        throw new Error(`Invalid max value for ${key}: ${ctrl.max}`);
+      // Validate max value (check both property names)
+      const max = ctrl.max ?? ctrl.maxValue;
+      if (max !== undefined && (max < 0 || max > 127)) {
+        throw new Error(`Invalid max value for ${key}: ${max}`);
       }
 
-      if (ctrl.min !== undefined && ctrl.max !== undefined && ctrl.min > ctrl.max) {
+      if (min !== undefined && max !== undefined && min > max) {
         throw new Error(`Min value greater than max for ${key}`);
       }
     }
+
+    // Validate LED configurations if present
+    if (mode.leds) {
+      // Handle both Map and object formats
+      const ledsMap = mode.leds instanceof Map ? mode.leds : new Map(Object.entries(mode.leds));
+
+      for (const [controlId, led] of ledsMap.entries()) {
+        const ledData = led as any;
+        const behaviour = ledData.behaviour ?? ledData.behavior;
+
+        if (behaviour && !VALID_LED_BEHAVIOURS.includes(behaviour)) {
+          // Get control name for better error message
+          const controlName = this.getControlIdName(Number(controlId));
+          throw new Error(`Invalid LED behaviour for ${controlName}: ${behaviour}`);
+        }
+      }
+    }
   }
 
   /**
@@ -545,7 +689,7 @@ export class CustomModeManager extends EventEmitter {
    */
   cleanup(): void {
     this.pendingOperations.clear();
-    this.cachedModes.clear();
+    this.cache.clear();
     this.removeAllListeners();
   }
 
@@ -554,7 +698,7 @@ export class CustomModeManager extends EventEmitter {
    */
   clearCache(): void {
     this.pendingOperations.clear();
-    this.cachedModes.clear();
+    this.cache.clear();
   }
 
   /**
@@ -563,7 +707,11 @@ export class CustomModeManager extends EventEmitter {
    * @returns Map of slot numbers to cached CustomMode objects
    */
   getCachedModes(): Map<number, CustomMode> {
-    return new Map(this.cachedModes);
+    const result = new Map<number, CustomMode>();
+    for (const [slot, entry] of this.cache.entries()) {
+      result.set(slot, entry.mode);
+    }
+    return result;
   }
 }
 
diff --git a/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts b/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts
index dba85c4..1c7151b 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/types/CustomMode.ts
@@ -16,17 +16,27 @@ export interface Control {
   behavior: ControlBehavior;
 }
 
+export interface LedMapping {
+  color?: number;        // LED color value
+  colour?: number;       // Alternative spelling
+  behaviour?: string;    // LED behavior: 'static', 'flash', 'pulse', 'flashing', 'pulsing'
+}
+
 export interface CustomMode {
   name: string;           // Mode name (max 8 chars)
   controls: Record<string, ControlMapping>;    // Control mappings by ID
+  leds?: Map<number, LedMapping>;  // LED mappings by control ID
   labels?: Map<number, string>;  // Control labels by ID
-  colors?: Map<number, number>;  // Control colors by ID
+  colors?: Map<number, number>;  // Control colors by ID (legacy)
   // Note: LED states are controlled via real-time MIDI messages (0x78),
   // not stored in custom mode configurations
   metadata?: {
     name?: string;
     description?: string;
     version?: string;
+    slot?: number;
+    createdAt?: Date;
+    modifiedAt?: Date;
     [key: string]: any;
   };
   slot?: number;          // Mode slot (0-15)
@@ -73,4 +83,4 @@ export interface CustomModeResponse {
   name?: string;
   controls: Control[];
   rawData?: number[];
-}
\ No newline at end of file
+}
diff --git a/modules/audio-control/modules/launch-control-xl3/test/unit/ControlMapper.test.ts b/modules/audio-control/modules/launch-control-xl3/test/unit/ControlMapper.test.ts
index e6a9e52..322f40c 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/unit/ControlMapper.test.ts
+++ b/modules/audio-control/modules/launch-control-xl3/test/unit/ControlMapper.test.ts
@@ -18,7 +18,7 @@ describe('ControlMapper', () => {
 
   beforeEach(() => {
     controlMapper = new ControlMapper({
-      defaultChannel: 0,
+      defaultChannel: 1,
       enableValueSmoothing: false,
       enableDeadzone: false,
     });
@@ -65,7 +65,7 @@ describe('ControlMapper', () => {
     it('should unmap a control successfully', () => {
       const mapping: ControlMapping = {
         type: 'button',
-        channel: 0,
+        channel: 1,
         cc: 60,
         min: 0,
         max: 127,
@@ -85,7 +85,7 @@ describe('ControlMapper', () => {
 
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 30,
         min: 0,
         max: 127,
@@ -106,7 +106,7 @@ describe('ControlMapper', () => {
     it('should update control mapping', () => {
       const originalMapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 40,
         min: 0,
         max: 127,
@@ -190,7 +190,7 @@ describe('ControlMapper', () => {
     it('should apply min/max range scaling', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 20,
         max: 80,
@@ -217,7 +217,7 @@ describe('ControlMapper', () => {
 
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -237,7 +237,7 @@ describe('ControlMapper', () => {
     it('should apply exponential transform', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -260,7 +260,7 @@ describe('ControlMapper', () => {
     it('should apply toggle transform', () => {
       const mapping: ControlMapping = {
         type: 'button',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -288,7 +288,7 @@ describe('ControlMapper', () => {
       it('should pass through values unchanged in absolute mode', () => {
         const mapping: ControlMapping = {
           type: 'knob',
-          channel: 0,
+          channel: 1,
           cc: 10,
           min: 0,
           max: 127,
@@ -306,7 +306,7 @@ describe('ControlMapper', () => {
       it('should handle relative1 mode correctly', () => {
         const mapping: ControlMapping = {
           type: 'knob',
-          channel: 0,
+          channel: 1,
           cc: 10,
           min: 0,
           max: 127,
@@ -331,7 +331,7 @@ describe('ControlMapper', () => {
       it('should handle relative2 mode correctly', () => {
         const mapping: ControlMapping = {
           type: 'knob',
-          channel: 0,
+          channel: 1,
           cc: 10,
           min: 0,
           max: 127,
@@ -356,7 +356,7 @@ describe('ControlMapper', () => {
       it('should handle relative3 mode correctly', () => {
         const mapping: ControlMapping = {
           type: 'knob',
-          channel: 0,
+          channel: 1,
           cc: 10,
           min: 0,
           max: 127,
@@ -389,7 +389,7 @@ describe('ControlMapper', () => {
     it('should smooth values using moving average', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -427,7 +427,7 @@ describe('ControlMapper', () => {
     it('should ignore small value changes within deadzone', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -559,7 +559,7 @@ describe('ControlMapper', () => {
     it('should track control values and timestamps', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -579,7 +579,7 @@ describe('ControlMapper', () => {
     it('should reset control state', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -602,7 +602,7 @@ describe('ControlMapper', () => {
     it('should reset all controls', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -626,7 +626,7 @@ describe('ControlMapper', () => {
     it('should handle invalid control values gracefully', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -646,7 +646,7 @@ describe('ControlMapper', () => {
     it('should handle missing transform gracefully', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -669,7 +669,7 @@ describe('ControlMapper', () => {
 
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -687,7 +687,7 @@ describe('ControlMapper', () => {
     it('should clean up resources', () => {
       const mapping: ControlMapping = {
         type: 'knob',
-        channel: 0,
+        channel: 1,
         cc: 10,
         min: 0,
         max: 127,
@@ -777,7 +777,7 @@ describe('RelativeHandlers', () => {
 
     it('should clamp to valid range', () => {
       expect(RelativeHandlers.twosComplement(50, 100)).toBe(127); // Clamped to max
-      expect(RelativeHandlers.twosComplement(150, 10)).toBe(0); // Clamped to min
+      expect(RelativeHandlers.twosComplement(100, 5)).toBe(0); // Clamped to min
     });
   });
 
diff --git a/modules/audio-control/modules/launch-control-xl3/test/unit/SysExParser.test.ts b/modules/audio-control/modules/launch-control-xl3/test/unit/SysExParser.test.ts
index b3b0c90..8fd637a 100644
--- a/modules/audio-control/modules/launch-control-xl3/test/unit/SysExParser.test.ts
+++ b/modules/audio-control/modules/launch-control-xl3/test/unit/SysExParser.test.ts
@@ -175,7 +175,7 @@ describe('SysExParser', () => {
   // ===== buildCustomModeReadRequest() Tests =====
   describe('buildCustomModeReadRequest', () => {
     it('should build correct custom mode read request', () => {
-      const message = SysExParser.buildCustomModeReadRequest(3);
+      const message = SysExParser.buildCustomModeReadRequest(3, 0);
 
       expect(message).toEqual([
         0xF0,             // SysEx start
@@ -185,27 +185,27 @@ describe('SysExParser', () => {
         0x05,             // Sub-command
         0x00,             // Reserved
         0x40,             // Read operation
+        0x00,             // Page byte (0x00 for page 0)
         3,                // Slot number
-        0x00,             // Parameter
         0xF7              // SysEx end
       ]);
     });
 
     it('should handle slot boundaries', () => {
-      const slot0 = SysExParser.buildCustomModeReadRequest(0);
-      const slot15 = SysExParser.buildCustomModeReadRequest(15);
+      const slot0 = SysExParser.buildCustomModeReadRequest(0, 0);
+      const slot14 = SysExParser.buildCustomModeReadRequest(14, 0);
 
-      expect(slot0[9]).toBe(0); // Slot number at position 9
-      expect(slot15[9]).toBe(15);
+      expect(slot0[10]).toBe(0); // Slot number at position 10
+      expect(slot14[10]).toBe(14);
     });
 
     it('should validate slot range', () => {
-      expect(() => SysExParser.buildCustomModeReadRequest(-1)).toThrow('Custom mode slot must be 0-15');
-      expect(() => SysExParser.buildCustomModeReadRequest(16)).toThrow('Custom mode slot must be 0-15');
+      expect(() => SysExParser.buildCustomModeReadRequest(-1, 0)).toThrow('Custom mode slot must be 0-14');
+      expect(() => SysExParser.buildCustomModeReadRequest(15, 0)).toThrow('Custom mode slot must be 0-14');
     });
 
     it('should create valid SysEx format', () => {
-      const message = SysExParser.buildCustomModeReadRequest(5);
+      const message = SysExParser.buildCustomModeReadRequest(5, 0);
 
       expect(SysExParser.isValidSysEx(message)).toBe(true);
     });
@@ -300,7 +300,7 @@ describe('SysExParser', () => {
     };
 
     it('should build valid custom mode write request', () => {
-      const message = SysExParser.buildCustomModeWriteRequest(2, mockModeData);
+      const message = SysExParser.buildCustomModeWriteRequest(2, 0, mockModeData);
 
       expect(message[0]).toBe(0xF0); // SysEx start
       expect(message.slice(1, 4)).toEqual([0x00, 0x20, 0x29]); // Manufacturer ID
@@ -309,13 +309,14 @@ describe('SysExParser', () => {
       expect(message[6]).toBe(0x05); // Sub-command
       expect(message[7]).toBe(0x00); // Reserved
       expect(message[8]).toBe(0x45); // Write operation
-      expect(message[9]).toBe(2); // Slot number
+      expect(message[9]).toBe(0); // Page number
+      expect(message[10]).toBe(2); // Slot number
       expect(message[message.length - 1]).toBe(0xF7); // SysEx end
     });
 
     it('should validate slot range', () => {
-      expect(() => SysExParser.buildCustomModeWriteRequest(-1, mockModeData)).toThrow('Custom mode slot must be 0-15');
-      expect(() => SysExParser.buildCustomModeWriteRequest(16, mockModeData)).toThrow('Custom mode slot must be 0-15');
+      expect(() => SysExParser.buildCustomModeWriteRequest(-1, 0, mockModeData)).toThrow('Custom mode slot must be 0-14');
+      expect(() => SysExParser.buildCustomModeWriteRequest(15, 0, mockModeData)).toThrow('Custom mode slot must be 0-14');
     });
 
     it('should validate mode data before encoding', () => {
@@ -329,11 +330,11 @@ describe('SysExParser', () => {
         ]
       };
 
-      expect(() => SysExParser.buildCustomModeWriteRequest(0, invalidModeData)).toThrow('CC number must be 0-127');
+      expect(() => SysExParser.buildCustomModeWriteRequest(0, 0, invalidModeData)).toThrow('CC number must be 0-127');
     });
 
     it('should create valid SysEx format', () => {
-      const message = SysExParser.buildCustomModeWriteRequest(0, mockModeData);
+      const message = SysExParser.buildCustomModeWriteRequest(0, 0, mockModeData);
 
       expect(SysExParser.isValidSysEx(message)).toBe(true);
     });
@@ -690,8 +691,8 @@ describe('SysExParser', () => {
   // ===== Boundary Condition Tests =====
   describe('Boundary Conditions', () => {
     it('should handle maximum slot numbers', () => {
-      expect(() => SysExParser.buildCustomModeReadRequest(15)).not.toThrow();
-      expect(() => SysExParser.buildCustomModeReadRequest(0)).not.toThrow();
+      expect(() => SysExParser.buildCustomModeReadRequest(14, 0)).not.toThrow();
+      expect(() => SysExParser.buildCustomModeReadRequest(0, 0)).not.toThrow();
     });
 
     it('should handle maximum CC values', () => {


---

_**Agent (claude-sonnet-4-5-20250929)**_

fix(launch-control-xl3): resolve MIDI channel validation, LED mapping, and protocol compliance test failures

