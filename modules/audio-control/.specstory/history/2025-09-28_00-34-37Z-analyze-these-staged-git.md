<!-- Generated by SpecStory -->

# MIDI Device Handshake: Error Handling & Type Safety (2025-09-28 00:34:37Z)

<!-- Claude Code Session 19f72baa-cdc9-42db-a6d8-d98a3a0385a4 (2025-09-28_00-34-37Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/audio-control/modules/launch-control-xl3/SPEC.md b/modules/audio-control/modules/launch-control-xl3/SPEC.md
index 7955c35..68dbaaf 100644
--- a/modules/audio-control/modules/launch-control-xl3/SPEC.md
+++ b/modules/audio-control/modules/launch-control-xl3/SPEC.md
@@ -47,22 +47,30 @@ features should be deferred to later phases.
     - [x] Install and configure essential dependencies
 
 ### Feature MVP.1: Multiple Environment Support with a Common API
+
 - [x] The library API supports MIDI communication in node execution environments
-- [x] The library API supports MIDI communication in WebMIDI browser execution environments 
+- [x] The library API supports MIDI communication in WebMIDI browser execution environments
 
 ### Feature MVP.2: Device Handshake
 
-- [ ] Library API offers a function to initiate a handshake with the connected device
-- [ ] Library handshake function successfully listens for and processes the handshake response from the device
-- [ ] Library handshake function offers well-defined error messages
-- [ ] Library API offers a function to interrogate the current state of the device connection
+- [x] Library API offers a function to initiate a handshake with the connected device
+- [x] Library handshake function successfully listens for and processes the handshake response from the device
+- [x] Library handshake function offers well-defined error messages
+- [x] Library API offers a function to interrogate the current state of the device connection
+
+#### Feature MVP.2 Testing Requirements
+
+- [ ] There is a "one-click" pnpm script in this module that a developer may use to initiates a handshake via Node MIDI
+  with a connected device and reports success or failure
+- [ ] There is an html document that may be loaded into a chrome browser by a developer to initiate a handshake via
+  WebMIDI and report success or failure
 
 ### Feature MVP.3: Device Custom Mode Fetch
 
 - [ ] Library API offers a function to fetch the data from the current custom mode in the connected device
 - [ ] The fetch function listens for and parses response message(s) from the device and returns a data structure
   representing the custom mode data to the API client
-- [ ] The fetch 
+- [ ] The fetch
 
 ## Feature Prioritization
 
@@ -162,6 +170,6 @@ Long-term vision and experimental features
 
 ### Current Status
 
-- **Current Phase**: MVP (Planning)
-- **MVP Progress**: 0% (Not Started)
-- **Overall Progress**: 0% (Not Started)
\ No newline at end of file
+- **Current Phase**: MVP (In Progress)
+- **MVP Progress**: 80% (8/10 features complete)
+- **Overall Progress**: 80% (8/10 features complete)
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/src/LaunchControlXL3.ts b/modules/audio-control/modules/launch-control-xl3/src/LaunchControlXL3.ts
index 5ced032..4a2352c 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/LaunchControlXL3.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/LaunchControlXL3.ts
@@ -576,6 +576,41 @@ export class LaunchControlXL3 extends EventEmitter {
     return this.currentSlot;
   }
 
+  /**
+   * Verify device identity and retrieve hardware information
+   * @returns Device information
+   * @throws Error if not connected or handshake fails
+   */
+  async verifyDevice(): Promise<LaunchControlXL3Info> {
+    if (!this.isConnected()) {
+      throw new Error('Device not connected. Call connect() first before verifying device.');
+    }
+
+    const status = this.getStatus();
+    if (!status.deviceInfo) {
+      throw new Error('Device connected but device information not available. Device handshake may have failed.');
+    }
+
+    // Perform fresh device identity query to verify current connection
+    try {
+      // Access private method through device manager's queryDeviceIdentity
+      // Since DeviceManager doesn't expose this publicly, we'll trigger a reconnection
+      // which forces a fresh handshake
+      await this.disconnect();
+      await this.connect();
+
+      const updatedStatus = this.getStatus();
+      if (!updatedStatus.deviceInfo) {
+        throw new Error('Device verification failed: Unable to retrieve device information after reconnection.');
+      }
+
+      return updatedStatus.deviceInfo;
+    } catch (error) {
+      const errorMessage = error instanceof Error ? error.message : String(error);
+      throw new Error(`Device verification failed: ${errorMessage}`);
+    }
+  }
+
   /**
    * Clean up resources
    */
diff --git a/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts b/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
index 1e766ea..20ed64e 100644
--- a/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
+++ b/modules/audio-control/modules/launch-control-xl3/src/device/DeviceManager.ts
@@ -20,6 +20,7 @@ import {
   CustomMode,
   DeviceInquiryResponse
 } from '../types/index.js';
+import { z } from 'zod';
 
 export interface DeviceManagerOptions {
   midiBackend?: MidiBackendInterface | undefined;
@@ -122,21 +123,46 @@ export class DeviceManager extends EventEmitter {
       this.inputPortId = inputPort.id;
       this.outputPortId = outputPort.id;
 
-      // Query device identity (optional - some devices don't respond)
+      // Query device identity - handshake is critical for device verification
       try {
         const deviceInfo = await this.queryDeviceIdentity();
         if (deviceInfo) {
           this.deviceInfo = this.parseDeviceInfo(deviceInfo);
+        } else {
+          throw new Error('Device inquiry returned null response. Device may not be compatible or may be in an invalid state.');
         }
       } catch (error) {
-        console.warn('Device inquiry failed, continuing anyway:', error);
-        // Create default device info
-        this.deviceInfo = {
-          name: 'Launch Control XL 3',
-          firmwareVersion: 'Unknown',
-          serialNumber: undefined,
-          deviceId: 0x11
-        } as any;
+        const errorMessage = error instanceof Error ? error.message : String(error);
+
+        // Only use fallback in development mode
+        if (process.env['NODE_ENV'] === 'development') {
+          console.warn('Device inquiry failed in development mode, using fallback device info:', errorMessage);
+          this.deviceInfo = this.createFallbackDeviceInfo();
+        } else {
+          // In production, provide actionable error handling
+          if (errorMessage.includes('timeout')) {
+            throw new Error(
+              `Device handshake timeout after ${this.options.inquiryTimeout}ms. ` +
+              'Troubleshooting steps: 1) Check device is powered on and connected, ' +
+              '2) Verify MIDI drivers are installed, 3) Try reconnecting the device, ' +
+              '4) Check for conflicting MIDI applications.'
+            );
+          } else if (errorMessage.includes('permission') || errorMessage.includes('access')) {
+            throw new Error(
+              `MIDI permission denied: ${errorMessage}. ` +
+              'Troubleshooting steps: 1) Grant MIDI access in browser settings, ' +
+              '2) Ensure you\'re using HTTPS in production, 3) Try refreshing the page, ' +
+              '4) Check browser MIDI support.'
+            );
+          } else {
+            throw new Error(
+              `Device handshake failed: ${errorMessage}. ` +
+              'Troubleshooting steps: 1) Verify device compatibility, ' +
+              '2) Check device is not in use by another application, ' +
+              '3) Try power cycling the device.'
+            );
+          }
+        }
       }
 
       // Initialize device settings
@@ -231,7 +257,13 @@ export class DeviceManager extends EventEmitter {
     return new Promise((resolve, reject) => {
       const timeout = setTimeout(() => {
         this.midi.removeListener('sysex', handleResponse);
-        reject(new Error('Device inquiry timeout'));
+        reject(new Error(
+          `Device inquiry timeout after ${this.options.inquiryTimeout}ms. ` +
+          'The device may not support SysEx handshake or may be unresponsive. ' +
+          'Troubleshooting steps: 1) Verify device is powered and connected, ' +
+          '2) Check MIDI cable/USB connection, 3) Ensure device supports identity inquiry, ' +
+          '4) Try increasing inquiry timeout in options.'
+        ));
       }, this.options.inquiryTimeout);
 
       const handleResponse = (message: MidiMessage) => {
@@ -242,7 +274,8 @@ export class DeviceManager extends EventEmitter {
             if (parsed.type === 'device_inquiry_response') {
               clearTimeout(timeout);
               this.midi.removeListener('sysex', handleResponse);
-              resolve(parsed as unknown as DeviceInquiryResponse);
+              const validatedResponse = this.validateDeviceInquiryResponse(parsed);
+              resolve(validatedResponse);
             }
           } catch {
             // Ignore parse errors for non-matching messages
@@ -262,16 +295,19 @@ export class DeviceManager extends EventEmitter {
    * Parse device info from inquiry response
    */
   private parseDeviceInfo(response: DeviceInquiryResponse): LaunchControlXL3Info {
-    return {
+    const validatedInfo = this.validateDeviceInfo({
       manufacturerId: response.manufacturerId.map(b =>
         b.toString(16).padStart(2, '0')
       ).join(' '),
-      deviceFamily: response.familyCode ?? 0,
-      modelNumber: response.familyMember ?? 0,
+      deviceFamily: response.familyCode ?? response.deviceFamily ?? 0,
+      modelNumber: response.familyMember ?? response.deviceModel ?? 0,
       firmwareVersion: response.softwareRevision ?
         `${response.softwareRevision[0]}.${response.softwareRevision[1]}.${response.softwareRevision[2]}.${response.softwareRevision[3]}` :
-        'unknown',
-    };
+        (response.firmwareVersion ? Array.from(response.firmwareVersion).join('.') : 'unknown'),
+      serialNumber: response.serialNumber ? Array.from(response.serialNumber).join('') : undefined,
+    });
+
+    return validatedInfo;
   }
 
   /**
@@ -317,7 +353,7 @@ export class DeviceManager extends EventEmitter {
 
       switch (parsed.type) {
         case 'template_change':
-          const templateChange = parsed as any;
+          const templateChange = this.validateTemplateChangeResponse(parsed);
           this.currentMode = {
             type: 'template',
             slot: templateChange.templateNumber,
@@ -477,7 +513,13 @@ export class DeviceManager extends EventEmitter {
     return new Promise((resolve, reject) => {
       const timeout = setTimeout(() => {
         this.midi.removeListener('sysex', handleResponse);
-        reject(new Error('Custom mode read timeout'));
+        reject(new Error(
+          `Custom mode read timeout after ${this.options.inquiryTimeout}ms for slot ${slot}. ` +
+          'The device may be unresponsive or the slot may be empty. ' +
+          'Troubleshooting steps: 1) Verify device connection, ' +
+          '2) Check if custom mode exists in the specified slot, ' +
+          '3) Try reading a different slot, 4) Power cycle the device.'
+        ));
       }, this.options.inquiryTimeout);
 
       const handleResponse = (message: MidiMessage) => {
@@ -489,12 +531,12 @@ export class DeviceManager extends EventEmitter {
               clearTimeout(timeout);
               this.midi.removeListener('sysex', handleResponse);
 
-              const response = parsed as any;
+              const response = this.validateCustomModeResponse(parsed);
               resolve({
-                slot: response.slot,
+                slot: response.slot ?? slot,
                 name: response.name || `Custom ${slot + 1}`,
-                controls: response.controls,
-                colors: response.colors,
+                controls: response.controls || {},
+                colors: response.colors || {},
               });
             }
           } catch {
@@ -526,7 +568,8 @@ export class DeviceManager extends EventEmitter {
       colors: mode.colors,
     };
 
-    const message = SysExParser.buildCustomModeWriteRequest(slot, modeData as any);
+    const validatedModeData = this.validateCustomModeData(modeData);
+    const message = SysExParser.buildCustomModeWriteRequest(slot, validatedModeData);
     await this.sendSysEx(message);
   }
 
@@ -548,6 +591,153 @@ export class DeviceManager extends EventEmitter {
     return status;
   }
 
+  /**
+   * Create fallback device info for development mode
+   */
+  private createFallbackDeviceInfo(): LaunchControlXL3Info {
+    return {
+      manufacturerId: '00 20 29', // Novation manufacturer ID
+      deviceFamily: 2,
+      modelNumber: 13, // Launch Control XL 3
+      firmwareVersion: 'Unknown',
+    };
+  }
+
+  /**
+   * Validate device inquiry response with proper type checking
+   */
+  private validateDeviceInquiryResponse(response: unknown): DeviceInquiryResponse {
+    const schema = z.object({
+      type: z.literal('device_inquiry_response'),
+      manufacturerId: z.array(z.number().min(0).max(127)),
+      deviceFamily: z.number().optional(),
+      deviceModel: z.number().optional(),
+      familyCode: z.number().optional(),
+      familyMember: z.number().optional(),
+      firmwareVersion: z.array(z.number()).optional(),
+      softwareRevision: z.array(z.number()).optional(),
+      serialNumber: z.array(z.number()).optional(),
+    });
+
+    try {
+      const validated = schema.parse(response);
+      return {
+        manufacturerId: validated.manufacturerId,
+        deviceFamily: validated.deviceFamily ?? validated.familyCode ?? 0,
+        deviceModel: validated.deviceModel ?? validated.familyMember ?? 0,
+        firmwareVersion: validated.firmwareVersion ?? validated.softwareRevision ?? [],
+        ...(validated.serialNumber && { serialNumber: validated.serialNumber }),
+        ...(validated.familyCode !== undefined && { familyCode: validated.familyCode }),
+        ...(validated.familyMember !== undefined && { familyMember: validated.familyMember }),
+        ...(validated.softwareRevision && { softwareRevision: validated.softwareRevision }),
+      };
+    } catch (error) {
+      throw new Error(`Invalid device inquiry response format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate device info with proper typing
+   */
+  private validateDeviceInfo(info: unknown): LaunchControlXL3Info {
+    const schema = z.object({
+      manufacturerId: z.string(),
+      deviceFamily: z.number(),
+      modelNumber: z.number(),
+      firmwareVersion: z.string(),
+      serialNumber: z.string().optional(),
+      deviceName: z.string().optional(),
+      portInfo: z.any().optional(), // MidiPortInfo type is complex, allow any for now
+    });
+
+    try {
+      const validated = schema.parse(info);
+      // Construct object with only defined optional properties
+      const result: LaunchControlXL3Info = {
+        manufacturerId: validated.manufacturerId,
+        deviceFamily: validated.deviceFamily,
+        modelNumber: validated.modelNumber,
+        firmwareVersion: validated.firmwareVersion,
+        ...(validated.serialNumber !== undefined && { serialNumber: validated.serialNumber }),
+        ...(validated.deviceName !== undefined && { deviceName: validated.deviceName }),
+        ...(validated.portInfo !== undefined && { portInfo: validated.portInfo }),
+      };
+
+      return result;
+    } catch (error) {
+      throw new Error(`Invalid device info format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate custom mode response with type guards
+   */
+  private validateCustomModeResponse(response: unknown): { slot?: number; name?: string; controls?: any; colors?: any } {
+    const schema = z.object({
+      type: z.literal('custom_mode_response'),
+      slot: z.number().min(0).max(15).optional(),
+      name: z.string().optional(),
+      controls: z.any().optional(), // Complex type, validate separately
+      colors: z.any().optional(),
+    });
+
+    try {
+      const validated = schema.parse(response);
+      const result: { slot?: number; name?: string; controls?: any; colors?: any } = {};
+
+      if (validated.slot !== undefined) {
+        result.slot = validated.slot;
+      }
+      if (validated.name !== undefined) {
+        result.name = validated.name;
+      }
+      if (validated.controls !== undefined) {
+        result.controls = validated.controls;
+      }
+      if (validated.colors !== undefined) {
+        result.colors = validated.colors;
+      }
+
+      return result;
+    } catch (error) {
+      throw new Error(`Invalid custom mode response format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate custom mode data before sending
+   */
+  private validateCustomModeData(data: unknown): any {
+    const schema = z.object({
+      slot: z.number().min(0).max(15),
+      name: z.string(),
+      controls: z.any(),
+      colors: z.any(),
+    });
+
+    try {
+      return schema.parse(data);
+    } catch (error) {
+      throw new Error(`Invalid custom mode data format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
+  /**
+   * Validate template change response with type guards
+   */
+  private validateTemplateChangeResponse(response: unknown): { templateNumber: number } {
+    const schema = z.object({
+      type: z.literal('template_change'),
+      templateNumber: z.number().min(0).max(15),
+    });
+
+    try {
+      return schema.parse(response);
+    } catch (error) {
+      throw new Error(`Invalid template change response format: ${error instanceof Error ? error.message : String(error)}`);
+    }
+  }
+
   /**
    * Clean up resources
    */
diff --git a/modules/audio-control/modules/launch-control-xl3/test/device/DeviceManager.test.ts b/modules/audio-control/modules/launch-control-xl3/test/device/DeviceManager.test.ts
new file mode 100644
index 0000000..c466ba3
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/device/DeviceManager.test.ts
@@ -0,0 +1,845 @@
+/**
+ * DeviceManager Unit Tests
+ *
+ * Tests for Feature MVP.2 (Device Handshake) functionality including:
+ * - Device discovery and connection
+ * - SysEx-based handshake protocol
+ * - Timeout and error handling
+ * - Connection state management
+ * - Reconnection scenarios
+ */
+
+import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
+import { DeviceManager, DeviceManagerOptions } from '@/device/DeviceManager';
+import { MidiInterface, MidiBackendInterface, MidiPortInfo, MidiInputPort, MidiOutputPort, MidiMessage, createMockBackend } from '@/core/MidiInterface';
+import { SysExParser, MANUFACTURER_ID } from '@/core/SysExParser';
+import type { DeviceInquiryResponse, LaunchControlXL3Info } from '@/types/index';
+
+// Mock implementations
+class MockMidiBackend implements MidiBackendInterface {
+  private isInitialized = false;
+  private inputPorts: MidiPortInfo[] = [];
+  private outputPorts: MidiPortInfo[] = [];
+  private openInputs = new Map<string, MockMidiInputPort>();
+  private openOutputs = new Map<string, MockMidiOutputPort>();
+  public messageHandler?: (port: string, message: MidiMessage) => void;
+
+  constructor() {
+    this.setupDefaultPorts();
+  }
+
+  private setupDefaultPorts(): void {
+    this.inputPorts = [
+      {
+        id: 'lcxl3-input',
+        name: 'LCXL3 1 MIDI Out',
+        manufacturer: 'Novation',
+        version: '1.0.0'
+      },
+      {
+        id: 'other-input',
+        name: 'Other Device',
+        manufacturer: 'Other',
+        version: '1.0.0'
+      }
+    ];
+
+    this.outputPorts = [
+      {
+        id: 'lcxl3-output',
+        name: 'LCXL3 1 DAW In',
+        manufacturer: 'Novation',
+        version: '1.0.0'
+      },
+      {
+        id: 'other-output',
+        name: 'Other Device Out',
+        manufacturer: 'Other',
+        version: '1.0.0'
+      }
+    ];
+  }
+
+  async initialize(): Promise<void> {
+    this.isInitialized = true;
+  }
+
+  async getInputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized) {
+      throw new Error('Backend not initialized');
+    }
+    return [...this.inputPorts];
+  }
+
+  async getOutputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized) {
+      throw new Error('Backend not initialized');
+    }
+    return [...this.outputPorts];
+  }
+
+  async openInput(portId: string): Promise<MidiInputPort> {
+    const portInfo = this.inputPorts.find(p => p.id === portId);
+    if (!portInfo) {
+      throw new Error(`Input port not found: ${portId}`);
+    }
+
+    const mockPort = new MockMidiInputPort(portInfo, this);
+    this.openInputs.set(portId, mockPort);
+    return mockPort;
+  }
+
+  async openOutput(portId: string): Promise<MidiOutputPort> {
+    const portInfo = this.outputPorts.find(p => p.id === portId);
+    if (!portInfo) {
+      throw new Error(`Output port not found: ${portId}`);
+    }
+
+    const mockPort = new MockMidiOutputPort(portInfo, this);
+    this.openOutputs.set(portId, mockPort);
+    return mockPort;
+  }
+
+  async sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
+    // Simulate message being sent - can be intercepted by tests
+    if (this.messageHandler) {
+      this.messageHandler(port.id, message);
+    }
+  }
+
+  async closePort(port: MidiInputPort | MidiOutputPort): Promise<void> {
+    if (port.type === 'input') {
+      this.openInputs.delete(port.id);
+    } else {
+      this.openOutputs.delete(port.id);
+    }
+  }
+
+  async cleanup(): Promise<void> {
+    this.openInputs.clear();
+    this.openOutputs.clear();
+    this.isInitialized = false;
+  }
+
+  // Test helpers
+  simulateDeviceInquiryResponse(): void {
+    const inputPort = this.openInputs.get('lcxl3-input');
+    if (inputPort && inputPort.onMessage) {
+      const responseData = [
+        0xF0, // Start
+        0x7E, // Universal non-realtime
+        0x00, // Device ID
+        0x06, // Inquiry response
+        0x02, // Sub-ID
+        0x00, 0x20, 0x29, // Manufacturer ID (Novation)
+        0x00, 0x61, // Family code
+        0x00, 0x01, // Family member
+        0x01, 0x00, 0x00, 0x00, // Software revision
+        0xF7, // End
+      ];
+
+      const message: MidiMessage = {
+        timestamp: Date.now(),
+        data: responseData,
+        type: 'sysex'
+      };
+
+      inputPort.onMessage(message);
+    }
+  }
+
+  simulateTemplateChangeResponse(templateNumber: number): void {
+    const inputPort = this.openInputs.get('lcxl3-input');
+    if (inputPort && inputPort.onMessage) {
+      const responseData = [
+        0xF0, // Start
+        ...MANUFACTURER_ID,
+        0x11, // Device ID
+        0x00, // Template change response
+        templateNumber,
+        0xF7, // End
+      ];
+
+      const message: MidiMessage = {
+        timestamp: Date.now(),
+        data: responseData,
+        type: 'sysex'
+      };
+
+      inputPort.onMessage(message);
+    }
+  }
+
+  removeDevice(): void {
+    this.inputPorts = this.inputPorts.filter(p => !p.name.includes('LCXL3'));
+    this.outputPorts = this.outputPorts.filter(p => !p.name.includes('LCXL3'));
+  }
+
+  addDevice(): void {
+    if (!this.inputPorts.find(p => p.id === 'lcxl3-input')) {
+      this.inputPorts.unshift({
+        id: 'lcxl3-input',
+        name: 'LCXL3 1 MIDI Out',
+        manufacturer: 'Novation',
+        version: '1.0.0'
+      });
+    }
+    if (!this.outputPorts.find(p => p.id === 'lcxl3-output')) {
+      this.outputPorts.unshift({
+        id: 'lcxl3-output',
+        name: 'LCXL3 1 DAW In',
+        manufacturer: 'Novation',
+        version: '1.0.0'
+      });
+    }
+  }
+}
+
+class MockMidiInputPort implements MidiInputPort {
+  readonly type = 'input' as const;
+  onMessage?: ((message: MidiMessage) => void) | undefined;
+
+  constructor(
+    private portInfo: MidiPortInfo,
+    private backend: MockMidiBackend
+  ) {}
+
+  get id(): string { return this.portInfo.id; }
+  get name(): string { return this.portInfo.name; }
+
+  async close(): Promise<void> {
+    await this.backend.closePort(this);
+  }
+}
+
+class MockMidiOutputPort implements MidiOutputPort {
+  readonly type = 'output' as const;
+
+  constructor(
+    private portInfo: MidiPortInfo,
+    private backend: MockMidiBackend
+  ) {}
+
+  get id(): string { return this.portInfo.id; }
+  get name(): string { return this.portInfo.name; }
+
+  async close(): Promise<void> {
+    await this.backend.closePort(this);
+  }
+}
+
+describe('DeviceManager', () => {
+  let deviceManager: DeviceManager;
+  let mockBackend: MockMidiBackend;
+
+  beforeEach(() => {
+    mockBackend = new MockMidiBackend();
+
+    const options: DeviceManagerOptions = {
+      midiBackend: mockBackend,
+      autoConnect: false, // Control connection manually in tests
+      inquiryTimeout: 1000, // Shorter timeout for tests
+      retryAttempts: 2,
+      retryDelay: 100
+    };
+
+    deviceManager = new DeviceManager(options);
+  });
+
+  afterEach(async () => {
+    await deviceManager.cleanup();
+  });
+
+  describe('initialization', () => {
+    it('should initialize successfully with valid backend', async () => {
+      await expect(deviceManager.initialize()).resolves.not.toThrow();
+    });
+
+    it('should initialize and auto-connect when autoConnect is true', async () => {
+      const autoConnectManager = new DeviceManager({
+        midiBackend: mockBackend,
+        autoConnect: true,
+        inquiryTimeout: 100
+      });
+
+      const connectSpy = vi.spyOn(autoConnectManager, 'connect');
+
+      // Set up device inquiry response before connecting
+      setTimeout(() => {
+        mockBackend.simulateDeviceInquiryResponse();
+      }, 50);
+
+      await autoConnectManager.initialize();
+
+      expect(connectSpy).toHaveBeenCalled();
+      await autoConnectManager.cleanup();
+    });
+
+    it('should handle initialization errors gracefully', async () => {
+      const errorBackend = {
+        ...mockBackend,
+        initialize: vi.fn().mockRejectedValue(new Error('Backend init failed'))
+      };
+
+      const errorManager = new DeviceManager({
+        midiBackend: errorBackend as MidiBackendInterface
+      });
+
+      await expect(errorManager.initialize()).rejects.toThrow('Backend init failed');
+    });
+  });
+
+  describe('device discovery and connection', () => {
+    beforeEach(async () => {
+      await deviceManager.initialize();
+    });
+
+    it('should successfully connect to Launch Control XL3', async () => {
+      const connectPromise = deviceManager.connect();
+
+      // Simulate device responding to inquiry
+      setTimeout(() => {
+        mockBackend.simulateDeviceInquiryResponse();
+      }, 50);
+
+      await expect(connectPromise).resolves.not.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.state).toBe('connected');
+      expect(status.deviceInfo).toBeDefined();
+    });
+
+    it('should handle connection to device without inquiry response', async () => {
+      // Don't simulate device inquiry response - should still connect with fallback info
+      await expect(deviceManager.connect()).resolves.not.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.deviceInfo?.name).toBe('Launch Control XL 3');
+      expect(status.deviceInfo?.firmwareVersion).toBe('Unknown');
+    });
+
+    it('should emit device:connected and device:ready events', async () => {
+      const connectedSpy = vi.fn();
+      const readySpy = vi.fn();
+
+      deviceManager.on('device:connected', connectedSpy);
+      deviceManager.on('device:ready', readySpy);
+
+      const connectPromise = deviceManager.connect();
+
+      setTimeout(() => {
+        mockBackend.simulateDeviceInquiryResponse();
+      }, 50);
+
+      await connectPromise;
+
+      expect(connectedSpy).toHaveBeenCalledWith(expect.objectContaining({
+        manufacturerId: '00 20 29',
+        deviceFamily: 0x61,
+        modelNumber: 0x01
+      }));
+      expect(readySpy).toHaveBeenCalled();
+    });
+
+    it('should not reconnect if already connected', async () => {
+      const connectPromise1 = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise1;
+
+      // Should not throw or change state
+      await expect(deviceManager.connect()).resolves.not.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+
+    it('should not reconnect if already connecting', async () => {
+      const connectPromise1 = deviceManager.connect();
+      const connectPromise2 = deviceManager.connect();
+
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+
+      await Promise.all([connectPromise1, connectPromise2]);
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+
+    it('should fail when device not found', async () => {
+      mockBackend.removeDevice();
+
+      await expect(deviceManager.connect()).rejects.toThrow('Launch Control XL 3 not found');
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(false);
+      expect(status.state).toBe('disconnected');
+    });
+  });
+
+  describe('handshake timeout handling', () => {
+    beforeEach(async () => {
+      await deviceManager.initialize();
+    });
+
+    it('should timeout when device does not respond to inquiry', async () => {
+      const shortTimeoutManager = new DeviceManager({
+        midiBackend: mockBackend,
+        inquiryTimeout: 100 // Very short timeout
+      });
+
+      await shortTimeoutManager.initialize();
+
+      // Don't simulate response - let it timeout
+      await expect(shortTimeoutManager.connect()).resolves.not.toThrow();
+
+      // Should still connect with fallback device info
+      const status = shortTimeoutManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.deviceInfo?.firmwareVersion).toBe('Unknown');
+
+      await shortTimeoutManager.cleanup();
+    });
+
+    it('should handle inquiry timeout gracefully and continue with connection', async () => {
+      const consoleSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});
+
+      // Connect without device response
+      await expect(deviceManager.connect()).resolves.not.toThrow();
+
+      expect(consoleSpy).toHaveBeenCalledWith(
+        expect.stringContaining('Device inquiry failed'),
+        expect.any(Error)
+      );
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      consoleSpy.mockRestore();
+    });
+  });
+
+  describe('invalid device response processing', () => {
+    beforeEach(async () => {
+      await deviceManager.initialize();
+    });
+
+    it('should handle malformed SysEx responses', async () => {
+      const connectPromise = deviceManager.connect();
+
+      // Simulate malformed response
+      setTimeout(() => {
+        const inputPort = mockBackend['openInputs'].get('lcxl3-input');
+        if (inputPort && inputPort.onMessage) {
+          const malformedMessage: MidiMessage = {
+            timestamp: Date.now(),
+            data: [0xF0, 0x00, 0x01], // Invalid/incomplete SysEx
+            type: 'sysex'
+          };
+          inputPort.onMessage(malformedMessage);
+
+          // Then send valid response
+          setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 10);
+        }
+      }, 50);
+
+      await expect(connectPromise).resolves.not.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+
+    it('should ignore non-device-inquiry SysEx messages during handshake', async () => {
+      const connectPromise = deviceManager.connect();
+
+      setTimeout(() => {
+        const inputPort = mockBackend['openInputs'].get('lcxl3-input');
+        if (inputPort && inputPort.onMessage) {
+          // Send template change message instead of device inquiry response
+          const templateMessage: MidiMessage = {
+            timestamp: Date.now(),
+            data: [0xF0, ...MANUFACTURER_ID, 0x11, 0x00, 0x05, 0xF7],
+            type: 'sysex'
+          };
+          inputPort.onMessage(templateMessage);
+
+          // Then send correct response
+          setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 10);
+        }
+      }, 50);
+
+      await expect(connectPromise).resolves.not.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+  });
+
+  describe('connection state management', () => {
+    beforeEach(async () => {
+      await deviceManager.initialize();
+    });
+
+    it('should transition through connection states correctly', async () => {
+      const states: string[] = [];
+
+      // Monitor state changes through status calls
+      const originalGetStatus = deviceManager.getStatus;
+      deviceManager.getStatus = vi.fn().mockImplementation(() => {
+        const status = originalGetStatus.call(deviceManager);
+        states.push(status.state);
+        return status;
+      });
+
+      const connectPromise = deviceManager.connect();
+
+      // Check initial state
+      let status = deviceManager.getStatus();
+      expect(states).toContain('connecting');
+
+      setTimeout(() => {
+        mockBackend.simulateDeviceInquiryResponse();
+      }, 50);
+
+      await connectPromise;
+
+      status = deviceManager.getStatus();
+      expect(status.state).toBe('connected');
+    });
+
+    it('should set state to error on connection failure', async () => {
+      mockBackend.removeDevice();
+
+      await expect(deviceManager.connect()).rejects.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.state).toBe('disconnected');
+    });
+
+    it('should handle device errors during connection', async () => {
+      const errorBackend = {
+        ...mockBackend,
+        openInput: vi.fn().mockRejectedValue(new Error('Port open failed'))
+      };
+
+      const errorManager = new DeviceManager({
+        midiBackend: errorBackend as MidiBackendInterface
+      });
+
+      await errorManager.initialize();
+      await expect(errorManager.connect()).rejects.toThrow();
+
+      const status = errorManager.getStatus();
+      expect(status.state).toBe('disconnected');
+
+      await errorManager.cleanup();
+    });
+  });
+
+  describe('multiple handshake attempts', () => {
+    it('should support multiple connection attempts after failure', async () => {
+      await deviceManager.initialize();
+
+      // First attempt - device not available
+      mockBackend.removeDevice();
+      await expect(deviceManager.connect()).rejects.toThrow('Launch Control XL 3 not found');
+
+      // Second attempt - device becomes available
+      mockBackend.addDevice();
+      const connectPromise = deviceManager.connect();
+
+      setTimeout(() => {
+        mockBackend.simulateDeviceInquiryResponse();
+      }, 50);
+
+      await expect(connectPromise).resolves.not.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+
+    it('should clean up properly between connection attempts', async () => {
+      await deviceManager.initialize();
+
+      // First failed attempt
+      mockBackend.removeDevice();
+      await expect(deviceManager.connect()).rejects.toThrow();
+
+      // Verify clean state
+      let status = deviceManager.getStatus();
+      expect(status.connected).toBe(false);
+      expect(status.deviceInfo).toBeUndefined();
+
+      // Second successful attempt
+      mockBackend.addDevice();
+      const connectPromise = deviceManager.connect();
+
+      setTimeout(() => {
+        mockBackend.simulateDeviceInquiryResponse();
+      }, 50);
+
+      await connectPromise;
+
+      status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.deviceInfo).toBeDefined();
+    });
+  });
+
+  describe('error recovery scenarios', () => {
+    beforeEach(async () => {
+      await deviceManager.initialize();
+    });
+
+    it('should handle MIDI backend errors', async () => {
+      const errorSpy = vi.fn();
+      deviceManager.on('device:error', errorSpy);
+
+      // Connect successfully first
+      const connectPromise = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise;
+
+      // Simulate MIDI error
+      const error = new Error('MIDI backend error');
+      deviceManager['handleError'](error);
+
+      expect(errorSpy).toHaveBeenCalledWith(error);
+    });
+
+    it('should attempt reconnection after connection loss', async () => {
+      const connectPromise = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise;
+
+      // Verify connected
+      let status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      // Simulate connection loss by triggering error handling
+      const reconnectManager = new DeviceManager({
+        midiBackend: mockBackend,
+        retryAttempts: 1,
+        retryDelay: 50
+      });
+
+      await reconnectManager.initialize();
+
+      const reconnectPromise = reconnectManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await reconnectPromise;
+
+      // Simulate error that triggers reconnection
+      const disconnectedSpy = vi.fn();
+      reconnectManager.on('device:disconnected', disconnectedSpy);
+
+      // Trigger error and test reconnection logic
+      reconnectManager['handleError'](new Error('Connection lost'));
+
+      await reconnectManager.cleanup();
+    });
+
+    it('should emit device:disconnected on cleanup', async () => {
+      const connectPromise = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise;
+
+      const disconnectedSpy = vi.fn();
+      deviceManager.on('device:disconnected', disconnectedSpy);
+
+      await deviceManager.disconnect('Manual disconnect');
+
+      expect(disconnectedSpy).toHaveBeenCalledWith('Manual disconnect');
+    });
+
+    it('should handle message sending after disconnection', async () => {
+      // Should throw when not connected
+      await expect(deviceManager.sendSysEx([0xF0, 0xF7])).rejects.toThrow('Device not connected');
+      await expect(deviceManager.sendCC(1, 127)).rejects.toThrow('Device not connected');
+    });
+  });
+
+  describe('device communication after handshake', () => {
+    beforeEach(async () => {
+      await deviceManager.initialize();
+
+      const connectPromise = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise;
+    });
+
+    it('should send SysEx messages to connected device', async () => {
+      const sentMessages: MidiMessage[] = [];
+      mockBackend.messageHandler = (portId, message) => {
+        sentMessages.push(message);
+      };
+
+      const sysexData = [0xF0, 0x00, 0x20, 0x29, 0x11, 0x77, 0x00, 0xF7];
+      await deviceManager.sendSysEx(sysexData);
+
+      expect(sentMessages).toHaveLength(1);
+      expect(sentMessages[0].data).toEqual(sysexData);
+    });
+
+    it('should send CC messages to connected device', async () => {
+      const sentMessages: MidiMessage[] = [];
+      mockBackend.messageHandler = (portId, message) => {
+        sentMessages.push(message);
+      };
+
+      await deviceManager.sendCC(20, 100, 0);
+
+      expect(sentMessages).toHaveLength(1);
+      expect(sentMessages[0].data).toEqual([0xB0, 20, 100]);
+    });
+
+    it('should handle template selection', async () => {
+      const modeChangedSpy = vi.fn();
+      deviceManager.on('device:modeChanged', modeChangedSpy);
+
+      await deviceManager.selectTemplate(5);
+
+      expect(modeChangedSpy).toHaveBeenCalledWith({
+        type: 'template',
+        slot: 5
+      });
+    });
+
+    it('should validate template slot range', async () => {
+      await expect(deviceManager.selectTemplate(-1)).rejects.toThrow('Template slot must be 0-15');
+      await expect(deviceManager.selectTemplate(16)).rejects.toThrow('Template slot must be 0-15');
+    });
+
+    it('should handle incoming control changes after handshake', async () => {
+      const controlChangeSpy = vi.fn();
+      deviceManager.on('control:change', controlChangeSpy);
+
+      // Simulate incoming CC message
+      const inputPort = mockBackend['openInputs'].get('lcxl3-input');
+      if (inputPort && inputPort.onMessage) {
+        const ccMessage: MidiMessage = {
+          timestamp: Date.now(),
+          data: [0xB0, 13, 64], // Send A knob 1
+          type: 'controlchange',
+          channel: 0,
+          controller: 13,
+          value: 64
+        };
+        inputPort.onMessage(ccMessage);
+      }
+
+      expect(controlChangeSpy).toHaveBeenCalledWith('sendA1', 64, 0);
+    });
+
+    it('should ignore control changes during initialization', async () => {
+      // Create new manager to test initialization state
+      const testManager = new DeviceManager({
+        midiBackend: mockBackend,
+        autoConnect: false
+      });
+
+      await testManager.initialize();
+
+      const controlChangeSpy = vi.fn();
+      testManager.on('control:change', controlChangeSpy);
+
+      // Start connecting (initialization state)
+      const connectPromise = testManager.connect();
+
+      // Send CC during initialization
+      setTimeout(() => {
+        const inputPort = mockBackend['openInputs'].get('lcxl3-input');
+        if (inputPort && inputPort.onMessage) {
+          const ccMessage: MidiMessage = {
+            timestamp: Date.now(),
+            data: [0xB0, 13, 64],
+            type: 'controlchange',
+            channel: 0,
+            controller: 13,
+            value: 64
+          };
+          inputPort.onMessage(ccMessage);
+        }
+
+        // Complete handshake
+        mockBackend.simulateDeviceInquiryResponse();
+      }, 50);
+
+      await connectPromise;
+
+      // Should not have received the message sent during initialization
+      expect(controlChangeSpy).not.toHaveBeenCalled();
+
+      await testManager.cleanup();
+    });
+  });
+
+  describe('device status reporting', () => {
+    it('should report correct status when disconnected', () => {
+      const status = deviceManager.getStatus();
+
+      expect(status.connected).toBe(false);
+      expect(status.state).toBe('disconnected');
+      expect(status.deviceInfo).toBeUndefined();
+      expect(status.currentMode).toBeUndefined();
+      expect(status.lastSeen).toBeUndefined();
+    });
+
+    it('should report correct status when connected', async () => {
+      await deviceManager.initialize();
+
+      const connectPromise = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise;
+
+      const status = deviceManager.getStatus();
+
+      expect(status.connected).toBe(true);
+      expect(status.state).toBe('connected');
+      expect(status.deviceInfo).toBeDefined();
+      expect(status.lastSeen).toBeInstanceOf(Date);
+    });
+  });
+
+  describe('resource cleanup', () => {
+    it('should clean up all resources', async () => {
+      await deviceManager.initialize();
+
+      const connectPromise = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise;
+
+      // Verify resources are active
+      let status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      await deviceManager.cleanup();
+
+      // Verify cleanup
+      status = deviceManager.getStatus();
+      expect(status.connected).toBe(false);
+      expect(status.deviceInfo).toBeUndefined();
+
+      // Should not throw if called again
+      await expect(deviceManager.cleanup()).resolves.not.toThrow();
+    });
+
+    it('should clean up timers on disconnect', async () => {
+      await deviceManager.initialize();
+
+      const connectPromise = deviceManager.connect();
+      setTimeout(() => mockBackend.simulateDeviceInquiryResponse(), 50);
+      await connectPromise;
+
+      // Spy on clearTimeout to verify timer cleanup
+      const clearTimeoutSpy = vi.spyOn(global, 'clearTimeout');
+
+      await deviceManager.disconnect();
+
+      expect(clearTimeoutSpy).toHaveBeenCalled();
+
+      clearTimeoutSpy.mockRestore();
+    });
+  });
+});
\ No newline at end of file
diff --git a/modules/audio-control/modules/launch-control-xl3/test/integration/device-handshake.test.ts b/modules/audio-control/modules/launch-control-xl3/test/integration/device-handshake.test.ts
new file mode 100644
index 0000000..b5de504
--- /dev/null
+++ b/modules/audio-control/modules/launch-control-xl3/test/integration/device-handshake.test.ts
@@ -0,0 +1,827 @@
+/**
+ * Device Handshake Integration Tests
+ *
+ * Integration tests for Feature MVP.2 (Device Handshake) covering:
+ * - Complete handshake with mocked device
+ * - End-to-end connection and verification flow
+ * - Reconnection with handshake
+ * - Multiple device handling
+ * - Full workflow from discovery to communication
+ */
+
+import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
+import { DeviceManager, DeviceManagerOptions } from '@/device/DeviceManager';
+import { MidiInterface, MidiBackendInterface, MidiPortInfo, MidiInputPort, MidiOutputPort, MidiMessage } from '@/core/MidiInterface';
+import { SysExParser, MANUFACTURER_ID } from '@/core/SysExParser';
+import type { DeviceInquiryResponse, LaunchControlXL3Info, DeviceMode, CustomMode } from '@/types/index';
+
+/**
+ * Advanced Mock MIDI Backend for Integration Testing
+ * Simulates real-world device behavior with timing and state management
+ */
+class IntegrationMockBackend implements MidiBackendInterface {
+  private isInitialized = false;
+  private connectedDevices: Map<string, MockDevice> = new Map();
+  private openInputs = new Map<string, MockInputPort>();
+  private openOutputs = new Map<string, MockOutputPort>();
+
+  // Device simulation parameters
+  public deviceResponseDelay = 50; // ms
+  public deviceInquiryEnabled = true;
+  public templateChangeEnabled = true;
+  public connectionStable = true;
+
+  constructor() {
+    this.setupDefaultDevices();
+  }
+
+  private setupDefaultDevices(): void {
+    // Primary Launch Control XL3 device
+    this.addDevice('lcxl3-primary', {
+      inputName: 'LCXL3 1 MIDI Out',
+      outputName: 'LCXL3 1 DAW In',
+      manufacturerId: [0x00, 0x20, 0x29],
+      familyCode: 0x61,
+      familyMember: 0x01,
+      firmwareVersion: [1, 2, 3, 4],
+      serialNumber: [0x31, 0x32, 0x33, 0x34], // "1234"
+      deviceId: 0x11
+    });
+
+    // Secondary device for multi-device testing
+    this.addDevice('lcxl3-secondary', {
+      inputName: 'LCXL3 2 MIDI Out',
+      outputName: 'LCXL3 2 DAW In',
+      manufacturerId: [0x00, 0x20, 0x29],
+      familyCode: 0x61,
+      familyMember: 0x01,
+      firmwareVersion: [1, 2, 4, 0],
+      serialNumber: [0x35, 0x36, 0x37, 0x38], // "5678"
+      deviceId: 0x12
+    });
+  }
+
+  addDevice(id: string, config: MockDeviceConfig): void {
+    this.connectedDevices.set(id, new MockDevice(id, config));
+  }
+
+  removeDevice(id: string): void {
+    this.connectedDevices.delete(id);
+  }
+
+  disconnectDevice(id: string): void {
+    const device = this.connectedDevices.get(id);
+    if (device) {
+      device.connected = false;
+    }
+  }
+
+  reconnectDevice(id: string): void {
+    const device = this.connectedDevices.get(id);
+    if (device) {
+      device.connected = true;
+    }
+  }
+
+  async initialize(): Promise<void> {
+    this.isInitialized = true;
+  }
+
+  async getInputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized) {
+      throw new Error('Backend not initialized');
+    }
+
+    return Array.from(this.connectedDevices.values())
+      .filter(device => device.connected)
+      .map(device => ({
+        id: `${device.id}-input`,
+        name: device.config.inputName,
+        manufacturer: 'Novation',
+        version: device.config.firmwareVersion.join('.')
+      }));
+  }
+
+  async getOutputPorts(): Promise<MidiPortInfo[]> {
+    if (!this.isInitialized) {
+      throw new Error('Backend not initialized');
+    }
+
+    return Array.from(this.connectedDevices.values())
+      .filter(device => device.connected)
+      .map(device => ({
+        id: `${device.id}-output`,
+        name: device.config.outputName,
+        manufacturer: 'Novation',
+        version: device.config.firmwareVersion.join('.')
+      }));
+  }
+
+  async openInput(portId: string): Promise<MidiInputPort> {
+    const deviceId = portId.replace('-input', '');
+    const device = this.connectedDevices.get(deviceId);
+
+    if (!device || !device.connected) {
+      throw new Error(`Input port not found: ${portId}`);
+    }
+
+    const mockPort = new MockInputPort(portId, device.config.inputName, device, this);
+    this.openInputs.set(portId, mockPort);
+    return mockPort;
+  }
+
+  async openOutput(portId: string): Promise<MidiOutputPort> {
+    const deviceId = portId.replace('-output', '');
+    const device = this.connectedDevices.get(deviceId);
+
+    if (!device || !device.connected) {
+      throw new Error(`Output port not found: ${portId}`);
+    }
+
+    const mockPort = new MockOutputPort(portId, device.config.outputName, device, this);
+    this.openOutputs.set(portId, mockPort);
+    return mockPort;
+  }
+
+  async sendMessage(port: MidiOutputPort, message: MidiMessage): Promise<void> {
+    const deviceId = port.id.replace('-output', '');
+    const device = this.connectedDevices.get(deviceId);
+
+    if (!device || !device.connected) {
+      throw new Error(`Device not available: ${deviceId}`);
+    }
+
+    if (!this.connectionStable) {
+      throw new Error('Connection unstable - message failed');
+    }
+
+    // Process the message and potentially generate responses
+    await device.handleMessage(message, this);
+  }
+
+  async closePort(port: MidiInputPort | MidiOutputPort): Promise<void> {
+    if (port.type === 'input') {
+      this.openInputs.delete(port.id);
+    } else {
+      this.openOutputs.delete(port.id);
+    }
+  }
+
+  async cleanup(): Promise<void> {
+    this.openInputs.clear();
+    this.openOutputs.clear();
+    this.isInitialized = false;
+  }
+
+  // Test utilities
+  getInputPort(portId: string): MockInputPort | undefined {
+    return this.openInputs.get(portId);
+  }
+
+  getOutputPort(portId: string): MockOutputPort | undefined {
+    return this.openOutputs.get(portId);
+  }
+
+  simulateConnectionLoss(deviceId: string): void {
+    this.disconnectDevice(deviceId);
+
+    // Notify open ports about disconnection
+    const inputPort = this.openInputs.get(`${deviceId}-input`);
+    const outputPort = this.openOutputs.get(`${deviceId}-output`);
+
+    if (inputPort) {
+      inputPort.simulateDisconnection();
+    }
+    if (outputPort) {
+      outputPort.simulateDisconnection();
+    }
+  }
+}
+
+interface MockDeviceConfig {
+  inputName: string;
+  outputName: string;
+  manufacturerId: number[];
+  familyCode: number;
+  familyMember: number;
+  firmwareVersion: number[];
+  serialNumber?: number[];
+  deviceId: number;
+}
+
+class MockDevice {
+  public connected = true;
+  private currentTemplate = 0;
+  private customModes = new Map<number, any>();
+
+  constructor(
+    public readonly id: string,
+    public readonly config: MockDeviceConfig
+  ) {}
+
+  async handleMessage(message: MidiMessage, backend: IntegrationMockBackend): Promise<void> {
+    if (message.type === 'sysex' || message.data[0] === 0xF0) {
+      await this.handleSysExMessage(message, backend);
+    }
+  }
+
+  private async handleSysExMessage(message: MidiMessage, backend: IntegrationMockBackend): Promise<void> {
+    try {
+      const parsed = SysExParser.parse([...message.data]);
+
+      switch (parsed.type) {
+        case 'device_inquiry':
+          if (backend.deviceInquiryEnabled) {
+            setTimeout(() => {
+              this.sendDeviceInquiryResponse(backend);
+            }, backend.deviceResponseDelay);
+          }
+          break;
+
+        case 'template_change':
+          if (backend.templateChangeEnabled) {
+            const templateMsg = parsed as any;
+            this.currentTemplate = templateMsg.templateNumber;
+            setTimeout(() => {
+              this.sendTemplateChangeConfirmation(backend, this.currentTemplate);
+            }, backend.deviceResponseDelay);
+          }
+          break;
+
+        case 'custom_mode_read':
+          const readMsg = parsed as any;
+          setTimeout(() => {
+            this.sendCustomModeResponse(backend, readMsg.slot);
+          }, backend.deviceResponseDelay);
+          break;
+      }
+    } catch (error) {
+      // Ignore invalid SysEx messages
+    }
+  }
+
+  private sendDeviceInquiryResponse(backend: IntegrationMockBackend): void {
+    const inputPort = backend.getInputPort(`${this.id}-input`);
+    if (inputPort && inputPort.onMessage) {
+      const responseData = [
+        0xF0, // Start
+        0x7E, // Universal non-realtime
+        0x00, // Device ID
+        0x06, // Inquiry response
+        0x02, // Sub-ID
+        ...this.config.manufacturerId,
+        (this.config.familyCode >> 8) & 0x7F, this.config.familyCode & 0x7F,
+        (this.config.familyMember >> 8) & 0x7F, this.config.familyMember & 0x7F,
+        ...this.config.firmwareVersion,
+        0xF7, // End
+      ];
+
+      const message: MidiMessage = {
+        timestamp: Date.now(),
+        data: responseData,
+        type: 'sysex'
+      };
+
+      inputPort.onMessage(message);
+    }
+  }
+
+  private sendTemplateChangeConfirmation(backend: IntegrationMockBackend, templateNumber: number): void {
+    const inputPort = backend.getInputPort(`${this.id}-input`);
+    if (inputPort && inputPort.onMessage) {
+      const responseData = [
+        0xF0, // Start
+        ...MANUFACTURER_ID,
+        this.config.deviceId,
+        0x00, // Template change confirmation
+        templateNumber,
+        0xF7, // End
+      ];
+
+      const message: MidiMessage = {
+        timestamp: Date.now(),
+        data: responseData,
+        type: 'sysex'
+      };
+
+      inputPort.onMessage(message);
+    }
+  }
+
+  private sendCustomModeResponse(backend: IntegrationMockBackend, slot: number): void {
+    const inputPort = backend.getInputPort(`${this.id}-input`);
+    if (inputPort && inputPort.onMessage) {
+      // Simulate custom mode data (simplified)
+      const customMode = this.customModes.get(slot) || {
+        slot,
+        name: `Custom ${slot + 1}`,
+        controls: [],
+        colors: []
+      };
+
+      // Build custom mode response (simplified format)
+      const responseData = [
+        0xF0, // Start
+        ...MANUFACTURER_ID,
+        this.config.deviceId,
+        0x01, // Custom mode response
+        slot,
+        ...Array.from(customMode.name).map((c: string) => c.charCodeAt(0)),
+        0xF7, // End
+      ];
+
+      const message: MidiMessage = {
+        timestamp: Date.now(),
+        data: responseData,
+        type: 'sysex'
+      };
+
+      inputPort.onMessage(message);
+    }
+  }
+}
+
+class MockInputPort implements MidiInputPort {
+  readonly type = 'input' as const;
+  onMessage?: ((message: MidiMessage) => void) | undefined;
+  private disconnected = false;
+
+  constructor(
+    public readonly id: string,
+    public readonly name: string,
+    private device: MockDevice,
+    private backend: IntegrationMockBackend
+  ) {}
+
+  async close(): Promise<void> {
+    await this.backend.closePort(this);
+  }
+
+  simulateDisconnection(): void {
+    this.disconnected = true;
+  }
+
+  simulateControlChange(controller: number, value: number, channel = 0): void {
+    if (this.disconnected || !this.onMessage) return;
+
+    const message: MidiMessage = {
+      timestamp: Date.now(),
+      data: [0xB0 | channel, controller, value],
+      type: 'controlchange',
+      channel,
+      controller,
+      value
+    };
+
+    this.onMessage(message);
+  }
+}
+
+class MockOutputPort implements MidiOutputPort {
+  readonly type = 'output' as const;
+  public sentMessages: MidiMessage[] = [];
+
+  constructor(
+    public readonly id: string,
+    public readonly name: string,
+    private device: MockDevice,
+    private backend: IntegrationMockBackend
+  ) {}
+
+  async close(): Promise<void> {
+    await this.backend.closePort(this);
+  }
+
+  simulateDisconnection(): void {
+    // Output ports don't receive messages, so just mark as disconnected
+  }
+}
+
+describe('Device Handshake Integration Tests', () => {
+  let backend: IntegrationMockBackend;
+  let deviceManager: DeviceManager;
+
+  beforeEach(() => {
+    backend = new IntegrationMockBackend();
+
+    const options: DeviceManagerOptions = {
+      midiBackend: backend,
+      autoConnect: false,
+      inquiryTimeout: 2000, // Longer timeout for integration tests
+      retryAttempts: 3,
+      retryDelay: 200
+    };
+
+    deviceManager = new DeviceManager(options);
+  });
+
+  afterEach(async () => {
+    await deviceManager.cleanup();
+  });
+
+  describe('complete handshake with mocked device', () => {
+    it('should complete full handshake flow successfully', async () => {
+      await deviceManager.initialize();
+
+      // Track events during handshake
+      const events: string[] = [];
+      deviceManager.on('device:connected', () => events.push('connected'));
+      deviceManager.on('device:ready', () => events.push('ready'));
+
+      // Execute handshake
+      await deviceManager.connect();
+
+      // Verify connection state
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.state).toBe('connected');
+      expect(status.deviceInfo).toBeDefined();
+
+      // Verify handshake events occurred in order
+      expect(events).toEqual(['connected', 'ready']);
+
+      // Verify device information was received correctly
+      expect(status.deviceInfo?.manufacturerId).toBe('00 20 29');
+      expect(status.deviceInfo?.deviceFamily).toBe(0x61);
+      expect(status.deviceInfo?.modelNumber).toBe(0x01);
+      expect(status.deviceInfo?.firmwareVersion).toBe('1.2.3.4');
+    });
+
+    it('should handle handshake with device that responds slowly', async () => {
+      backend.deviceResponseDelay = 500; // Slow device
+
+      await deviceManager.initialize();
+
+      const startTime = Date.now();
+      await deviceManager.connect();
+      const endTime = Date.now();
+
+      // Should still connect successfully
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      // Should have taken at least the response delay
+      expect(endTime - startTime).toBeGreaterThanOrEqual(400);
+    });
+
+    it('should handle handshake when device inquiry is disabled', async () => {
+      backend.deviceInquiryEnabled = false;
+
+      await deviceManager.initialize();
+
+      // Should still connect with fallback device info in development mode
+      const originalEnv = process.env.NODE_ENV;
+      process.env.NODE_ENV = 'development';
+
+      await deviceManager.connect();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.deviceInfo?.firmwareVersion).toBe('Unknown');
+
+      process.env.NODE_ENV = originalEnv;
+    });
+
+    it('should validate device response format during handshake', async () => {
+      await deviceManager.initialize();
+
+      // Corrupt the device response
+      const originalSendResponse = backend.connectedDevices.get('lcxl3-primary')!['sendDeviceInquiryResponse'];
+      backend.connectedDevices.get('lcxl3-primary')!['sendDeviceInquiryResponse'] = function(backend: IntegrationMockBackend) {
+        const inputPort = backend.getInputPort(`${this.id}-input`);
+        if (inputPort && inputPort.onMessage) {
+          // Send malformed response
+          const corruptedData = [0xF0, 0x7E, 0x00, 0x06, 0x02, 0xFF, 0xFF, 0xF7]; // Invalid manufacturer ID
+
+          const message: MidiMessage = {
+            timestamp: Date.now(),
+            data: corruptedData,
+            type: 'sysex'
+          };
+
+          inputPort.onMessage(message);
+        }
+      };
+
+      // Should handle validation error gracefully
+      const originalEnv = process.env.NODE_ENV;
+      process.env.NODE_ENV = 'development';
+
+      await deviceManager.connect();
+
+      // Should still connect with fallback
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      process.env.NODE_ENV = originalEnv;
+    });
+  });
+
+  describe('end-to-end connection and verification flow', () => {
+    it('should complete entire workflow from discovery to communication', async () => {
+      await deviceManager.initialize();
+
+      // Phase 1: Discovery and Connection
+      await deviceManager.connect();
+
+      let status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      // Phase 2: Device Communication
+      const modeChangedSpy = vi.fn();
+      deviceManager.on('device:modeChanged', modeChangedSpy);
+
+      await deviceManager.selectTemplate(3);
+
+      // Verify template change was processed
+      expect(modeChangedSpy).toHaveBeenCalledWith({
+        type: 'template',
+        slot: 3
+      });
+
+      // Phase 3: Control Message Handling
+      const controlChangeSpy = vi.fn();
+      deviceManager.on('control:change', controlChangeSpy);
+
+      // Simulate control input from device
+      const inputPort = backend.getInputPort('lcxl3-primary-input') as MockInputPort;
+      inputPort.simulateControlChange(13, 64, 0); // Send A knob 1
+
+      expect(controlChangeSpy).toHaveBeenCalledWith('sendA1', 64, 0);
+
+      // Phase 4: SysEx Communication
+      const sysexSpy = vi.fn();
+      deviceManager.on('sysex:received', sysexSpy);
+
+      // Send custom SysEx message
+      await deviceManager.sendSysEx([0xF0, 0x00, 0x20, 0x29, 0x11, 0x77, 0x00, 0xF7]);
+
+      // Verify communication is working
+      status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+
+    it('should handle device verification during communication', async () => {
+      await deviceManager.initialize();
+      await deviceManager.connect();
+
+      // Attempt to read custom mode (tests SysEx round-trip)
+      const customModePromise = deviceManager.readCustomMode(0);
+
+      // Should receive response and complete successfully
+      await expect(customModePromise).resolves.toEqual(
+        expect.objectContaining({
+          slot: 0,
+          name: 'Custom 1'
+        })
+      );
+    });
+
+    it('should maintain connection state throughout communication', async () => {
+      await deviceManager.initialize();
+      await deviceManager.connect();
+
+      // Perform multiple operations
+      await deviceManager.selectTemplate(1);
+      await deviceManager.sendCC(20, 100);
+      await deviceManager.selectTemplate(2);
+
+      // Connection should remain stable
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.state).toBe('connected');
+    });
+  });
+
+  describe('reconnection with handshake', () => {
+    it('should reconnect and perform handshake after connection loss', async () => {
+      await deviceManager.initialize();
+      await deviceManager.connect();
+
+      // Verify initial connection
+      let status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      // Simulate connection loss
+      const disconnectedSpy = vi.fn();
+      deviceManager.on('device:disconnected', disconnectedSpy);
+
+      backend.simulateConnectionLoss('lcxl3-primary');
+      await deviceManager.disconnect('Connection lost');
+
+      expect(disconnectedSpy).toHaveBeenCalled();
+
+      // Reconnect device
+      backend.reconnectDevice('lcxl3-primary');
+
+      // Reconnect and verify handshake occurs again
+      const connectedSpy = vi.fn();
+      deviceManager.on('device:connected', connectedSpy);
+
+      await deviceManager.connect();
+
+      expect(connectedSpy).toHaveBeenCalled();
+
+      status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.deviceInfo).toBeDefined();
+    });
+
+    it('should handle intermittent connection issues during reconnection', async () => {
+      await deviceManager.initialize();
+      await deviceManager.connect();
+
+      // Make connection unstable
+      backend.connectionStable = false;
+
+      // Disconnect and try to reconnect
+      await deviceManager.disconnect('Unstable connection');
+
+      // First reconnection attempt should fail
+      backend.connectionStable = false;
+      await expect(deviceManager.connect()).rejects.toThrow();
+
+      // Second attempt with stable connection should succeed
+      backend.connectionStable = true;
+      await expect(deviceManager.connect()).resolves.not.toThrow();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+
+    it('should preserve device settings after reconnection', async () => {
+      await deviceManager.initialize();
+      await deviceManager.connect();
+
+      // Set a specific template
+      await deviceManager.selectTemplate(5);
+
+      // Disconnect and reconnect
+      await deviceManager.disconnect();
+      await deviceManager.connect();
+
+      // Device should reinitialize (template gets reset to 0 during initialization)
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+      expect(status.currentMode?.type).toBe('template');
+      expect(status.currentMode?.slot).toBe(0); // Reset during initialization
+    });
+  });
+
+  describe('multiple device handling', () => {
+    it('should handle multiple devices with separate handshakes', async () => {
+      // Create manager for primary device
+      const primaryManager = new DeviceManager({
+        midiBackend: backend,
+        deviceNameFilter: 'LCXL3 1',
+        autoConnect: false
+      });
+
+      // Create manager for secondary device
+      const secondaryManager = new DeviceManager({
+        midiBackend: backend,
+        deviceNameFilter: 'LCXL3 2',
+        autoConnect: false
+      });
+
+      await primaryManager.initialize();
+      await secondaryManager.initialize();
+
+      // Connect both devices
+      await primaryManager.connect();
+      await secondaryManager.connect();
+
+      // Verify both are connected with different device info
+      const primaryStatus = primaryManager.getStatus();
+      const secondaryStatus = secondaryManager.getStatus();
+
+      expect(primaryStatus.connected).toBe(true);
+      expect(secondaryStatus.connected).toBe(true);
+
+      // They should have different firmware versions to distinguish them
+      expect(primaryStatus.deviceInfo?.firmwareVersion).toBe('1.2.3.4');
+      expect(secondaryStatus.deviceInfo?.firmwareVersion).toBe('1.2.4.0');
+
+      // Cleanup
+      await primaryManager.cleanup();
+      await secondaryManager.cleanup();
+    });
+
+    it('should handle device discovery when multiple devices are available', async () => {
+      await deviceManager.initialize();
+
+      // Should connect to the first matching device by default
+      await deviceManager.connect();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      // Should have connected to primary device (first one found)
+      expect(status.deviceInfo?.firmwareVersion).toBe('1.2.3.4');
+    });
+
+    it('should handle device conflicts gracefully', async () => {
+      // Remove secondary device to test single device handling
+      backend.removeDevice('lcxl3-secondary');
+
+      await deviceManager.initialize();
+      await deviceManager.connect();
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+
+      // Add secondary device after connection
+      backend.addDevice('lcxl3-secondary', {
+        inputName: 'LCXL3 2 MIDI Out',
+        outputName: 'LCXL3 2 DAW In',
+        manufacturerId: [0x00, 0x20, 0x29],
+        familyCode: 0x61,
+        familyMember: 0x01,
+        firmwareVersion: [1, 3, 0, 0],
+        deviceId: 0x12
+      });
+
+      // Original connection should remain stable
+      const statusAfter = deviceManager.getStatus();
+      expect(statusAfter.connected).toBe(true);
+      expect(statusAfter.deviceInfo?.firmwareVersion).toBe('1.2.3.4'); // Still primary
+    });
+  });
+
+  describe('handshake timeout and error scenarios', () => {
+    it('should handle complete device unresponsiveness', async () => {
+      backend.deviceInquiryEnabled = false;
+      backend.templateChangeEnabled = false;
+
+      await deviceManager.initialize();
+
+      const originalEnv = process.env.NODE_ENV;
+      process.env.NODE_ENV = 'production';
+
+      // Should fail in production mode when device doesn't respond
+      await expect(deviceManager.connect()).rejects.toThrow(/Device handshake timeout/);
+
+      process.env.NODE_ENV = originalEnv;
+    });
+
+    it('should provide helpful error messages for different failure modes', async () => {
+      await deviceManager.initialize();
+
+      // Test timeout scenario
+      backend.deviceResponseDelay = 3000; // Longer than inquiry timeout
+
+      const originalEnv = process.env.NODE_ENV;
+      process.env.NODE_ENV = 'production';
+
+      await expect(deviceManager.connect()).rejects.toThrow(/Device handshake timeout/);
+      await expect(deviceManager.connect()).rejects.toThrow(/Troubleshooting steps/);
+
+      process.env.NODE_ENV = originalEnv;
+    });
+
+    it('should handle concurrent connection attempts gracefully', async () => {
+      await deviceManager.initialize();
+
+      // Start multiple connection attempts simultaneously
+      const connection1 = deviceManager.connect();
+      const connection2 = deviceManager.connect();
+      const connection3 = deviceManager.connect();
+
+      // All should resolve successfully (subsequent calls should be no-ops)
+      await Promise.all([connection1, connection2, connection3]);
+
+      const status = deviceManager.getStatus();
+      expect(status.connected).toBe(true);
+    });
+
+    it('should handle backend initialization failures during handshake', async () => {
+      // Create manager with backend that fails after initial success
+      const failingBackend = new IntegrationMockBackend();
+      const originalGetInputPorts = failingBackend.getInputPorts;
+
+      failingBackend.getInputPorts = vi.fn().mockImplementation(async () => {
+        // Fail on second call (during connection)
+        if ((failingBackend.getInputPorts as any).mock.calls.length > 1) {
+          throw new Error('Backend connection lost');
+        }
+        return originalGetInputPorts.call(failingBackend);
+      });
+
+      const errorManager = new DeviceManager({
+        midiBackend: failingBackend,
+        autoConnect: false
+      });
+
+      await errorManager.initialize();
+
+      // First connection should succeed
+      await errorManager.connect();
+      await errorManager.disconnect();
+
+      // Second connection should fail
+      await expect(errorManager.connect()).rejects.toThrow('Backend connection lost');
+
+      await errorManager.cleanup();
+    });
+  });
+});
\ No newline at end of file


---

_**Agent (claude-opus-4-1-20250805)**_

feat(launch-control-xl3): implement device handshake with verification, timeout handling, and comprehensive test suite

