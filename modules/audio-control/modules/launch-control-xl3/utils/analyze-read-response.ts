#!/usr/bin/env tsx
/**
 * Analyze the read response to understand the data format
 */

// The response we got from reading slot 0 after web editor wrote to it
const responseHex = `0xf0 0x00 0x20 0x29 0x02 0x15 0x05 0x00 0x10 0x00 0x06 0x20 0x10 0x2a 0x4e 0x65 0x77 0x20 0x43 0x75 0x73 0x74 0x6f 0x6d 0x20 0x4d 0x6f 0x64 0x65 0x21 0x00 0x48 0x10 0x02 0x05 0x00 0x01 0x48 0x00 0x0d 0x7f 0x48 0x11 0x02 0x05 0x00 0x01 0x48 0x00 0x0e 0x7f 0x48 0x12 0x02 0x05 0x00 0x01 0x48 0x00 0x0f 0x7f 0x48 0x13 0x02 0x05 0x00 0x01 0x48 0x00 0x10 0x7f 0x48 0x14 0x02 0x05 0x00 0x01 0x48 0x00 0x11 0x7f 0x48 0x15 0x02 0x05 0x00 0x01 0x48 0x00 0x12 0x7f 0x48 0x16 0x02 0x05 0x00 0x01 0x48 0x00 0x13 0x7f 0x48 0x17 0x02 0x05 0x00 0x01 0x48 0x00 0x14 0x7f 0x48 0x18 0x02 0x09 0x00 0x01 0x48 0x00 0x15 0x7f 0x48 0x19 0x02 0x09 0x00 0x01 0x48 0x00 0x16 0x7f 0x48 0x1a 0x02 0x09 0x00 0x01 0x48 0x00 0x17 0x7f 0x48 0x1b 0x02 0x09 0x00 0x01 0x48 0x00 0x18 0x7f 0x48 0x1c 0x02 0x09 0x00 0x01 0x48 0x00 0x19 0x7f 0x48 0x1d 0x02 0x09 0x00 0x01 0x48 0x00 0x1a 0x7f 0x48 0x1e 0x02 0x09 0x00 0x01 0x48 0x00 0x1b 0x7f 0x48 0x1f 0x02 0x09 0x00 0x01 0x48 0x00 0x1c 0x7f 0x48 0x20 0x02 0x0d 0x00 0x01 0x48 0x00 0x1d 0x7f 0x48 0x21 0x02 0x0d 0x00 0x01 0x48 0x00 0x1e 0x7f 0x48 0x22 0x02 0x0d 0x00 0x01 0x48 0x00 0x1f 0x7f 0x48 0x23 0x02 0x0d 0x00 0x01 0x48 0x00 0x20 0x7f 0x48 0x24 0x02 0x0d 0x00 0x01 0x48 0x00 0x21 0x7f 0x48 0x25 0x02 0x0d 0x00 0x01 0x48 0x00 0x22 0x7f 0x48 0x26 0x02 0x0d 0x00 0x01 0x48 0x00 0x23 0x7f 0x48 0x27 0x02 0x0d 0x00 0x01 0x48 0x00 0x24 0x7f 0x6b 0x10 0x54 0x65 0x73 0x74 0x56 0x6f 0x6c 0x75 0x6d 0x65 0x31 0x60 0x11 0x60 0x12 0x60 0x13 0x60 0x14 0x60 0x15 0x60 0x16 0x60 0x17 0x60 0x18 0x60 0x19 0x60 0x1a 0x60 0x1b 0x60 0x1c 0x60 0x1d 0x60 0x1e 0x60 0x1f 0x60 0x20 0x60 0x21 0x60 0x22 0x60 0x23 0x60 0x24 0x60 0x25 0x60 0x26 0x60 0x27 0x06 0x00 0x04 0x40 0xf7`;

// Parse the hex string into bytes
const bytes = responseHex.split(' ').map(h => parseInt(h, 16));

console.log('Response Analysis');
console.log('=================\n');

console.log(`Total length: ${bytes.length} bytes\n`);

// Header analysis
console.log('Header (first 13 bytes):');
console.log(bytes.slice(0, 13).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
console.log('\nBreakdown:');
console.log('0xf0 - SysEx start');
console.log('0x00 0x20 0x29 - Novation manufacturer ID');
console.log('0x02 0x15 - Device/model identifiers');
console.log('0x05 0x00 - Command type');
console.log('0x10 - Response indicator (vs 0x15 for command, 0x45 for our write)');
console.log('0x00 - Slot number (0)');
console.log('0x06 0x20 0x10 - Unknown (possibly data format markers)');

// Mode name
console.log('\n\nMode Name Section:');
const nameStart = 13;
let nameEnd = nameStart;
while (bytes[nameEnd] !== 0x21 && nameEnd < bytes.length) {
  nameEnd++;
}
const nameBytes = bytes.slice(nameStart, nameEnd);
const modeName = String.fromCharCode(...nameBytes.filter(b => b !== 0x2a)); // Remove 0x2a
console.log(`Position ${nameStart}-${nameEnd}: "${modeName}"`);
console.log('Raw bytes:', nameBytes.map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));

// Control definitions
console.log('\n\nControl Definitions:');
console.log('Each control starts with 0x48, followed by control ID and parameters');

// Find the label section (starts with 0x6b)
const labelMarkerIndex = bytes.indexOf(0x6b, nameEnd);
console.log(`\nLabel section starts at position ${labelMarkerIndex} (0x6b marker)`);

// Parse the TestVolume1 label
if (labelMarkerIndex !== -1) {
  const labelStart = labelMarkerIndex;
  console.log('\nFirst Label:');
  console.log(`0x6b 0x10 - Label for control 0x10`);
  const labelTextStart = labelStart + 2;
  let labelTextEnd = labelTextStart;
  // Find end of label (next 0x60 or 0x6b)
  while (bytes[labelTextEnd] !== 0x60 && bytes[labelTextEnd] !== 0x6b && labelTextEnd < bytes.length) {
    labelTextEnd++;
  }
  const labelText = String.fromCharCode(...bytes.slice(labelTextStart, labelTextEnd));
  console.log(`Label text: "${labelText}"`);
  console.log('Raw bytes:', bytes.slice(labelTextStart, labelTextEnd).map(b => '0x' + b.toString(16).padStart(2, '0')).join(' '));
}

// Color section
const colorMarkerIndex = bytes.indexOf(0x60, labelMarkerIndex);
console.log(`\n\nColor section starts at position ${colorMarkerIndex} (0x60 markers)`);
console.log('Each entry: 0x60 [control_id] [color_value?]');

console.log('\n\nKey Findings:');
console.log('=============');
console.log('1. The READ response contains the full custom mode data');
console.log('2. "TestVolume1" label is present at the expected position');
console.log('3. The simple 12-byte commands from web editor don\'t write data directly');
console.log('4. They likely tell the device to store/activate pre-configured data');

console.log('\n\nHypothesis Update:');
console.log('==================');
console.log('The web editor likely:');
console.log('1. Sends the full data using a different protocol (WebMIDI, HTTP, etc.)');
console.log('2. Then sends the 12-byte command to activate/save it');
console.log('3. The 12-byte message is just a trigger, not a data transfer');