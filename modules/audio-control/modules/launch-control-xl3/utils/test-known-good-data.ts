#!/usr/bin/env npx tsx
/**
 * Test sending exact known-good data captured from the web editor
 * This helps verify if the issue is with our data format or something else
 */

import { LaunchControlXL3 } from '../src/index.js';
import { EasyMidiBackend } from '../src/core/backends/EasyMidiBackend.js';

// Exact data captured from web editor for slot 0 (342 bytes)
const KNOWN_GOOD_DATA_SLOT_0 = Buffer.from([
  0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x00, 0x01, 0x20, 0x10, 0x2A, 0x4E, 0x65,
  0x77, 0x20, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x49, 0x10, 0x02,
  0x05, 0x00, 0x01, 0x40, 0x00, 0x0D, 0x7F, 0x00, 0x49, 0x11, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00,
  0x0E, 0x7F, 0x00, 0x49, 0x12, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x0F, 0x7F, 0x00, 0x49, 0x13,
  0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x10, 0x7F, 0x00, 0x49, 0x14, 0x02, 0x05, 0x00, 0x01, 0x40,
  0x00, 0x11, 0x7F, 0x00, 0x49, 0x15, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x12, 0x7F, 0x00, 0x49,
  0x16, 0x02, 0x05, 0x00, 0x01, 0x40, 0x00, 0x13, 0x7F, 0x00, 0x49, 0x17, 0x02, 0x05, 0x00, 0x01,
  0x40, 0x00, 0x14, 0x7F, 0x00, 0x49, 0x18, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x15, 0x7F, 0x00,
  0x49, 0x19, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x16, 0x7F, 0x00, 0x49, 0x1A, 0x02, 0x09, 0x00,
  0x01, 0x40, 0x00, 0x17, 0x7F, 0x00, 0x49, 0x1B, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x18, 0x7F,
  0x00, 0x49, 0x1C, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x19, 0x7F, 0x00, 0x49, 0x1D, 0x02, 0x09,
  0x00, 0x01, 0x40, 0x00, 0x1A, 0x7F, 0x00, 0x49, 0x1E, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1B,
  0x7F, 0x00, 0x49, 0x1F, 0x02, 0x09, 0x00, 0x01, 0x40, 0x00, 0x1C, 0x7F, 0x00, 0x49, 0x20, 0x02,
  0x0D, 0x00, 0x01, 0x40, 0x00, 0x1D, 0x7F, 0x00, 0x49, 0x21, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00,
  0x1E, 0x7F, 0x00, 0x49, 0x22, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x1F, 0x7F, 0x00, 0x49, 0x23,
  0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x20, 0x7F, 0x00, 0x49, 0x24, 0x02, 0x0D, 0x00, 0x01, 0x40,
  0x00, 0x21, 0x7F, 0x00, 0x49, 0x25, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x22, 0x7F, 0x00, 0x49,
  0x26, 0x02, 0x0D, 0x00, 0x01, 0x40, 0x00, 0x23, 0x7F, 0x00, 0x49, 0x27, 0x02, 0x0D, 0x00, 0x01,
  0x40, 0x00, 0x24, 0x7F, 0x00, 0x60, 0x10, 0x60, 0x11, 0x60, 0x12, 0x60, 0x13, 0x60, 0x14, 0x60,
  0x15, 0x60, 0x16, 0x60, 0x17, 0x60, 0x18, 0x60, 0x19, 0x60, 0x1A, 0x60, 0x1B, 0x60, 0x1C, 0x60,
  0x1D, 0x60, 0x1E, 0x60, 0x1F, 0x60, 0x20, 0x60, 0x21, 0x60, 0x22, 0x60, 0x23, 0x60, 0x24, 0x60,
  0x25, 0x60, 0x26, 0x60, 0x27, 0xF7
]);

// Exact data captured from web editor for slot 3 (342 bytes)
const KNOWN_GOOD_DATA_SLOT_3 = Buffer.from([
  0xF0, 0x00, 0x20, 0x29, 0x02, 0x15, 0x05, 0x00, 0x45, 0x03, 0x01, 0x20, 0x10, 0x2A, 0x4E, 0x65,
  0x77, 0x20, 0x43, 0x75, 0x73, 0x74, 0x6F, 0x6D, 0x20, 0x4D, 0x6F, 0x64, 0x65, 0x49, 0x28, 0x02,
  0x00, 0x00, 0x01, 0x40, 0x00, 0x05, 0x7F, 0x00, 0x49, 0x29, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00,
  0x06, 0x7F, 0x00, 0x49, 0x2A, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x07, 0x7F, 0x00, 0x49, 0x2B,
  0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x08, 0x7F, 0x00, 0x49, 0x2C, 0x02, 0x00, 0x00, 0x01, 0x40,
  0x00, 0x09, 0x7F, 0x00, 0x49, 0x2D, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x0A, 0x7F, 0x00, 0x49,
  0x2E, 0x02, 0x00, 0x00, 0x01, 0x40, 0x00, 0x0B, 0x7F, 0x00, 0x49, 0x2F, 0x02, 0x00, 0x00, 0x01,
  0x40, 0x00, 0x0C, 0x7F, 0x00, 0x60, 0x28, 0x60, 0x29, 0x60, 0x2A, 0x60, 0x2B, 0x60, 0x2C, 0x60,
  0x2D, 0x60, 0x2E, 0x60, 0x2F, 0x49, 0x30, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x25, 0x7F, 0x00,
  0x49, 0x31, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x26, 0x7F, 0x00, 0x49, 0x32, 0x02, 0x19, 0x03,
  0x01, 0x50, 0x00, 0x27, 0x7F, 0x00, 0x49, 0x33, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x28, 0x7F,
  0x00, 0x49, 0x34, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x29, 0x7F, 0x00, 0x49, 0x35, 0x02, 0x19,
  0x03, 0x01, 0x50, 0x00, 0x2A, 0x7F, 0x00, 0x49, 0x36, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x2B,
  0x7F, 0x00, 0x49, 0x37, 0x02, 0x19, 0x03, 0x01, 0x50, 0x00, 0x2C, 0x7F, 0x00, 0x49, 0x38, 0x02,
  0x25, 0x03, 0x01, 0x50, 0x00, 0x2D, 0x7F, 0x00, 0x49, 0x39, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00,
  0x2E, 0x7F, 0x00, 0x49, 0x3A, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x2F, 0x7F, 0x00, 0x49, 0x3B,
  0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x30, 0x7F, 0x00, 0x49, 0x3C, 0x02, 0x25, 0x03, 0x01, 0x50,
  0x00, 0x31, 0x7F, 0x00, 0x49, 0x3D, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x32, 0x7F, 0x00, 0x49,
  0x3E, 0x02, 0x25, 0x03, 0x01, 0x50, 0x00, 0x33, 0x7F, 0x00, 0x49, 0x3F, 0x02, 0x25, 0x03, 0x01,
  0x50, 0x00, 0x34, 0x7F, 0x00, 0x60, 0x30, 0x60, 0x31, 0x60, 0x32, 0x60, 0x33, 0x60, 0x34, 0x60,
  0x35, 0x60, 0x36, 0x60, 0x37, 0x60, 0x38, 0x60, 0x39, 0x60, 0x3A, 0x60, 0x3B, 0x60, 0x3C, 0x60,
  0x3D, 0x60, 0x3E, 0x60, 0x3F, 0xF7
]);

async function testKnownGoodData() {
  console.log('Testing Known-Good Data from Web Editor');
  console.log('========================================\n');

  let device: LaunchControlXL3 | null = null;

  try {
    // Initialize MIDI backend
    const midiBackend = new EasyMidiBackend();
    await midiBackend.initialize();

    // Create device with custom modes enabled
    device = new LaunchControlXL3({
      midiBackend: midiBackend,
      enableLedControl: false,
      enableCustomModes: true
    });

    console.log('→ Connecting to device...');
    await device.connect();
    console.log('✓ Connected\n');

    // Test 1: Send known-good data to slot 0
    console.log('=== Test 1: Sending Known-Good Data to Slot 0 ===');
    console.log(`Data size: ${KNOWN_GOOD_DATA_SLOT_0.length} bytes`);
    console.log(`First 20 bytes: ${Array.from(KNOWN_GOOD_DATA_SLOT_0.slice(0, 20)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ')}`);
    console.log(`Mode name in data: "New Custom Mode"`);

    console.log('\n→ Sending SysEx to device...');

    // Send the raw SysEx data directly through our backend
    await midiBackend.sendSysEx(Array.from(KNOWN_GOOD_DATA_SLOT_0));

    console.log('✓ SysEx sent');

    // Wait for response
    await new Promise(resolve => setTimeout(resolve, 500));

    // Try to read back
    console.log('\n→ Reading back from slot 0...');
    try {
      const readMode = await device.readCustomMode(0);

      if (readMode) {
        console.log('✓ Read successful');
        console.log(`Mode name: "${readMode.name}"`);
        console.log(`Control count: ${readMode.controls?.length || 0}`);

        // Check if it matches what we sent
        if (readMode.name === 'New Custom Mode') {
          console.log('✅ SUCCESS: Known-good data was written and read correctly!');
        } else {
          console.log('⚠️ WARNING: Data was read but name doesn\'t match');
        }
      } else {
        console.log('✗ Read returned no data');
      }
    } catch (error) {
      console.log(`✗ Read failed: ${error}`);
    }

    // Test 2: Send known-good data to slot 3
    console.log('\n\n=== Test 2: Sending Known-Good Data to Slot 3 ===');
    console.log(`Data size: ${KNOWN_GOOD_DATA_SLOT_3.length} bytes`);
    console.log(`First 20 bytes: ${Array.from(KNOWN_GOOD_DATA_SLOT_3.slice(0, 20)).map(b => b.toString(16).padStart(2, '0').toUpperCase()).join(' ')}`);

    console.log('\n→ Sending SysEx to device...');

    // Send the raw SysEx data directly through our backend
    await midiBackend.sendSysEx(Array.from(KNOWN_GOOD_DATA_SLOT_3));

    console.log('✓ SysEx sent');

    // Wait for response
    await new Promise(resolve => setTimeout(resolve, 500));

    // Try to read back
    console.log('\n→ Reading back from slot 3...');
    try {
      const readMode = await device.readCustomMode(3);

      if (readMode) {
        console.log('✓ Read successful');
        console.log(`Mode name: "${readMode.name}"`);
        console.log(`Control count: ${readMode.controls?.length || 0}`);

        // Check if it matches what we sent
        if (readMode.name === 'New Custom Mode') {
          console.log('✅ SUCCESS: Known-good data was written and read correctly!');
        } else {
          console.log('⚠️ WARNING: Data was read but name doesn\'t match');
        }
      } else {
        console.log('✗ Read returned no data');
      }
    } catch (error) {
      console.log(`✗ Read failed: ${error}`);
    }

    // Compare with our generated data
    console.log('\n\n=== Comparison with Our Generated Data ===');

    // Generate data using our encoder
    const testMode = {
      name: 'New Custom Mode',
      controls: []
    };

    // Add encoders (matching the web editor data)
    for (let i = 0; i < 24; i++) {
      const controlId = 0x10 + i;
      testMode.controls.push({
        id: controlId,
        controlId: controlId,
        type: 'encoder',
        index: i,
        cc: 0x0D + i, // Starting at CC 13
        channel: 1,
        minValue: 0,
        maxValue: 127
      });
    }

    const ourData = await (device as any).customModeManager.encodeMode(testMode, 0);

    console.log(`Our data size: ${ourData.length} bytes`);
    console.log(`Known-good size: ${KNOWN_GOOD_DATA_SLOT_0.length} bytes`);

    if (ourData.length === KNOWN_GOOD_DATA_SLOT_0.length) {
      // Find differences
      let differences = 0;
      for (let i = 0; i < ourData.length; i++) {
        if (ourData[i] !== KNOWN_GOOD_DATA_SLOT_0[i]) {
          if (differences < 10) {
            console.log(`Difference at byte ${i}: Our=${ourData[i].toString(16).padStart(2, '0')} Known=${KNOWN_GOOD_DATA_SLOT_0[i].toString(16).padStart(2, '0')}`);
          }
          differences++;
        }
      }
      console.log(`Total differences: ${differences} bytes`);
    } else {
      console.log('⚠️ Data sizes don\'t match!');
    }

  } catch (error) {
    console.error('\n✗ Test failed:', error instanceof Error ? error.message : String(error));
  } finally {
    if (device) {
      console.log('\n→ Disconnecting...');
      await device.disconnect();
      console.log('✓ Disconnected');
    }
  }
}

// Run the test
testKnownGoodData().catch(console.error);