<!-- Generated by SpecStory -->

# 2025-10-07 05:53:04Z

<!-- Claude Code Session 85ca5f06-a103-4344-8c2b-a0366b3f0fbd (2025-10-07_05-53-04Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/network/routing/MidiRouter.h b/modules/juce/midi-server/network/routing/MidiRouter.h
index 27e1424..c34b3eb 100644
--- a/modules/juce/midi-server/network/routing/MidiRouter.h
+++ b/modules/juce/midi-server/network/routing/MidiRouter.h
@@ -55,20 +55,128 @@ public:
 };
 
 /**
- * Thread-safe MIDI message router
+ * MidiRouter - Core MIDI message forwarding engine
  *
- * Design:
+ * Routes MIDI messages between local ports and network nodes based on
+ * forwarding rules from RouteManager. Provides loop prevention, statistics
+ * tracking, and filter-based message forwarding.
+ *
+ * Thread-safe: All public methods can be called from any thread.
+ *
+ * DESIGN OVERVIEW:
+ * ────────────────
  * - Transparent routing: Client code doesn't care if device is local or remote
  * - Local devices: Direct JUCE MIDI port access (zero overhead)
  * - Remote devices: Network transport via UDP (Phase 4 integration)
  * - Message queuing: Buffered receive for pull-based consumption
- * - Thread-safe: All operations protected by mutex
+ * - Loop prevention: Hop count limiting and visited device tracking
+ *
+ * USAGE EXAMPLE 1: Basic Setup
+ * ────────────────────────────
+ *
+ *   DeviceRegistry registry;
+ *   RoutingTable routingTable;
+ *   RouteManager routeManager(registry);
+ *   MidiRouter router(registry, routingTable);
+ *
+ *   // Configure router
+ *   router.setRouteManager(&routeManager);
+ *   router.setNetworkTransport(&networkTransport);
+ *   router.setErrorCallback([](const juce::String& error) {
+ *       std::cerr << "Router error: " << error << std::endl;
+ *   });
+ *
+ *   // Register local MIDI output port
+ *   auto port = std::make_unique<VirtualMidiPort>("My Synth", false);
+ *   router.registerLocalPort(2, std::move(port));
+ *
+ * USAGE EXAMPLE 2: Forwarding Messages
+ * ─────────────────────────────────────
+ *
+ *   // Receive MIDI from network and forward according to rules
+ *   void onNetworkMidiReceived(const juce::Uuid& sourceNode,
+ *                              uint16_t sourceDevice,
+ *                              const std::vector<uint8_t>& midiData)
+ *   {
+ *       router.forwardMessage(sourceNode, sourceDevice, midiData);
+ *       // MidiRouter will:
+ *       //   1. Query RouteManager for destination rules
+ *       //   2. Apply channel and message type filters
+ *       //   3. Route to local ports or network nodes
+ *       //   4. Update statistics
+ *       //   5. Prevent loops (hop count & visited devices)
+ *   }
+ *
+ * USAGE EXAMPLE 3: Monitoring Statistics
+ * ───────────────────────────────────────
+ *
+ *   auto stats = router.getStatistics();
+ *   std::cout << "Local messages: " << stats.localMessagesSent << std::endl;
+ *   std::cout << "Network messages: " << stats.networkMessagesSent
+ *             << std::endl;
+ *   std::cout << "Loops detected: " << stats.loopsDetected << std::endl;
+ *
+ *   // Reset statistics (e.g., every minute)
+ *   router.resetStatistics();
+ *
+ * USAGE EXAMPLE 4: Local MIDI Input Handling
+ * ───────────────────────────────────────────
  *
- * Integration points:
+ *   // When local MIDI device sends a message
+ *   void handleMidiInput(const juce::MidiMessage& msg) {
+ *       std::vector<uint8_t> data(msg.getRawData(),
+ *                                 msg.getRawData() + msg.getRawDataSize());
+ *
+ *       // Send via router (triggers forwarding rules)
+ *       router.sendMessage(1, data);  // deviceId = 1
+ *   }
+ *
+ * USAGE EXAMPLE 5: Retrieving Messages for Local Devices
+ * ────────────────────────────────────────────────────────
+ *
+ *   // Poll for messages routed to a local device
+ *   auto messages = router.getMessages(2);  // deviceId = 2
+ *   for (const auto& midiData : messages) {
+ *       processMidiData(midiData);
+ *   }
+ *
+ *   // Check queue depth before retrieving
+ *   int pending = router.getMessageCount(2);
+ *   if (pending > 100) {
+ *       router.clearMessages(2);  // Prevent buffer overflow
+ *   }
+ *
+ * PERFORMANCE CHARACTERISTICS:
+ * ────────────────────────────
+ * - Destination lookup: O(log N) where N = number of rules (indexed)
+ * - Filter matching: O(1) per rule
+ * - Loop prevention: O(log H) where H = hop count (std::set lookup)
+ * - Thread contention: Minimal (short critical sections)
+ * - Memory: ~50 bytes overhead per forwarded message (transient)
+ *
+ * LOOP PREVENTION:
+ * ────────────────
+ * - Max hops: 8 (prevents infinite chains)
+ * - Visited devices: Tracked per message (prevents cycles)
+ * - Context: Currently single-node (Phase 4 will add network-wide context)
+ *
+ * ERROR HANDLING:
+ * ───────────────
+ * - Empty messages: Logged and ignored
+ * - Unknown devices: Logged and ignored
+ * - Null transport: Logged and ignored
+ * - All errors reported via errorCallback if set
+ *
+ * INTEGRATION POINTS:
+ * ───────────────────
  * - DeviceRegistry: Device enumeration and lookup
  * - RoutingTable: Device-to-node mapping
  * - NetworkTransport: Network message transmission (Phase 4)
  * - VirtualMidiPort: Remote device wrapping (Phase 5)
+ *
+ * @see RouteManager for rule management
+ * @see ForwardingRule for rule structure and filters
+ * @see DeviceRegistry for device management
  */
 class MidiRouter {
 public:
@@ -130,6 +238,36 @@ public:
     void setErrorCallback(ErrorCallback callback);
 
 private:
+    //==========================================================================
+    // Thread Safety & Mutex Ordering Convention
+    //
+    // This class uses three mutexes for thread safety. To prevent deadlocks,
+    // always acquire mutexes in this order:
+    //
+    //   1. portMutex (highest priority - protects local MIDI ports)
+    //   2. messageMutex (medium priority - protects message queues)
+    //   3. statsMutex (lowest priority - protects statistics)
+    //
+    // RULE: Never acquire a higher-numbered mutex while holding a
+    //       lower-numbered one.
+    //
+    // Example (CORRECT):
+    //   std::lock_guard<std::mutex> portLock(portMutex);      // Lock 1
+    //   doSomething();
+    //   std::lock_guard<std::mutex> statsLock(statsMutex);    // Lock 3
+    //                                                          // (OK: 1→3)
+    //
+    // Example (INCORRECT - DEADLOCK RISK):
+    //   std::lock_guard<std::mutex> statsLock(statsMutex);    // Lock 3
+    //   doSomething();
+    //   std::lock_guard<std::mutex> portLock(portMutex);      // Lock 1
+    //                                                          // (BAD: 3→1)
+    //
+    // If you need multiple locks simultaneously, use std::scoped_lock:
+    //   std::scoped_lock lock(portMutex, messageMutex, statsMutex);
+    //
+    //==========================================================================
+
     /**
      * Context for tracking message forwarding to prevent loops
      *
@@ -172,16 +310,18 @@ private:
     // Route manager (Phase 3.1)
     RouteManager* routeManager;
 
+    // Thread synchronization (acquire in this order to prevent deadlocks)
+    mutable std::mutex portMutex;        // 1. Protects localPorts map
+    mutable std::mutex messageMutex;     // 2. Protects messageQueues map
+    mutable std::mutex statsMutex;       // 3. Protects stats structure
+
     // Local MIDI ports
-    mutable std::mutex portMutex;
     std::map<uint16_t, std::unique_ptr<MidiPortInterface>> localPorts;
 
     // Received message queues (per device)
-    mutable std::mutex messageMutex;
     std::map<uint16_t, std::queue<std::vector<uint8_t>>> messageQueues;
 
     // Statistics
-    mutable std::mutex statsMutex;
     Statistics stats;
 
     // Error handling
diff --git a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
index 23d5a26..aba5875 100644
--- a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
+++ b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
@@ -252,6 +252,54 @@ protected:
         midiRouter->forwardMessage(srcNode, srcDev, midiData);
     }
 
+    // Helper to create additional remote nodes for loop prevention testing
+    void setupAdditionalNodes() {
+        // First, add missing input devices for existing nodes
+        deviceRegistry->addRemoteDevice(remoteNode2, 21, "Remote Input 2", "input", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode3, 31, "Remote Input 3", "input", "RemoteVendor");
+        routingTable->addRoute(remoteNode2, 21, "Remote Input 2", "input");
+        routingTable->addRoute(remoteNode3, 31, "Remote Input 3", "input");
+
+        // Create additional nodes for complex topologies
+        remoteNode4 = juce::Uuid();
+        remoteNode5 = juce::Uuid();
+        remoteNode6 = juce::Uuid();
+        remoteNode7 = juce::Uuid();
+        remoteNode8 = juce::Uuid();
+        remoteNode9 = juce::Uuid();
+        remoteNode10 = juce::Uuid();
+
+        // Add devices for these nodes
+        deviceRegistry->addRemoteDevice(remoteNode4, 40, "Remote Output 4", "output", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode4, 41, "Remote Input 4", "input", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode5, 50, "Remote Output 5", "output", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode5, 51, "Remote Input 5", "input", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode6, 60, "Remote Output 6", "output", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode6, 61, "Remote Input 6", "input", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode7, 70, "Remote Output 7", "output", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode7, 71, "Remote Input 7", "input", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode8, 80, "Remote Output 8", "output", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode8, 81, "Remote Input 8", "input", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode9, 90, "Remote Output 9", "output", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode9, 91, "Remote Input 9", "input", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode10, 100, "Remote Output 10", "output", "RemoteVendor");
+
+        // Add routes
+        routingTable->addRoute(remoteNode4, 40, "Remote Output 4", "output");
+        routingTable->addRoute(remoteNode4, 41, "Remote Input 4", "input");
+        routingTable->addRoute(remoteNode5, 50, "Remote Output 5", "output");
+        routingTable->addRoute(remoteNode5, 51, "Remote Input 5", "input");
+        routingTable->addRoute(remoteNode6, 60, "Remote Output 6", "output");
+        routingTable->addRoute(remoteNode6, 61, "Remote Input 6", "input");
+        routingTable->addRoute(remoteNode7, 70, "Remote Output 7", "output");
+        routingTable->addRoute(remoteNode7, 71, "Remote Input 7", "input");
+        routingTable->addRoute(remoteNode8, 80, "Remote Output 8", "output");
+        routingTable->addRoute(remoteNode8, 81, "Remote Input 8", "input");
+        routingTable->addRoute(remoteNode9, 90, "Remote Output 9", "output");
+        routingTable->addRoute(remoteNode9, 91, "Remote Input 9", "input");
+        routingTable->addRoute(remoteNode10, 100, "Remote Output 10", "output");
+    }
+
     // Test infrastructure
     std::unique_ptr<DeviceRegistry> deviceRegistry;
     std::unique_ptr<RoutingTable> routingTable;
@@ -268,6 +316,13 @@ protected:
     juce::Uuid remoteNode1;
     juce::Uuid remoteNode2;
     juce::Uuid remoteNode3;
+    juce::Uuid remoteNode4;
+    juce::Uuid remoteNode5;
+    juce::Uuid remoteNode6;
+    juce::Uuid remoteNode7;
+    juce::Uuid remoteNode8;
+    juce::Uuid remoteNode9;
+    juce::Uuid remoteNode10;
 };
 
 //==============================================================================
@@ -861,3 +916,349 @@ TEST_F(MidiMessageForwardingTest, DynamicRuleUpdatesDuringForwarding) {
     forwardMessage(localNode, 1, createNoteOn(1, 67, 100));
     EXPECT_EQ(1, mockTransport->getSentMessageCount());
 }
+
+//==============================================================================
+// Loop Prevention Tests
+//==============================================================================
+
+/**
+ * Test: Loop prevention via multi-destination forwarding
+ *
+ * This test verifies that when a source device forwards to multiple destinations,
+ * the loop prevention mechanism correctly tracks each forwarding path independently.
+ * While the current implementation doesn't pass context across actual network hops
+ * (that's Phase 4), this test validates the internal loop prevention logic.
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionMultipleDestinationsIndependent) {
+    setupAdditionalNodes();
+
+    // Create a fan-out: one source to many destinations
+    // This tests that each destination is treated independently
+    addRule(localNode, 1, remoteNode1, 10);
+    addRule(localNode, 1, remoteNode2, 20);
+    addRule(localNode, 1, remoteNode3, 30);
+    addRule(localNode, 1, remoteNode4, 40);
+
+    // Forward a single message
+    auto noteOn = createNoteOn(1, 60, 100);
+    forwardMessage(localNode, 1, noteOn);
+
+    // All destinations should receive the message
+    EXPECT_EQ(4, mockTransport->getSentMessageCount());
+
+    // No loops should be detected (fan-out is not a loop)
+    auto stats = midiRouter->getStatistics();
+    EXPECT_EQ(0u, stats.loopsDetected);
+}
+
+/**
+ * Test: Loop prevention statistics tracking
+ *
+ * Verifies that the loopsDetected statistic exists and is correctly initialized.
+ * This is a foundational test for the loop prevention feature.
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionStatisticsInitialized) {
+    // Get initial statistics
+    auto stats = midiRouter->getStatistics();
+
+    // Verify loopsDetected field exists and is zero
+    EXPECT_EQ(0u, stats.loopsDetected);
+
+    // Reset statistics
+    midiRouter->resetStatistics();
+
+    // Verify it's still zero after reset
+    stats = midiRouter->getStatistics();
+    EXPECT_EQ(0u, stats.loopsDetected);
+}
+
+/**
+ * Test: Diamond topology (multiple paths to same destination)
+ *
+ * Setup: Source → Path A → Destination
+ *        Source → Path B → Destination
+ *
+ * This tests that multiple independent paths to the same destination
+ * are NOT considered a loop. The destination should receive the message
+ * multiple times (once per path).
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionDiamondTopologyNotALoop) {
+    // Create diamond topology:
+    // Local Input 1 → Remote Output 1 (Path A)
+    // Local Input 1 → Remote Output 2 (Path B)
+    // Both outputs are on different destination nodes
+    addRule(localNode, 1, remoteNode1, 10);  // Path A
+    addRule(localNode, 1, remoteNode2, 20);  // Path B - to different node output
+
+    // Forward message
+    auto noteOn = createNoteOn(1, 60, 100);
+    forwardMessage(localNode, 1, noteOn);
+
+    // Both paths should complete successfully
+    EXPECT_EQ(2, mockTransport->getSentMessageCount());
+
+    // No loops should be detected (multiple paths are valid)
+    auto stats = midiRouter->getStatistics();
+    EXPECT_EQ(0u, stats.loopsDetected);
+
+    // Verify both destinations received the message
+    auto sent = mockTransport->getSentMessages();
+    ASSERT_EQ(2u, sent.size());
+    EXPECT_EQ(remoteNode1, sent[0].destNode);
+    EXPECT_EQ(10, sent[0].deviceId);
+    EXPECT_EQ(remoteNode2, sent[1].destNode);
+    EXPECT_EQ(20, sent[1].deviceId);
+}
+
+/**
+ * Test: Complex multi-hop chain validation
+ *
+ * Creates a 6-hop chain (under the MAX_HOPS=8 limit) and verifies
+ * that all hops complete successfully with no loop detection.
+ *
+ * Chain: Node1 → Node2 → Node3 → Node4 → Node5 → Node6
+ *
+ * Note: Due to current implementation (context not passed across network),
+ * we simulate this by manually forwarding at each hop.
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionComplexMultiHopChain) {
+    setupAdditionalNodes();
+
+    // Create 6-hop chain (under MAX_HOPS limit)
+    // Each node forwards to the next node's output device
+    addRule(localNode, 1, remoteNode1, 10);      // Hop 1: input 1 → output 10
+    addRule(remoteNode1, 11, remoteNode2, 20);   // Hop 2: input 11 → output 20
+    addRule(remoteNode2, 21, remoteNode3, 30);   // Hop 3: input 21 → output 30
+    addRule(remoteNode3, 31, remoteNode4, 40);   // Hop 4: input 31 → output 40
+    addRule(remoteNode4, 41, remoteNode5, 50);   // Hop 5: input 41 → output 50
+    addRule(remoteNode5, 51, remoteNode6, 60);   // Hop 6: input 51 → output 60
+
+    auto noteOn = createNoteOn(1, 60, 100);
+
+    // Hop 1: Local → Remote1
+    forwardMessage(localNode, 1, noteOn);
+    EXPECT_EQ(1, mockTransport->getSentMessageCount());
+    mockTransport->clearSentMessages();
+
+    // Hop 2: Remote1 → Remote2
+    forwardMessage(remoteNode1, 11, noteOn);
+    EXPECT_EQ(1, mockTransport->getSentMessageCount());
+    mockTransport->clearSentMessages();
+
+    // Hop 3: Remote2 → Remote3
+    forwardMessage(remoteNode2, 21, noteOn);
+    EXPECT_EQ(1, mockTransport->getSentMessageCount());
+    mockTransport->clearSentMessages();
+
+    // Hop 4: Remote3 → Remote4
+    forwardMessage(remoteNode3, 31, noteOn);
+    EXPECT_EQ(1, mockTransport->getSentMessageCount());
+    mockTransport->clearSentMessages();
+
+    // Hop 5: Remote4 → Remote5
+    forwardMessage(remoteNode4, 41, noteOn);
+    EXPECT_EQ(1, mockTransport->getSentMessageCount());
+    mockTransport->clearSentMessages();
+
+    // Hop 6: Remote5 → Remote6
+    forwardMessage(remoteNode5, 51, noteOn);
+    EXPECT_EQ(1, mockTransport->getSentMessageCount());
+
+    // All hops should complete successfully (under MAX_HOPS=8)
+    // No loops detected since each hop is a fresh forwardMessage() call
+    auto stats = midiRouter->getStatistics();
+    EXPECT_EQ(0u, stats.loopsDetected);
+}
+
+/**
+ * Test: Self-loop detection (same source and destination device)
+ *
+ * Attempts to create a rule where a device forwards to itself.
+ * This should be caught during rule creation or result in immediate
+ * loop detection during forwarding.
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionSelfLoopDetection) {
+    // Try to create a self-referential rule
+    // Device 1 → Device 1 on the same node
+    ForwardingRule selfLoopRule(localNode, 1, localNode, 1);
+
+    // This might be caught during validation, or might be allowed
+    // but detected during forwarding. Try to add it:
+    std::string ruleId;
+    bool ruleAddedSuccessfully = false;
+
+    try {
+        ruleId = routeManager->addRule(selfLoopRule);
+        ruleAddedSuccessfully = true;
+    } catch (const std::exception& e) {
+        // Rule validation might reject self-loops
+        // This is acceptable behavior
+        ruleAddedSuccessfully = false;
+    }
+
+    if (ruleAddedSuccessfully) {
+        // If rule was added, forwarding should detect the loop
+        auto noteOn = createNoteOn(1, 60, 100);
+
+        // Initial statistics
+        auto statsBefore = midiRouter->getStatistics();
+        uint64_t loopsBefore = statsBefore.loopsDetected;
+
+        // Try to forward - should detect loop
+        forwardMessage(localNode, 1, noteOn);
+
+        // Note: Current implementation creates a fresh context per forwardMessage,
+        // so this won't detect a loop unless the implementation changes.
+        // This test documents the current behavior.
+        auto statsAfter = midiRouter->getStatistics();
+
+        // The test passes regardless of whether a loop is detected,
+        // as it documents current behavior. In Phase 4, this should detect a loop.
+    }
+
+    // Test passes if we get here without crashing
+    SUCCEED();
+}
+
+/**
+ * Test: Loop prevention with disabled rules
+ *
+ * Verifies that disabled rules in a potential loop are not considered,
+ * preventing false loop detection.
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionDisabledRulesIgnored) {
+    // Create potential loop: Device 1 → Device 2, Device 4 → Device 2
+    // But disable the second rule to break the loop
+    addRule(localNode, 1, localNode, 2, 100, true);   // Enabled: input 1 → output 2
+    addRule(localNode, 4, localNode, 2, 100, false);  // Disabled: input 4 → output 2
+
+    // Register port 2 for local forwarding
+    // (already done in SetUp)
+
+    // Forward message from device 1
+    auto noteOn = createNoteOn(1, 60, 100);
+    forwardMessage(localNode, 1, noteOn);
+
+    // Should forward to device 2
+    EXPECT_EQ(1, mockPort2->getSentMessageCount());
+
+    // No loop should be detected (second rule is disabled)
+    auto stats = midiRouter->getStatistics();
+    EXPECT_EQ(0u, stats.loopsDetected);
+
+    // If we forward from device 4, nothing should happen (rule is disabled)
+    mockPort2->clearSentMessages();
+    forwardMessage(localNode, 4, noteOn);
+
+    EXPECT_EQ(0, mockPort2->getSentMessageCount());  // No forwarding
+    stats = midiRouter->getStatistics();
+    EXPECT_EQ(0u, stats.loopsDetected);  // Still no loops
+}
+
+/**
+ * Test: Maximum hop count theoretical behavior
+ *
+ * Documents the expected behavior when MAX_HOPS would be exceeded.
+ * Due to current implementation (fresh context per call), we can't
+ * actually test this without Phase 4 context propagation, but we
+ * can verify the constant is defined correctly.
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionMaxHopsConstantDefined) {
+    // This test verifies the ForwardingContext::MAX_HOPS constant
+    // We can't directly access it, but we can test that very long chains
+    // would eventually be limited
+
+    setupAdditionalNodes();
+
+    // Create a 10-hop chain (exceeds MAX_HOPS=8)
+    // In Phase 4, hops 9 and 10 should be blocked
+    addRule(localNode, 1, remoteNode1, 10);      // Hop 1
+    addRule(remoteNode1, 11, remoteNode2, 20);   // Hop 2
+    addRule(remoteNode2, 21, remoteNode3, 30);   // Hop 3
+    addRule(remoteNode3, 31, remoteNode4, 40);   // Hop 4
+    addRule(remoteNode4, 41, remoteNode5, 50);   // Hop 5
+    addRule(remoteNode5, 51, remoteNode6, 60);   // Hop 6
+    addRule(remoteNode6, 61, remoteNode7, 70);   // Hop 7
+    addRule(remoteNode7, 71, remoteNode8, 80);   // Hop 8
+    addRule(remoteNode8, 81, remoteNode9, 90);   // Hop 9 - would exceed MAX_HOPS
+    addRule(remoteNode9, 91, remoteNode10, 100); // Hop 10 - would exceed MAX_HOPS
+
+    auto noteOn = createNoteOn(1, 60, 100);
+
+    // Execute all 10 hops manually
+    // Current implementation: each hop is independent (fresh context)
+    // Phase 4 implementation: hops 9-10 would be blocked
+
+    for (int hop = 1; hop <= 10; ++hop) {
+        juce::Uuid sourceNode;
+        uint16_t sourceDevice;
+
+        switch (hop) {
+            case 1: sourceNode = localNode; sourceDevice = 1; break;
+            case 2: sourceNode = remoteNode1; sourceDevice = 11; break;
+            case 3: sourceNode = remoteNode2; sourceDevice = 21; break;
+            case 4: sourceNode = remoteNode3; sourceDevice = 31; break;
+            case 5: sourceNode = remoteNode4; sourceDevice = 41; break;
+            case 6: sourceNode = remoteNode5; sourceDevice = 51; break;
+            case 7: sourceNode = remoteNode6; sourceDevice = 61; break;
+            case 8: sourceNode = remoteNode7; sourceDevice = 71; break;
+            case 9: sourceNode = remoteNode8; sourceDevice = 81; break;
+            case 10: sourceNode = remoteNode9; sourceDevice = 91; break;
+        }
+
+        mockTransport->clearSentMessages();
+        forwardMessage(sourceNode, sourceDevice, noteOn);
+
+        // Current implementation: all hops succeed
+        // Phase 4 implementation: hops 9+ would fail with loopsDetected++
+        if (hop <= 8) {
+            // First 8 hops should always work
+            EXPECT_EQ(1, mockTransport->getSentMessageCount())
+                << "Hop " << hop << " should succeed (under MAX_HOPS)";
+        }
+        // For hops 9-10, current implementation forwards (no context propagation)
+        // This documents current behavior
+    }
+
+    // Current implementation: no loops detected (each call is independent)
+    auto stats = midiRouter->getStatistics();
+    // Phase 4 would have stats.loopsDetected >= 2 (hops 9 and 10)
+    // Current implementation: loopsDetected == 0
+
+    // Test passes - we're documenting behavior, not enforcing Phase 4 semantics yet
+    SUCCEED();
+}
+
+/**
+ * Test: Bidirectional communication without loops
+ *
+ * Verifies that bidirectional communication between two nodes
+ * doesn't trigger false loop detection when messages flow in
+ * opposite directions.
+ *
+ * Setup: Node A → Node B (one message)
+ *        Node B → Node A (different message)
+ */
+TEST_F(MidiMessageForwardingTest, LoopPreventionBidirectionalCommunication) {
+    // Create bidirectional rules
+    addRule(localNode, 1, remoteNode1, 10);    // Local → Remote1
+    addRule(remoteNode1, 11, localNode, 2);    // Remote1 → Local
+
+    // Send message from Local to Remote1
+    auto noteOn1 = createNoteOn(1, 60, 100);
+    forwardMessage(localNode, 1, noteOn1);
+
+    EXPECT_EQ(1, mockTransport->getSentMessageCount());
+    mockTransport->clearSentMessages();
+
+    // Send DIFFERENT message from Remote1 to Local
+    auto noteOn2 = createNoteOn(2, 64, 100);
+    forwardMessage(remoteNode1, 11, noteOn2);
+
+    // Should forward to local device 2
+    EXPECT_EQ(1, mockPort2->getSentMessageCount());
+
+    // No loops should be detected (different messages, different directions)
+    auto stats = midiRouter->getStatistics();
+    EXPECT_EQ(0u, stats.loopsDetected);
+}


---

_**Agent (claude-sonnet-4-5-20250929)**_

refactor(midi-server): add comprehensive MidiRouter documentation and loop prevention tests

