<!-- Generated by SpecStory -->

# 2025-10-07 05:25:18Z

<!-- Claude Code Session acba19f7-e799-4ce2-b2d5-9c832b490422 (2025-10-07_05-25-18Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/docs/1.0/routing/phase4_architecture_diagram.md b/modules/juce/midi-server/docs/1.0/routing/phase4_architecture_diagram.md
new file mode 100644
index 0000000..76e1dd3
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/routing/phase4_architecture_diagram.md
@@ -0,0 +1,479 @@
+# Phase 4 Architecture Diagrams
+
+## 1. Context Flow Through Network
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                        Multi-Hop Message Flow                           │
+└─────────────────────────────────────────────────────────────────────────┘
+
+   Node A                    Node B                    Node C
+┌──────────┐              ┌──────────┐              ┌──────────┐
+│          │              │          │              │          │
+│ Device 1 │──MIDI──►     │          │              │          │
+│  (Input) │              │          │              │          │
+│          │              │          │              │          │
+└────┬─────┘              │          │              │          │
+     │                    │          │              │          │
+     │ Forward            │          │              │          │
+     ▼                    │          │              │          │
+┌──────────┐              │          │              │          │
+│ Router   │              │          │              │          │
+│          │              │          │              │          │
+│ Context: │              │          │              │          │
+│  visited={}            │          │              │          │
+│  hops=0  │              │          │              │          │
+│          │              │          │              │          │
+│ Update:  │              │          │              │          │
+│  visited={A:1}         │          │              │          │
+│  hops=1  │              │          │              │          │
+└────┬─────┘              │          │              │          │
+     │                    │          │              │          │
+     │ Embed Context      │          │              │          │
+     ▼                    │          │              │          │
+┌──────────┐              │          │              │          │
+│ Packet   │              │          │              │          │
+│ Builder  │              │          │              │          │
+│          │              │          │              │          │
+│ [Header] │              │          │              │          │
+│ [MIDI]   │              │          │              │          │
+│ [Context]│              │          │              │          │
+│  hops=1  │              │          │              │          │
+│  devices │              │          │              │          │
+│   A:1    │              │          │              │          │
+└────┬─────┘              │          │              │          │
+     │                    │          │              │          │
+     │ UDP Transmit       │          │              │          │
+     └────────────────────┼─────────►│              │          │
+                          │          │              │          │
+                          │ Receive  │              │          │
+                          ▼          │              │          │
+                     ┌──────────┐    │              │          │
+                     │ Packet   │    │              │          │
+                     │ Parser   │    │              │          │
+                     │          │    │              │          │
+                     │ Extract: │    │              │          │
+                     │  context │    │              │          │
+                     └────┬─────┘    │              │          │
+                          │          │              │          │
+                          ▼          │              │          │
+                     ┌──────────┐    │              │          │
+                     │ Router   │    │              │          │
+                     │          │    │              │          │
+                     │ Context: │    │              │          │
+                     │  visited={A:1}│              │          │
+                     │  hops=1  │    │              │          │
+                     │          │    │              │          │
+                     │ Update:  │    │              │          │
+                     │  visited={A:1, B:2}          │          │
+                     │  hops=2  │    │              │          │
+                     └────┬─────┘    │              │          │
+                          │          │              │          │
+                          │ Embed    │              │          │
+                          ▼          │              │          │
+                     ┌──────────┐    │              │          │
+                     │ Packet   │    │              │          │
+                     │          │    │              │          │
+                     │ [Header] │    │              │          │
+                     │ [MIDI]   │    │              │          │
+                     │ [Context]│    │              │          │
+                     │  hops=2  │    │              │          │
+                     │  devices │    │              │          │
+                     │   A:1    │    │              │          │
+                     │   B:2    │    │              │          │
+                     └────┬─────┘    │              │          │
+                          │          │              │          │
+                          │ UDP      │              │          │
+                          └──────────┼──────────────┼─────────►│
+                                     │              │          │
+                                     │              │ Receive  │
+                                     │              ▼          │
+                                     │         ┌──────────┐    │
+                                     │         │ Router   │    │
+                                     │         │          │    │
+                                     │         │ Context: │    │
+                                     │         │  visited={A:1, B:2}
+                                     │         │  hops=2  │    │
+                                     │         │          │    │
+                                     │         │ Check:   │    │
+                                     │         │  C:3 not │    │
+                                     │         │  visited │    │
+                                     │         │  ✓ OK    │    │
+                                     │         └────┬─────┘    │
+                                     │              │          │
+                                     │              ▼          │
+                                     │         ┌──────────┐    │
+                                     │         │ Device 3 │    │
+                                     │         │ (Output) │    │
+                                     │         │  MIDI►   │    │
+                                     │         └──────────┘    │
+                                     │                         │
+                                     └─────────────────────────┘
+```
+
+---
+
+## 2. Loop Detection Example
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                    Circular Route: A → B → A                           │
+└─────────────────────────────────────────────────────────────────────────┘
+
+Step 1: Message originates at Node A
+┌──────────┐
+│ Node A   │
+│          │
+│ Context: │
+│  visited={A:1}
+│  hops=1  │
+└────┬─────┘
+     │ Forward to B
+     ▼
+
+Step 2: Node B receives and forwards back to A
+┌──────────┐
+│ Node B   │
+│          │
+│ Context: │
+│  visited={A:1, B:2}
+│  hops=2  │
+└────┬─────┘
+     │ Forward to A
+     ▼
+
+Step 3: Node A receives - LOOP DETECTED!
+┌──────────┐
+│ Node A   │
+│          │
+│ Context: │
+│  visited={A:1, B:2}
+│  hops=2  │
+│          │
+│ Check:   │
+│  A:1 in visitedDevices?
+│  YES! Loop detected
+│          │
+│ Action:  │
+│  Drop message
+│  stats.loopsDetected++
+└──────────┘
+```
+
+---
+
+## 3. Packet Format Layout
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                      MidiPacket with Context                            │
+└─────────────────────────────────────────────────────────────────────────┘
+
+Offset | Size | Field                    | Example Value
+-------|------|--------------------------|------------------
+  0    |  2   | Magic                    | 0x4D49 ("MI")
+  2    |  1   | Version                  | 0x01
+  3    |  1   | Flags                    | 0x08 (HasContext)
+  4    |  4   | Source Node Hash         | 0x1A2B3C4D
+  8    |  4   | Dest Node Hash           | 0x5E6F7A8B
+ 12    |  2   | Sequence                 | 0x0042
+ 14    |  4   | Timestamp                | 0x00123456
+ 18    |  2   | Device ID                | 0x0005
+ ──────────────────────────────────────────────────────────────────
+ 20    |  N   | MIDI Data                | [0x90, 0x3C, 0x64]
+ ──────────────────────────────────────────────────────────────────
+20+N   |  1   | Extension Type           | 0x01 (Context)
+21+N   |  1   | Extension Length         | 0x16 (22 bytes)
+22+N   |  1   | Hop Count                | 0x02
+23+N   |  1   | Device Count             | 0x02
+24+N   |  6   | Visited Device 1         |
+       |  4   |   Node Hash              | 0x1A2B3C4D
+       |  2   |   Device ID              | 0x0001
+30+N   |  6   | Visited Device 2         |
+       |  4   |   Node Hash              | 0x5E6F7A8B
+       |  2   |   Device ID              | 0x0002
+ ──────────────────────────────────────────────────────────────────
+
+Total Size: 20 + N + (4 + M*6) bytes
+Example: 20 + 3 + (4 + 2*6) = 39 bytes
+```
+
+---
+
+## 4. Component Integration
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                    Phase 4 Component Architecture                       │
+└─────────────────────────────────────────────────────────────────────────┘
+
+┌─────────────────────────────────────────────────────────────────────────┐
+│                           MeshManager                                   │
+│  ┌──────────────────┐  ┌──────────────────┐  ┌──────────────────┐     │
+│  │ Connection Pool  │  │  UuidRegistry    │  │  Node Discovery  │     │
+│  │                  │  │                  │  │                  │     │
+│  │ Node A: ────────►│  │ register(uuid)   │  │  mDNS Scanner    │     │
+│  │ Node B: ────────►│  │ lookup(hash)     │  │                  │     │
+│  │ Node C: ────────►│  │ unregister(uuid) │  │                  │     │
+│  └──────────────────┘  └─────────┬────────┘  └──────────────────┘     │
+│                                  │                                     │
+└──────────────────────────────────┼─────────────────────────────────────┘
+                                   │
+                                   │ inject
+                                   ▼
+┌─────────────────────────────────────────────────────────────────────────┐
+│                            MidiRouter                                   │
+│  ┌──────────────────────────────────────────────────────────────┐     │
+│  │                     forwardMessage()                         │     │
+│  │                                                              │     │
+│  │  1. Extract context from incoming packet (if present)       │     │
+│  │     ├─► packet.getForwardingContext(*uuidRegistry)          │     │
+│  │     └─► deserialize visited devices                         │     │
+│  │                                                              │     │
+│  │  2. Check loop prevention                                   │     │
+│  │     ├─► shouldForward(sourceDevice)?                        │     │
+│  │     └─► if loop: drop, stats.loopsDetected++               │     │
+│  │                                                              │     │
+│  │  3. Update context                                          │     │
+│  │     ├─► recordVisit(sourceDevice)                           │     │
+│  │     └─► hopCount++                                          │     │
+│  │                                                              │     │
+│  │  4. Embed context in outgoing packet                        │     │
+│  │     ├─► packet.setForwardingContext(context)                │     │
+│  │     └─► serialize visited devices                           │     │
+│  └──────────────────────────────────────────────────────────────┘     │
+│                                                                         │
+└────────────────────────────┬────────────────────────────────────────────┘
+                             │
+                             │ sendPacket()
+                             ▼
+┌─────────────────────────────────────────────────────────────────────────┐
+│                      NetworkConnection                                  │
+│  ┌──────────────────────────────────────────────────────────────┐     │
+│  │                    ConnectionWorker                          │     │
+│  │                                                              │     │
+│  │  SEDA Command: SendPacketCommand                            │     │
+│  │  ├─► classify message (realtime/non-realtime)               │     │
+│  │  │                                                           │     │
+│  │  ├─► if realtime:                                           │     │
+│  │  │   └─► UdpMidiTransport.sendPacket()                      │     │
+│  │  │                                                           │     │
+│  │  └─► if non-realtime:                                       │     │
+│  │      └─► TcpMidiTransport.sendPacket()                      │     │
+│  └──────────────────────────────────────────────────────────────┘     │
+│                                                                         │
+└────────────────────────────┬────────────────────────────────────────────┘
+                             │
+                             │ UDP/TCP
+                             ▼
+                    ┌────────────────┐
+                    │   Network      │
+                    └────────────────┘
+```
+
+---
+
+## 5. Backward Compatibility Matrix
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│              Phase 3 ↔ Phase 4 Compatibility Matrix                    │
+└─────────────────────────────────────────────────────────────────────────┘
+
+Sender    Receiver   Context      Result
+────────  ─────────  ───────────  ──────────────────────────────────────
+Phase 3 → Phase 3    None         ✓ Works (original behavior)
+Phase 3 → Phase 4    None         ✓ Works (P4 creates fresh context)
+Phase 4 → Phase 3    Embedded     ✓ Works (P3 ignores context)
+Phase 4 → Phase 4    Embedded     ✓ Works (context preserved)
+
+┌─────────────────────────────────────────────────────────────────────────┐
+│                      Mixed Mesh Example                                 │
+└─────────────────────────────────────────────────────────────────────────┘
+
+   P4 Node A        P3 Node B        P4 Node C
+   ─────────        ─────────        ─────────
+   Context:         Context:         Context:
+   {A:1}            RESET            {C:3}
+   hops=1    ────►  (ignored)  ────► (fresh)
+
+   Result: Loop prevention only works within Phase 4 nodes
+   Migration: Upgrade all nodes to Phase 4 for full coverage
+```
+
+---
+
+## 6. Performance Visualization
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                     Per-Hop Latency Breakdown                           │
+└─────────────────────────────────────────────────────────────────────────┘
+
+Operation                         Time
+─────────────────────────────────────────────────────────────────
+Extract context from packet       ████ 200ns
+Update visited devices            ██ 100ns
+Increment hop count               ▌ 10ns
+Serialize context                 ██████ 300ns
+Embed in outgoing packet          ███ 150ns
+─────────────────────────────────────────────────────────────────
+Total per hop                     ███████████████ 760ns
+
+Multi-hop:
+1 hop:  ███████████████ 760ns
+2 hops: ██████████████████████████████ 1.5μs
+3 hops: █████████████████████████████████████████████ 2.3μs
+8 hops: ████████████████████████████████████████████████████████████ 6.1μs
+
+Target: <10μs ✓ Met
+
+┌─────────────────────────────────────────────────────────────────────────┐
+│                       Packet Size Growth                                │
+└─────────────────────────────────────────────────────────────────────────┘
+
+Hops | Packet Size (3-byte MIDI)
+─────┼────────────────────────────────────────────────────
+  0  | ███████████████████████ 23 bytes
+  1  | █████████████████████████████████ 33 bytes
+  2  | ███████████████████████████████████████ 39 bytes
+  3  | █████████████████████████████████████████████ 45 bytes
+  8  | ███████████████████████████████████████████████████████████████████████ 75 bytes
+
+Target: <100 bytes ✓ Met
+```
+
+---
+
+## 7. State Transition Diagram
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                Context State Through Forwarding Chain                   │
+└─────────────────────────────────────────────────────────────────────────┘
+
+┌─────────────┐
+│ Initial     │
+│ Context:    │
+│  visited={} │
+│  hops=0     │
+└──────┬──────┘
+       │
+       │ Record visit: A:1
+       │ Increment hops
+       ▼
+┌─────────────┐
+│ After A     │
+│ Context:    │
+│  visited=   │
+│   {A:1}     │
+│  hops=1     │
+└──────┬──────┘
+       │
+       │ Serialize → Packet
+       │ Send to B
+       │ Receive at B
+       │ Deserialize → Context
+       │ Record visit: B:2
+       │ Increment hops
+       ▼
+┌─────────────┐
+│ After B     │
+│ Context:    │
+│  visited=   │
+│   {A:1,     │
+│    B:2}     │
+│  hops=2     │
+└──────┬──────┘
+       │
+       │ Serialize → Packet
+       │ Send to C
+       │ Receive at C
+       │ Deserialize → Context
+       │ Record visit: C:3
+       │ Increment hops
+       ▼
+┌─────────────┐
+│ After C     │
+│ Context:    │
+│  visited=   │
+│   {A:1,     │
+│    B:2,     │
+│    C:3}     │
+│  hops=3     │
+└──────┬──────┘
+       │
+       │ shouldForward(D:4)?
+       │ ✓ D:4 not in visited
+       │ ✓ hops < MAX_HOPS (8)
+       │
+       │ shouldForward(A:1)?
+       │ ✗ A:1 in visited
+       │ → Loop detected!
+       ▼
+┌─────────────┐
+│ Drop        │
+│ Message     │
+│             │
+│ stats.      │
+│  loops      │
+│  Detected++ │
+└─────────────┘
+```
+
+---
+
+## 8. Implementation Dependencies
+
+```
+┌─────────────────────────────────────────────────────────────────────────┐
+│                     Task Dependency Graph                               │
+└─────────────────────────────────────────────────────────────────────────┘
+
+                    ┌────────────┐
+                    │   Task 4.1 │
+                    │ MidiPacket │
+                    │  Context   │
+                    └──────┬─────┘
+                           │
+                           │
+          ┌────────────────┴────────────────┐
+          │                                 │
+          ▼                                 ▼
+    ┌────────────┐                    ┌────────────┐
+    │   Task 4.2 │                    │   Task 4.4 │
+    │ UuidRegistry│                    │  Network   │
+    │            │                    │ Transport  │
+    └──────┬─────┘                    └──────┬─────┘
+          │                                 │
+          │                                 │
+          └────────────┬────────────────────┘
+                       │
+                       ▼
+                 ┌────────────┐
+                 │   Task 4.3 │
+                 │ MidiRouter │
+                 │  Context   │
+                 │ Handling   │
+                 └──────┬─────┘
+                        │
+                        │
+         ┌──────────────┴──────────────┐
+         │                             │
+         ▼                             ▼
+   ┌────────────┐              ┌────────────┐
+   │   Task 4.5 │              │   Task 4.6 │
+   │MeshManager │              │    E2E     │
+   │Integration │              │  Testing   │
+   └────────────┘              └────────────┘
+
+Critical Path: 4.1 → 4.3 → 4.6 (10 days)
+Parallel Work: 4.2, 4.4, 4.5 can start earlier
+Total Duration: 16 days (3 weeks)
+```
+
+---
+
+**For detailed implementation specifications, see:**
+- [Full Phase 4 Design Document](./phase4_multihop_context.md)
+- [Executive Summary](./phase4_executive_summary.md)
diff --git a/modules/juce/midi-server/docs/1.0/routing/phase4_executive_summary.md b/modules/juce/midi-server/docs/1.0/routing/phase4_executive_summary.md
new file mode 100644
index 0000000..3bbf590
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/routing/phase4_executive_summary.md
@@ -0,0 +1,350 @@
+# Phase 4 Executive Summary: Multi-Hop Context Architecture
+
+**Version:** 1.0
+**Date:** 2025-10-06
+**Status:** Design Approved for Implementation
+
+---
+
+## Problem Statement
+
+Phase 3 routing implements loop prevention **within a single node** using `ForwardingContext`. However, this context is not transmitted across the network, making multi-hop loop detection impossible:
+
+```
+❌ Node A → Node B → Node A (loop NOT detected - context lost at Node B)
+```
+
+**Phase 4 Goal:** Embed `ForwardingContext` in MIDI packets for network-wide loop prevention.
+
+---
+
+## Solution Architecture
+
+### 1. Packet Format Extension
+
+**Add optional context extension to MidiPacket:**
+
+```
+┌─────────────────────────────────────────────┐
+│ Standard 20-byte header (unchanged)         │
+├─────────────────────────────────────────────┤
+│ Context Extension (optional):               │
+│   • Extension Type: 0x01           (1 byte) │
+│   • Extension Length: N            (1 byte) │
+│   • Hop Count: 0-8                 (1 byte) │
+│   • Device Count: M                (1 byte) │
+│   • Visited Device 1               (6 bytes)│
+│     - Node ID Hash: uint32         (4 bytes)│
+│     - Device ID: uint16            (2 bytes)│
+│   • ... (repeat for M devices)              │
+└─────────────────────────────────────────────┘
+```
+
+**Key Features:**
+- New `HasContext` flag bit indicates extension presence
+- Max size: 50 bytes (2 header + 8 devices × 6 bytes)
+- Backward compatible (Phase 3 nodes ignore extension)
+
+---
+
+### 2. Context Serialization Format
+
+**Hybrid Compact Format:**
+- Self-describing (device_count indicates array length)
+- Bounded size (max 8 hops × 6 bytes = 50 bytes)
+- Reuses existing UUID hash infrastructure from MidiPacket
+- Simple to serialize/deserialize (~700ns total)
+
+**Why Not Bitmap?**
+- Bitmap requires global device ID registry (complex)
+- Hybrid format is simpler and meets size requirements
+
+---
+
+### 3. UUID Reverse Lookup
+
+**Problem:** Context stores 32-bit hashes, need full UUIDs for DeviceKey.
+
+**Solution:** `UuidRegistry` class maintains hash → UUID mapping.
+
+```cpp
+class UuidRegistry {
+public:
+    void registerNode(const juce::Uuid& nodeId);
+    std::optional<juce::Uuid> lookupFromHash(uint32_t hash) const;
+};
+```
+
+**Integration:**
+- MeshManager owns registry
+- Registers nodes on connection establishment
+- Unregisters on disconnection
+- Injected into MidiRouter for context deserialization
+
+**Hash Collision Risk:**
+- 32-bit hash: ~1 in 4 billion collision probability
+- Acceptable for mesh <1000 nodes
+- Future: Use full UUID if collisions become issue
+
+---
+
+### 4. MidiRouter Changes
+
+**Updated Flow:**
+
+```cpp
+// Receive network packet
+void MidiRouter::onNetworkPacketReceived(const MidiPacket& packet) {
+    // Extract context from incoming packet (if present)
+    auto contextOpt = packet.getForwardingContext(*uuidRegistry);
+
+    ForwardingContext context = contextOpt.value_or(ForwardingContext{});
+
+    // Forward with context
+    forwardMessageInternal(sourceNode, deviceId, midiData, context);
+}
+
+// Forward to remote node
+void MidiRouter::forwardToDestination(..., const ForwardingContext& context) {
+    // Create packet
+    MidiPacket packet = MidiPacket::createDataPacket(...);
+
+    // Embed context
+    packet.setForwardingContext(context);
+
+    // Send via network
+    networkTransport->sendPacket(packet, address, port);
+}
+```
+
+**Key Changes:**
+1. Extract context from incoming packets
+2. Update context (visited devices, hop count)
+3. Embed context in outgoing packets
+4. Maintain backward compatibility
+
+---
+
+## Performance Characteristics
+
+### Latency
+
+```
+Per-hop overhead:        ~760ns
+3-hop total overhead:    ~2.3μs
+8-hop total overhead:    ~6.1μs
+Target: <10μs           ✓ Met
+```
+
+### Packet Size
+
+```
+Hops | Context Size | Total Packet Size
+-----|--------------|------------------
+0    | 0 bytes      | 23 bytes
+1    | 10 bytes     | 33 bytes
+2    | 16 bytes     | 39 bytes
+8    | 52 bytes     | 75 bytes (max)
+
+Target: <100 bytes      ✓ Met
+```
+
+### Memory
+
+```
+Per-message:             50 bytes (transient)
+UUID registry:           16 bytes/node (persistent)
+100-node mesh:           1.6 KB total
+                        ✓ Negligible
+```
+
+---
+
+## Backward Compatibility
+
+### Phase 3 ↔ Phase 4 Interoperability
+
+**Phase 3 Node receives Phase 4 packet:**
+- Ignores `HasContext` flag (reserved bit)
+- Forwards with fresh context (Phase 3 behavior)
+- No errors
+
+**Phase 4 Node receives Phase 3 packet:**
+- No context flag set
+- Creates fresh context
+- Continues forwarding normally
+
+**Mixed Mesh:**
+- P3 → P4: Context starts at P4 node
+- P4 → P3 → P4: Context lost at P3, resets at second P4
+- Gradual rollout safe
+
+---
+
+## Implementation Plan
+
+### Task Breakdown (16 days total)
+
+| Task | Description | Duration |
+|------|-------------|----------|
+| 4.1  | Extend MidiPacket with context | 3 days |
+| 4.2  | Implement UuidRegistry | 2 days |
+| 4.3  | Update MidiRouter for context | 4 days |
+| 4.4  | Update NetworkTransport interface | 2 days |
+| 4.5  | Integrate with MeshManager | 2 days |
+| 4.6  | End-to-end testing | 3 days |
+
+**Critical Path:** 4.1 → 4.3 → 4.6
+
+---
+
+## Testing Strategy
+
+### Unit Tests (15 cases)
+- Context serialization/deserialization
+- UUID registry lifecycle
+- Hash collision detection
+- Backward compatibility
+
+### Integration Tests (8 scenarios)
+- Two-node context propagation
+- Three-node multi-hop
+- Loop detection (circular route)
+- Max hops exceeded
+- Phase 3 ↔ Phase 4 compatibility
+
+### Performance Tests
+- Latency per hop (<10μs)
+- Packet size distribution
+- Throughput (1000 msg/sec with context)
+
+---
+
+## Risk Assessment
+
+### High Risk (Mitigated)
+
+**UUID Hash Collisions:**
+- Probability: ~1/4B per pair
+- Mitigation: Log collisions, monitor statistics
+- Fallback: Use full UUID in v2.0
+
+**Context Serialization Bugs:**
+- Impact: Corrupted context, infinite loops
+- Mitigation: Extensive unit tests, fuzz testing
+- Fail-safe: Drop context on deserialization error
+
+### Medium Risk
+
+**Backward Compatibility:**
+- Impact: Phase 3 nodes unable to communicate
+- Mitigation: Phase 4 understands Phase 3 packets
+- Rollout: Feature flag, gradual deployment
+
+**Performance Degradation:**
+- Impact: Increased latency
+- Mitigation: Benchmarks show <10μs overhead
+- Rollback: Disable context via feature flag
+
+---
+
+## Migration Strategy
+
+### Rollout Stages
+
+**Stage 1: Deploy with Context Disabled**
+- Feature flag: `enable_forwarding_context=false`
+- Test in staging environment
+- No risk to existing traffic
+
+**Stage 2: Enable on Test Nodes**
+- 2-3 test nodes with context enabled
+- Monitor packet sizes, latency
+- Validate loop prevention
+
+**Stage 3: Gradual Rollout**
+- 25% of nodes enabled
+- Monitor `loopsDetected`, `contextsProcessed` stats
+- Roll back if issues detected
+
+**Stage 4: Full Deployment**
+- Enable on all nodes
+- Context becomes standard for forwarding
+
+---
+
+## Success Criteria
+
+### Must Have (MVP)
+- ✅ Multi-hop routing with context (3+ nodes)
+- ✅ Network-wide loop detection
+- ✅ Backward compatibility with Phase 3
+- ✅ <10μs latency overhead per hop
+- ✅ <100 byte packet size
+- ✅ All integration tests passing
+
+### Should Have
+- UUID registry with collision detection
+- Performance monitoring dashboard
+- Feature flag for gradual rollout
+- Migration documentation
+
+---
+
+## Key Decisions
+
+### Decision 1: Hybrid Context Format (vs Bitmap)
+**Rationale:** Simpler implementation, meets size requirements, no global ID registry needed.
+
+### Decision 2: Optional Context Extension (vs Mandatory)
+**Rationale:** Enables backward compatibility, gradual rollout, reduces overhead for local-only routing.
+
+### Decision 3: 32-bit UUID Hashes (vs Full UUID)
+**Rationale:** Saves 24 bytes per hop, collision risk acceptable for mesh <1000 nodes.
+
+### Decision 4: Context in Packet Extension (vs Separate Channel)
+**Rationale:** Keeps context with message, simpler to implement, no synchronization issues.
+
+---
+
+## Files to Modify
+
+### Core Packet Format
+- `/network/core/MidiPacket.h` (add context methods)
+- `/network/core/MidiPacket.cpp` (serialization logic)
+
+### UUID Registry (New)
+- `/network/routing/UuidRegistry.h` (new class)
+- `/network/routing/UuidRegistry.cpp` (implementation)
+
+### Routing Engine
+- `/network/routing/MidiRouter.h` (context extraction/embedding)
+- `/network/routing/MidiRouter.cpp` (forwarding logic)
+
+### Mesh Integration
+- `/network/mesh/MeshManager.h` (UUID registry ownership)
+- `/network/mesh/MeshManager.cpp` (register/unregister nodes)
+- `/network/mesh/NetworkConnection.h` (sendPacket method)
+
+---
+
+## Next Steps
+
+1. **Approval:** Architecture team sign-off on design
+2. **Prototype:** Context serialization benchmark (validate <1μs)
+3. **Implementation:** Begin Task 4.1 (MidiPacket extension)
+4. **Testing:** Set up 3-node test mesh
+5. **Deployment:** Staged rollout with feature flag
+
+**Target Completion:** 3 weeks from start
+
+---
+
+## Questions?
+
+For detailed technical design, see:
+- [Full Phase 4 Design Document](./phase4_multihop_context.md)
+- [Routing Workplan (Phases 1-3)](./implementation/workplan.md)
+- [Transport Layer Report](../../network/transport/PHASE4_REPORT.md)
+
+**Contact:** Architecture team for review and approval.
diff --git a/modules/juce/midi-server/docs/1.0/routing/phase4_multihop_context.md b/modules/juce/midi-server/docs/1.0/routing/phase4_multihop_context.md
new file mode 100644
index 0000000..4109236
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/routing/phase4_multihop_context.md
@@ -0,0 +1,1167 @@
+# Phase 4: Multi-Hop Context & Network-Wide Loop Prevention
+
+**Version:** 1.0
+**Status:** Design
+**Last Updated:** 2025-10-06
+**Author:** Backend TypeScript Architect (Claude)
+
+---
+
+## Executive Summary
+
+Phase 3 of the cross-node MIDI routing system implemented local loop prevention using `ForwardingContext` (visited devices tracking, hop count limiting). However, this context only exists within a single node's memory and is **not transmitted over the network**.
+
+**Current Limitation:**
+```
+Node A → Node B → Node C (multi-hop works)
+Node A → Node B → Node A (loop NOT detected across network!)
+```
+
+**Phase 4 Goal:** Embed `ForwardingContext` in MIDI packets to enable network-wide loop prevention across multiple hops.
+
+**Key Requirements:**
+1. Minimal packet overhead (<50 bytes)
+2. Backward compatibility with Phase 3 packets
+3. Sub-microsecond serialization performance
+4. Support for up to 8 hops (Phase 3 MAX_HOPS)
+5. Efficient visited device tracking
+
+---
+
+## Architecture Analysis
+
+### Current State (Phase 3)
+
+#### ForwardingContext Structure
+```cpp
+// From MidiRouter.h (lines 140-163)
+struct ForwardingContext {
+    std::set<DeviceKey> visitedDevices;
+    uint8_t hopCount = 0;
+    static constexpr uint8_t MAX_HOPS = 8;
+};
+```
+
+#### Packet Flow Without Context
+```
+┌─────────┐                  ┌─────────┐                  ┌─────────┐
+│ Node A  │                  │ Node B  │                  │ Node C  │
+│         │                  │         │                  │         │
+│ Router  │──MidiPacket───►  │ Router  │──MidiPacket───►  │ Router  │
+│         │  (no context)    │         │  (no context)    │         │
+│ Context │                  │ Context │                  │ Context │
+│  LOST   │                  │  RESET  │                  │  RESET  │
+└─────────┘                  └─────────┘                  └─────────┘
+```
+
+**Problem:** Each node creates fresh `ForwardingContext`, losing visited device history.
+
+### Target State (Phase 4)
+
+#### Packet Flow With Embedded Context
+```
+┌─────────┐                  ┌─────────┐                  ┌─────────┐
+│ Node A  │                  │ Node B  │                  │ Node C  │
+│         │                  │         │                  │         │
+│ Router  │──MidiPacket───►  │ Router  │──MidiPacket───►  │ Router  │
+│         │  + Context       │         │  + Context       │         │
+│ {A:1}   │  {A:1}          │ {A:1,    │  {A:1, B:2,     │ {A:1,    │
+│ hops=1  │                  │  B:2}    │   C:3}          │  B:2,    │
+│         │                  │ hops=2   │                  │  C:3}    │
+│         │                  │         │                  │ hops=3   │
+└─────────┘                  └─────────┘                  └─────────┘
+```
+
+**Solution:** Context travels with packet, accumulating visited devices.
+
+---
+
+## Design Decisions
+
+### Decision 1: Context Storage Format
+
+#### Option A: Variable-Length Visited Device List (REJECTED)
+
+**Format:**
+```
+┌────────────┬──────────────────────────────────┐
+│ hop_count  │ visited_devices[]                │
+│  (1 byte)  │  [(nodeId, deviceId), ...]       │
+└────────────┴──────────────────────────────────┘
+```
+
+**Size Calculation:**
+- Per device: 4 bytes (nodeId hash) + 2 bytes (deviceId) = 6 bytes
+- Max 8 hops: 1 + (8 × 6) = 49 bytes
+
+**Pros:** Exact device tracking, simple deserialization
+**Cons:** Variable size complicates parsing, grows with hop count
+
+---
+
+#### Option B: Compact Bitmap (REJECTED for Phase 4)
+
+**Format:**
+```
+┌────────────┬──────────────────────────────────┐
+│ hop_count  │ visited_device_bitmap (32 bytes) │
+│  (1 byte)  │  (256 bits, 1 bit per device)    │
+└────────────┴──────────────────────────────────┘
+```
+
+**Pros:** Fixed size (33 bytes), fast bitmap operations
+**Cons:** Requires global device ID registry, complex to maintain
+
+---
+
+#### Option C: Hybrid Format (SELECTED)
+
+**Format:**
+```
+┌────────────┬───────────────┬──────────────────────────┐
+│ hop_count  │ device_count  │ visited_devices[]        │
+│  (1 byte)  │  (1 byte)     │  [6 bytes each]          │
+└────────────┴───────────────┴──────────────────────────┘
+```
+
+**Implementation Details:**
+- `hop_count`: Current hop count (0-8)
+- `device_count`: Number of visited devices (0-8)
+- `visited_devices`: Array of (nodeIdHash: uint32, deviceId: uint16) pairs
+
+**Size Calculation:**
+- Header: 2 bytes (hop_count + device_count)
+- Per device: 6 bytes (4 + 2)
+- Max size: 2 + (8 × 6) = **50 bytes**
+
+**Pros:**
+- Self-describing (device_count = array length)
+- Bounded size (max 50 bytes)
+- Simple serialization/deserialization
+- Uses existing UUID hash infrastructure from MidiPacket
+
+**Cons:**
+- Slightly larger than bitmap (17 bytes overhead)
+- Still need to pack/unpack on each hop
+
+**Decision Rationale:**
+- Meets <50 byte requirement
+- Compatible with existing MidiPacket UUID hash mechanism
+- Simple to implement and debug
+- Performant (linear scan over max 8 devices is negligible)
+
+---
+
+### Decision 2: Packet Format Extension
+
+#### Updated MidiPacket Structure
+
+**Current Header (20 bytes):**
+```cpp
+// From MidiPacket.h (lines 12-21)
+┌─────────────────────────────────────────────┐
+│ Magic: 0x4D49 ("MI")              | 2 bytes │
+│ Version: 0x01                     | 1 byte  │
+│ Flags: [SysEx|Reliable|Frag|Rsv] | 1 byte  │
+│ Source Node UUID (hash)           | 4 bytes │
+│ Dest Node UUID (hash)             | 4 bytes │
+│ Sequence Number                   | 2 bytes │
+│ Timestamp (microseconds)          | 4 bytes │
+│ Device ID                         | 2 bytes │
+└─────────────────────────────────────────────┘
+```
+
+**Extended Header with Context (20 + variable):**
+```cpp
+┌─────────────────────────────────────────────┐
+│ ... (20-byte header unchanged) ...          │
+├─────────────────────────────────────────────┤
+│ Optional Extension Section:                 │
+│   ┌─────────────────────────────────┐       │
+│   │ Ext Type: 0x01 (Context) | 1 b │       │
+│   │ Ext Length: N bytes      | 1 b │       │
+│   │ Hop Count                | 1 b │       │
+│   │ Device Count: M          | 1 b │       │
+│   │ Visited Device 1         | 6 b │       │
+│   │ Visited Device 2         | 6 b │       │
+│   │ ...                              │       │
+│   │ Visited Device M         | 6 b │       │
+│   └─────────────────────────────────┘       │
+└─────────────────────────────────────────────┘
+```
+
+**Flags Update:**
+```cpp
+// Add new flag bit for context presence
+enum Flags : uint8_t {
+    None = 0,
+    SysEx = 1 << 0,
+    Reliable = 1 << 1,
+    Fragment = 1 << 2,
+    HasContext = 1 << 3,  // NEW: Indicates context extension present
+    Reserved4 = 1 << 4,
+    Reserved5 = 1 << 5,
+    Reserved6 = 1 << 6,
+    Reserved7 = 1 << 7
+};
+```
+
+**Extension Format:**
+```cpp
+struct ContextExtension {
+    uint8_t extType = 0x01;       // Extension type: context
+    uint8_t extLength;            // Total bytes (including header)
+    uint8_t hopCount;             // Current hop count
+    uint8_t deviceCount;          // Number of visited devices
+
+    struct VisitedDevice {
+        uint32_t nodeIdHash;      // 4 bytes (reuse MidiPacket::hashUuid)
+        uint16_t deviceId;        // 2 bytes
+    };
+
+    std::vector<VisitedDevice> visitedDevices;
+};
+```
+
+**Backward Compatibility:**
+- Nodes without Phase 4 support ignore `HasContext` flag
+- Context is optional (only set when forwarding is active)
+- No context = fresh ForwardingContext (Phase 3 behavior)
+
+---
+
+### Decision 3: Serialization Strategy
+
+#### Binary Format (Big-Endian)
+
+**Layout:**
+```
+Offset | Size | Field
+-------|------|----------------------------------
+0      | 1    | Extension Type (0x01)
+1      | 1    | Extension Length (N = 4 + M*6)
+2      | 1    | Hop Count
+3      | 1    | Device Count (M)
+4      | 4    | Device 1: Node ID Hash
+8      | 2    | Device 1: Device ID
+10     | 4    | Device 2: Node ID Hash
+14     | 2    | Device 2: Device ID
+...    | ...  | ...
+```
+
+**Serialization Pseudocode:**
+```cpp
+void serializeContext(const ForwardingContext& ctx, std::vector<uint8_t>& buffer) {
+    buffer.push_back(0x01);  // Extension type
+
+    uint8_t deviceCount = static_cast<uint8_t>(ctx.visitedDevices.size());
+    uint8_t extLength = 4 + (deviceCount * 6);
+    buffer.push_back(extLength);
+
+    buffer.push_back(ctx.hopCount);
+    buffer.push_back(deviceCount);
+
+    for (const auto& devKey : ctx.visitedDevices) {
+        uint32_t hash = MidiPacket::hashUuid(devKey.ownerNode);
+        buffer.push_back((hash >> 24) & 0xFF);  // Big-endian
+        buffer.push_back((hash >> 16) & 0xFF);
+        buffer.push_back((hash >> 8) & 0xFF);
+        buffer.push_back(hash & 0xFF);
+
+        buffer.push_back((devKey.deviceId >> 8) & 0xFF);
+        buffer.push_back(devKey.deviceId & 0xFF);
+    }
+}
+```
+
+**Deserialization Pseudocode:**
+```cpp
+ForwardingContext deserializeContext(const uint8_t* data, size_t length) {
+    ForwardingContext ctx;
+
+    if (length < 4) throw std::runtime_error("Context too short");
+
+    uint8_t extType = data[0];
+    if (extType != 0x01) throw std::runtime_error("Invalid extension type");
+
+    uint8_t extLength = data[1];
+    ctx.hopCount = data[2];
+    uint8_t deviceCount = data[3];
+
+    if (extLength != 4 + (deviceCount * 6)) {
+        throw std::runtime_error("Context length mismatch");
+    }
+
+    size_t offset = 4;
+    for (uint8_t i = 0; i < deviceCount; ++i) {
+        uint32_t hash = (data[offset] << 24) | (data[offset+1] << 16) |
+                        (data[offset+2] << 8) | data[offset+3];
+        uint16_t devId = (data[offset+4] << 8) | data[offset+5];
+
+        // Need UUID lookup table to reverse hash → UUID
+        juce::Uuid nodeId = lookupNodeFromHash(hash);
+        ctx.visitedDevices.insert(DeviceKey(nodeId, devId));
+
+        offset += 6;
+    }
+
+    return ctx;
+}
+```
+
+**Performance:**
+- Serialization: ~300ns (8 devices × 6 bytes)
+- Deserialization: ~400ns (includes hash lookups)
+- Memory allocation: 50 bytes heap (amortized via vector reserve)
+
+**Target: <1μs ✓**
+
+---
+
+### Decision 4: UUID Hash Reverse Lookup
+
+**Problem:** Context stores 32-bit hashes, but `DeviceKey` needs full `juce::Uuid`.
+
+**Solution:** Maintain UUID lookup tables at connection level.
+
+#### UUID Registry Interface
+```cpp
+class UuidRegistry {
+public:
+    // Register node UUID when connection established
+    void registerNode(const juce::Uuid& nodeId);
+
+    // Lookup UUID from hash (O(1))
+    std::optional<juce::Uuid> lookupFromHash(uint32_t hash) const;
+
+    // Remove node when connection closed
+    void unregisterNode(const juce::Uuid& nodeId);
+
+private:
+    std::unordered_map<uint32_t, juce::Uuid> hashToUuid;
+    mutable std::mutex registryMutex;
+};
+```
+
+#### Integration Points
+
+**In MeshManager:**
+```cpp
+class MeshManager {
+private:
+    UuidRegistry nodeRegistry;  // Shared registry for all connections
+
+public:
+    void onConnectionEstablished(const juce::Uuid& nodeId) {
+        nodeRegistry.registerNode(nodeId);
+    }
+
+    void onConnectionClosed(const juce::Uuid& nodeId) {
+        nodeRegistry.unregisterNode(nodeId);
+    }
+};
+```
+
+**In MidiRouter:**
+```cpp
+void MidiRouter::setUuidRegistry(UuidRegistry* registry) {
+    uuidRegistry = registry;
+}
+
+ForwardingContext MidiRouter::deserializeContext(const uint8_t* data, size_t len) {
+    // ... deserialize hash values ...
+
+    juce::Uuid nodeId = uuidRegistry->lookupFromHash(hash).value_or(juce::Uuid());
+    if (nodeId.isNull()) {
+        throw std::runtime_error("Unknown node hash: " + std::to_string(hash));
+    }
+}
+```
+
+**Hash Collision Handling:**
+- 32-bit hash has ~1 in 4 billion collision probability (acceptable for mesh <1000 nodes)
+- If collision detected (multiple UUIDs map to same hash), log error and drop packet
+- Future enhancement: Use full UUID in context (increases size to ~170 bytes)
+
+---
+
+## Implementation Plan
+
+### Task Breakdown
+
+#### Task 4.1: Extend MidiPacket with Context Support (3 days)
+
+**Files to Modify:**
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/core/MidiPacket.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/core/MidiPacket.cpp`
+
+**Changes:**
+1. Add `HasContext` flag to `Flags` enum
+2. Add `contextData` member (optional `std::vector<uint8_t>`)
+3. Implement `setContextData()` / `getContextData()` accessors
+4. Update `serialize()` to append context extension when `HasContext` flag set
+5. Update `deserialize()` to extract context extension
+6. Add `hasContext()` helper method
+
+**API Design:**
+```cpp
+class MidiPacket {
+public:
+    // Context management
+    void setForwardingContext(const ForwardingContext& ctx);
+    std::optional<ForwardingContext> getForwardingContext(const UuidRegistry& registry) const;
+    bool hasForwardingContext() const;
+
+private:
+    std::vector<uint8_t> contextExtension;  // Raw context bytes
+
+    // Helpers
+    static std::vector<uint8_t> serializeContext(const ForwardingContext& ctx);
+    static ForwardingContext deserializeContext(const uint8_t* data, size_t len,
+                                                 const UuidRegistry& registry);
+};
+```
+
+**Backward Compatibility:**
+- If `contextExtension` is empty, serialize as Phase 3 packet
+- If `HasContext` flag not set during deserialize, return `std::nullopt`
+
+**Testing:**
+- Unit test: Serialize/deserialize context with 0, 1, and 8 devices
+- Unit test: Round-trip ForwardingContext with MAX_HOPS
+- Unit test: Backward compatibility (Phase 3 packets decode correctly)
+- Unit test: Invalid context data throws exception
+
+---
+
+#### Task 4.2: Implement UuidRegistry (2 days)
+
+**New Files:**
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/UuidRegistry.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/UuidRegistry.cpp`
+
+**Implementation:**
+```cpp
+class UuidRegistry {
+public:
+    UuidRegistry();
+    ~UuidRegistry();
+
+    // Registration (called when connection established)
+    void registerNode(const juce::Uuid& nodeId);
+    void unregisterNode(const juce::Uuid& nodeId);
+
+    // Lookup (called during context deserialization)
+    std::optional<juce::Uuid> lookupFromHash(uint32_t hash) const;
+
+    // Statistics
+    size_t getRegisteredNodeCount() const;
+    std::vector<juce::Uuid> getAllNodes() const;
+
+    // Collision detection
+    bool hasCollision(uint32_t hash) const;
+
+private:
+    mutable std::mutex mutex;
+    std::unordered_map<uint32_t, juce::Uuid> hashToUuid;
+
+    // Helper
+    static uint32_t computeHash(const juce::Uuid& uuid);
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(UuidRegistry)
+};
+```
+
+**Testing:**
+- Unit test: Register/unregister lifecycle
+- Unit test: Hash lookup accuracy
+- Unit test: Collision detection
+- Unit test: Thread safety (concurrent register/lookup)
+
+---
+
+#### Task 4.3: Update MidiRouter for Context Forwarding (4 days)
+
+**Files to Modify:**
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/MidiRouter.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/MidiRouter.cpp`
+
+**Changes:**
+
+**1. Add UuidRegistry Integration:**
+```cpp
+class MidiRouter {
+public:
+    void setUuidRegistry(UuidRegistry* registry);
+
+private:
+    UuidRegistry* uuidRegistry = nullptr;
+};
+```
+
+**2. Update `forwardMessage()` to Extract Context:**
+```cpp
+void MidiRouter::forwardMessage(const juce::Uuid& sourceNode,
+                                uint16_t sourceDevice,
+                                const std::vector<uint8_t>& midiData,
+                                const MidiPacket* incomingPacket)  // NEW
+{
+    ForwardingContext context;
+
+    // Extract context from incoming packet (if present)
+    if (incomingPacket && incomingPacket->hasForwardingContext()) {
+        if (!uuidRegistry) {
+            reportError("Cannot deserialize context - UuidRegistry not set");
+            return;
+        }
+
+        auto ctxOpt = incomingPacket->getForwardingContext(*uuidRegistry);
+        if (ctxOpt.has_value()) {
+            context = ctxOpt.value();
+        }
+    }
+
+    // Delegate to internal implementation
+    forwardMessageInternal(sourceNode, sourceDevice, midiData, context);
+}
+```
+
+**3. Update `forwardToDestination()` to Embed Context:**
+```cpp
+void MidiRouter::forwardToDestination(const juce::Uuid& destNode,
+                                      uint16_t destDevice,
+                                      const std::vector<uint8_t>& midiData,
+                                      const ForwardingContext& context)  // NEW
+{
+    if (destNode.isNull()) {
+        // Local device - no context needed
+        routeLocalMessage(destDevice, midiData);
+    } else {
+        // Remote device - embed context in packet
+        MidiPacket packet = MidiPacket::createDataPacket(
+            myNodeId, destNode, destDevice, midiData, nextSequence++
+        );
+
+        // Add context extension
+        packet.setForwardingContext(context);
+
+        // Send via network
+        networkTransport->sendPacket(packet, /* address, port */);
+    }
+}
+```
+
+**4. Update `onNetworkPacketReceived()` to Pass Packet:**
+```cpp
+void MidiRouter::onNetworkPacketReceived(const MidiPacket& packet)
+{
+    // Extract source and device info
+    juce::Uuid sourceNode = packet.getSourceNode();
+    uint16_t deviceId = packet.getDeviceId();
+    std::vector<uint8_t> midiData = packet.getMidiData();
+
+    // Queue for consumption
+    queueReceivedMessage(deviceId, midiData);
+
+    // Forward to other destinations (with context)
+    forwardMessage(sourceNode, deviceId, midiData, &packet);  // Pass packet
+
+    // Update statistics
+    std::lock_guard<std::mutex> lock(statsMutex);
+    stats.networkMessagesReceived++;
+}
+```
+
+**Testing:**
+- Unit test: Context extraction from packet
+- Unit test: Context embedding in outgoing packet
+- Unit test: Backward compatibility (no context = fresh context)
+- Integration test: Multi-hop forwarding with context preservation
+
+---
+
+#### Task 4.4: Update NetworkTransport Interface (2 days)
+
+**Files to Modify:**
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/MidiRouter.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnection.h`
+
+**Changes:**
+
+**1. Extend NetworkTransport Interface:**
+```cpp
+class NetworkTransport {
+public:
+    virtual ~NetworkTransport() = default;
+
+    // Legacy method (Phase 3 compatibility)
+    virtual void sendMidiMessage(const juce::Uuid& destNode,
+                                 uint16_t deviceId,
+                                 const std::vector<uint8_t>& midiData) = 0;
+
+    // NEW: Send full packet (Phase 4)
+    virtual void sendPacket(const MidiPacket& packet,
+                           const juce::String& destAddress,
+                           int destPort) = 0;
+};
+```
+
+**2. Update NetworkConnection to Implement `sendPacket()`:**
+```cpp
+class NetworkConnection : public NetworkTransport {
+public:
+    // Phase 4 implementation
+    void sendPacket(const MidiPacket& packet,
+                   const juce::String& destAddress,
+                   int destPort) override;
+
+    // Callback for receiving full packets
+    std::function<void(const MidiPacket&)> onMidiPacketReceived;  // NEW
+};
+```
+
+**3. Wire Up to UdpMidiTransport:**
+```cpp
+// In ConnectionWorker
+void ConnectionWorker::handleSendPacketCommand(Commands::SendPacketCommand* cmd) {
+    if (realtimeTransport) {
+        realtimeTransport->sendPacket(cmd->packet, cmd->destAddress, cmd->destPort);
+    }
+}
+```
+
+**Testing:**
+- Unit test: sendPacket() forwards to UdpMidiTransport
+- Integration test: Full packet with context sent over network
+
+---
+
+#### Task 4.5: Integrate with MeshManager (2 days)
+
+**Files to Modify:**
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/MeshManager.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/MeshManager.cpp`
+
+**Changes:**
+
+**1. Add UuidRegistry to MeshManager:**
+```cpp
+class MeshManager {
+public:
+    UuidRegistry& getUuidRegistry() { return uuidRegistry; }
+
+private:
+    UuidRegistry uuidRegistry;
+};
+```
+
+**2. Register/Unregister Nodes on Connection Lifecycle:**
+```cpp
+void MeshManager::handleConnectionEstablished(const juce::Uuid& nodeId) {
+    uuidRegistry.registerNode(nodeId);
+
+    // Existing handshake logic...
+}
+
+void MeshManager::handleConnectionClosed(const juce::Uuid& nodeId) {
+    uuidRegistry.unregisterNode(nodeId);
+
+    // Existing cleanup logic...
+}
+```
+
+**3. Inject UuidRegistry into MidiRouter:**
+```cpp
+void MeshManager::initialize() {
+    // Existing initialization...
+
+    if (midiRouter) {
+        midiRouter->setUuidRegistry(&uuidRegistry);
+    }
+}
+```
+
+**Testing:**
+- Integration test: UUID registry populated on connection
+- Integration test: Registry cleaned up on disconnection
+
+---
+
+#### Task 4.6: End-to-End Testing (3 days)
+
+**New Test File:**
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/integration/multihop_context_test.sh`
+
+**Test Scenarios:**
+
+**Test 1: Two-Node Context Propagation**
+```bash
+# Start two nodes
+./node1 --port 8001 &
+./node2 --port 8002 &
+
+# Create forwarding rule: Node1 → Node2
+curl -X POST http://localhost:8001/routing/routes \
+  -d '{"source_device_id": 2, "destination_node_id": "$NODE2_UUID", "destination_device_id": 5}'
+
+# Send MIDI to Node1
+curl -X POST http://localhost:8001/midi/send \
+  -d '{"device_id": 2, "data": [0x90, 0x3C, 0x64]}'
+
+# Verify Node2 received with context
+# Expected: hopCount=1, visitedDevices=[Node1:2]
+```
+
+**Test 2: Three-Node Multi-Hop**
+```bash
+# Topology: Node1 → Node2 → Node3
+
+# Send from Node1
+# Expected at Node3:
+#   hopCount=2
+#   visitedDevices=[Node1:2, Node2:5]
+```
+
+**Test 3: Loop Detection**
+```bash
+# Create circular route: Node1 → Node2 → Node1
+
+# Send from Node1
+# Expected: Loop detected at Node1 (second visit)
+# Statistics: loopsDetected=1, messagesDropped=1
+```
+
+**Test 4: Max Hops Exceeded**
+```bash
+# Create chain: N1 → N2 → N3 → N4 → N5 → N6 → N7 → N8 → N9
+
+# Send from N1
+# Expected: N9 drops message (hopCount=8, MAX_HOPS exceeded)
+```
+
+**Test 5: Backward Compatibility**
+```bash
+# Node1 with Phase 4, Node2 with Phase 3
+
+# Send from Node1 to Node2
+# Expected: Node2 treats as fresh context (no error)
+
+# Send from Node2 to Node1
+# Expected: Node1 treats as fresh context
+```
+
+**Performance Benchmarks:**
+- Measure latency overhead of context serialization
+- Target: <1μs per hop
+- Measure packet size growth
+- Target: <50 bytes for max context
+
+---
+
+## API Changes Summary
+
+### MidiPacket (Extended)
+
+```cpp
+// NEW methods
+void setForwardingContext(const ForwardingContext& ctx);
+std::optional<ForwardingContext> getForwardingContext(const UuidRegistry& registry) const;
+bool hasForwardingContext() const;
+
+// NEW flag
+enum Flags {
+    HasContext = 1 << 3,  // Indicates context extension present
+};
+```
+
+### UuidRegistry (New Class)
+
+```cpp
+class UuidRegistry {
+public:
+    void registerNode(const juce::Uuid& nodeId);
+    void unregisterNode(const juce::Uuid& nodeId);
+    std::optional<juce::Uuid> lookupFromHash(uint32_t hash) const;
+};
+```
+
+### MidiRouter (Modified)
+
+```cpp
+// NEW methods
+void setUuidRegistry(UuidRegistry* registry);
+
+// MODIFIED signature (adds optional packet parameter)
+void forwardMessage(const juce::Uuid& sourceNode,
+                   uint16_t sourceDevice,
+                   const std::vector<uint8_t>& midiData,
+                   const MidiPacket* incomingPacket = nullptr);  // NEW
+
+// MODIFIED signature (adds context parameter)
+void forwardToDestination(const juce::Uuid& destNode,
+                         uint16_t destDevice,
+                         const std::vector<uint8_t>& midiData,
+                         const ForwardingContext& context);  // NEW
+
+// MODIFIED signature (receives full packet)
+void onNetworkPacketReceived(const MidiPacket& packet);  // Changed from individual params
+```
+
+### NetworkTransport (Extended)
+
+```cpp
+// NEW method
+virtual void sendPacket(const MidiPacket& packet,
+                       const juce::String& destAddress,
+                       int destPort) = 0;
+```
+
+### MeshManager (Extended)
+
+```cpp
+// NEW method
+UuidRegistry& getUuidRegistry();
+```
+
+---
+
+## Migration Strategy
+
+### Backward Compatibility Plan
+
+**Phase 3 Nodes (No Context Support):**
+- Ignore `HasContext` flag (treat as reserved bit)
+- Forward messages with fresh context (Phase 3 behavior)
+- No errors, graceful degradation
+
+**Phase 4 Nodes (With Context Support):**
+- Receive Phase 3 packets: Treat as fresh context
+- Receive Phase 4 packets: Extract and update context
+- Send Phase 3 packets: For local-only forwarding
+- Send Phase 4 packets: For network forwarding
+
+### Rollout Stages
+
+**Stage 1: Add Context Support (Non-Breaking)**
+- Deploy Phase 4 code with context disabled by default
+- Feature flag: `enable_forwarding_context=false`
+- Test in staging environment
+
+**Stage 2: Enable Context on Test Nodes**
+- Enable context on 2-3 test nodes
+- Monitor packet sizes and latency
+- Validate loop prevention
+
+**Stage 3: Gradual Rollout**
+- Enable context on 25% of nodes
+- Monitor statistics (loopsDetected, contextsProcessed)
+- Roll back if issues detected
+
+**Stage 4: Full Deployment**
+- Enable context on all nodes
+- Make context mandatory for forwarding (future version)
+
+### Configuration
+
+**Server Config File:**
+```json
+{
+  "routing": {
+    "enable_forwarding_context": true,
+    "max_context_hops": 8,
+    "context_serialization_format": "compact"  // Future: "bitmap"
+  }
+}
+```
+
+---
+
+## Performance Analysis
+
+### Latency Budget
+
+**Per-Hop Overhead:**
+```
+Operation                    Time
+─────────────────────────────────────
+Extract context from packet   200ns
+Update visited devices        100ns
+Increment hop count            10ns
+Serialize context             300ns
+Embed in outgoing packet      150ns
+─────────────────────────────────────
+Total per hop                 760ns
+```
+
+**Multi-Hop Latency:**
+- 3 hops: ~2.3μs overhead
+- 8 hops: ~6.1μs overhead
+- Target: <10μs ✓
+
+### Packet Size Overhead
+
+**Packet Size Growth:**
+```
+Hops | Context Size | Total Size (3-byte MIDI)
+-----|--------------|-------------------------
+0    | 0 bytes      | 23 bytes (20 + 3)
+1    | 10 bytes     | 33 bytes
+2    | 16 bytes     | 39 bytes
+3    | 22 bytes     | 45 bytes
+8    | 52 bytes     | 75 bytes (max)
+```
+
+**Network Bandwidth Impact:**
+- Worst case: 3.3x size increase (0 hops → 8 hops)
+- Typical case: 1.4x size increase (0 hops → 2 hops)
+- Absolute overhead: +52 bytes max
+
+**Impact on 1000 msg/sec:**
+- Without context: 23 KB/sec
+- With max context: 75 KB/sec
+- Delta: +52 KB/sec (negligible on LAN)
+
+### Memory Overhead
+
+**Per-Message:**
+- Context storage: 50 bytes (heap allocated)
+- UUID registry: 16 bytes per node (amortized)
+
+**System-Wide (100 nodes, 1000 msg/sec):**
+- Context buffers: 50 KB (transient)
+- UUID registry: 1.6 KB (persistent)
+- Total: <100 KB (negligible)
+
+---
+
+## Risk Assessment
+
+### High Risk
+
+**1. UUID Hash Collisions**
+- **Probability:** ~1 in 4 billion per pair
+- **Impact:** False loop detection, dropped messages
+- **Mitigation:**
+  - Log hash collisions when detected
+  - Use full UUID in future version if collisions occur
+  - Monitor `hashCollisions` statistic
+
+**2. Context Serialization Bugs**
+- **Probability:** Medium (complex binary format)
+- **Impact:** Corrupted context, infinite loops
+- **Mitigation:**
+  - Extensive unit tests (fuzz testing)
+  - Checksum in context extension (future)
+  - Fail-safe: Drop context on deserialization error
+
+### Medium Risk
+
+**3. Backward Compatibility Issues**
+- **Probability:** Low (design includes fallback)
+- **Impact:** Phase 3 nodes unable to communicate with Phase 4
+- **Mitigation:**
+  - Phase 4 nodes always understand Phase 3 packets
+  - Feature flag for gradual rollout
+  - Monitoring dashboard for version mix
+
+**4. Performance Degradation**
+- **Probability:** Low (benchmarks look good)
+- **Impact:** Increased latency, reduced throughput
+- **Mitigation:**
+  - Performance tests before deployment
+  - Rollback plan if latency >10μs per hop
+  - Profiling in production
+
+### Low Risk
+
+**5. Memory Leaks**
+- **Probability:** Very low (RAII, smart pointers)
+- **Impact:** Gradual memory exhaustion
+- **Mitigation:**
+  - Valgrind testing
+  - Memory monitoring in production
+  - Bounded data structures (max 8 devices)
+
+---
+
+## Testing Strategy
+
+### Unit Tests (15 test cases)
+
+**MidiPacket Context Tests:**
+1. Serialize empty context (hopCount=0)
+2. Serialize context with 1 device
+3. Serialize context with 8 devices (max)
+4. Round-trip context preservation
+5. Backward compatibility (Phase 3 packet)
+6. Invalid context data handling
+7. Context size validation
+
+**UuidRegistry Tests:**
+8. Register/lookup lifecycle
+9. Hash collision detection
+10. Thread safety (concurrent access)
+
+**MidiRouter Tests:**
+11. Extract context from incoming packet
+12. Embed context in outgoing packet
+13. Update visited devices correctly
+14. Hop count increment
+15. Loop detection with context
+
+### Integration Tests (8 scenarios)
+
+**Network Tests:**
+1. Two-node context propagation
+2. Three-node multi-hop
+3. Loop detection (circular route)
+4. Max hops exceeded
+5. Backward compatibility (Phase 3 ↔ Phase 4)
+6. UUID registry sync on connection
+7. Context preserved across node restart
+8. Stress test (1000 msg/sec with context)
+
+### Performance Tests (4 benchmarks)
+
+**Latency:**
+1. Per-hop overhead measurement
+2. Multi-hop latency (1, 3, 5, 8 hops)
+
+**Throughput:**
+3. Messages/sec with context enabled
+4. Packet size distribution
+
+---
+
+## Success Criteria
+
+### Must Have (MVP)
+
+1. ✅ Multi-hop routing with context preservation (3 nodes)
+2. ✅ Network-wide loop detection
+3. ✅ Backward compatibility with Phase 3
+4. ✅ <10μs latency overhead per hop
+5. ✅ <100 byte packet size (max context)
+6. ✅ Integration tests passing
+
+### Should Have
+
+1. UUID registry with collision detection
+2. Performance monitoring (context stats)
+3. Feature flag for gradual rollout
+4. Documentation and migration guide
+
+### Nice to Have
+
+1. Bitmap-based context format (future optimization)
+2. Context compression for long chains
+3. WebUI visualization of forwarding paths
+4. Context-aware routing metrics
+
+---
+
+## Timeline Estimate
+
+| Task | Description | Duration | Dependencies |
+|------|-------------|----------|--------------|
+| 4.1  | Extend MidiPacket | 3 days | None |
+| 4.2  | Implement UuidRegistry | 2 days | None |
+| 4.3  | Update MidiRouter | 4 days | 4.1, 4.2 |
+| 4.4  | Update NetworkTransport | 2 days | 4.1 |
+| 4.5  | Integrate with MeshManager | 2 days | 4.2, 4.4 |
+| 4.6  | End-to-End Testing | 3 days | 4.3, 4.5 |
+
+**Total Estimated Time:** 16 days (approximately 3 weeks)
+
+**Critical Path:** Task 4.1 → 4.3 → 4.6
+
+---
+
+## Open Questions
+
+### Q1: Should context be mandatory for all forwarding?
+
+**Current Answer:** No, optional (controlled by `HasContext` flag)
+
+**Rationale:**
+- Allows backward compatibility with Phase 3
+- Reduces overhead for local-only routing
+- Feature flag enables gradual rollout
+
+**Future Consideration:** Make mandatory in v2.0 after migration complete
+
+---
+
+### Q2: How to handle context size exceeding MTU?
+
+**Current Answer:** Reject messages with >8 hops
+
+**Rationale:**
+- 8 hops = 75 bytes total (well under 1500 MTU)
+- Realistic mesh topologies rarely exceed 3-4 hops
+- MAX_HOPS limit prevents pathological cases
+
+**Future Enhancement:** Fragment context across multiple packets (complex)
+
+---
+
+### Q3: Should we track message type in context?
+
+**Current Answer:** No, only visited devices
+
+**Rationale:**
+- Message type already in MIDI data (first byte)
+- Context is for loop prevention, not filtering
+- Keeps context minimal (<50 bytes)
+
+**Future Enhancement:** Optional metadata extension (Phase 5)
+
+---
+
+### Q4: What happens if UuidRegistry missing a node?
+
+**Current Answer:** Throw exception, drop packet
+
+**Rationale:**
+- Indicates serious bug (connection closed but still receiving packets)
+- Better to fail fast than corrupt routing state
+- Logged as error for investigation
+
+**Mitigation:** Retry logic in NetworkConnection to re-register nodes
+
+---
+
+## References
+
+**Implementation Files:**
+- [MidiPacket.h/cpp](/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/core/MidiPacket.h)
+- [MidiRouter.h/cpp](/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/MidiRouter.h)
+- [ForwardingRule.h](/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/ForwardingRule.h)
+- [NetworkConnection.h](/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnection.h)
+
+**Design Documents:**
+- [Routing Workplan (Phases 1-3)](/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/docs/1.0/routing/implementation/workplan.md)
+- [Phase 4 Transport Report](/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/PHASE4_REPORT.md)
+
+**Testing:**
+- [Integration Test](/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/integration/mesh_midi_routing_test.sh)
+
+---
+
+## Next Steps
+
+1. **Review this design** with architecture team
+2. **Prototype context serialization** (validate performance)
+3. **Create implementation tickets** for Tasks 4.1-4.6
+4. **Set up test environment** (3-node mesh)
+5. **Begin Task 4.1** (MidiPacket extension)
+
+**Recommended Start Date:** After Phase 3 deployment to production
+
+**Target Completion:** 3 weeks from start
+
+---
+
+**Document Status:** Ready for Review
+**Approval Required:** Architecture Team, Tech Lead
+**Next Milestone:** Task 4.1 Implementation


---

_**Agent (claude-sonnet-4-5-20250929)**_

docs(midi-server): add Phase 4 multi-hop context architecture documentation

