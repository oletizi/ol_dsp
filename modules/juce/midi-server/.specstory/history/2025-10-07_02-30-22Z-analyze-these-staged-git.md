<!-- Generated by SpecStory -->

# 2025-10-07 02:30:22Z

<!-- Claude Code Session 98b0347b-50f5-4cc5-a932-5386614d1565 (2025-10-07_02-30-22Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/NetworkMidiServer.cpp b/modules/juce/midi-server/NetworkMidiServer.cpp
index ca6e1a6..b393105 100644
--- a/modules/juce/midi-server/NetworkMidiServer.cpp
+++ b/modules/juce/midi-server/NetworkMidiServer.cpp
@@ -548,6 +548,38 @@ private:
             std::cerr << "Connection failed to " << node.name.toStdString()
                       << ": " << error.toStdString() << std::endl;
         };
+
+        // Register remote devices when they are discovered
+        meshManager->onRemoteDevicesDiscovered = [this](const juce::Uuid& nodeId,
+                                                        const std::vector<NetworkMidi::DeviceInfo>& devices) {
+            std::cout << "Registering " << devices.size() << " remote devices from node "
+                      << nodeId.toString().toStdString() << std::endl;
+
+            // Add each remote device to registry and routing table
+            for (const auto& device : devices) {
+                uint16_t remoteDeviceId = device.id;
+
+                // Add to device registry as remote device
+                deviceRegistry->addRemoteDevice(
+                    nodeId,
+                    remoteDeviceId,
+                    device.name,
+                    device.type
+                );
+
+                // Add route to routing table
+                routingTable->addRoute(
+                    remoteDeviceId,
+                    nodeId,  // Route to remote node
+                    device.name,
+                    device.type
+                );
+
+                std::cout << "  Registered remote device: " << device.name.toStdString()
+                          << " (ID: " << remoteDeviceId << ", type: " << device.type.toStdString() << ")"
+                          << std::endl;
+            }
+        };
     }
 
     void handleNetworkPacket(const NetworkMidi::MidiPacket& packet) {
diff --git a/modules/juce/midi-server/network/mesh/Commands.h b/modules/juce/midi-server/network/mesh/Commands.h
index 4ca958a..64dc6ee 100644
--- a/modules/juce/midi-server/network/mesh/Commands.h
+++ b/modules/juce/midi-server/network/mesh/Commands.h
@@ -8,9 +8,12 @@
 #pragma once
 
 #include "NetworkConnection.h"
-#include <juce_events/juce_events.h>
+#include <juce_core/juce_core.h>
 #include <memory>
 #include <vector>
+#include <mutex>
+#include <condition_variable>
+#include <atomic>
 
 namespace NetworkMidi {
 namespace Commands {
@@ -77,27 +80,81 @@ struct SendMidiCommand : Command {
 
 //==============================================================================
 // Query commands with synchronous response mechanism
-// Uses juce::WaitableEvent to block caller until worker responds
+// Uses std::condition_variable for reliable cross-platform synchronization
 
 struct GetStateQuery : Command {
-    juce::WaitableEvent responseReady;
+    std::atomic<bool> ready{false};
     NetworkConnection::State result{NetworkConnection::State::Disconnected};
 
     GetStateQuery() : Command(GetState) {}
+
+    void signal() {
+        ready.store(true);
+    }
+
+    bool wait(int timeoutMs) {
+        // WORKAROUND: Use polling instead of condition_variable to avoid macOS libc++ bug
+        auto startTime = std::chrono::steady_clock::now();
+        auto timeout = std::chrono::milliseconds(timeoutMs);
+
+        while (std::chrono::steady_clock::now() - startTime < timeout) {
+            if (ready.load()) {
+                return true;
+            }
+            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        }
+        return false;
+    }
 };
 
 struct GetRemoteNodeQuery : Command {
-    juce::WaitableEvent responseReady;
+    std::atomic<bool> ready{false};
     NodeInfo result;
 
     GetRemoteNodeQuery() : Command(GetRemoteNode) {}
+
+    void signal() {
+        ready.store(true);
+    }
+
+    bool wait(int timeoutMs) {
+        // WORKAROUND: Use polling instead of condition_variable to avoid macOS libc++ bug
+        auto startTime = std::chrono::steady_clock::now();
+        auto timeout = std::chrono::milliseconds(timeoutMs);
+
+        while (std::chrono::steady_clock::now() - startTime < timeout) {
+            if (ready.load()) {
+                return true;
+            }
+            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        }
+        return false;
+    }
 };
 
 struct GetDevicesQuery : Command {
-    juce::WaitableEvent responseReady;
+    std::atomic<bool> ready{false};
     std::vector<DeviceInfo> result;
 
     GetDevicesQuery() : Command(GetDevices) {}
+
+    void signal() {
+        ready.store(true);
+    }
+
+    bool wait(int timeoutMs) {
+        // WORKAROUND: Use polling instead of condition_variable to avoid macOS libc++ bug
+        auto startTime = std::chrono::steady_clock::now();
+        auto timeout = std::chrono::milliseconds(timeoutMs);
+
+        while (std::chrono::steady_clock::now() - startTime < timeout) {
+            if (ready.load()) {
+                return true;
+            }
+            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        }
+        return false;
+    }
 };
 
 /**
@@ -105,10 +162,28 @@ struct GetDevicesQuery : Command {
  * Provides accurate timing information from worker thread.
  */
 struct GetHeartbeatQuery : Command {
-    juce::WaitableEvent responseReady;
+    std::atomic<bool> ready{false};
     int64_t timeSinceLastHeartbeat{0};
 
     GetHeartbeatQuery() : Command(GetHeartbeat) {}
+
+    void signal() {
+        ready.store(true);
+    }
+
+    bool wait(int timeoutMs) {
+        // WORKAROUND: Use polling instead of condition_variable to avoid macOS libc++ bug
+        auto startTime = std::chrono::steady_clock::now();
+        auto timeout = std::chrono::milliseconds(timeoutMs);
+
+        while (std::chrono::steady_clock::now() - startTime < timeout) {
+            if (ready.load()) {
+                return true;
+            }
+            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        }
+        return false;
+    }
 };
 
 } // namespace Commands
diff --git a/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp b/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
index 67db2bc..012d9f5 100644
--- a/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
+++ b/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
@@ -176,15 +176,67 @@ void ConnectionWorker::handleConnectCommand()
             throw std::runtime_error("Handshake response missing udp_endpoint");
         }
 
-        // Parse devices array (basic parsing for now)
+        // Parse devices array
+        remoteDevices.clear();
         size_t devicesPos = responseBody.find("\"devices\":[");
         if (devicesPos != std::string::npos) {
-            // TODO: Implement proper JSON parsing for device list
-            juce::Logger::writeToLog("Received device list from " + remoteNodeInfo.name);
-
-            // Notify callback if devices were received
-            if (onDevicesReceived) {
-                onDevicesReceived(remoteDevices);
+            size_t arrayStart = devicesPos + 11; // strlen("\"devices\":[")
+            size_t arrayEnd = responseBody.find("]", arrayStart);
+
+            if (arrayEnd != std::string::npos) {
+                std::string devicesJson = responseBody.substr(arrayStart, arrayEnd - arrayStart);
+
+                // Parse each device object (simple approach)
+                size_t pos = 0;
+                while ((pos = devicesJson.find("{", pos)) != std::string::npos) {
+                    size_t objEnd = devicesJson.find("}", pos);
+                    if (objEnd == std::string::npos) break;
+
+                    std::string deviceObj = devicesJson.substr(pos, objEnd - pos + 1);
+
+                    // Extract id
+                    uint16_t id = 0;
+                    size_t idPos = deviceObj.find("\"id\":");
+                    if (idPos != std::string::npos) {
+                        id = std::stoi(deviceObj.substr(idPos + 5));
+                    }
+
+                    // Extract name
+                    juce::String name;
+                    size_t namePos = deviceObj.find("\"name\":\"");
+                    if (namePos != std::string::npos) {
+                        size_t nameStart = namePos + 8;
+                        size_t nameEnd = deviceObj.find("\"", nameStart);
+                        if (nameEnd != std::string::npos) {
+                            name = juce::String(deviceObj.substr(nameStart, nameEnd - nameStart));
+                        }
+                    }
+
+                    // Extract type
+                    juce::String type;
+                    size_t typePos = deviceObj.find("\"type\":\"");
+                    if (typePos != std::string::npos) {
+                        size_t typeStart = typePos + 8;
+                        size_t typeEnd = deviceObj.find("\"", typeStart);
+                        if (typeEnd != std::string::npos) {
+                            type = juce::String(deviceObj.substr(typeStart, typeEnd - typeStart));
+                        }
+                    }
+
+                    if (id > 0 && name.isNotEmpty()) {
+                        remoteDevices.push_back({id, name, type});
+                    }
+
+                    pos = objEnd + 1;
+                }
+
+                juce::Logger::writeToLog("Received " + juce::String(static_cast<int>(remoteDevices.size())) +
+                                        " devices from " + remoteNodeInfo.name);
+
+                // Notify callback if devices were received
+                if (onDevicesReceived) {
+                    onDevicesReceived(remoteDevices);
+                }
             }
         }
 
@@ -385,7 +437,7 @@ void ConnectionWorker::handleGetStateQuery(Commands::GetStateQuery* query)
     query->result = currentState;
 
     // Signal response ready
-    query->responseReady.signal();
+    query->signal();
 }
 
 void ConnectionWorker::handleGetRemoteNodeQuery(Commands::GetRemoteNodeQuery* query)
@@ -396,7 +448,7 @@ void ConnectionWorker::handleGetRemoteNodeQuery(Commands::GetRemoteNodeQuery* qu
     query->result = remoteNodeInfo;
 
     // Signal response ready
-    query->responseReady.signal();
+    query->signal();
 }
 
 void ConnectionWorker::handleGetDevicesQuery(Commands::GetDevicesQuery* query)
@@ -407,7 +459,7 @@ void ConnectionWorker::handleGetDevicesQuery(Commands::GetDevicesQuery* query)
     query->result = remoteDevices;
 
     // Signal response ready
-    query->responseReady.signal();
+    query->signal();
 }
 
 void ConnectionWorker::handleGetHeartbeatQuery(Commands::GetHeartbeatQuery* query)
@@ -419,7 +471,7 @@ void ConnectionWorker::handleGetHeartbeatQuery(Commands::GetHeartbeatQuery* quer
     query->timeSinceLastHeartbeat = currentTime - lastHeartbeatTime;
 
     // Signal response ready
-    query->responseReady.signal();
+    query->signal();
 }
 
 //==============================================================================
diff --git a/modules/juce/midi-server/network/mesh/MeshManager.cpp b/modules/juce/midi-server/network/mesh/MeshManager.cpp
index 29ed01d..5d2418a 100644
--- a/modules/juce/midi-server/network/mesh/MeshManager.cpp
+++ b/modules/juce/midi-server/network/mesh/MeshManager.cpp
@@ -218,10 +218,30 @@ void MeshManager::createConnection(const NodeInfo& node)
             }
         };
 
-        connection->onDevicesReceived = [nodeInfo = node]
+        connection->onDevicesReceived = [this, nodeId = node.uuid, nodeInfo = node]
             (const std::vector<DeviceInfo>& devices) {
-            juce::Logger::writeToLog("Received " + juce::String(static_cast<int>(devices.size())) +
-                                    " devices from " + nodeInfo.name);
+            std::cout << "===== DEBUG: Lambda invoked, devices.size()=" << devices.size() << " =====" << std::endl << std::flush;
+            try {
+                std::cout << "DEBUG: About to call juce::Logger" << std::endl << std::flush;
+                juce::Logger::writeToLog("Received " + juce::String(static_cast<int>(devices.size())) +
+                                        " devices from " + nodeInfo.name);
+                std::cout << "DEBUG: juce::Logger returned" << std::endl << std::flush;
+
+                // Notify server to register remote devices
+                std::cout << "DEBUG: About to check onRemoteDevicesDiscovered callback, is null: "
+                          << (onRemoteDevicesDiscovered ? "false" : "true") << std::endl << std::flush;
+                if (onRemoteDevicesDiscovered) {
+                    std::cout << "DEBUG: Invoking onRemoteDevicesDiscovered callback" << std::endl;
+                    onRemoteDevicesDiscovered(nodeId, devices);
+                    std::cout << "DEBUG: Callback invoked" << std::endl;
+                } else {
+                    std::cout << "DEBUG: Callback was null!" << std::endl;
+                }
+            } catch (const std::exception& e) {
+                std::cout << "EXCEPTION in onDevicesReceived: " << e.what() << std::endl;
+            } catch (...) {
+                std::cout << "UNKNOWN EXCEPTION in onDevicesReceived" << std::endl;
+            }
         };
 
         connection->onMidiMessageReceived = [](const MidiMessage& msg) {
diff --git a/modules/juce/midi-server/network/mesh/MeshManager.h b/modules/juce/midi-server/network/mesh/MeshManager.h
index 33ebd6a..565579e 100644
--- a/modules/juce/midi-server/network/mesh/MeshManager.h
+++ b/modules/juce/midi-server/network/mesh/MeshManager.h
@@ -55,6 +55,8 @@ public:
         onNodeDisconnected;
     std::function<void(const NodeInfo& node, const juce::String& error)>
         onConnectionFailed;
+    std::function<void(const juce::Uuid& nodeId, const std::vector<DeviceInfo>& devices)>
+        onRemoteDevicesDiscovered;
 
     //==============================================================================
     // Constructor/Destructor
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnection.cpp b/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
index e5d2e70..c95512f 100644
--- a/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
+++ b/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
@@ -71,15 +71,34 @@ void NetworkConnection::disconnect()
 //==============================================================================
 NetworkConnection::State NetworkConnection::getState() const
 {
+    // SAFETY CHECK 1: Verify worker thread is running
+    if (!worker || !worker->isThreadRunning()) {
+        juce::Logger::writeToLog("NetworkConnection::getState() - Worker thread not running");
+        return State::Disconnected;
+    }
+
     // Use query command for thread-safe state access
     auto query = std::make_unique<Commands::GetStateQuery>();
     auto* queryPtr = query.get();
 
     commandQueue->pushCommand(std::move(query));
 
-    // Wait for response (with timeout)
-    if (queryPtr->responseReady.wait(1000)) {
-        return queryPtr->result;
+    // SAFETY CHECK 2: Validate timeout value (1ms - 60s range)
+    int timeoutMs = 1000;
+    if (timeoutMs <= 0 || timeoutMs > 60000) {
+        juce::Logger::writeToLog("NetworkConnection::getState() - Invalid timeout value");
+        return State::Disconnected;
+    }
+
+    // SAFETY CHECK 3: Wrap wait() in try-catch to handle exceptions
+    try {
+        if (queryPtr->wait(timeoutMs)) {
+            return queryPtr->result;
+        }
+    } catch (const std::exception& e) {
+        juce::Logger::writeToLog("NetworkConnection::getState() - WaitableEvent exception: " +
+                                juce::String(e.what()));
+        return State::Disconnected;
     }
 
     // Timeout - return Disconnected as safe default
@@ -90,13 +109,33 @@ NetworkConnection::State NetworkConnection::getState() const
 //==============================================================================
 NodeInfo NetworkConnection::getRemoteNode() const
 {
+    // SAFETY CHECK 1: Verify worker thread is running
+    if (!worker || !worker->isThreadRunning()) {
+        juce::Logger::writeToLog("NetworkConnection::getRemoteNode() - Worker thread not running");
+        return remoteNodeInfo;
+    }
+
     auto query = std::make_unique<Commands::GetRemoteNodeQuery>();
     auto* queryPtr = query.get();
 
     commandQueue->pushCommand(std::move(query));
 
-    if (queryPtr->responseReady.wait(1000)) {
-        return queryPtr->result;
+    // SAFETY CHECK 2: Validate timeout value
+    int timeoutMs = 1000;
+    if (timeoutMs <= 0 || timeoutMs > 60000) {
+        juce::Logger::writeToLog("NetworkConnection::getRemoteNode() - Invalid timeout value");
+        return remoteNodeInfo;
+    }
+
+    // SAFETY CHECK 3: Wrap wait() in try-catch
+    try {
+        if (queryPtr->wait(timeoutMs)) {
+            return queryPtr->result;
+        }
+    } catch (const std::exception& e) {
+        juce::Logger::writeToLog("NetworkConnection::getRemoteNode() - WaitableEvent exception: " +
+                                juce::String(e.what()));
+        return remoteNodeInfo;
     }
 
     // Timeout - return initial node info
@@ -107,13 +146,33 @@ NodeInfo NetworkConnection::getRemoteNode() const
 //==============================================================================
 std::vector<DeviceInfo> NetworkConnection::getRemoteDevices() const
 {
+    // SAFETY CHECK 1: Verify worker thread is running
+    if (!worker || !worker->isThreadRunning()) {
+        juce::Logger::writeToLog("NetworkConnection::getRemoteDevices() - Worker thread not running");
+        return {};
+    }
+
     auto query = std::make_unique<Commands::GetDevicesQuery>();
     auto* queryPtr = query.get();
 
     commandQueue->pushCommand(std::move(query));
 
-    if (queryPtr->responseReady.wait(1000)) {
-        return queryPtr->result;
+    // SAFETY CHECK 2: Validate timeout value
+    int timeoutMs = 1000;
+    if (timeoutMs <= 0 || timeoutMs > 60000) {
+        juce::Logger::writeToLog("NetworkConnection::getRemoteDevices() - Invalid timeout value");
+        return {};
+    }
+
+    // SAFETY CHECK 3: Wrap wait() in try-catch
+    try {
+        if (queryPtr->wait(timeoutMs)) {
+            return queryPtr->result;
+        }
+    } catch (const std::exception& e) {
+        juce::Logger::writeToLog("NetworkConnection::getRemoteDevices() - WaitableEvent exception: " +
+                                juce::String(e.what()));
+        return {};
     }
 
     // Timeout - return empty vector
@@ -137,15 +196,34 @@ void NetworkConnection::sendMidiMessage(uint16_t deviceId,
 //==============================================================================
 int64_t NetworkConnection::getTimeSinceLastHeartbeat() const
 {
+    // SAFETY CHECK 1: Verify worker thread is running
+    if (!worker || !worker->isThreadRunning()) {
+        juce::Logger::writeToLog("NetworkConnection::getTimeSinceLastHeartbeat() - Worker thread not running");
+        return HEARTBEAT_TIMEOUT_MS + 1;  // Return value indicating disconnected
+    }
+
     // Use GetHeartbeatQuery command for accurate timing from worker thread
     auto query = std::make_unique<Commands::GetHeartbeatQuery>();
     auto* queryPtr = query.get();
 
     commandQueue->pushCommand(std::move(query));
 
-    // Wait for response (with timeout)
-    if (queryPtr->responseReady.wait(1000)) {
-        return queryPtr->timeSinceLastHeartbeat;
+    // SAFETY CHECK 2: Validate timeout value
+    int timeoutMs = 1000;
+    if (timeoutMs <= 0 || timeoutMs > 60000) {
+        juce::Logger::writeToLog("NetworkConnection::getTimeSinceLastHeartbeat() - Invalid timeout value");
+        return HEARTBEAT_TIMEOUT_MS + 1;
+    }
+
+    // SAFETY CHECK 3: Wrap wait() in try-catch
+    try {
+        if (queryPtr->wait(timeoutMs)) {
+            return queryPtr->timeSinceLastHeartbeat;
+        }
+    } catch (const std::exception& e) {
+        juce::Logger::writeToLog("NetworkConnection::getTimeSinceLastHeartbeat() - WaitableEvent exception: " +
+                                juce::String(e.what()));
+        return HEARTBEAT_TIMEOUT_MS + 1;
     }
 
     // Timeout - assume disconnected (return value > timeout threshold)
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp
index 9423f52..7aae1a8 100644
--- a/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp
+++ b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp
@@ -5,6 +5,7 @@
  */
 
 #include "NetworkConnectionQueue.h"
+#include <chrono>
 
 namespace NetworkMidi {
 
@@ -15,33 +16,34 @@ void NetworkConnectionQueue::pushCommand(std::unique_ptr<Commands::Command> cmd)
         commandQueue.push_back(std::move(cmd));
     }
 
-    // Signal event AFTER releasing lock to avoid waking worker while we hold lock
-    queueEvent.signal();
+    // Notify waiting thread
+    queueCondition.notify_one();
 }
 
 std::unique_ptr<Commands::Command> NetworkConnectionQueue::waitAndPop(int timeoutMs)
 {
-    // Wait for signal with timeout
-    if (!queueEvent.wait(timeoutMs)) {
-        return nullptr;  // Timeout - no command available
+    // WORKAROUND: Use polling instead of condition_variable to avoid macOS libc++ bug
+    // macOS libc++ has a bug where condition_variable::wait_for throws
+    // "Invalid argument" exception on repeated calls
+
+    auto startTime = std::chrono::steady_clock::now();
+    auto timeout = std::chrono::milliseconds(timeoutMs);
+
+    while (std::chrono::steady_clock::now() - startTime < timeout) {
+        {
+            std::lock_guard<std::mutex> lock(queueMutex);
+            if (!commandQueue.empty()) {
+                auto cmd = std::move(commandQueue.front());
+                commandQueue.pop_front();
+                return cmd;
+            }
+        }
+
+        // Sleep for 1ms to avoid busy-waiting
+        std::this_thread::sleep_for(std::chrono::milliseconds(1));
     }
 
-    std::lock_guard<std::mutex> lock(queueMutex);
-
-    if (commandQueue.empty()) {
-        return nullptr;  // Spurious wakeup - no command
-    }
-
-    // Move command out of queue
-    auto cmd = std::move(commandQueue.front());
-    commandQueue.pop_front();
-
-    // If more commands remain, re-signal event
-    if (!commandQueue.empty()) {
-        queueEvent.signal();
-    }
-
-    return cmd;
+    return nullptr;  // Timeout
 }
 
 size_t NetworkConnectionQueue::size() const
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h
index 941d18a..c9b20b0 100644
--- a/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h
+++ b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h
@@ -8,16 +8,17 @@
 #pragma once
 
 #include "Commands.h"
-#include <juce_events/juce_events.h>
+#include <juce_core/juce_core.h>
 #include <deque>
 #include <memory>
 #include <mutex>
+#include <condition_variable>
 
 namespace NetworkMidi {
 
 //==============================================================================
 /**
- * Thread-safe command queue using juce::WaitableEvent for blocking operations.
+ * Thread-safe command queue using std::condition_variable for blocking operations.
  *
  * Design:
  * - Multi-producer safe: Any thread can push commands
@@ -61,8 +62,8 @@ public:
 
 private:
     mutable std::mutex queueMutex;
+    std::condition_variable queueCondition;
     std::deque<std::unique_ptr<Commands::Command>> commandQueue;
-    juce::WaitableEvent queueEvent;
 
     JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(NetworkConnectionQueue)
 };
diff --git a/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp b/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp
index 44339e1..3393466 100644
--- a/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp
+++ b/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp
@@ -203,7 +203,7 @@ TEST(NetworkConnectionQueueTest, QueryCommandWithResponse) {
         // Process query
         auto* query = static_cast<Commands::GetStateQuery*>(cmd.get());
         query->result = NetworkConnection::State::Connected;
-        query->responseReady.signal();
+        query->signal();
     });
 
     // Main thread sends query and waits for response
@@ -213,7 +213,7 @@ TEST(NetworkConnectionQueueTest, QueryCommandWithResponse) {
     queue.pushCommand(std::move(query));
 
     // Wait for response (with timeout)
-    bool gotResponse = queryPtr->responseReady.wait(1000);
+    bool gotResponse = queryPtr->wait(1000);
     EXPECT_TRUE(gotResponse);
     EXPECT_EQ(queryPtr->result, NetworkConnection::State::Connected);
 
@@ -236,7 +236,7 @@ TEST(NetworkConnectionQueueTest, MultipleQueriesConcurrent) {
                 query->result.name = "TestNode";
                 query->result.uuid = juce::Uuid();
 
-                query->responseReady.signal();
+                query->signal();
                 queriesProcessed.fetch_add(1, std::memory_order_relaxed);
             }
         }
@@ -251,7 +251,7 @@ TEST(NetworkConnectionQueueTest, MultipleQueriesConcurrent) {
 
             queue.pushCommand(std::move(query));
 
-            bool gotResponse = queryPtr->responseReady.wait(2000);
+            bool gotResponse = queryPtr->wait(2000);
             EXPECT_TRUE(gotResponse);
             EXPECT_EQ(queryPtr->result.name, "TestNode");
         });


---

_**Agent (claude-sonnet-4-5-20250929)**_

fix(midi-server): replace juce::WaitableEvent with polling to avoid macOS libc++ condition_variable bug

