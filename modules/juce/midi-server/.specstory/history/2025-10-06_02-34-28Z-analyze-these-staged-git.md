<!-- Generated by SpecStory -->

# 2025-10-06 02:34:28Z

<!-- Claude Code Session 6cfa77c9-e284-4eb1-8aff-2e03ba162570 (2025-10-06_02-34-28Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/CMakeLists.txt b/modules/juce/midi-server/CMakeLists.txt
index fd7f553..719852f 100644
--- a/modules/juce/midi-server/CMakeLists.txt
+++ b/modules/juce/midi-server/CMakeLists.txt
@@ -150,6 +150,41 @@ elseif(WIN32)
     # Windows - Bonjour (when implemented)
 endif()
 
+# Performance Benchmarks - Measure Network MIDI Mesh performance
+juce_add_console_app(network_midi_benchmarks
+    PRODUCT_NAME "Network MIDI Benchmarks"
+)
+
+target_sources(network_midi_benchmarks
+    PRIVATE
+    network/benchmarks/PerformanceBenchmark.cpp
+    ${CORE_SOURCES}
+    ${MESH_SOURCES}
+    ${TRANSPORT_SOURCES}
+    ${ROUTING_SOURCES}
+)
+
+target_compile_definitions(network_midi_benchmarks
+    PRIVATE
+    JUCE_WEB_BROWSER=0
+    JUCE_USE_CURL=0
+)
+
+target_include_directories(network_midi_benchmarks
+    PRIVATE
+    ${CMAKE_CURRENT_SOURCE_DIR}
+)
+
+target_link_libraries(network_midi_benchmarks
+    PRIVATE
+    juce::juce_core
+    juce::juce_audio_devices
+    juce::juce_events
+    PUBLIC
+    juce::juce_recommended_config_flags
+    juce::juce_recommended_warning_flags
+)
+
 # Unit Tests with Google Test and Coverage
 # Note: Google Test is already configured in the parent project's test/ directory
 # No need to fetch it again - just use the existing targets
diff --git a/modules/juce/midi-server/network/benchmarks/BENCHMARK_RESULTS.md b/modules/juce/midi-server/network/benchmarks/BENCHMARK_RESULTS.md
new file mode 100644
index 0000000..ae93cab
--- /dev/null
+++ b/modules/juce/midi-server/network/benchmarks/BENCHMARK_RESULTS.md
@@ -0,0 +1,342 @@
+# Network MIDI Mesh - Performance Benchmark Results
+
+**Date**: 2025-10-05
+**Platform**: macOS 14.6.0 (Darwin 24.6.0)
+**Compiler**: Apple Clang (JUCE default optimizations)
+**Build**: Debug/Default (not optimized)
+
+## Executive Summary
+
+The Network MIDI Mesh implementation demonstrates **excellent performance** across all critical paths:
+
+- **Packet serialization**: 516 ns avg (target: < 1 μs) ✓ PASS
+- **Packet deserialization**: 383-599 ns avg (target: < 1 μs) ✓ PASS
+- **Buffer reordering**: 251 ns avg (target: < 5 μs) ✓ PASS
+- **Throughput**: 646,818 msgs/sec single-threaded
+- **Lookup operations**: 153-208 ns avg (target: < 100 ns) ✗ MARGINAL
+
+### Key Findings
+
+1. **Serialization/deserialization performance exceeds targets by 2x**
+2. **Buffer reordering is 20x faster than target** (251 ns vs 5 μs)
+3. **Lookup operations slightly exceed target** (150-200 ns vs 100 ns target)
+4. **Memory footprint is minimal** (~25 KB for 1000 buffered messages)
+5. **Throughput excellent** at 646K msgs/sec single-threaded
+
+---
+
+## 1. Packet Serialization/Deserialization
+
+### Minimal Packet (3 bytes - Note On)
+
+| Operation | Min | Avg | Max | p95 | p99 | Target | Status |
+|-----------|-----|-----|-----|-----|-----|--------|--------|
+| **Serialization** | 375 ns | 516 ns | 9.7 μs | 583 ns | 750 ns | 1 μs | ✓ PASS |
+| **Deserialization** | 291 ns | 383 ns | 5.1 μs | 417 ns | 500 ns | 1 μs | ✓ PASS |
+
+### Average Packet (6 bytes - CC messages)
+
+| Operation | Min | Avg | Max | p95 | p99 | Target | Status |
+|-----------|-----|-----|-----|-----|-----|--------|--------|
+| **Serialization** | 375 ns | 500 ns | 1.1 μs | 583 ns | 666 ns | 1 μs | ✓ PASS |
+| **Deserialization** | 291 ns | 389 ns | 19.8 μs | 458 ns | 500 ns | 1 μs | ✓ PASS |
+
+### Large Packet (64 bytes - SysEx)
+
+| Operation | Min | Avg | Max | p95 | p99 | Target | Status |
+|-----------|-----|-----|-----|-----|-----|--------|--------|
+| **Serialization** | 375 ns | 491 ns | 6.3 μs | 625 ns | 667 ns | 1 μs | ✓ PASS |
+| **Deserialization** | 500 ns | 599 ns | 12.6 μs | 667 ns | 792 ns | 1 μs | ✓ PASS |
+
+**Analysis**:
+- All packet sizes meet the < 1 μs target comfortably
+- Serialization is ~100-200 ns faster than deserialization (expected)
+- SysEx (64 bytes) only adds ~100 ns compared to minimal packets
+- Max latencies show occasional outliers (likely GC or scheduler preemption)
+- **Verdict**: Excellent performance, ready for real-time MIDI
+
+---
+
+## 2. UDP Transport Latency
+
+### Packet Preparation (Create + Serialize)
+
+| Metric | Value |
+|--------|-------|
+| **Average** | 936 ns |
+| **Min** | 750 ns |
+| **Max** | 9.5 μs |
+| **p95** | 1.08 μs |
+| **p99** | 1.21 μs |
+
+**Note**: Full UDP round-trip testing requires running server with event loop.
+Target: < 100 μs localhost RTT (requires integration testing)
+
+**Analysis**:
+- Packet preparation overhead is < 1 μs on average
+- This leaves ~99 μs budget for actual UDP send/receive
+- Integration tests with live UDP sockets needed for full RTT measurement
+
+---
+
+## 3. Message Buffer Reordering
+
+### In-Order Delivery (Best Case)
+
+| Metric | Value |
+|--------|-------|
+| **Average** | 413 ns |
+| **Min** | 166 ns |
+| **Max** | 11.0 μs |
+| **Delivered** | 1000/1000 packets |
+
+### Out-of-Order Reordering (Worst Case - Reverse Order)
+
+| Metric | Value | Target | Status |
+|--------|-------|--------|--------|
+| **Average** | 251 ns | 5 μs | ✓ PASS |
+| **Min** | 125 ns | - | - |
+| **Max** | 1.29 μs | - | - |
+| **p95** | 334 ns | - | - |
+| **Delivered** | 1/100 packets | - | - |
+
+### Large Buffer (1000 packets out-of-order)
+
+| Metric | Value |
+|--------|-------|
+| **Average** | 411 ns |
+| **Min** | 166 ns |
+| **Max** | 1.71 μs |
+| **p95** | 542 ns |
+
+**Analysis**:
+- In-order delivery is **extremely fast** (~400 ns)
+- Out-of-order reordering beats target by **20x** (251 ns vs 5 μs)
+- Buffer scales well even with 1000 packets (411 ns avg)
+- MessageBuffer uses `std::map` which gives O(log n) lookups
+- **Verdict**: Buffer reordering will not be a bottleneck
+
+---
+
+## 4. Device/Route Lookup Performance
+
+### 10 Devices
+
+| Component | Avg | Target | Status |
+|-----------|-----|--------|--------|
+| **DeviceRegistry** | 153 ns | 100 ns | ✗ FAIL (1.5x) |
+| **RoutingTable** | 157 ns | 100 ns | ✗ FAIL (1.6x) |
+
+### 50 Devices
+
+| Component | Avg | Target | Status |
+|-----------|-----|--------|--------|
+| **DeviceRegistry** | 208 ns | 100 ns | ✗ FAIL (2.1x) |
+| **RoutingTable** | 208 ns | 100 ns | ✗ FAIL (2.1x) |
+
+### 100 Devices
+
+| Component | Avg | Target | Status |
+|-----------|-----|--------|--------|
+| **DeviceRegistry** | 187 ns | 100 ns | ✗ FAIL (1.9x) |
+| **RoutingTable** | 188 ns | 100 ns | ✗ FAIL (1.9x) |
+
+**Analysis**:
+- Lookup times are 1.5-2x slower than target (150-208 ns vs 100 ns)
+- Performance **does not degrade** as device count increases (good!)
+- Both use `std::map` with O(log n) lookup (expected ~7 comparisons for 100 devices)
+- Mutex lock overhead likely contributes ~50-100 ns
+- **Verdict**: MARGINAL - acceptable for typical use cases (< 1 μs), but room for optimization
+
+**Optimization opportunities** (if needed):
+1. Replace `std::map` with `std::unordered_map` for O(1) lookups
+2. Use lock-free data structures (e.g., `std::atomic` with RCU pattern)
+3. Cache frequently accessed devices
+4. Use reader-writer locks instead of mutex
+
+---
+
+## 5. Memory Footprint
+
+### Data Structure Sizes
+
+| Structure | Size (bytes) |
+|-----------|--------------|
+| **MidiPacket** | 80 |
+| **MessageBuffer** | 424 |
+| **DeviceRegistry** | 96 |
+| **RoutingTable** | 88 |
+| **juce::Uuid** | 16 |
+
+### Per-Packet Overhead
+
+| Component | Size (bytes) |
+|-----------|--------------|
+| **Header** | 20 |
+| **Sample MIDI data** | 3 |
+| **Total serialized** | 23 |
+| **In-memory object** | 80 |
+
+### Buffered Messages (1000 packets)
+
+| Component | Size |
+|-----------|------|
+| **Serialized data** | ~25 KB |
+| **With std::map overhead** | ~38 KB |
+
+### Device/Route Storage (100 devices)
+
+| Component | Size |
+|-----------|------|
+| **Total** | ~12 KB |
+
+**Analysis**:
+- Memory footprint is **minimal and acceptable**
+- 1000 buffered messages = ~38 KB (negligible on modern systems)
+- 100 devices = ~12 KB (trivial)
+- In-memory MidiPacket (80 bytes) is larger than serialized (23 bytes) due to std::vector overhead
+- **Verdict**: Memory usage is not a concern
+
+---
+
+## 6. Message Throughput
+
+### Single-Threaded End-to-End Processing
+
+| Metric | Value |
+|--------|-------|
+| **Total messages** | 100,000 |
+| **Total time** | 154.6 ms |
+| **Throughput** | 646,818 msgs/sec |
+| **Avg per message** | 1.55 μs |
+
+**Processing pipeline**: Create packet → Serialize → Deserialize
+
+**Analysis**:
+- **646K msgs/sec** is excellent single-threaded performance
+- At 31.25 μs MIDI clock resolution, this is **20x faster than MIDI timing**
+- Multi-threaded server will achieve even higher throughput
+- Network bandwidth (not CPU) will likely be the bottleneck in production
+
+**Extrapolation**:
+- 1 Gbps network = ~125 MB/s
+- At ~23 bytes/packet = ~5.4M packets/sec theoretical max
+- CPU can handle 646K msgs/sec × N threads
+- **Bottleneck**: Network bandwidth, not CPU processing
+
+---
+
+## Performance Bottlenecks Identified
+
+### 1. Lookup Operations (MARGINAL)
+
+**Issue**: DeviceRegistry and RoutingTable lookups are 1.5-2x slower than target (150-208 ns vs 100 ns)
+
+**Impact**: LOW
+- Still < 1 μs, acceptable for MIDI timing
+- Does not degrade with device count
+
+**Recommendations**:
+1. **If needed**: Replace `std::map` with `std::unordered_map` for O(1) lookups
+2. **If needed**: Use lock-free structures (RCU pattern with `std::atomic<std::shared_ptr>`)
+3. Monitor in production - may not need optimization
+
+### 2. No Other Bottlenecks Identified
+
+All other components exceed performance targets:
+- Serialization: 2x faster than target
+- Deserialization: 2x faster than target
+- Buffer reordering: 20x faster than target
+- Throughput: Exceeds MIDI timing requirements by 20x
+
+---
+
+## Comparison to Performance Targets
+
+| Component | Target | Actual | Margin | Status |
+|-----------|--------|--------|--------|--------|
+| **Serialization** | < 1 μs | 491-516 ns | 2x faster | ✓ PASS |
+| **Deserialization** | < 1 μs | 383-599 ns | 1.7-2.6x faster | ✓ PASS |
+| **Buffer reordering** | < 5 μs | 251 ns | 20x faster | ✓ PASS |
+| **Lookup operations** | < 100 ns | 153-208 ns | 1.5-2x slower | ✗ MARGINAL |
+| **RTT (localhost)** | < 100 μs | Not tested | - | Integration test |
+
+---
+
+## Recommendations
+
+### 1. Production Optimizations
+
+Enable compiler optimizations for production builds:
+
+```cmake
+# Release build with optimizations
+cmake -DCMAKE_BUILD_TYPE=Release -B build -S .
+
+# Or aggressive optimizations
+set(CMAKE_CXX_FLAGS_RELEASE "-O3 -march=native -DNDEBUG")
+```
+
+**Expected improvements with -O3**:
+- Serialization: ~250-300 ns (2x faster)
+- Deserialization: ~200-250 ns (2x faster)
+- Lookups: ~80-120 ns (1.5x faster, may meet target)
+
+### 2. Lookup Optimization (Optional)
+
+If lookup performance becomes critical:
+
+```cpp
+// Replace std::map with std::unordered_map
+std::unordered_map<uint16_t, MidiDevice> devices;  // O(1) lookup
+std::unordered_map<uint16_t, Route> routes;        // O(1) lookup
+```
+
+### 3. Integration Testing
+
+Next steps:
+1. **UDP round-trip latency** - measure actual localhost RTT with running server
+2. **Multi-threaded throughput** - test with concurrent connections
+3. **Network stress testing** - packet loss, reordering, high latency scenarios
+4. **Real MIDI devices** - end-to-end latency with actual hardware
+
+### 4. Profiling Recommendations
+
+For further optimization:
+1. Run with Instruments (macOS) to identify hotspots
+2. Use `perf` (Linux) or VTune (Intel) for CPU profiling
+3. Profile with realistic workloads (multiple connections, high message rates)
+
+---
+
+## Conclusion
+
+The Network MIDI Mesh implementation **exceeds performance targets** in nearly all areas:
+
+✅ **Serialization**: 2x faster than target
+✅ **Deserialization**: 2x faster than target
+✅ **Buffer reordering**: 20x faster than target
+✅ **Throughput**: 646K msgs/sec (far exceeds MIDI timing requirements)
+✅ **Memory**: Minimal footprint (~38 KB for 1000 messages)
+⚠️ **Lookups**: 1.5-2x slower than target (but still < 1 μs, acceptable)
+
+### Performance Verdict: EXCELLENT
+
+The implementation is **production-ready** from a performance perspective:
+- All critical paths are sub-microsecond
+- Throughput exceeds MIDI requirements by 20x
+- Memory usage is negligible
+- Scales well with device count
+
+### Next Steps
+
+1. Enable compiler optimizations (-O3) for production
+2. Run integration tests for UDP RTT measurement
+3. Consider lookup optimization if monitoring reveals issues
+4. Profile under realistic multi-threaded workloads
+
+---
+
+**Benchmark Suite**: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/benchmarks/PerformanceBenchmark.cpp`
+**Build Command**: `cmake --build build --target network_midi_benchmarks`
+**Run Command**: `./build/modules/juce/midi-server/network_midi_benchmarks_artefacts/network_midi_benchmarks`
diff --git a/modules/juce/midi-server/network/benchmarks/PerformanceBenchmark.cpp b/modules/juce/midi-server/network/benchmarks/PerformanceBenchmark.cpp
new file mode 100644
index 0000000..128489a
--- /dev/null
+++ b/modules/juce/midi-server/network/benchmarks/PerformanceBenchmark.cpp
@@ -0,0 +1,467 @@
+/**
+ * PerformanceBenchmark.cpp
+ *
+ * Comprehensive performance benchmarking suite for Network MIDI Mesh.
+ * Measures critical path performance: serialization, transport, buffering,
+ * routing lookups, and memory usage.
+ */
+
+#include "../core/MidiPacket.h"
+#include "../core/NodeIdentity.h"
+#include "../transport/MessageBuffer.h"
+#include "../transport/UdpMidiTransport.h"
+#include "../routing/DeviceRegistry.h"
+#include "../routing/RoutingTable.h"
+
+#include <juce_core/juce_core.h>
+#include <juce_events/juce_events.h>
+
+#include <chrono>
+#include <iostream>
+#include <iomanip>
+#include <vector>
+#include <algorithm>
+#include <cmath>
+#include <memory>
+
+using namespace NetworkMidi;
+using namespace std::chrono;
+
+// Performance targets from workplan
+namespace PerformanceTargets {
+    constexpr int64_t SERIALIZATION_TARGET_NS = 1000;      // < 1μs
+    constexpr int64_t DESERIALIZATION_TARGET_NS = 1000;    // < 1μs
+    constexpr int64_t BUFFER_REORDER_TARGET_NS = 5000;     // < 5μs
+    constexpr int64_t LOOKUP_TARGET_NS = 100;              // < 100ns
+    constexpr int64_t RTT_LOCALHOST_TARGET_US = 100;       // < 100μs
+}
+
+// Statistics accumulator
+struct BenchmarkStats {
+    std::vector<int64_t> measurements;
+
+    void record(int64_t value) {
+        measurements.push_back(value);
+    }
+
+    void clear() {
+        measurements.clear();
+    }
+
+    int64_t min() const {
+        return measurements.empty() ? 0 : *std::min_element(measurements.begin(), measurements.end());
+    }
+
+    int64_t max() const {
+        return measurements.empty() ? 0 : *std::max_element(measurements.begin(), measurements.end());
+    }
+
+    double mean() const {
+        if (measurements.empty()) return 0.0;
+        double sum = 0.0;
+        for (auto v : measurements) sum += v;
+        return sum / measurements.size();
+    }
+
+    int64_t percentile(double p) const {
+        if (measurements.empty()) return 0;
+        auto sorted = measurements;
+        std::sort(sorted.begin(), sorted.end());
+        size_t idx = static_cast<size_t>(sorted.size() * p / 100.0);
+        if (idx >= sorted.size()) idx = sorted.size() - 1;
+        return sorted[idx];
+    }
+
+    double stddev() const {
+        if (measurements.size() < 2) return 0.0;
+        double avg = mean();
+        double variance = 0.0;
+        for (auto v : measurements) {
+            double diff = v - avg;
+            variance += diff * diff;
+        }
+        return std::sqrt(variance / measurements.size());
+    }
+};
+
+// Output formatting helpers
+void printHeader(const std::string& title) {
+    std::cout << "\n" << std::string(70, '=') << "\n";
+    std::cout << "  " << title << "\n";
+    std::cout << std::string(70, '=') << "\n\n";
+}
+
+void printStats(const std::string& name, const BenchmarkStats& stats,
+                const std::string& unit, int64_t target = -1) {
+    std::cout << std::left << std::setw(30) << name << ": ";
+    std::cout << std::right << std::setw(8) << stats.min() << " " << unit << " (min)  ";
+    std::cout << std::setw(8) << static_cast<int64_t>(stats.mean()) << " " << unit << " (avg)  ";
+    std::cout << std::setw(8) << stats.max() << " " << unit << " (max)\n";
+    std::cout << std::setw(30) << "" << "  ";
+    std::cout << std::setw(8) << stats.percentile(95) << " " << unit << " (p95)  ";
+    std::cout << std::setw(8) << stats.percentile(99) << " " << unit << " (p99)  ";
+    std::cout << std::setw(8) << static_cast<int64_t>(stats.stddev()) << " " << unit << " (σ)\n";
+
+    if (target > 0) {
+        int64_t avg = static_cast<int64_t>(stats.mean());
+        std::string status = avg <= target ? "✓ PASS" : "✗ FAIL";
+        std::cout << std::setw(30) << "" << "  Target: " << target << " " << unit
+                  << "  Status: " << status << "\n";
+    }
+    std::cout << "\n";
+}
+
+// Benchmark 1: Packet Serialization/Deserialization
+void benchmarkPacketSerialization() {
+    printHeader("1. Packet Serialization/Deserialization Performance");
+
+    const int iterations = 10000;
+    juce::Uuid sourceNode;
+    juce::Uuid destNode;
+
+    // Test different packet sizes
+    std::vector<std::pair<std::string, std::vector<uint8_t>>> testCases = {
+        {"Minimal (3 bytes)", {0x90, 0x3C, 0x7F}},  // Note On
+        {"Average (6 bytes)", {0xB0, 0x07, 0x64, 0xB0, 0x0A, 0x40}},  // CC messages
+        {"SysEx (64 bytes)", std::vector<uint8_t>(64, 0xF0)}  // Large SysEx
+    };
+
+    for (const auto& [name, midiData] : testCases) {
+        std::cout << "Test case: " << name << "\n\n";
+
+        // Serialization benchmark
+        BenchmarkStats serializeStats;
+        for (int i = 0; i < iterations; i++) {
+            auto packet = MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, i);
+
+            auto start = high_resolution_clock::now();
+            auto serialized = packet.serialize();
+            auto end = high_resolution_clock::now();
+
+            serializeStats.record(duration_cast<nanoseconds>(end - start).count());
+        }
+        printStats("Serialization", serializeStats, "ns", PerformanceTargets::SERIALIZATION_TARGET_NS);
+
+        // Deserialization benchmark
+        BenchmarkStats deserializeStats;
+        auto packet = MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, 0);
+        auto serialized = packet.serialize();
+
+        for (int i = 0; i < iterations; i++) {
+            auto start = high_resolution_clock::now();
+            auto deserialized = MidiPacket::deserialize(serialized.data(), serialized.size());
+            auto end = high_resolution_clock::now();
+
+            deserializeStats.record(duration_cast<nanoseconds>(end - start).count());
+        }
+        printStats("Deserialization", deserializeStats, "ns", PerformanceTargets::DESERIALIZATION_TARGET_NS);
+    }
+}
+
+// Benchmark 2: UDP Transport Latency
+void benchmarkUdpTransport() {
+    printHeader("2. UDP Transport Latency (Localhost)");
+
+    // This requires message loop, so we use a simpler packet creation benchmark
+    std::cout << "Note: Full UDP round-trip requires event loop (run with NetworkMidiServer)\n";
+    std::cout << "Measuring packet preparation overhead instead:\n\n";
+
+    const int iterations = 10000;
+    juce::Uuid sourceNode;
+    juce::Uuid destNode;
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x7F};
+
+    BenchmarkStats packetPrepStats;
+
+    for (int i = 0; i < iterations; i++) {
+        auto start = high_resolution_clock::now();
+        auto packet = MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, i);
+        auto serialized = packet.serialize();
+        auto end = high_resolution_clock::now();
+
+        packetPrepStats.record(duration_cast<nanoseconds>(end - start).count());
+    }
+
+    printStats("Packet prep (create+serialize)", packetPrepStats, "ns");
+
+    std::cout << "For actual RTT measurement, see integration tests with running server.\n";
+    std::cout << "Target: < " << PerformanceTargets::RTT_LOCALHOST_TARGET_US << " μs round-trip\n\n";
+}
+
+// Benchmark 3: Message Buffer Performance
+void benchmarkMessageBuffer() {
+    printHeader("3. Message Buffer Reordering Performance");
+
+    const int iterations = 1000;
+    juce::Uuid sourceNode;
+    juce::Uuid destNode;
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x7F};
+
+    // Test 1: In-order delivery (best case)
+    {
+        MessageBuffer::Config config;
+        config.maxBufferSize = 100;
+        MessageBuffer buffer(config);
+
+        BenchmarkStats inOrderStats;
+        int deliveredCount = 0;
+
+        buffer.onPacketReady = [&deliveredCount](const MidiPacket&) {
+            deliveredCount++;
+        };
+
+        for (int i = 0; i < iterations; i++) {
+            auto packet = MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, i);
+
+            auto start = high_resolution_clock::now();
+            buffer.addPacket(packet);
+            auto end = high_resolution_clock::now();
+
+            inOrderStats.record(duration_cast<nanoseconds>(end - start).count());
+        }
+
+        printStats("In-order delivery", inOrderStats, "ns");
+        std::cout << "Packets delivered: " << deliveredCount << "/" << iterations << "\n\n";
+    }
+
+    // Test 2: Out-of-order delivery (worst case)
+    {
+        MessageBuffer::Config config;
+        config.maxBufferSize = 100;
+        MessageBuffer buffer(config);
+
+        // Create packets in reverse order
+        std::vector<MidiPacket> packets;
+        for (int i = 0; i < 100; i++) {
+            packets.push_back(MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, i));
+        }
+        std::reverse(packets.begin(), packets.end());
+
+        BenchmarkStats outOfOrderStats;
+        int deliveredCount = 0;
+
+        buffer.onPacketReady = [&deliveredCount](const MidiPacket&) {
+            deliveredCount++;
+        };
+
+        for (const auto& packet : packets) {
+            auto start = high_resolution_clock::now();
+            buffer.addPacket(packet);
+            auto end = high_resolution_clock::now();
+
+            outOfOrderStats.record(duration_cast<nanoseconds>(end - start).count());
+        }
+
+        printStats("Out-of-order reordering", outOfOrderStats, "ns",
+                   PerformanceTargets::BUFFER_REORDER_TARGET_NS);
+        std::cout << "Packets delivered: " << deliveredCount << "/" << packets.size() << "\n\n";
+    }
+
+    // Test 3: Buffer with many packets
+    {
+        MessageBuffer::Config config;
+        config.maxBufferSize = 1000;
+        MessageBuffer buffer(config);
+
+        BenchmarkStats largeBufferStats;
+
+        // Fill buffer with out-of-order packets
+        for (int i = 999; i >= 0; i--) {
+            auto packet = MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, i);
+
+            auto start = high_resolution_clock::now();
+            buffer.addPacket(packet);
+            auto end = high_resolution_clock::now();
+
+            largeBufferStats.record(duration_cast<nanoseconds>(end - start).count());
+        }
+
+        printStats("Large buffer (1000 packets)", largeBufferStats, "ns");
+    }
+}
+
+// Benchmark 4: Device/Route Lookup Performance
+void benchmarkLookups() {
+    printHeader("4. Device/Route Lookup Performance");
+
+    const std::vector<int> deviceCounts = {10, 50, 100};
+
+    for (int deviceCount : deviceCounts) {
+        std::cout << "Device count: " << deviceCount << "\n\n";
+
+        // DeviceRegistry benchmark
+        {
+            DeviceRegistry registry;
+            juce::Uuid nodeId;
+
+            // Populate registry
+            for (int i = 0; i < deviceCount; i++) {
+                registry.addLocalDevice(i, "Device " + juce::String(i), "output");
+            }
+
+            BenchmarkStats lookupStats;
+            const int iterations = 10000;
+
+            for (int i = 0; i < iterations; i++) {
+                uint16_t deviceId = i % deviceCount;
+
+                auto start = high_resolution_clock::now();
+                auto device = registry.getDevice(deviceId);
+                auto end = high_resolution_clock::now();
+
+                lookupStats.record(duration_cast<nanoseconds>(end - start).count());
+            }
+
+            printStats("DeviceRegistry lookup", lookupStats, "ns",
+                       PerformanceTargets::LOOKUP_TARGET_NS);
+        }
+
+        // RoutingTable benchmark
+        {
+            RoutingTable routingTable;
+            juce::Uuid nodeId;
+
+            // Populate routing table
+            for (int i = 0; i < deviceCount; i++) {
+                routingTable.addRoute(i, nodeId, "Device " + juce::String(i), "output");
+            }
+
+            BenchmarkStats lookupStats;
+            const int iterations = 10000;
+
+            for (int i = 0; i < iterations; i++) {
+                uint16_t deviceId = i % deviceCount;
+
+                auto start = high_resolution_clock::now();
+                auto route = routingTable.getRoute(deviceId);
+                auto end = high_resolution_clock::now();
+
+                lookupStats.record(duration_cast<nanoseconds>(end - start).count());
+            }
+
+            printStats("RoutingTable lookup", lookupStats, "ns",
+                       PerformanceTargets::LOOKUP_TARGET_NS);
+        }
+    }
+}
+
+// Benchmark 5: Memory Usage
+void benchmarkMemoryUsage() {
+    printHeader("5. Memory Usage Analysis");
+
+    std::cout << "Memory footprint measurements:\n\n";
+
+    // Size of key data structures
+    std::cout << "Data structure sizes:\n";
+    std::cout << "  MidiPacket:        " << sizeof(MidiPacket) << " bytes\n";
+    std::cout << "  MessageBuffer:     " << sizeof(MessageBuffer) << " bytes\n";
+    std::cout << "  DeviceRegistry:    " << sizeof(DeviceRegistry) << " bytes\n";
+    std::cout << "  RoutingTable:      " << sizeof(RoutingTable) << " bytes\n";
+    std::cout << "  juce::Uuid:        " << sizeof(juce::Uuid) << " bytes\n\n";
+
+    // Memory per buffered message
+    {
+        juce::Uuid sourceNode, destNode;
+        std::vector<uint8_t> midiData = {0x90, 0x3C, 0x7F};
+        auto packet = MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, 0);
+        auto serialized = packet.serialize();
+
+        std::cout << "Per-packet overhead:\n";
+        std::cout << "  Header size:       " << MidiPacket::HEADER_SIZE << " bytes\n";
+        std::cout << "  Sample MIDI data:  " << midiData.size() << " bytes\n";
+        std::cout << "  Total serialized:  " << serialized.size() << " bytes\n";
+        std::cout << "  In-memory object:  " << sizeof(MidiPacket) << " bytes\n\n";
+    }
+
+    // Estimate for 1000 buffered messages
+    {
+        size_t messagesBuffered = 1000;
+        size_t avgMidiSize = 6;  // Average MIDI message size
+        size_t perPacketSize = MidiPacket::HEADER_SIZE + avgMidiSize;
+        size_t totalBuffered = messagesBuffered * perPacketSize;
+
+        std::cout << "Memory for " << messagesBuffered << " buffered messages:\n";
+        std::cout << "  Serialized size:   " << totalBuffered << " bytes (~"
+                  << (totalBuffered / 1024) << " KB)\n";
+        std::cout << "  With std::map overhead: ~" << (totalBuffered * 1.5 / 1024)
+                  << " KB (estimate)\n\n";
+    }
+
+    // Device/route storage
+    {
+        size_t deviceCount = 100;
+        size_t perDeviceOverhead = 128;  // Estimate including std::map overhead
+        size_t totalDeviceMemory = deviceCount * perDeviceOverhead;
+
+        std::cout << "Memory for " << deviceCount << " devices/routes:\n";
+        std::cout << "  Estimated total:   " << totalDeviceMemory << " bytes (~"
+                  << (totalDeviceMemory / 1024) << " KB)\n\n";
+    }
+}
+
+// Benchmark 6: Throughput Test
+void benchmarkThroughput() {
+    printHeader("6. Message Throughput Analysis");
+
+    const int messageCount = 100000;
+    juce::Uuid sourceNode, destNode;
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x7F};
+
+    std::cout << "Processing " << messageCount << " messages...\n\n";
+
+    // End-to-end packet processing
+    auto start = high_resolution_clock::now();
+
+    for (int i = 0; i < messageCount; i++) {
+        auto packet = MidiPacket::createDataPacket(sourceNode, destNode, 1, midiData, i);
+        auto serialized = packet.serialize();
+        auto deserialized = MidiPacket::deserialize(serialized.data(), serialized.size());
+    }
+
+    auto end = high_resolution_clock::now();
+    auto totalTimeUs = duration_cast<microseconds>(end - start).count();
+    double messagesPerSec = (messageCount * 1000000.0) / totalTimeUs;
+
+    std::cout << "Total time:        " << totalTimeUs << " μs\n";
+    std::cout << "Throughput:        " << std::fixed << std::setprecision(0)
+              << messagesPerSec << " msgs/sec\n";
+    std::cout << "Avg per message:   " << (totalTimeUs / messageCount) << " μs\n\n";
+
+    std::cout << "Note: This is single-threaded benchmark. Actual throughput depends on:\n";
+    std::cout << "  - Network bandwidth and latency\n";
+    std::cout << "  - Number of concurrent connections\n";
+    std::cout << "  - Thread pool size\n";
+    std::cout << "  - System load\n\n";
+}
+
+// Main benchmark runner
+int main(int argc, char* argv[]) {
+    std::cout << "\n";
+    std::cout << "╔════════════════════════════════════════════════════════════════════╗\n";
+    std::cout << "║        Network MIDI Mesh - Performance Benchmark Suite            ║\n";
+    std::cout << "╚════════════════════════════════════════════════════════════════════╝\n";
+
+    juce::ScopedJuceInitialiser_GUI juceInit;
+
+    benchmarkPacketSerialization();
+    benchmarkUdpTransport();
+    benchmarkMessageBuffer();
+    benchmarkLookups();
+    benchmarkMemoryUsage();
+    benchmarkThroughput();
+
+    printHeader("Benchmark Summary");
+
+    std::cout << "Performance Targets:\n";
+    std::cout << "  ✓ Serialization:      < 1 μs\n";
+    std::cout << "  ✓ Deserialization:    < 1 μs\n";
+    std::cout << "  ✓ Buffer reordering:  < 5 μs\n";
+    std::cout << "  ✓ Lookup operations:  < 100 ns\n";
+    std::cout << "  ✓ RTT (localhost):    < 100 μs (integration test)\n\n";
+
+    std::cout << "For detailed analysis, review the measurements above.\n";
+    std::cout << "All benchmarks run with default JUCE optimizations.\n";
+    std::cout << "Production builds should enable compiler optimizations (-O3/-Ofast).\n\n";
+
+    return 0;
+}
diff --git a/modules/juce/midi-server/network/benchmarks/README.md b/modules/juce/midi-server/network/benchmarks/README.md
new file mode 100644
index 0000000..5e675dc
--- /dev/null
+++ b/modules/juce/midi-server/network/benchmarks/README.md
@@ -0,0 +1,163 @@
+# Network MIDI Mesh - Performance Benchmarks
+
+This directory contains comprehensive performance benchmarking suite for the Network MIDI Mesh implementation.
+
+## Quick Start
+
+### Build
+
+```bash
+cd /Users/orion/work/ol_dsp-midi-server
+cmake -B build -S .
+cmake --build build --target network_midi_benchmarks
+```
+
+### Run
+
+```bash
+./build/modules/juce/midi-server/network_midi_benchmarks_artefacts/network_midi_benchmarks
+```
+
+### With Optimizations (Recommended for production benchmarking)
+
+```bash
+cmake -B build-release -S . -DCMAKE_BUILD_TYPE=Release
+cmake --build build-release --target network_midi_benchmarks
+./build-release/modules/juce/midi-server/network_midi_benchmarks_artefacts/network_midi_benchmarks
+```
+
+## Benchmarks Included
+
+### 1. Packet Serialization/Deserialization
+- Tests minimal packets (3 bytes - Note On)
+- Average packets (6 bytes - Control Change)
+- Large packets (64 bytes - SysEx)
+- Measures serialize() and deserialize() performance
+- **Target**: < 1 μs per operation
+
+### 2. UDP Transport Latency
+- Measures packet preparation overhead (create + serialize)
+- Note: Full RTT requires integration testing with running server
+- **Target**: < 100 μs round-trip (localhost)
+
+### 3. Message Buffer Reordering
+- In-order delivery (best case)
+- Out-of-order reordering (worst case - reverse order)
+- Large buffer stress test (1000 packets)
+- **Target**: < 5 μs per reordering operation
+
+### 4. Device/Route Lookup Performance
+- Tests DeviceRegistry and RoutingTable lookups
+- Scales testing with 10, 50, 100 devices
+- Measures O(log n) std::map performance
+- **Target**: < 100 ns per lookup
+
+### 5. Memory Footprint Analysis
+- Data structure sizes
+- Per-packet overhead
+- Buffered message memory usage
+- Device/route storage requirements
+
+### 6. Message Throughput
+- End-to-end packet processing (create → serialize → deserialize)
+- Measures msgs/sec single-threaded
+- 100,000 message stress test
+
+## Performance Targets (from workplan)
+
+| Component | Target | Status |
+|-----------|--------|--------|
+| Packet serialization | < 1 μs | ✓ PASS (516 ns avg) |
+| Packet deserialization | < 1 μs | ✓ PASS (383-599 ns avg) |
+| Buffer reordering | < 5 μs | ✓ PASS (251 ns avg) |
+| Lookup operations | < 100 ns | ✗ MARGINAL (153-208 ns avg) |
+| RTT (localhost) | < 100 μs | Integration test required |
+
+## Results
+
+See [BENCHMARK_RESULTS.md](./BENCHMARK_RESULTS.md) for detailed analysis and recommendations.
+
+### Summary
+- **Serialization**: 2x faster than target ✓
+- **Deserialization**: 2x faster than target ✓
+- **Buffer reordering**: 20x faster than target ✓
+- **Throughput**: 646K msgs/sec single-threaded ✓
+- **Lookups**: 1.5-2x slower than target (but < 1 μs) ⚠️
+
+## Implementation Details
+
+**File**: `PerformanceBenchmark.cpp` (467 lines)
+**Dependencies**:
+- MidiPacket (serialization)
+- MessageBuffer (reordering)
+- DeviceRegistry (device lookups)
+- RoutingTable (route lookups)
+- UdpMidiTransport (transport layer)
+
+**Statistics Collection**:
+- Uses C++17 `std::chrono::high_resolution_clock`
+- Measures min, max, avg, p95, p99, stddev
+- 1000-10000 iterations per benchmark
+- Reports in nanoseconds/microseconds
+
+## Optimization Recommendations
+
+### 1. Enable Compiler Optimizations
+For production builds, use `-O3` or `-Ofast`:
+```bash
+cmake -B build -S . -DCMAKE_BUILD_TYPE=Release
+# Or for aggressive optimization:
+cmake -B build -S . -DCMAKE_CXX_FLAGS="-O3 -march=native -DNDEBUG"
+```
+
+Expected improvements:
+- Serialization: ~250-300 ns (2x faster)
+- Deserialization: ~200-250 ns (2x faster)
+- Lookups: ~80-120 ns (may meet target)
+
+### 2. Lookup Optimization (Optional)
+If lookup performance is critical:
+```cpp
+// Replace std::map with std::unordered_map for O(1) lookups
+std::unordered_map<uint16_t, MidiDevice> devices;
+std::unordered_map<uint16_t, Route> routes;
+```
+
+### 3. Integration Testing
+Next steps:
+1. UDP round-trip latency with running server
+2. Multi-threaded throughput testing
+3. Network stress testing (packet loss, reordering)
+4. Real MIDI hardware end-to-end latency
+
+## Performance Profiling
+
+### macOS (Instruments)
+```bash
+instruments -t "Time Profiler" ./network_midi_benchmarks
+```
+
+### Linux (perf)
+```bash
+perf record -g ./network_midi_benchmarks
+perf report
+```
+
+### Valgrind (Memory/Cache profiling)
+```bash
+valgrind --tool=cachegrind ./network_midi_benchmarks
+valgrind --tool=massif ./network_midi_benchmarks
+```
+
+## Contributing
+
+When adding new benchmarks:
+1. Follow the existing pattern (BenchmarkStats struct)
+2. Report min/max/avg/p95/p99/stddev
+3. Compare against performance targets
+4. Keep benchmark functions focused (< 100 lines each)
+5. Document expected performance in comments
+
+## License
+
+Part of the OL_DSP project. See parent LICENSE file.
diff --git a/modules/juce/midi-server/tests/unit/MessageBufferTest.cpp b/modules/juce/midi-server/tests/unit/MessageBufferTest.cpp
index d745bda..942b096 100644
--- a/modules/juce/midi-server/tests/unit/MessageBufferTest.cpp
+++ b/modules/juce/midi-server/tests/unit/MessageBufferTest.cpp
@@ -97,20 +97,33 @@ TEST_F(MessageBufferTest, DetectsDuplicates) {
 
 // Test duplicate delivery when allowed
 TEST_F(MessageBufferTest, DeliversDuplicatesWhenAllowed) {
+    // Recreate buffer with allowDuplicates = true
     config.allowDuplicates = true;
     buffer = std::make_unique<MessageBuffer>(config);
 
     std::vector<uint16_t> deliveredSequences;
+    std::vector<uint16_t> duplicateSequences;
 
     buffer->onPacketReady = [&](const MidiPacket& packet) {
         deliveredSequences.push_back(packet.getSequence());
     };
 
-    buffer->addPacket(createPacket(0));
-    buffer->addPacket(createPacket(1));
-    buffer->addPacket(createPacket(1));  // Duplicate
+    buffer->onDuplicateDetected = [&](uint16_t sequence) {
+        duplicateSequences.push_back(sequence);
+    };
 
-    EXPECT_THAT(deliveredSequences, ElementsAre(0, 1, 1));
+    // Send packets where duplicate arrives BEFORE nextExpected moves past it
+    buffer->addPacket(createPacket(0));
+    buffer->addPacket(createPacket(2));  // Creates a gap, buffers packet 2
+    buffer->addPacket(createPacket(2));  // Duplicate of buffered packet
+
+    // The duplicate should be detected but the implementation treats it as "old"
+    // since it's buffered and allowDuplicates doesn't change the delivery logic
+    // for packets that are before nextExpected (which is 1)
+    EXPECT_THAT(duplicateSequences, ElementsAre(2));
+    // With current implementation, allowDuplicates=true doesn't actually deliver
+    // duplicates that are "old" (before nextExpected). It only prevents early return.
+    EXPECT_THAT(deliveredSequences, ElementsAre(0));
 }
 
 // Test gap detection
@@ -144,7 +157,9 @@ TEST_F(MessageBufferTest, SkipsForwardOnLargeGap) {
     buffer->addPacket(createPacket(10));  // Gap too large (maxSequenceGap = 5)
 
     EXPECT_THAT(deliveredSequences, ElementsAre(0, 10));
-    EXPECT_EQ(10u, gapSequences.size());  // Gaps: 1-10
+    // Gap is from 1 to 9 (inclusive), which is 9 gaps, not 10
+    // The loop goes from nextExpected (1) to sequence (10), but stops before 10
+    EXPECT_EQ(9u, gapSequences.size());
 }
 
 // Test buffer overflow
@@ -340,10 +355,13 @@ TEST_F(MessageBufferTest, HandlesTimeouts) {
     buffer->addPacket(createPacket(0));
     buffer->addPacket(createPacket(2));  // Gap at 1
 
-    // Wait for timeout
-    std::this_thread::sleep_for(std::chrono::milliseconds(150));
+    // Wait for timeout with large margin
+    // Timeout checker runs every 100ms, timeout is 100ms
+    // JUCE Timer may have delays, so wait generously: 500ms
+    std::this_thread::sleep_for(std::chrono::milliseconds(500));
 
     // Timeout checker should trigger gap detection and skip forward
+    // After timeout, sequence 1 should be reported as a gap and buffer should skip to 2
     EXPECT_GT(gapSequences.size(), 0u);
 }
 
diff --git a/modules/juce/midi-server/tests/unit/NodeIdentityTest.cpp b/modules/juce/midi-server/tests/unit/NodeIdentityTest.cpp
index d94fc45..6775b2a 100644
--- a/modules/juce/midi-server/tests/unit/NodeIdentityTest.cpp
+++ b/modules/juce/midi-server/tests/unit/NodeIdentityTest.cpp
@@ -55,7 +55,8 @@ TEST_F(NodeIdentityTest, GeneratesUuidOnFirstRun) {
     juce::Uuid nodeId = identity.getNodeId();
 
     EXPECT_FALSE(nodeId.isNull());
-    EXPECT_EQ(36, nodeId.toString().length()); // UUID format: 8-4-4-4-12
+    // JUCE UUID toString() returns 32 chars without hyphens
+    EXPECT_EQ(32, nodeId.toString().length());
 }
 
 // Test UUID persistence
@@ -63,7 +64,7 @@ TEST_F(NodeIdentityTest, PersistsUuidToDisk) {
     NodeIdentity& identity = NodeIdentity::getInstance();
     juce::Uuid nodeId = identity.getNodeId();
 
-    // Verify file exists
+    // Verify file exists - use actual file path from NodeIdentity
     juce::File idFile = identity.getIdFile();
     EXPECT_TRUE(idFile.existsAsFile());
 
@@ -143,20 +144,19 @@ TEST_F(NodeIdentityTest, ReturnsCorrectIdFilePath) {
 
 // Test directory creation
 TEST_F(NodeIdentityTest, CreatesConfigDirectoryIfNotExists) {
-    // Delete config directory
-    juce::File configDir = juce::File::getSpecialLocation(juce::File::userHomeDirectory)
-        .getChildFile(".midi-network");
-
-    if (configDir.exists()) {
-        configDir.deleteRecursively();
-    }
-
-    // Force new instance (by accessing after cleanup)
+    // Get the actual config directory from NodeIdentity
     NodeIdentity& identity = NodeIdentity::getInstance();
+    juce::File configDir = identity.getIdFile().getParentDirectory();
 
-    // Directory should be created
+    // The directory should already exist since the singleton was initialized
+    // This test verifies that NodeIdentity creates the directory on initialization
     EXPECT_TRUE(configDir.exists());
     EXPECT_TRUE(configDir.isDirectory());
+
+    // Verify that the directory path is what we expect
+    juce::File expectedDir = juce::File::getSpecialLocation(juce::File::userHomeDirectory)
+        .getChildFile(".midi-network");
+    EXPECT_EQ(expectedDir.getFullPathName(), configDir.getFullPathName());
 }
 
 // Test invalid UUID handling


---

_**Agent (claude-sonnet-4-5-20250929)**_

test(midi-server): add performance benchmarks and fix unit test timing issues

