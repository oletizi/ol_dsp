<!-- Generated by SpecStory -->

# 2025-10-07 22:09:56Z

<!-- Claude Code Session 470c28b2-cef9-4202-b2ef-17a1831244f7 (2025-10-07_22-09-56Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/CMakeLists.txt b/modules/juce/midi-server/CMakeLists.txt
index a38ee5c..329d7ac 100644
--- a/modules/juce/midi-server/CMakeLists.txt
+++ b/modules/juce/midi-server/CMakeLists.txt
@@ -216,6 +216,42 @@ target_link_libraries(network_midi_benchmarks
     juce::juce_recommended_warning_flags
 )
 
+#==============================================================================
+# Phase 4 Context Performance Benchmark
+#==============================================================================
+
+juce_add_console_app(context_performance_test
+    PRODUCT_NAME "Context Performance Test"
+)
+
+target_sources(context_performance_test
+    PRIVATE
+    tests/performance/context_performance_test.cpp
+    ${CORE_SOURCES}
+    ${ROUTING_SOURCES}
+)
+
+target_compile_definitions(context_performance_test
+    PRIVATE
+    JUCE_WEB_BROWSER=0
+    JUCE_USE_CURL=0
+)
+
+target_include_directories(context_performance_test
+    PRIVATE
+    ${CMAKE_CURRENT_SOURCE_DIR}
+)
+
+target_link_libraries(context_performance_test
+    PRIVATE
+    juce::juce_core
+    juce::juce_audio_devices
+    juce::juce_events
+    PUBLIC
+    juce::juce_recommended_config_flags
+    juce::juce_recommended_warning_flags
+)
+
 # Unit Tests with Google Test and Coverage
 # Note: Google Test is already configured in the parent project's test/ directory
 # No need to fetch it again - just use the existing targets
@@ -235,6 +271,9 @@ add_executable(network_midi_tests
     tests/unit/ConnectionPoolTest.cpp
     tests/unit/MidiClassifierTest.cpp
     tests/unit/MidiMessageRouterTest.cpp
+    tests/unit/UuidRegistryTest.cpp
+    # Phase 4.6: MidiRouter context tests
+    tests/unit/MidiRouterContextTest.cpp
     # SEDA infrastructure tests (Phase B.1)
     network/mesh/tests/NetworkConnectionQueueTest.cpp
     # Dual-transport tests (Phase C.1-C.3)
diff --git a/modules/juce/midi-server/NetworkMidiServer.cpp b/modules/juce/midi-server/NetworkMidiServer.cpp
index d0ea6c6..bf4e3a2 100644
--- a/modules/juce/midi-server/NetworkMidiServer.cpp
+++ b/modules/juce/midi-server/NetworkMidiServer.cpp
@@ -198,6 +198,20 @@ public:
         }
     }
 
+    void sendPacket(const NetworkMidi::MidiPacket& packet) override {
+        // Phase 4.5: Send packet with full context via UDP
+        if (meshManager) {
+            auto nodeInfo = meshManager->getNodeInfo(packet.getDestNode());
+            if (nodeInfo.isValid()) {
+                udpTransport.sendPacket(
+                    packet,
+                    nodeInfo.ipAddress,
+                    nodeInfo.udpPort
+                );
+            }
+        }
+    }
+
     void setMeshManager(NetworkMidi::MeshManager* manager) {
         meshManager = manager;
     }
@@ -339,6 +353,12 @@ public:
         // Connect network adapter to mesh manager
         networkAdapter->setMeshManager(meshManager.get());
 
+        // Phase 4.5: Inject UuidRegistry and node ID into MidiRouter
+        if (midiRouter) {
+            midiRouter->setNodeId(identity.getNodeId());
+            midiRouter->setUuidRegistry(&meshManager->getUuidRegistry());
+        }
+
         // 9. NOW start MIDI inputs (after everything is fully initialized)
         startMidiInputs();
     }
diff --git a/modules/juce/midi-server/NetworkMidiServer.cpp.backup b/modules/juce/midi-server/NetworkMidiServer.cpp.backup
new file mode 100644
index 0000000..d0ea6c6
--- /dev/null
+++ b/modules/juce/midi-server/NetworkMidiServer.cpp.backup
@@ -0,0 +1,1326 @@
+/**
+ * Network MIDI Server - Zero-configuration network MIDI mesh
+ *
+ * Provides HTTP API for MIDI operations and supports auto-discovery
+ * for multi-node network MIDI mesh topology.
+ *
+ * Uses cpp-httplib for robust HTTP server implementation.
+ */
+
+#include <juce_core/juce_core.h>
+#include <juce_events/juce_events.h>
+#include <juce_audio_devices/juce_audio_devices.h>
+
+#include "httplib.h"
+#include "network/core/NodeIdentity.h"
+#include "network/core/InstanceManager.h"
+#include "network/discovery/ServiceDiscovery.h"
+#include "network/mesh/MeshManager.h"
+#include "network/routing/MidiRouter.h"
+#include "network/routing/DeviceRegistry.h"
+#include "network/routing/RoutingTable.h"
+#include "network/routing/RouteManager.h"
+#include "network/transport/UdpMidiTransport.h"
+
+#include <iostream>
+#include <map>
+#include <memory>
+#include <mutex>
+#include <queue>
+#include <vector>
+#include <string>
+#include <thread>
+#include <sstream>
+
+//==============================================================================
+// Simple JSON builder for responses
+class JsonBuilder
+{
+public:
+    JsonBuilder& startObject() {
+        if (!firstItem) ss << ",";
+        ss << "{";
+        firstItem = true;
+        return *this;
+    }
+    JsonBuilder& endObject() {
+        ss << "}";
+        firstItem = false;  // Next key/item in parent needs comma
+        return *this;
+    }
+    JsonBuilder& startArray() {
+        if (!firstItem) ss << ",";
+        ss << "[";
+        firstItem = true;
+        return *this;
+    }
+    JsonBuilder& endArray() {
+        ss << "]";
+        firstItem = false;  // Next item in parent needs comma
+        return *this;
+    }
+
+    JsonBuilder& key(const std::string& k) {
+        if (!firstItem) ss << ",";
+        ss << "\"" << k << "\":";
+        firstItem = true;  // Next value (not key) should not have comma
+        return *this;
+    }
+
+    JsonBuilder& value(const std::string& v) {
+        ss << "\"" << v << "\"";
+        firstItem = false;  // Next key needs comma
+        return *this;
+    }
+
+    JsonBuilder& value(bool b) {
+        ss << (b ? "true" : "false");
+        firstItem = false;  // Next key needs comma
+        return *this;
+    }
+
+    JsonBuilder& value(int i) {
+        ss << i;
+        firstItem = false;  // Next key needs comma
+        return *this;
+    }
+
+    JsonBuilder& arrayValue(const std::string& v) {
+        if (!firstItem) ss << ",";
+        ss << "\"" << v << "\"";
+        firstItem = false;
+        return *this;
+    }
+
+    JsonBuilder& arrayValue(int i) {
+        if (!firstItem) ss << ",";
+        ss << i;
+        firstItem = false;
+        return *this;
+    }
+
+    std::string toString() { return ss.str(); }
+
+private:
+    std::stringstream ss;
+    bool firstItem = true;
+};
+
+//==============================================================================
+// JUCE MIDI port wrapper implementing MidiPortInterface
+class JuceMidiPort : public NetworkMidi::MidiPortInterface
+{
+public:
+    JuceMidiPort(const juce::String& deviceName, bool isInputPort)
+        : name(deviceName), inputPort(isInputPort) {}
+
+    void sendMessage(const std::vector<uint8_t>& data) override {
+        if (!output || data.empty()) return;
+
+        if (data[0] == 0xF0) {
+            // SysEx message
+            if (data.back() != 0xF7 || data.size() <= 2) {
+                std::cerr << "Warning: Invalid SysEx message\n";
+                return;
+            }
+            output->sendMessageNow(
+                juce::MidiMessage::createSysExMessage(
+                    data.data() + 1,
+                    (int)data.size() - 2
+                )
+            );
+        } else if (data.size() >= 1 && data.size() <= 3) {
+            output->sendMessageNow(
+                juce::MidiMessage(data.data(), (int)data.size())
+            );
+        }
+    }
+
+    std::vector<std::vector<uint8_t>> getMessages() override {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        std::vector<std::vector<uint8_t>> result;
+        while (!messageQueue.empty()) {
+            result.push_back(messageQueue.front());
+            messageQueue.pop();
+        }
+        return result;
+    }
+
+    juce::String getName() const override { return name; }
+    bool isInput() const override { return inputPort; }
+    bool isOutput() const override { return !inputPort; }
+
+    void setMidiInput(std::unique_ptr<juce::MidiInput> in) {
+        input = std::move(in);
+    }
+
+    void setMidiOutput(std::unique_ptr<juce::MidiOutput> out) {
+        output = std::move(out);
+    }
+
+    void queueMessage(const std::vector<uint8_t>& data) {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        messageQueue.push(data);
+    }
+
+private:
+    juce::String name;
+    bool inputPort;
+    std::unique_ptr<juce::MidiInput> input;
+    std::unique_ptr<juce::MidiOutput> output;
+    std::queue<std::vector<uint8_t>> messageQueue;
+    std::mutex queueMutex;
+};
+
+//==============================================================================
+// Network transport adapter for MidiRouter
+class NetworkTransportAdapter : public NetworkMidi::NetworkTransport
+{
+public:
+    NetworkTransportAdapter(NetworkMidi::UdpMidiTransport& transport)
+        : udpTransport(transport) {}
+
+    void sendMidiMessage(const juce::Uuid& destNode,
+                        uint16_t deviceId,
+                        const std::vector<uint8_t>& midiData) override {
+        // Get destination node info from mesh manager
+        if (meshManager) {
+            auto nodeInfo = meshManager->getNodeInfo(destNode);
+            if (nodeInfo.isValid()) {
+                udpTransport.sendMessage(
+                    destNode,
+                    nodeInfo.ipAddress,
+                    nodeInfo.udpPort,
+                    deviceId,
+                    midiData
+                );
+            }
+        }
+    }
+
+    void setMeshManager(NetworkMidi::MeshManager* manager) {
+        meshManager = manager;
+    }
+
+private:
+    NetworkMidi::UdpMidiTransport& udpTransport;
+    NetworkMidi::MeshManager* meshManager = nullptr;
+};
+
+//==============================================================================
+// Helper to convert between NodeInfo types (ServiceDiscovery vs NetworkMidi)
+NetworkMidi::NodeInfo convertToMeshNodeInfo(const ::NodeInfo& discoveryNode) {
+    NetworkMidi::NodeInfo meshNode;
+    meshNode.uuid = discoveryNode.uuid;
+    meshNode.name = discoveryNode.name;
+    meshNode.hostname = discoveryNode.hostname;
+    meshNode.ipAddress = discoveryNode.ipAddress;
+    meshNode.httpPort = discoveryNode.httpPort;
+    meshNode.udpPort = discoveryNode.udpPort;
+    meshNode.version = discoveryNode.version;
+    meshNode.deviceCount = discoveryNode.deviceCount;
+    return meshNode;
+}
+
+//==============================================================================
+// Network MIDI Server class with full mesh integration
+class NetworkMidiServer : public juce::MidiInputCallback
+{
+public:
+    NetworkMidiServer(const NetworkMidi::NodeIdentity& nodeIdentity,
+                     NetworkMidi::InstanceManager* instanceMgr,
+                     int port = 0)
+        : identity(nodeIdentity)
+        , instanceManager(instanceMgr)
+        , requestedPort(port)
+        , actualPort(0)
+        , udpPort(0) {}
+
+    ~NetworkMidiServer() {
+        stopServer();
+    }
+
+    int getActualPort() const {
+        return actualPort;
+    }
+
+    int getUdpPort() const {
+        return udpPort;
+    }
+
+    void startServer() {
+        // 1. Create UDP transport (auto-assign port)
+        udpTransport = std::make_unique<NetworkMidi::UdpMidiTransport>(0);
+        udpTransport->setNodeId(identity.getNodeId());
+        udpTransport->start();
+        udpPort = udpTransport->getPort();
+
+        std::cout << "UDP transport started on port " << udpPort << std::endl;
+
+        // 2. Create routing infrastructure
+        deviceRegistry = std::make_unique<NetworkMidi::DeviceRegistry>();
+        routingTable = std::make_unique<NetworkMidi::RoutingTable>();
+        routeManager = std::make_unique<NetworkMidi::RouteManager>(*deviceRegistry);
+
+        // 3. Create MIDI router BEFORE registering devices
+        midiRouter = std::make_unique<NetworkMidi::MidiRouter>(*deviceRegistry, *routingTable);
+        networkAdapter = std::make_unique<NetworkTransportAdapter>(*udpTransport);
+        midiRouter->setNetworkTransport(networkAdapter.get());
+
+        // 4. Enumerate and register local MIDI devices (now that router exists)
+        registerLocalMidiDevices();
+
+        // 5. Load persisted routes (after devices are registered)
+        loadRoutes();
+
+        // Set up UDP packet reception callback
+        udpTransport->onPacketReceived = [this](const NetworkMidi::MidiPacket& packet,
+                                                const juce::String& /*sourceAddr*/,
+                                                int /*sourcePort*/) {
+            handleNetworkPacket(packet);
+        };
+
+        // 6. Create HTTP server
+        server = std::make_unique<httplib::Server>();
+        setupRoutes();
+
+        // Start HTTP server in a separate thread
+        serverThread = std::thread([this]() {
+            if (requestedPort == 0) {
+                actualPort = server->bind_to_any_port("0.0.0.0");
+                if (actualPort < 0) {
+                    std::cerr << "Failed to bind to any port" << std::endl;
+                    return;
+                }
+            } else {
+                if (!server->bind_to_port("0.0.0.0", requestedPort)) {
+                    std::cerr << "Failed to bind to port " << requestedPort << std::endl;
+                    return;
+                }
+                actualPort = requestedPort;
+            }
+
+            std::cout << "HTTP Server bound to port " << actualPort << std::endl;
+            server->listen_after_bind();
+        });
+
+        // Wait for HTTP server to start
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+
+        // 7. Create service discovery (advertise this node)
+        int deviceCount = deviceRegistry->getLocalDeviceCount();
+        serviceDiscovery = std::make_unique<ServiceDiscovery>(
+            identity.getNodeId(),
+            identity.getNodeName(),
+            actualPort,
+            udpPort,
+            deviceCount
+        );
+
+        // Set up discovery callbacks
+        setupDiscoveryCallbacks();
+
+        serviceDiscovery->advertise();
+        std::cout << "Started mDNS advertising" << std::endl;
+
+        // 8. Create mesh manager (handle peer connections)
+        meshManager = std::make_unique<NetworkMidi::MeshManager>(
+            identity.getNodeId(),
+            actualPort,
+            udpPort
+        );
+
+        // Wire mesh callbacks
+        setupMeshCallbacks();
+
+        meshManager->start();
+        std::cout << "Mesh manager started" << std::endl;
+
+        // Connect network adapter to mesh manager
+        networkAdapter->setMeshManager(meshManager.get());
+
+        // 9. NOW start MIDI inputs (after everything is fully initialized)
+        startMidiInputs();
+    }
+
+    void stopServer() {
+        // Save routes before shutdown
+        saveRoutes();
+
+        // Stop MIDI inputs first
+        for (auto& input : midiInputs) {
+            if (input) {
+                input->stop();
+            }
+        }
+
+        // Stop mesh and discovery
+        if (meshManager) {
+            meshManager->stop();
+        }
+        if (serviceDiscovery) {
+            serviceDiscovery->stopAdvertising();
+            serviceDiscovery->stopBrowsing();
+        }
+
+        // Stop UDP transport
+        if (udpTransport) {
+            udpTransport->stop();
+        }
+
+        // Stop HTTP server
+        if (server) {
+            server->stop();
+        }
+        if (serverThread.joinable()) {
+            serverThread.join();
+        }
+
+        // Clean up MIDI ports
+        if (midiRouter) {
+            midiRouter->clearLocalPorts();
+        }
+        midiInputs.clear();
+        midiOutputs.clear();
+    }
+
+    // MidiInputCallback interface
+    void handleIncomingMidiMessage(juce::MidiInput* source,
+                                   const juce::MidiMessage& message) override {
+        // Convert JUCE message to raw bytes
+        std::vector<uint8_t> data(
+            message.getRawData(),
+            message.getRawData() + message.getRawDataSize()
+        );
+
+        // Find device ID for this input
+        auto deviceId = getDeviceIdForInput(source);
+        if (deviceId != 0xFFFF && midiRouter) {
+            // Route through MidiRouter (handles local and network delivery)
+            midiRouter->sendMessage(deviceId, data);
+        }
+    }
+
+private:
+    void registerLocalMidiDevices() {
+        uint16_t deviceId = 1;  // Start at 1 (0 reserved)
+
+        // Register MIDI inputs (but don't start them yet)
+        auto inputs = juce::MidiInput::getAvailableDevices();
+        for (const auto& deviceInfo : inputs) {
+            // Add to device registry
+            deviceRegistry->addLocalDevice(
+                deviceId,
+                deviceInfo.name,
+                "input",
+                deviceInfo.identifier
+            );
+
+            // Add to routing table (local route has null UUID)
+            routingTable->addRoute(
+                juce::Uuid(),  // Local devices use null UUID
+                deviceId,
+                deviceInfo.name,
+                "input"
+            );
+
+            // Open MIDI input but DON'T start it yet
+            auto input = juce::MidiInput::openDevice(
+                deviceInfo.identifier,
+                this  // MidiInputCallback
+            );
+            if (input) {
+                // Create port wrapper
+                auto port = std::make_unique<JuceMidiPort>(deviceInfo.name, true);
+                port->setMidiInput(std::move(input));
+
+                // Store reference for device lookup
+                inputDeviceMap[deviceInfo.identifier] = deviceId;
+
+                // Register with router
+                midiRouter->registerLocalPort(deviceId, std::move(port));
+            }
+            deviceId++;
+        }
+
+        // Register MIDI outputs
+        auto outputs = juce::MidiOutput::getAvailableDevices();
+        for (const auto& deviceInfo : outputs) {
+            // Add to device registry
+            deviceRegistry->addLocalDevice(
+                deviceId,
+                deviceInfo.name,
+                "output",
+                deviceInfo.identifier
+            );
+
+            // Add to routing table
+            routingTable->addRoute(
+                juce::Uuid(),  // Local devices use null UUID
+                deviceId,
+                deviceInfo.name,
+                "output"
+            );
+
+            // Open MIDI output
+            auto output = juce::MidiOutput::openDevice(deviceInfo.identifier);
+            if (output) {
+                // Create port wrapper
+                auto port = std::make_unique<JuceMidiPort>(deviceInfo.name, false);
+                port->setMidiOutput(std::move(output));
+
+                // Register with router
+                midiRouter->registerLocalPort(deviceId, std::move(port));
+            }
+            deviceId++;
+        }
+
+        std::cout << "Registered " << deviceRegistry->getLocalDeviceCount()
+                  << " local MIDI devices" << std::endl;
+    }
+
+    void startMidiInputs() {
+        // Start all MIDI inputs now that everything is initialized
+        auto localDevices = deviceRegistry->getLocalDevices();
+        for (const auto& device : localDevices) {
+            if (device.type == "input") {
+                // Find the corresponding MIDI input by device ID
+                // This requires storing the inputs separately
+                // For now, we can iterate through available devices again
+                auto inputs = juce::MidiInput::getAvailableDevices();
+                for (const auto& deviceInfo : inputs) {
+                    if (inputDeviceMap.count(deviceInfo.identifier) > 0 &&
+                        inputDeviceMap[deviceInfo.identifier] == device.id()) {
+                        // Re-open and start the input
+                        auto input = juce::MidiInput::openDevice(
+                            deviceInfo.identifier,
+                            this
+                        );
+                        if (input) {
+                            input->start();
+                            midiInputs.push_back(std::move(input));
+                        }
+                    }
+                }
+            }
+        }
+        std::cout << "Started " << midiInputs.size() << " MIDI inputs" << std::endl;
+    }
+
+    uint16_t getDeviceIdForInput(juce::MidiInput* source) {
+        if (!source) return 0xFFFF;
+
+        auto identifier = source->getIdentifier();
+        auto it = inputDeviceMap.find(identifier);
+        if (it != inputDeviceMap.end()) {
+            return it->second;
+        }
+        return 0xFFFF;
+    }
+
+    void setupDiscoveryCallbacks() {
+        serviceDiscovery->startBrowsing(
+            [this](const ::NodeInfo& node) {
+                std::cout << "Discovered peer: " << node.name.toStdString()
+                          << " (UUID: " << node.uuid.toString().toStdString() << ")"
+                          << " at " << node.ipAddress.toStdString()
+                          << ":" << node.httpPort
+                          << " (UDP: " << node.udpPort << ")"
+                          << std::endl;
+
+                // Convert to mesh NodeInfo and notify mesh manager
+                if (meshManager) {
+                    auto meshNode = convertToMeshNodeInfo(node);
+                    meshManager->onNodeDiscovered(meshNode);
+                }
+            },
+            [this](const juce::Uuid& nodeId) {
+                std::cout << "Lost peer: " << nodeId.toString().toStdString() << std::endl;
+
+                // Notify mesh manager
+                if (meshManager) {
+                    meshManager->onNodeRemoved(nodeId);
+                }
+            }
+        );
+    }
+
+    void setupMeshCallbacks() {
+        meshManager->onNodeConnected = [this](const NetworkMidi::NodeInfo& node) {
+            std::cout << "Connected to node: " << node.name.toStdString()
+                      << " (" << node.deviceCount << " devices)" << std::endl;
+        };
+
+        meshManager->onNodeDisconnected = [this](const juce::Uuid& nodeId,
+                                                  const juce::String& reason) {
+            std::cout << "Disconnected from node: " << nodeId.toString().toStdString()
+                      << " - " << reason.toStdString() << std::endl;
+        };
+
+        meshManager->onConnectionFailed = [this](const NetworkMidi::NodeInfo& node,
+                                                 const juce::String& error) {
+            std::cerr << "Connection failed to " << node.name.toStdString()
+                      << ": " << error.toStdString() << std::endl;
+        };
+
+        // Register remote devices when they are discovered
+        meshManager->onRemoteDevicesDiscovered = [this](const juce::Uuid& nodeId,
+                                                        const std::vector<NetworkMidi::DeviceInfo>& devices) {
+            std::cout << "Registering " << devices.size() << " remote devices from node "
+                      << nodeId.toString().toStdString() << std::endl;
+
+            // Add each remote device to registry and routing table
+            for (const auto& device : devices) {
+                uint16_t remoteDeviceId = device.id;
+
+                // Add to device registry as remote device
+                deviceRegistry->addRemoteDevice(
+                    nodeId,
+                    remoteDeviceId,
+                    device.name,
+                    device.type
+                );
+
+                // Add route to routing table
+                routingTable->addRoute(
+                    nodeId,  // Remote node UUID
+                    remoteDeviceId,
+                    device.name,
+                    device.type
+                );
+
+                std::cout << "  Registered remote device: " << device.name.toStdString()
+                          << " (ID: " << remoteDeviceId << ", type: " << device.type.toStdString() << ")"
+                          << std::endl;
+            }
+        };
+    }
+
+    void handleNetworkPacket(const NetworkMidi::MidiPacket& packet) {
+        // Route received network MIDI to appropriate local device
+        if (midiRouter) {
+            // Use getter methods to access packet fields
+            auto midiData = packet.getMidiData();
+            midiRouter->onNetworkPacketReceived(
+                packet.getSourceNode(),
+                packet.getDeviceId(),
+                midiData
+            );
+        }
+    }
+
+    void loadRoutes() {
+        if (!routeManager || !instanceManager) {
+            return;
+        }
+
+        auto routesFile = instanceManager->getStateFile("routes.json");
+        if (routesFile.existsAsFile()) {
+            std::cout << "Loading routes from " << routesFile.getFullPathName().toStdString() << std::endl;
+            if (routeManager->loadFromFile(routesFile)) {
+                int count = routeManager->getRuleCount();
+                std::cout << "Loaded " << count << " routing rule(s)" << std::endl;
+            } else {
+                std::cerr << "Warning: Failed to load routes from file" << std::endl;
+            }
+        } else {
+            std::cout << "No routes file found, starting with empty routing table" << std::endl;
+        }
+    }
+
+    void saveRoutes() {
+        if (!routeManager || !instanceManager) {
+            return;
+        }
+
+        auto routesFile = instanceManager->getStateFile("routes.json");
+        std::cout << "Saving routes to " << routesFile.getFullPathName().toStdString() << std::endl;
+        if (routeManager->saveToFile(routesFile)) {
+            int count = routeManager->getRuleCount();
+            std::cout << "Saved " << count << " routing rule(s)" << std::endl;
+        } else {
+            std::cerr << "Warning: Failed to save routes to file" << std::endl;
+        }
+    }
+
+    void setupRoutes() {
+        // Health check endpoint
+        server->Get("/health", [](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject().key("status").value(std::string("ok")).endObject();
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // Node information endpoint
+        server->Get("/node/info", [this](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject()
+                .key("uuid").value(identity.getNodeId().toString().toStdString())
+                .key("name").value(identity.getNodeName().toStdString())
+                .key("hostname").value(identity.getHostname().toStdString())
+                .key("http_port").value(actualPort)
+                .key("udp_port").value(udpPort)
+                .key("local_devices").value(deviceRegistry ? deviceRegistry->getLocalDeviceCount() : 0)
+                .key("total_devices").value(deviceRegistry ? deviceRegistry->getTotalDeviceCount() : 0)
+                .endObject();
+
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // List MIDI devices (integrated with device registry)
+        server->Get("/midi/devices", [this](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject();
+
+            if (deviceRegistry) {
+                auto devices = deviceRegistry->getAllDevices();
+
+                json.key("devices").startArray();
+                for (const auto& device : devices) {
+                    json.startObject()
+                        .key("id").value((int)device.id())
+                        .key("name").value(device.name.toStdString())
+                        .key("type").value(device.type.toStdString())
+                        .key("is_local").value(device.isLocal())
+                        .key("owner_node").value(device.ownerNode().toString().toStdString())
+                        .endObject();
+                }
+                json.endArray();
+            }
+
+            json.endObject();
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // Network mesh status
+        server->Get("/network/mesh", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                std::cerr << "DEBUG: /network/mesh: Starting" << std::endl;
+                JsonBuilder json;
+                json.startObject();
+
+                if (meshManager) {
+                    std::cerr << "DEBUG: /network/mesh: Getting statistics" << std::endl;
+                    auto stats = meshManager->getStatistics();
+                    std::cerr << "DEBUG: /network/mesh: Got statistics" << std::endl;
+                    json.key("connected_nodes").value((int)stats.connectedNodes)
+                        .key("total_nodes").value((int)stats.totalNodes)
+                        .key("total_devices").value(stats.totalDevices);
+
+                    std::cerr << "DEBUG: /network/mesh: Getting connected nodes" << std::endl;
+                    json.key("nodes").startArray();
+                    auto nodes = meshManager->getConnectedNodes();
+                    std::cerr << "DEBUG: /network/mesh: Got " << nodes.size() << " nodes" << std::endl;
+                    for (const auto& node : nodes) {
+                        std::cerr << "DEBUG: /network/mesh: Processing node " << node.name.toStdString() << std::endl;
+                        json.startObject()
+                            .key("uuid").value(node.uuid.toString().toStdString())
+                            .key("name").value(node.name.toStdString())
+                            .key("ip").value(node.ipAddress.toStdString())
+                            .key("http_port").value(node.httpPort)
+                            .key("udp_port").value(node.udpPort)
+                            .key("devices").value(node.deviceCount)
+                            .endObject();
+                        std::cerr << "DEBUG: /network/mesh: Finished node " << node.name.toStdString() << std::endl;
+                    }
+                    json.endArray();
+                } else {
+                    json.key("error").value(std::string("Mesh manager not initialized"));
+                }
+
+                std::cerr << "DEBUG: /network/mesh: Building JSON" << std::endl;
+                json.endObject();
+                std::cerr << "DEBUG: /network/mesh: Sending response" << std::endl;
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+                std::cerr << "DEBUG: /network/mesh: Done" << std::endl;
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /network/mesh: " << e.what() << std::endl;
+                res.set_content(std::string("Error: ") + e.what(), "text/plain");
+                res.status = 500;
+            }
+        });
+
+        // Router statistics
+        server->Get("/network/stats", [this](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject();
+
+            if (midiRouter) {
+                auto stats = midiRouter->getStatistics();
+                json.key("local_sent").value((int)stats.localMessagesSent)
+                    .key("local_received").value((int)stats.localMessagesReceived)
+                    .key("network_sent").value((int)stats.networkMessagesSent)
+                    .key("network_received").value((int)stats.networkMessagesReceived)
+                    .key("routing_errors").value((int)stats.routingErrors);
+            }
+
+            if (udpTransport) {
+                auto stats = udpTransport->getStatistics();
+                json.key("packets_sent").value((int)stats.packetsSent)
+                    .key("packets_received").value((int)stats.packetsReceived)
+                    .key("bytes_sent").value((int)stats.bytesSent)
+                    .key("bytes_received").value((int)stats.bytesReceived);
+            }
+
+            json.endObject();
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // Network handshake endpoint (for mesh connection establishment)
+        server->Post("/network/handshake", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                // Parse incoming handshake request
+                // Expected format: {"node_id":"...", "node_name":"...", "udp_endpoint":"...", "version":"..."}
+
+                std::string nodeIdStr, nodeName, udpEndpoint, version;
+
+                // Simple JSON parsing (extract values)
+                auto body = req.body;
+                size_t pos;
+
+                // Extract node_id
+                pos = body.find("\"node_id\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 11;
+                    size_t end = body.find("\"", start);
+                    nodeIdStr = body.substr(start, end - start);
+                }
+
+                // Extract node_name
+                pos = body.find("\"node_name\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 13;
+                    size_t end = body.find("\"", start);
+                    nodeName = body.substr(start, end - start);
+                }
+
+                // Extract udp_endpoint
+                pos = body.find("\"udp_endpoint\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 16;
+                    size_t end = body.find("\"", start);
+                    udpEndpoint = body.substr(start, end - start);
+                }
+
+                // Extract version
+                pos = body.find("\"version\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 11;
+                    size_t end = body.find("\"", start);
+                    version = body.substr(start, end - start);
+                }
+
+                std::cout << "Handshake request from: " << nodeName
+                          << " (UUID: " << nodeIdStr << ")"
+                          << " UDP: " << udpEndpoint << std::endl;
+
+                // Build handshake response with our node info and device list
+                JsonBuilder json;
+                json.startObject()
+                    .key("node_id").value(identity.getNodeId().toString().toStdString())
+                    .key("node_name").value(identity.getNodeName().toStdString())
+                    .key("udp_endpoint").value(std::to_string(udpPort))
+                    .key("version").value(std::string("1.0"));
+
+                // Add device list
+                if (deviceRegistry) {
+                    auto devices = deviceRegistry->getLocalDevices();
+                    json.key("devices").startArray();
+                    for (const auto& device : devices) {
+                        json.startObject()
+                            .key("id").value((int)device.id())
+                            .key("name").value(device.name.toStdString())
+                            .key("type").value(device.type.toStdString())
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                json.endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Handshake error: " << e.what() << std::endl;
+                res.set_content(std::string("Handshake failed: ") + e.what(), "text/plain");
+                res.status = 500;
+            }
+        });
+
+        //=================================================================================
+        // MIDI Routing Configuration API (Phase 2)
+        //=================================================================================
+
+        // Helper to parse node ID from string ("local" -> null UUID)
+        auto parseNodeId = [](const std::string& str) -> juce::Uuid {
+            if (str == "local" || str.empty()) {
+                return juce::Uuid();
+            }
+            return juce::Uuid(str);
+        };
+
+        // 1. GET /routing/routes - List all routing rules
+        server->Get("/routing/routes", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                auto rules = routeManager->getAllRules();
+                auto stats = routeManager->getStatistics();
+
+                JsonBuilder json;
+                json.startObject();
+
+                // Build routes array
+                json.key("routes").startArray();
+                for (const auto& rule : rules) {
+                    json.startObject()
+                        .key("route_id").value(rule.ruleId.toStdString())
+                        .key("enabled").value(rule.enabled)
+                        .key("priority").value(rule.priority);
+
+                    // Source device
+                    json.key("source").startObject()
+                        .key("node_id").value(rule.sourceNodeId().toString().toStdString())
+                        .key("device_id").value((int)rule.sourceDeviceId())
+                        .endObject();
+
+                    // Destination device
+                    json.key("destination").startObject()
+                        .key("node_id").value(rule.destinationNodeId().toString().toStdString())
+                        .key("device_id").value((int)rule.destinationDeviceId())
+                        .endObject();
+
+                    // Statistics
+                    json.key("messages_forwarded").value((int)rule.statistics.messagesForwarded)
+                        .key("messages_dropped").value((int)rule.statistics.messagesDropped)
+                        .endObject();
+                }
+                json.endArray();
+
+                // Summary statistics
+                json.key("total").value((int)stats.totalRules)
+                    .key("enabled").value((int)stats.enabledRules)
+                    .key("disabled").value((int)stats.disabledRules)
+                    .endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /routing/routes: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 2. POST /routing/routes - Create a new routing rule
+        server->Post("/routing/routes", [this, parseNodeId](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                // Parse JSON body (simple extraction)
+                auto body = req.body;
+                std::string srcNodeStr, dstNodeStr;
+                int srcDeviceId = 0, dstDeviceId = 0;
+                bool enabled = true;
+                int priority = 100;
+
+                // Extract fields
+                auto extractString = [&body](const std::string& key) -> std::string {
+                    std::string pattern = "\"" + key + "\":\"";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        size_t end = body.find("\"", start);
+                        if (end != std::string::npos) {
+                            return body.substr(start, end - start);
+                        }
+                    }
+                    return "";
+                };
+
+                auto extractInt = [&body](const std::string& key) -> int {
+                    std::string pattern = "\"" + key + "\":";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        size_t end = body.find_first_of(",}", start);
+                        if (end != std::string::npos) {
+                            return std::stoi(body.substr(start, end - start));
+                        }
+                    }
+                    return 0;
+                };
+
+                auto extractBool = [&body](const std::string& key) -> bool {
+                    std::string pattern = "\"" + key + "\":";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        return body.substr(start, 4) == "true";
+                    }
+                    return true;
+                };
+
+                srcNodeStr = extractString("source_node_id");
+                srcDeviceId = extractInt("source_device_id");
+                dstNodeStr = extractString("destination_node_id");
+                dstDeviceId = extractInt("destination_device_id");
+
+                // Optional fields
+                if (body.find("\"enabled\"") != std::string::npos) {
+                    enabled = extractBool("enabled");
+                }
+                if (body.find("\"priority\"") != std::string::npos) {
+                    priority = extractInt("priority");
+                }
+
+                // Parse node IDs
+                auto srcNodeId = parseNodeId(srcNodeStr);
+                auto dstNodeId = parseNodeId(dstNodeStr);
+
+                // Create rule
+                NetworkMidi::ForwardingRule rule(srcNodeId, (uint16_t)srcDeviceId,
+                                                  dstNodeId, (uint16_t)dstDeviceId);
+                rule.enabled = enabled;
+                rule.priority = priority;
+
+                // Add rule to manager
+                std::string ruleId = routeManager->addRule(rule);
+
+                // Build response
+                JsonBuilder json;
+                json.startObject()
+                    .key("route_id").value(ruleId)
+                    .key("status").value(std::string("created"))
+                    .endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 201;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error creating route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 400;
+            }
+        });
+
+        // 3. GET /routing/routes/:route_id - Get specific route details
+        server->Get(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+                auto rule = routeManager->getRule(ruleId);
+
+                if (!rule.has_value()) {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                    return;
+                }
+
+                // Build detailed response
+                JsonBuilder json;
+                json.startObject()
+                    .key("route_id").value(rule->ruleId.toStdString())
+                    .key("enabled").value(rule->enabled)
+                    .key("priority").value(rule->priority);
+
+                // Source device
+                json.key("source").startObject()
+                    .key("node_id").value(rule->sourceNodeId().toString().toStdString())
+                    .key("device_id").value((int)rule->sourceDeviceId())
+                    .endObject();
+
+                // Destination device
+                json.key("destination").startObject()
+                    .key("node_id").value(rule->destinationNodeId().toString().toStdString())
+                    .key("device_id").value((int)rule->destinationDeviceId())
+                    .endObject();
+
+                // Statistics
+                json.key("statistics").startObject()
+                    .key("messages_forwarded").value((int)rule->statistics.messagesForwarded)
+                    .key("messages_dropped").value((int)rule->statistics.messagesDropped)
+                    .endObject();
+
+                json.endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error retrieving route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 4. PUT /routing/routes/:route_id - Update a route
+        server->Put(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+                auto existingRule = routeManager->getRule(ruleId);
+
+                if (!existingRule.has_value()) {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                    return;
+                }
+
+                // Parse JSON body for updates
+                auto body = req.body;
+                auto updatedRule = *existingRule;
+
+                // Check for enabled field
+                if (body.find("\"enabled\"") != std::string::npos) {
+                    size_t pos = body.find("\"enabled\":");
+                    if (pos != std::string::npos) {
+                        size_t start = pos + 10;
+                        updatedRule.enabled = (body.substr(start, 4) == "true");
+                    }
+                }
+
+                // Check for priority field
+                if (body.find("\"priority\"") != std::string::npos) {
+                    size_t pos = body.find("\"priority\":");
+                    if (pos != std::string::npos) {
+                        size_t start = pos + 11;
+                        size_t end = body.find_first_of(",}", start);
+                        if (end != std::string::npos) {
+                            updatedRule.priority = std::stoi(body.substr(start, end - start));
+                        }
+                    }
+                }
+
+                // Update the rule
+                if (routeManager->updateRule(ruleId, updatedRule)) {
+                    JsonBuilder json;
+                    json.startObject()
+                        .key("status").value(std::string("updated"))
+                        .key("route_id").value(ruleId)
+                        .endObject();
+
+                    res.set_content(json.toString(), "application/json");
+                    res.status = 200;
+                } else {
+                    res.set_content("{\"error\":\"Failed to update route\"}", "application/json");
+                    res.status = 500;
+                }
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error updating route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 400;
+            }
+        });
+
+        // 5. DELETE /routing/routes/:route_id - Delete a route
+        server->Delete(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+
+                if (routeManager->removeRule(ruleId)) {
+                    JsonBuilder json;
+                    json.startObject()
+                        .key("status").value(std::string("deleted"))
+                        .key("route_id").value(ruleId)
+                        .endObject();
+
+                    res.set_content(json.toString(), "application/json");
+                    res.status = 200;
+                } else {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                }
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error deleting route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 6. GET /routing/table - Get complete routing state (debug endpoint)
+        server->Get("/routing/table", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                JsonBuilder json;
+                json.startObject();
+
+                if (routeManager) {
+                    auto rules = routeManager->getAllRules();
+                    auto stats = routeManager->getStatistics();
+
+                    json.key("total_rules").value((int)stats.totalRules)
+                        .key("enabled_rules").value((int)stats.enabledRules)
+                        .key("disabled_rules").value((int)stats.disabledRules)
+                        .key("total_messages_forwarded").value((int)stats.totalMessagesForwarded)
+                        .key("total_messages_dropped").value((int)stats.totalMessagesDropped);
+
+                    json.key("rules").startArray();
+                    for (const auto& rule : rules) {
+                        json.startObject()
+                            .key("route_id").value(rule.ruleId.toStdString())
+                            .key("enabled").value(rule.enabled)
+                            .key("priority").value(rule.priority)
+                            .key("source_node").value(rule.sourceNodeId().toString().toStdString())
+                            .key("source_device").value((int)rule.sourceDeviceId())
+                            .key("dest_node").value(rule.destinationNodeId().toString().toStdString())
+                            .key("dest_device").value((int)rule.destinationDeviceId())
+                            .key("messages_forwarded").value((int)rule.statistics.messagesForwarded)
+                            .key("messages_dropped").value((int)rule.statistics.messagesDropped)
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                if (deviceRegistry) {
+                    auto devices = deviceRegistry->getAllDevices();
+                    json.key("devices").startArray();
+                    for (const auto& device : devices) {
+                        json.startObject()
+                            .key("node_id").value(device.ownerNode().toString().toStdString())
+                            .key("device_id").value((int)device.id())
+                            .key("name").value(device.name.toStdString())
+                            .key("type").value(device.type.toStdString())
+                            .key("is_local").value(device.isLocal())
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                json.endObject();
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /routing/table: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+    }
+
+    const NetworkMidi::NodeIdentity& identity;
+    NetworkMidi::InstanceManager* instanceManager;
+    int requestedPort;
+    int actualPort;
+    int udpPort;
+
+    // Network components
+    std::unique_ptr<ServiceDiscovery> serviceDiscovery;
+    std::unique_ptr<NetworkMidi::UdpMidiTransport> udpTransport;
+    std::unique_ptr<NetworkMidi::DeviceRegistry> deviceRegistry;
+    std::unique_ptr<NetworkMidi::RoutingTable> routingTable;
+    std::unique_ptr<NetworkMidi::RouteManager> routeManager;
+    std::unique_ptr<NetworkMidi::MidiRouter> midiRouter;
+    std::unique_ptr<NetworkMidi::MeshManager> meshManager;
+    std::unique_ptr<NetworkTransportAdapter> networkAdapter;
+
+    // HTTP server
+    std::unique_ptr<httplib::Server> server;
+    std::thread serverThread;
+
+    // Local MIDI device tracking
+    std::vector<std::unique_ptr<juce::MidiInput>> midiInputs;
+    std::vector<std::unique_ptr<juce::MidiOutput>> midiOutputs;
+    std::map<juce::String, uint16_t> inputDeviceMap;
+};
+
+//==============================================================================
+int main(int argc, char* argv[])
+{
+    // Initialize JUCE
+    juce::ScopedJuceInitialiser_GUI juceInit;
+
+    std::cout << "\nNetwork MIDI Server v1.0 - Full Mesh Integration" << std::endl;
+    std::cout << "=================================================" << std::endl;
+
+    // Initialize node identity (each instance gets a unique UUID)
+    NetworkMidi::NodeIdentity identity;
+
+    // Initialize instance manager (creates lock file and temp directory)
+    std::unique_ptr<NetworkMidi::InstanceManager> instanceManager;
+    try {
+        instanceManager = std::make_unique<NetworkMidi::InstanceManager>(identity.getNodeId());
+    } catch (const std::exception& e) {
+        std::cerr << "\nError: " << e.what() << std::endl;
+        std::cerr << "Unexpected error during instance initialization." << std::endl;
+        return 1;
+    }
+
+    // Parse port from command line (0 = auto-assign)
+    int port = 0;
+    if (argc > 1) {
+        port = std::atoi(argv[1]);
+    }
+
+    std::cout << "\nStarting server..." << std::endl;
+    if (port == 0) {
+        std::cout << "  HTTP Port: auto-assigned" << std::endl;
+    } else {
+        std::cout << "  HTTP Port: " << port << std::endl;
+    }
+
+    NetworkMidiServer server(identity, instanceManager.get(), port);
+    server.startServer();
+
+    int actualPort = server.getActualPort();
+    int udpPort = server.getUdpPort();
+
+    std::cout << "\nServer running:" << std::endl;
+    std::cout << "  HTTP Port: " << actualPort << std::endl;
+    std::cout << "  UDP Port: " << udpPort << std::endl;
+    std::cout << "  Node: " << identity.getNodeName().toStdString() << std::endl;
+    std::cout << "  UUID: " << identity.getNodeId().toString().toStdString() << std::endl;
+    std::cout << "  Instance dir: " << instanceManager->getInstanceDirectory()
+                                       .getFullPathName().toStdString() << std::endl;
+
+    std::cout << "\nEndpoints:" << std::endl;
+    std::cout << "  GET    /health                - Health check" << std::endl;
+    std::cout << "  GET    /node/info             - Node information" << std::endl;
+    std::cout << "  GET    /midi/devices          - List all MIDI devices (local + remote)" << std::endl;
+    std::cout << "  GET    /network/mesh          - Network mesh status" << std::endl;
+    std::cout << "  GET    /network/stats         - Network statistics" << std::endl;
+    std::cout << "  GET    /routing/routes        - List all routing rules" << std::endl;
+    std::cout << "  POST   /routing/routes        - Create new routing rule" << std::endl;
+    std::cout << "  GET    /routing/routes/:id    - Get specific routing rule" << std::endl;
+    std::cout << "  PUT    /routing/routes/:id    - Update routing rule" << std::endl;
+    std::cout << "  DELETE /routing/routes/:id    - Delete routing rule" << std::endl;
+    std::cout << "  GET    /routing/table         - Get complete routing state (debug)" << std::endl;
+
+    std::cout << "\nReady. Press Ctrl+C to stop..." << std::endl;
+
+    // Run until interrupted
+    while (true) {
+        std::this_thread::sleep_for(std::chrono::seconds(1));
+    }
+
+    return 0;
+}
diff --git a/modules/juce/midi-server/NetworkMidiServer.cpp.bak b/modules/juce/midi-server/NetworkMidiServer.cpp.bak
new file mode 100644
index 0000000..04e61f3
--- /dev/null
+++ b/modules/juce/midi-server/NetworkMidiServer.cpp.bak
@@ -0,0 +1,1332 @@
+/**
+ * Network MIDI Server - Zero-configuration network MIDI mesh
+ *
+ * Provides HTTP API for MIDI operations and supports auto-discovery
+ * for multi-node network MIDI mesh topology.
+ *
+ * Uses cpp-httplib for robust HTTP server implementation.
+ */
+
+#include <juce_core/juce_core.h>
+#include <juce_events/juce_events.h>
+#include <juce_audio_devices/juce_audio_devices.h>
+
+#include "httplib.h"
+#include "network/core/NodeIdentity.h"
+#include "network/core/InstanceManager.h"
+#include "network/discovery/ServiceDiscovery.h"
+#include "network/mesh/MeshManager.h"
+#include "network/routing/MidiRouter.h"
+#include "network/routing/DeviceRegistry.h"
+#include "network/routing/RoutingTable.h"
+#include "network/routing/RouteManager.h"
+#include "network/transport/UdpMidiTransport.h"
+
+#include <iostream>
+#include <map>
+#include <memory>
+#include <mutex>
+#include <queue>
+#include <vector>
+#include <string>
+#include <thread>
+#include <sstream>
+
+//==============================================================================
+// Simple JSON builder for responses
+class JsonBuilder
+{
+public:
+    JsonBuilder& startObject() {
+        if (!firstItem) ss << ",";
+        ss << "{";
+        firstItem = true;
+        return *this;
+    }
+    JsonBuilder& endObject() {
+        ss << "}";
+        firstItem = false;  // Next key/item in parent needs comma
+        return *this;
+    }
+    JsonBuilder& startArray() {
+        if (!firstItem) ss << ",";
+        ss << "[";
+        firstItem = true;
+        return *this;
+    }
+    JsonBuilder& endArray() {
+        ss << "]";
+        firstItem = false;  // Next item in parent needs comma
+        return *this;
+    }
+
+    JsonBuilder& key(const std::string& k) {
+        if (!firstItem) ss << ",";
+        ss << "\"" << k << "\":";
+        firstItem = true;  // Next value (not key) should not have comma
+        return *this;
+    }
+
+    JsonBuilder& value(const std::string& v) {
+        ss << "\"" << v << "\"";
+        firstItem = false;  // Next key needs comma
+        return *this;
+    }
+
+    JsonBuilder& value(bool b) {
+        ss << (b ? "true" : "false");
+        firstItem = false;  // Next key needs comma
+        return *this;
+    }
+
+    JsonBuilder& value(int i) {
+        ss << i;
+        firstItem = false;  // Next key needs comma
+        return *this;
+    }
+
+    JsonBuilder& arrayValue(const std::string& v) {
+        if (!firstItem) ss << ",";
+        ss << "\"" << v << "\"";
+        firstItem = false;
+        return *this;
+    }
+
+    JsonBuilder& arrayValue(int i) {
+        if (!firstItem) ss << ",";
+        ss << i;
+        firstItem = false;
+        return *this;
+    }
+
+    std::string toString() { return ss.str(); }
+
+private:
+    std::stringstream ss;
+    bool firstItem = true;
+};
+
+//==============================================================================
+// JUCE MIDI port wrapper implementing MidiPortInterface
+class JuceMidiPort : public NetworkMidi::MidiPortInterface
+{
+public:
+    JuceMidiPort(const juce::String& deviceName, bool isInputPort)
+        : name(deviceName), inputPort(isInputPort) {}
+
+    void sendMessage(const std::vector<uint8_t>& data) override {
+        if (!output || data.empty()) return;
+
+        if (data[0] == 0xF0) {
+            // SysEx message
+            if (data.back() != 0xF7 || data.size() <= 2) {
+                std::cerr << "Warning: Invalid SysEx message\n";
+                return;
+            }
+            output->sendMessageNow(
+                juce::MidiMessage::createSysExMessage(
+                    data.data() + 1,
+                    (int)data.size() - 2
+                )
+            );
+        } else if (data.size() >= 1 && data.size() <= 3) {
+            output->sendMessageNow(
+                juce::MidiMessage(data.data(), (int)data.size())
+            );
+        }
+    }
+
+    std::vector<std::vector<uint8_t>> getMessages() override {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        std::vector<std::vector<uint8_t>> result;
+        while (!messageQueue.empty()) {
+            result.push_back(messageQueue.front());
+            messageQueue.pop();
+        }
+        return result;
+    }
+
+    juce::String getName() const override { return name; }
+    bool isInput() const override { return inputPort; }
+    bool isOutput() const override { return !inputPort; }
+
+    void setMidiInput(std::unique_ptr<juce::MidiInput> in) {
+        input = std::move(in);
+    }
+
+    void setMidiOutput(std::unique_ptr<juce::MidiOutput> out) {
+        output = std::move(out);
+    }
+
+    void queueMessage(const std::vector<uint8_t>& data) {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        messageQueue.push(data);
+    }
+
+private:
+    juce::String name;
+    bool inputPort;
+    std::unique_ptr<juce::MidiInput> input;
+    std::unique_ptr<juce::MidiOutput> output;
+    std::queue<std::vector<uint8_t>> messageQueue;
+    std::mutex queueMutex;
+};
+
+//==============================================================================
+// Network transport adapter for MidiRouter
+class NetworkTransportAdapter : public NetworkMidi::NetworkTransport
+{
+public:
+    NetworkTransportAdapter(NetworkMidi::UdpMidiTransport& transport)
+        : udpTransport(transport) {}
+
+    void sendMidiMessage(const juce::Uuid& destNode,
+                        uint16_t deviceId,
+                        const std::vector<uint8_t>& midiData) override {
+        // Get destination node info from mesh manager
+        if (meshManager) {
+            auto nodeInfo = meshManager->getNodeInfo(destNode);
+            if (nodeInfo.isValid()) {
+                udpTransport.sendMessage(
+                    destNode,
+                    nodeInfo.ipAddress,
+                    nodeInfo.udpPort,
+                    deviceId,
+                    midiData
+                );
+            }
+        }
+    }
+
+    void setMeshManager(NetworkMidi::MeshManager* manager) {
+        meshManager = manager;
+    }
+
+private:
+    NetworkMidi::UdpMidiTransport& udpTransport;
+    NetworkMidi::MeshManager* meshManager = nullptr;
+};
+
+//==============================================================================
+// Helper to convert between NodeInfo types (ServiceDiscovery vs NetworkMidi)
+NetworkMidi::NodeInfo convertToMeshNodeInfo(const ::NodeInfo& discoveryNode) {
+    NetworkMidi::NodeInfo meshNode;
+    meshNode.uuid = discoveryNode.uuid;
+    meshNode.name = discoveryNode.name;
+    meshNode.hostname = discoveryNode.hostname;
+    meshNode.ipAddress = discoveryNode.ipAddress;
+    meshNode.httpPort = discoveryNode.httpPort;
+    meshNode.udpPort = discoveryNode.udpPort;
+    meshNode.version = discoveryNode.version;
+    meshNode.deviceCount = discoveryNode.deviceCount;
+    return meshNode;
+}
+
+//==============================================================================
+// Network MIDI Server class with full mesh integration
+class NetworkMidiServer : public juce::MidiInputCallback
+{
+public:
+    NetworkMidiServer(const NetworkMidi::NodeIdentity& nodeIdentity,
+                     NetworkMidi::InstanceManager* instanceMgr,
+                     int port = 0)
+        : identity(nodeIdentity)
+        , instanceManager(instanceMgr)
+        , requestedPort(port)
+        , actualPort(0)
+        , udpPort(0) {}
+
+    ~NetworkMidiServer() {
+        stopServer();
+    }
+
+    int getActualPort() const {
+        return actualPort;
+    }
+
+    int getUdpPort() const {
+        return udpPort;
+    }
+
+    void startServer() {
+        // 1. Create UDP transport (auto-assign port)
+        udpTransport = std::make_unique<NetworkMidi::UdpMidiTransport>(0);
+        udpTransport->setNodeId(identity.getNodeId());
+        udpTransport->start();
+        udpPort = udpTransport->getPort();
+
+        std::cout << "UDP transport started on port " << udpPort << std::endl;
+
+        // 2. Create routing infrastructure
+        deviceRegistry = std::make_unique<NetworkMidi::DeviceRegistry>();
+        routingTable = std::make_unique<NetworkMidi::RoutingTable>();
+        routeManager = std::make_unique<NetworkMidi::RouteManager>(*deviceRegistry);
+
+        // 3. Create MIDI router BEFORE registering devices
+        midiRouter = std::make_unique<NetworkMidi::MidiRouter>(*deviceRegistry, *routingTable);
+        networkAdapter = std::make_unique<NetworkTransportAdapter>(*udpTransport);
+        midiRouter->setNetworkTransport(networkAdapter.get());
+
+        // 4. Enumerate and register local MIDI devices (now that router exists)
+        registerLocalMidiDevices();
+
+        // 5. Load persisted routes (after devices are registered)
+        loadRoutes();
+
+        // Set up UDP packet reception callback
+        udpTransport->onPacketReceived = [this](const NetworkMidi::MidiPacket& packet,
+                                                const juce::String& /*sourceAddr*/,
+                                                int /*sourcePort*/) {
+            handleNetworkPacket(packet);
+        };
+
+        // 6. Create HTTP server
+        server = std::make_unique<httplib::Server>();
+        setupRoutes();
+
+        // Start HTTP server in a separate thread
+        serverThread = std::thread([this]() {
+            if (requestedPort == 0) {
+                actualPort = server->bind_to_any_port("0.0.0.0");
+                if (actualPort < 0) {
+                    std::cerr << "Failed to bind to any port" << std::endl;
+                    return;
+                }
+            } else {
+                if (!server->bind_to_port("0.0.0.0", requestedPort)) {
+                    std::cerr << "Failed to bind to port " << requestedPort << std::endl;
+                    return;
+                }
+                actualPort = requestedPort;
+            }
+
+            std::cout << "HTTP Server bound to port " << actualPort << std::endl;
+            server->listen_after_bind();
+        });
+
+        // Wait for HTTP server to start
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+
+        // 7. Create service discovery (advertise this node)
+        int deviceCount = deviceRegistry->getLocalDeviceCount();
+        serviceDiscovery = std::make_unique<ServiceDiscovery>(
+            identity.getNodeId(),
+            identity.getNodeName(),
+            actualPort,
+            udpPort,
+            deviceCount
+        );
+
+        // Set up discovery callbacks
+        setupDiscoveryCallbacks();
+
+        serviceDiscovery->advertise();
+        std::cout << "Started mDNS advertising" << std::endl;
+
+        // 8. Create mesh manager (handle peer connections)
+        meshManager = std::make_unique<NetworkMidi::MeshManager>(
+            identity.getNodeId(),
+            actualPort,
+            udpPort
+        );
+
+        // Wire mesh callbacks
+        setupMeshCallbacks();
+
+        meshManager->start();
+        std::cout << "Mesh manager started" << std::endl;
+
+        // Connect network adapter to mesh manager
+        networkAdapter->setMeshManager(meshManager.get());
+
+        // Phase 4.5: Inject UuidRegistry and node ID into MidiRouter
+        if (midiRouter) {
+            midiRouter->setNodeId(identity.getNodeId());
+            midiRouter->setUuidRegistry(&meshManager->getUuidRegistry());
+        }
+
+        // 9. NOW start MIDI inputs (after everything is fully initialized)
+        startMidiInputs();
+    }
+
+    void stopServer() {
+        // Save routes before shutdown
+        saveRoutes();
+
+        // Stop MIDI inputs first
+        for (auto& input : midiInputs) {
+            if (input) {
+                input->stop();
+            }
+        }
+
+        // Stop mesh and discovery
+        if (meshManager) {
+            meshManager->stop();
+        }
+        if (serviceDiscovery) {
+            serviceDiscovery->stopAdvertising();
+            serviceDiscovery->stopBrowsing();
+        }
+
+        // Stop UDP transport
+        if (udpTransport) {
+            udpTransport->stop();
+        }
+
+        // Stop HTTP server
+        if (server) {
+            server->stop();
+        }
+        if (serverThread.joinable()) {
+            serverThread.join();
+        }
+
+        // Clean up MIDI ports
+        if (midiRouter) {
+            midiRouter->clearLocalPorts();
+        }
+        midiInputs.clear();
+        midiOutputs.clear();
+    }
+
+    // MidiInputCallback interface
+    void handleIncomingMidiMessage(juce::MidiInput* source,
+                                   const juce::MidiMessage& message) override {
+        // Convert JUCE message to raw bytes
+        std::vector<uint8_t> data(
+            message.getRawData(),
+            message.getRawData() + message.getRawDataSize()
+        );
+
+        // Find device ID for this input
+        auto deviceId = getDeviceIdForInput(source);
+        if (deviceId != 0xFFFF && midiRouter) {
+            // Route through MidiRouter (handles local and network delivery)
+            midiRouter->sendMessage(deviceId, data);
+        }
+    }
+
+private:
+    void registerLocalMidiDevices() {
+        uint16_t deviceId = 1;  // Start at 1 (0 reserved)
+
+        // Register MIDI inputs (but don't start them yet)
+        auto inputs = juce::MidiInput::getAvailableDevices();
+        for (const auto& deviceInfo : inputs) {
+            // Add to device registry
+            deviceRegistry->addLocalDevice(
+                deviceId,
+                deviceInfo.name,
+                "input",
+                deviceInfo.identifier
+            );
+
+            // Add to routing table (local route has null UUID)
+            routingTable->addRoute(
+                juce::Uuid(),  // Local devices use null UUID
+                deviceId,
+                deviceInfo.name,
+                "input"
+            );
+
+            // Open MIDI input but DON'T start it yet
+            auto input = juce::MidiInput::openDevice(
+                deviceInfo.identifier,
+                this  // MidiInputCallback
+            );
+            if (input) {
+                // Create port wrapper
+                auto port = std::make_unique<JuceMidiPort>(deviceInfo.name, true);
+                port->setMidiInput(std::move(input));
+
+                // Store reference for device lookup
+                inputDeviceMap[deviceInfo.identifier] = deviceId;
+
+                // Register with router
+                midiRouter->registerLocalPort(deviceId, std::move(port));
+            }
+            deviceId++;
+        }
+
+        // Register MIDI outputs
+        auto outputs = juce::MidiOutput::getAvailableDevices();
+        for (const auto& deviceInfo : outputs) {
+            // Add to device registry
+            deviceRegistry->addLocalDevice(
+                deviceId,
+                deviceInfo.name,
+                "output",
+                deviceInfo.identifier
+            );
+
+            // Add to routing table
+            routingTable->addRoute(
+                juce::Uuid(),  // Local devices use null UUID
+                deviceId,
+                deviceInfo.name,
+                "output"
+            );
+
+            // Open MIDI output
+            auto output = juce::MidiOutput::openDevice(deviceInfo.identifier);
+            if (output) {
+                // Create port wrapper
+                auto port = std::make_unique<JuceMidiPort>(deviceInfo.name, false);
+                port->setMidiOutput(std::move(output));
+
+                // Register with router
+                midiRouter->registerLocalPort(deviceId, std::move(port));
+            }
+            deviceId++;
+        }
+
+        std::cout << "Registered " << deviceRegistry->getLocalDeviceCount()
+                  << " local MIDI devices" << std::endl;
+    }
+
+    void startMidiInputs() {
+        // Start all MIDI inputs now that everything is initialized
+        auto localDevices = deviceRegistry->getLocalDevices();
+        for (const auto& device : localDevices) {
+            if (device.type == "input") {
+                // Find the corresponding MIDI input by device ID
+                // This requires storing the inputs separately
+                // For now, we can iterate through available devices again
+                auto inputs = juce::MidiInput::getAvailableDevices();
+                for (const auto& deviceInfo : inputs) {
+                    if (inputDeviceMap.count(deviceInfo.identifier) > 0 &&
+                        inputDeviceMap[deviceInfo.identifier] == device.id()) {
+                        // Re-open and start the input
+                        auto input = juce::MidiInput::openDevice(
+                            deviceInfo.identifier,
+                            this
+                        );
+                        if (input) {
+                            input->start();
+                            midiInputs.push_back(std::move(input));
+                        }
+                    }
+                }
+            }
+        }
+        std::cout << "Started " << midiInputs.size() << " MIDI inputs" << std::endl;
+    }
+
+    uint16_t getDeviceIdForInput(juce::MidiInput* source) {
+        if (!source) return 0xFFFF;
+
+        auto identifier = source->getIdentifier();
+        auto it = inputDeviceMap.find(identifier);
+        if (it != inputDeviceMap.end()) {
+            return it->second;
+        }
+        return 0xFFFF;
+    }
+
+    void setupDiscoveryCallbacks() {
+        serviceDiscovery->startBrowsing(
+            [this](const ::NodeInfo& node) {
+                std::cout << "Discovered peer: " << node.name.toStdString()
+                          << " (UUID: " << node.uuid.toString().toStdString() << ")"
+                          << " at " << node.ipAddress.toStdString()
+                          << ":" << node.httpPort
+                          << " (UDP: " << node.udpPort << ")"
+                          << std::endl;
+
+                // Convert to mesh NodeInfo and notify mesh manager
+                if (meshManager) {
+                    auto meshNode = convertToMeshNodeInfo(node);
+                    meshManager->onNodeDiscovered(meshNode);
+                }
+            },
+            [this](const juce::Uuid& nodeId) {
+                std::cout << "Lost peer: " << nodeId.toString().toStdString() << std::endl;
+
+                // Notify mesh manager
+                if (meshManager) {
+                    meshManager->onNodeRemoved(nodeId);
+                }
+            }
+        );
+    }
+
+    void setupMeshCallbacks() {
+        meshManager->onNodeConnected = [this](const NetworkMidi::NodeInfo& node) {
+            std::cout << "Connected to node: " << node.name.toStdString()
+                      << " (" << node.deviceCount << " devices)" << std::endl;
+        };
+
+        meshManager->onNodeDisconnected = [this](const juce::Uuid& nodeId,
+                                                  const juce::String& reason) {
+            std::cout << "Disconnected from node: " << nodeId.toString().toStdString()
+                      << " - " << reason.toStdString() << std::endl;
+        };
+
+        meshManager->onConnectionFailed = [this](const NetworkMidi::NodeInfo& node,
+                                                 const juce::String& error) {
+            std::cerr << "Connection failed to " << node.name.toStdString()
+                      << ": " << error.toStdString() << std::endl;
+        };
+
+        // Register remote devices when they are discovered
+        meshManager->onRemoteDevicesDiscovered = [this](const juce::Uuid& nodeId,
+                                                        const std::vector<NetworkMidi::DeviceInfo>& devices) {
+            std::cout << "Registering " << devices.size() << " remote devices from node "
+                      << nodeId.toString().toStdString() << std::endl;
+
+            // Add each remote device to registry and routing table
+            for (const auto& device : devices) {
+                uint16_t remoteDeviceId = device.id;
+
+                // Add to device registry as remote device
+                deviceRegistry->addRemoteDevice(
+                    nodeId,
+                    remoteDeviceId,
+                    device.name,
+                    device.type
+                );
+
+                // Add route to routing table
+                routingTable->addRoute(
+                    nodeId,  // Remote node UUID
+                    remoteDeviceId,
+                    device.name,
+                    device.type
+                );
+
+                std::cout << "  Registered remote device: " << device.name.toStdString()
+                          << " (ID: " << remoteDeviceId << ", type: " << device.type.toStdString() << ")"
+                          << std::endl;
+            }
+        };
+    }
+
+    void handleNetworkPacket(const NetworkMidi::MidiPacket& packet) {
+        // Route received network MIDI to appropriate local device
+        if (midiRouter) {
+            // Use getter methods to access packet fields
+            auto midiData = packet.getMidiData();
+            midiRouter->onNetworkPacketReceived(
+                packet.getSourceNode(),
+                packet.getDeviceId(),
+                midiData
+            );
+        }
+    }
+
+    void loadRoutes() {
+        if (!routeManager || !instanceManager) {
+            return;
+        }
+
+        auto routesFile = instanceManager->getStateFile("routes.json");
+        if (routesFile.existsAsFile()) {
+            std::cout << "Loading routes from " << routesFile.getFullPathName().toStdString() << std::endl;
+            if (routeManager->loadFromFile(routesFile)) {
+                int count = routeManager->getRuleCount();
+                std::cout << "Loaded " << count << " routing rule(s)" << std::endl;
+            } else {
+                std::cerr << "Warning: Failed to load routes from file" << std::endl;
+            }
+        } else {
+            std::cout << "No routes file found, starting with empty routing table" << std::endl;
+        }
+    }
+
+    void saveRoutes() {
+        if (!routeManager || !instanceManager) {
+            return;
+        }
+
+        auto routesFile = instanceManager->getStateFile("routes.json");
+        std::cout << "Saving routes to " << routesFile.getFullPathName().toStdString() << std::endl;
+        if (routeManager->saveToFile(routesFile)) {
+            int count = routeManager->getRuleCount();
+            std::cout << "Saved " << count << " routing rule(s)" << std::endl;
+        } else {
+            std::cerr << "Warning: Failed to save routes to file" << std::endl;
+        }
+    }
+
+    void setupRoutes() {
+        // Health check endpoint
+        server->Get("/health", [](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject().key("status").value(std::string("ok")).endObject();
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // Node information endpoint
+        server->Get("/node/info", [this](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject()
+                .key("uuid").value(identity.getNodeId().toString().toStdString())
+                .key("name").value(identity.getNodeName().toStdString())
+                .key("hostname").value(identity.getHostname().toStdString())
+                .key("http_port").value(actualPort)
+                .key("udp_port").value(udpPort)
+                .key("local_devices").value(deviceRegistry ? deviceRegistry->getLocalDeviceCount() : 0)
+                .key("total_devices").value(deviceRegistry ? deviceRegistry->getTotalDeviceCount() : 0)
+                .endObject();
+
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // List MIDI devices (integrated with device registry)
+        server->Get("/midi/devices", [this](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject();
+
+            if (deviceRegistry) {
+                auto devices = deviceRegistry->getAllDevices();
+
+                json.key("devices").startArray();
+                for (const auto& device : devices) {
+                    json.startObject()
+                        .key("id").value((int)device.id())
+                        .key("name").value(device.name.toStdString())
+                        .key("type").value(device.type.toStdString())
+                        .key("is_local").value(device.isLocal())
+                        .key("owner_node").value(device.ownerNode().toString().toStdString())
+                        .endObject();
+                }
+                json.endArray();
+            }
+
+            json.endObject();
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // Network mesh status
+        server->Get("/network/mesh", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                std::cerr << "DEBUG: /network/mesh: Starting" << std::endl;
+                JsonBuilder json;
+                json.startObject();
+
+                if (meshManager) {
+                    std::cerr << "DEBUG: /network/mesh: Getting statistics" << std::endl;
+                    auto stats = meshManager->getStatistics();
+                    std::cerr << "DEBUG: /network/mesh: Got statistics" << std::endl;
+                    json.key("connected_nodes").value((int)stats.connectedNodes)
+                        .key("total_nodes").value((int)stats.totalNodes)
+                        .key("total_devices").value(stats.totalDevices);
+
+                    std::cerr << "DEBUG: /network/mesh: Getting connected nodes" << std::endl;
+                    json.key("nodes").startArray();
+                    auto nodes = meshManager->getConnectedNodes();
+                    std::cerr << "DEBUG: /network/mesh: Got " << nodes.size() << " nodes" << std::endl;
+                    for (const auto& node : nodes) {
+                        std::cerr << "DEBUG: /network/mesh: Processing node " << node.name.toStdString() << std::endl;
+                        json.startObject()
+                            .key("uuid").value(node.uuid.toString().toStdString())
+                            .key("name").value(node.name.toStdString())
+                            .key("ip").value(node.ipAddress.toStdString())
+                            .key("http_port").value(node.httpPort)
+                            .key("udp_port").value(node.udpPort)
+                            .key("devices").value(node.deviceCount)
+                            .endObject();
+                        std::cerr << "DEBUG: /network/mesh: Finished node " << node.name.toStdString() << std::endl;
+                    }
+                    json.endArray();
+                } else {
+                    json.key("error").value(std::string("Mesh manager not initialized"));
+                }
+
+                std::cerr << "DEBUG: /network/mesh: Building JSON" << std::endl;
+                json.endObject();
+                std::cerr << "DEBUG: /network/mesh: Sending response" << std::endl;
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+                std::cerr << "DEBUG: /network/mesh: Done" << std::endl;
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /network/mesh: " << e.what() << std::endl;
+                res.set_content(std::string("Error: ") + e.what(), "text/plain");
+                res.status = 500;
+            }
+        });
+
+        // Router statistics
+        server->Get("/network/stats", [this](const httplib::Request&, httplib::Response& res) {
+            JsonBuilder json;
+            json.startObject();
+
+            if (midiRouter) {
+                auto stats = midiRouter->getStatistics();
+                json.key("local_sent").value((int)stats.localMessagesSent)
+                    .key("local_received").value((int)stats.localMessagesReceived)
+                    .key("network_sent").value((int)stats.networkMessagesSent)
+                    .key("network_received").value((int)stats.networkMessagesReceived)
+                    .key("routing_errors").value((int)stats.routingErrors);
+            }
+
+            if (udpTransport) {
+                auto stats = udpTransport->getStatistics();
+                json.key("packets_sent").value((int)stats.packetsSent)
+                    .key("packets_received").value((int)stats.packetsReceived)
+                    .key("bytes_sent").value((int)stats.bytesSent)
+                    .key("bytes_received").value((int)stats.bytesReceived);
+            }
+
+            json.endObject();
+            res.set_content(json.toString(), "application/json");
+        });
+
+        // Network handshake endpoint (for mesh connection establishment)
+        server->Post("/network/handshake", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                // Parse incoming handshake request
+                // Expected format: {"node_id":"...", "node_name":"...", "udp_endpoint":"...", "version":"..."}
+
+                std::string nodeIdStr, nodeName, udpEndpoint, version;
+
+                // Simple JSON parsing (extract values)
+                auto body = req.body;
+                size_t pos;
+
+                // Extract node_id
+                pos = body.find("\"node_id\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 11;
+                    size_t end = body.find("\"", start);
+                    nodeIdStr = body.substr(start, end - start);
+                }
+
+                // Extract node_name
+                pos = body.find("\"node_name\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 13;
+                    size_t end = body.find("\"", start);
+                    nodeName = body.substr(start, end - start);
+                }
+
+                // Extract udp_endpoint
+                pos = body.find("\"udp_endpoint\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 16;
+                    size_t end = body.find("\"", start);
+                    udpEndpoint = body.substr(start, end - start);
+                }
+
+                // Extract version
+                pos = body.find("\"version\":\"");
+                if (pos != std::string::npos) {
+                    size_t start = pos + 11;
+                    size_t end = body.find("\"", start);
+                    version = body.substr(start, end - start);
+                }
+
+                std::cout << "Handshake request from: " << nodeName
+                          << " (UUID: " << nodeIdStr << ")"
+                          << " UDP: " << udpEndpoint << std::endl;
+
+                // Build handshake response with our node info and device list
+                JsonBuilder json;
+                json.startObject()
+                    .key("node_id").value(identity.getNodeId().toString().toStdString())
+                    .key("node_name").value(identity.getNodeName().toStdString())
+                    .key("udp_endpoint").value(std::to_string(udpPort))
+                    .key("version").value(std::string("1.0"));
+
+                // Add device list
+                if (deviceRegistry) {
+                    auto devices = deviceRegistry->getLocalDevices();
+                    json.key("devices").startArray();
+                    for (const auto& device : devices) {
+                        json.startObject()
+                            .key("id").value((int)device.id())
+                            .key("name").value(device.name.toStdString())
+                            .key("type").value(device.type.toStdString())
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                json.endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Handshake error: " << e.what() << std::endl;
+                res.set_content(std::string("Handshake failed: ") + e.what(), "text/plain");
+                res.status = 500;
+            }
+        });
+
+        //=================================================================================
+        // MIDI Routing Configuration API (Phase 2)
+        //=================================================================================
+
+        // Helper to parse node ID from string ("local" -> null UUID)
+        auto parseNodeId = [](const std::string& str) -> juce::Uuid {
+            if (str == "local" || str.empty()) {
+                return juce::Uuid();
+            }
+            return juce::Uuid(str);
+        };
+
+        // 1. GET /routing/routes - List all routing rules
+        server->Get("/routing/routes", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                auto rules = routeManager->getAllRules();
+                auto stats = routeManager->getStatistics();
+
+                JsonBuilder json;
+                json.startObject();
+
+                // Build routes array
+                json.key("routes").startArray();
+                for (const auto& rule : rules) {
+                    json.startObject()
+                        .key("route_id").value(rule.ruleId.toStdString())
+                        .key("enabled").value(rule.enabled)
+                        .key("priority").value(rule.priority);
+
+                    // Source device
+                    json.key("source").startObject()
+                        .key("node_id").value(rule.sourceNodeId().toString().toStdString())
+                        .key("device_id").value((int)rule.sourceDeviceId())
+                        .endObject();
+
+                    // Destination device
+                    json.key("destination").startObject()
+                        .key("node_id").value(rule.destinationNodeId().toString().toStdString())
+                        .key("device_id").value((int)rule.destinationDeviceId())
+                        .endObject();
+
+                    // Statistics
+                    json.key("messages_forwarded").value((int)rule.statistics.messagesForwarded)
+                        .key("messages_dropped").value((int)rule.statistics.messagesDropped)
+                        .endObject();
+                }
+                json.endArray();
+
+                // Summary statistics
+                json.key("total").value((int)stats.totalRules)
+                    .key("enabled").value((int)stats.enabledRules)
+                    .key("disabled").value((int)stats.disabledRules)
+                    .endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /routing/routes: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 2. POST /routing/routes - Create a new routing rule
+        server->Post("/routing/routes", [this, parseNodeId](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                // Parse JSON body (simple extraction)
+                auto body = req.body;
+                std::string srcNodeStr, dstNodeStr;
+                int srcDeviceId = 0, dstDeviceId = 0;
+                bool enabled = true;
+                int priority = 100;
+
+                // Extract fields
+                auto extractString = [&body](const std::string& key) -> std::string {
+                    std::string pattern = "\"" + key + "\":\"";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        size_t end = body.find("\"", start);
+                        if (end != std::string::npos) {
+                            return body.substr(start, end - start);
+                        }
+                    }
+                    return "";
+                };
+
+                auto extractInt = [&body](const std::string& key) -> int {
+                    std::string pattern = "\"" + key + "\":";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        size_t end = body.find_first_of(",}", start);
+                        if (end != std::string::npos) {
+                            return std::stoi(body.substr(start, end - start));
+                        }
+                    }
+                    return 0;
+                };
+
+                auto extractBool = [&body](const std::string& key) -> bool {
+                    std::string pattern = "\"" + key + "\":";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        return body.substr(start, 4) == "true";
+                    }
+                    return true;
+                };
+
+                srcNodeStr = extractString("source_node_id");
+                srcDeviceId = extractInt("source_device_id");
+                dstNodeStr = extractString("destination_node_id");
+                dstDeviceId = extractInt("destination_device_id");
+
+                // Optional fields
+                if (body.find("\"enabled\"") != std::string::npos) {
+                    enabled = extractBool("enabled");
+                }
+                if (body.find("\"priority\"") != std::string::npos) {
+                    priority = extractInt("priority");
+                }
+
+                // Parse node IDs
+                auto srcNodeId = parseNodeId(srcNodeStr);
+                auto dstNodeId = parseNodeId(dstNodeStr);
+
+                // Create rule
+                NetworkMidi::ForwardingRule rule(srcNodeId, (uint16_t)srcDeviceId,
+                                                  dstNodeId, (uint16_t)dstDeviceId);
+                rule.enabled = enabled;
+                rule.priority = priority;
+
+                // Add rule to manager
+                std::string ruleId = routeManager->addRule(rule);
+
+                // Build response
+                JsonBuilder json;
+                json.startObject()
+                    .key("route_id").value(ruleId)
+                    .key("status").value(std::string("created"))
+                    .endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 201;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error creating route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 400;
+            }
+        });
+
+        // 3. GET /routing/routes/:route_id - Get specific route details
+        server->Get(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+                auto rule = routeManager->getRule(ruleId);
+
+                if (!rule.has_value()) {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                    return;
+                }
+
+                // Build detailed response
+                JsonBuilder json;
+                json.startObject()
+                    .key("route_id").value(rule->ruleId.toStdString())
+                    .key("enabled").value(rule->enabled)
+                    .key("priority").value(rule->priority);
+
+                // Source device
+                json.key("source").startObject()
+                    .key("node_id").value(rule->sourceNodeId().toString().toStdString())
+                    .key("device_id").value((int)rule->sourceDeviceId())
+                    .endObject();
+
+                // Destination device
+                json.key("destination").startObject()
+                    .key("node_id").value(rule->destinationNodeId().toString().toStdString())
+                    .key("device_id").value((int)rule->destinationDeviceId())
+                    .endObject();
+
+                // Statistics
+                json.key("statistics").startObject()
+                    .key("messages_forwarded").value((int)rule->statistics.messagesForwarded)
+                    .key("messages_dropped").value((int)rule->statistics.messagesDropped)
+                    .endObject();
+
+                json.endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error retrieving route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 4. PUT /routing/routes/:route_id - Update a route
+        server->Put(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+                auto existingRule = routeManager->getRule(ruleId);
+
+                if (!existingRule.has_value()) {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                    return;
+                }
+
+                // Parse JSON body for updates
+                auto body = req.body;
+                auto updatedRule = *existingRule;
+
+                // Check for enabled field
+                if (body.find("\"enabled\"") != std::string::npos) {
+                    size_t pos = body.find("\"enabled\":");
+                    if (pos != std::string::npos) {
+                        size_t start = pos + 10;
+                        updatedRule.enabled = (body.substr(start, 4) == "true");
+                    }
+                }
+
+                // Check for priority field
+                if (body.find("\"priority\"") != std::string::npos) {
+                    size_t pos = body.find("\"priority\":");
+                    if (pos != std::string::npos) {
+                        size_t start = pos + 11;
+                        size_t end = body.find_first_of(",}", start);
+                        if (end != std::string::npos) {
+                            updatedRule.priority = std::stoi(body.substr(start, end - start));
+                        }
+                    }
+                }
+
+                // Update the rule
+                if (routeManager->updateRule(ruleId, updatedRule)) {
+                    JsonBuilder json;
+                    json.startObject()
+                        .key("status").value(std::string("updated"))
+                        .key("route_id").value(ruleId)
+                        .endObject();
+
+                    res.set_content(json.toString(), "application/json");
+                    res.status = 200;
+                } else {
+                    res.set_content("{\"error\":\"Failed to update route\"}", "application/json");
+                    res.status = 500;
+                }
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error updating route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 400;
+            }
+        });
+
+        // 5. DELETE /routing/routes/:route_id - Delete a route
+        server->Delete(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+
+                if (routeManager->removeRule(ruleId)) {
+                    JsonBuilder json;
+                    json.startObject()
+                        .key("status").value(std::string("deleted"))
+                        .key("route_id").value(ruleId)
+                        .endObject();
+
+                    res.set_content(json.toString(), "application/json");
+                    res.status = 200;
+                } else {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                }
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error deleting route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 6. GET /routing/table - Get complete routing state (debug endpoint)
+        server->Get("/routing/table", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                JsonBuilder json;
+                json.startObject();
+
+                if (routeManager) {
+                    auto rules = routeManager->getAllRules();
+                    auto stats = routeManager->getStatistics();
+
+                    json.key("total_rules").value((int)stats.totalRules)
+                        .key("enabled_rules").value((int)stats.enabledRules)
+                        .key("disabled_rules").value((int)stats.disabledRules)
+                        .key("total_messages_forwarded").value((int)stats.totalMessagesForwarded)
+                        .key("total_messages_dropped").value((int)stats.totalMessagesDropped);
+
+                    json.key("rules").startArray();
+                    for (const auto& rule : rules) {
+                        json.startObject()
+                            .key("route_id").value(rule.ruleId.toStdString())
+                            .key("enabled").value(rule.enabled)
+                            .key("priority").value(rule.priority)
+                            .key("source_node").value(rule.sourceNodeId().toString().toStdString())
+                            .key("source_device").value((int)rule.sourceDeviceId())
+                            .key("dest_node").value(rule.destinationNodeId().toString().toStdString())
+                            .key("dest_device").value((int)rule.destinationDeviceId())
+                            .key("messages_forwarded").value((int)rule.statistics.messagesForwarded)
+                            .key("messages_dropped").value((int)rule.statistics.messagesDropped)
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                if (deviceRegistry) {
+                    auto devices = deviceRegistry->getAllDevices();
+                    json.key("devices").startArray();
+                    for (const auto& device : devices) {
+                        json.startObject()
+                            .key("node_id").value(device.ownerNode().toString().toStdString())
+                            .key("device_id").value((int)device.id())
+                            .key("name").value(device.name.toStdString())
+                            .key("type").value(device.type.toStdString())
+                            .key("is_local").value(device.isLocal())
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                json.endObject();
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /routing/table: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+    }
+
+    const NetworkMidi::NodeIdentity& identity;
+    NetworkMidi::InstanceManager* instanceManager;
+    int requestedPort;
+    int actualPort;
+    int udpPort;
+
+    // Network components
+    std::unique_ptr<ServiceDiscovery> serviceDiscovery;
+    std::unique_ptr<NetworkMidi::UdpMidiTransport> udpTransport;
+    std::unique_ptr<NetworkMidi::DeviceRegistry> deviceRegistry;
+    std::unique_ptr<NetworkMidi::RoutingTable> routingTable;
+    std::unique_ptr<NetworkMidi::RouteManager> routeManager;
+    std::unique_ptr<NetworkMidi::MidiRouter> midiRouter;
+    std::unique_ptr<NetworkMidi::MeshManager> meshManager;
+    std::unique_ptr<NetworkTransportAdapter> networkAdapter;
+
+    // HTTP server
+    std::unique_ptr<httplib::Server> server;
+    std::thread serverThread;
+
+    // Local MIDI device tracking
+    std::vector<std::unique_ptr<juce::MidiInput>> midiInputs;
+    std::vector<std::unique_ptr<juce::MidiOutput>> midiOutputs;
+    std::map<juce::String, uint16_t> inputDeviceMap;
+};
+
+//==============================================================================
+int main(int argc, char* argv[])
+{
+    // Initialize JUCE
+    juce::ScopedJuceInitialiser_GUI juceInit;
+
+    std::cout << "\nNetwork MIDI Server v1.0 - Full Mesh Integration" << std::endl;
+    std::cout << "=================================================" << std::endl;
+
+    // Initialize node identity (each instance gets a unique UUID)
+    NetworkMidi::NodeIdentity identity;
+
+    // Initialize instance manager (creates lock file and temp directory)
+    std::unique_ptr<NetworkMidi::InstanceManager> instanceManager;
+    try {
+        instanceManager = std::make_unique<NetworkMidi::InstanceManager>(identity.getNodeId());
+    } catch (const std::exception& e) {
+        std::cerr << "\nError: " << e.what() << std::endl;
+        std::cerr << "Unexpected error during instance initialization." << std::endl;
+        return 1;
+    }
+
+    // Parse port from command line (0 = auto-assign)
+    int port = 0;
+    if (argc > 1) {
+        port = std::atoi(argv[1]);
+    }
+
+    std::cout << "\nStarting server..." << std::endl;
+    if (port == 0) {
+        std::cout << "  HTTP Port: auto-assigned" << std::endl;
+    } else {
+        std::cout << "  HTTP Port: " << port << std::endl;
+    }
+
+    NetworkMidiServer server(identity, instanceManager.get(), port);
+    server.startServer();
+
+    int actualPort = server.getActualPort();
+    int udpPort = server.getUdpPort();
+
+    std::cout << "\nServer running:" << std::endl;
+    std::cout << "  HTTP Port: " << actualPort << std::endl;
+    std::cout << "  UDP Port: " << udpPort << std::endl;
+    std::cout << "  Node: " << identity.getNodeName().toStdString() << std::endl;
+    std::cout << "  UUID: " << identity.getNodeId().toString().toStdString() << std::endl;
+    std::cout << "  Instance dir: " << instanceManager->getInstanceDirectory()
+                                       .getFullPathName().toStdString() << std::endl;
+
+    std::cout << "\nEndpoints:" << std::endl;
+    std::cout << "  GET    /health                - Health check" << std::endl;
+    std::cout << "  GET    /node/info             - Node information" << std::endl;
+    std::cout << "  GET    /midi/devices          - List all MIDI devices (local + remote)" << std::endl;
+    std::cout << "  GET    /network/mesh          - Network mesh status" << std::endl;
+    std::cout << "  GET    /network/stats         - Network statistics" << std::endl;
+    std::cout << "  GET    /routing/routes        - List all routing rules" << std::endl;
+    std::cout << "  POST   /routing/routes        - Create new routing rule" << std::endl;
+    std::cout << "  GET    /routing/routes/:id    - Get specific routing rule" << std::endl;
+    std::cout << "  PUT    /routing/routes/:id    - Update routing rule" << std::endl;
+    std::cout << "  DELETE /routing/routes/:id    - Delete routing rule" << std::endl;
+    std::cout << "  GET    /routing/table         - Get complete routing state (debug)" << std::endl;
+
+    std::cout << "\nReady. Press Ctrl+C to stop..." << std::endl;
+
+    // Run until interrupted
+    while (true) {
+        std::this_thread::sleep_for(std::chrono::seconds(1));
+    }
+
+    return 0;
+}
diff --git a/modules/juce/midi-server/network/core/MidiPacket.cpp b/modules/juce/midi-server/network/core/MidiPacket.cpp
index bbfc945..6e44520 100644
--- a/modules/juce/midi-server/network/core/MidiPacket.cpp
+++ b/modules/juce/midi-server/network/core/MidiPacket.cpp
@@ -6,6 +6,14 @@
 
 namespace NetworkMidi {
 
+// Forward declaration - UuidRegistry will be implemented in Task 4.2
+// For now, we use abstract interface to avoid circular dependency
+class UuidRegistry {
+public:
+    virtual ~UuidRegistry() = default;
+    virtual std::optional<juce::Uuid> lookupFromHash(uint32_t hash) const = 0;
+};
+
 MidiPacket::MidiPacket()
     : magic(MAGIC)
     , version(VERSION)
@@ -86,7 +94,7 @@ MidiPacket MidiPacket::createNackPacket(
 
 std::vector<uint8_t> MidiPacket::serialize() const {
     std::vector<uint8_t> buffer;
-    buffer.reserve(HEADER_SIZE + midiData.size());
+    buffer.reserve(HEADER_SIZE + midiData.size() + contextExtension.size());
 
     // Magic (2 bytes, big-endian)
     buffer.push_back((magic >> 8) & 0xFF);
@@ -129,11 +137,20 @@ std::vector<uint8_t> MidiPacket::serialize() const {
     // MIDI data payload
     buffer.insert(buffer.end(), midiData.begin(), midiData.end());
 
+    // Phase 4: Append context extension (if present)
+    if (hasFlag(HasContext) && !contextExtension.empty()) {
+        buffer.insert(buffer.end(), contextExtension.begin(), contextExtension.end());
+    }
+
     return buffer;
 }
 
 bool MidiPacket::serializeInto(uint8_t* buffer, size_t bufferSize, size_t& bytesWritten) const {
     size_t requiredSize = HEADER_SIZE + midiData.size();
+    if (hasFlag(HasContext)) {
+        requiredSize += contextExtension.size();
+    }
+
     if (bufferSize < requiredSize) {
         bytesWritten = 0;
         return false;
@@ -185,6 +202,12 @@ bool MidiPacket::serializeInto(uint8_t* buffer, size_t bufferSize, size_t& bytes
         offset += midiData.size();
     }
 
+    // Phase 4: Append context extension (if present)
+    if (hasFlag(HasContext) && !contextExtension.empty()) {
+        std::memcpy(buffer + offset, contextExtension.data(), contextExtension.size());
+        offset += contextExtension.size();
+    }
+
     bytesWritten = offset;
     return true;
 }
@@ -249,12 +272,51 @@ bool MidiPacket::tryDeserialize(const uint8_t* data, size_t length, MidiPacket&
     uint16_t deviceId = (static_cast<uint16_t>(data[offset]) << 8) | data[offset + 1];
     offset += 2;
 
-    // MIDI data payload
+    // Calculate MIDI data size and context extension size
+    size_t remainingBytes = length - HEADER_SIZE;
+    size_t midiDataSize = remainingBytes;
+    size_t contextSize = 0;
+
+    // Phase 4: Check for context extension
+    bool hasContextFlag = (flags & HasContext) != 0;
+
     std::vector<uint8_t> midiData;
-    if (length > HEADER_SIZE) {
-        size_t payloadSize = length - HEADER_SIZE;
-        midiData.resize(payloadSize);
-        std::memcpy(midiData.data(), data + offset, payloadSize);
+    std::vector<uint8_t> contextExtension;
+
+    if (hasContextFlag && remainingBytes > 0) {
+        // Scan for context extension from the end of the packet
+        // Context format: Type(1) + Length(1) + HopCount(1) + DeviceCount(1) + Devices(N*6)
+        // We need to find where MIDI data ends and context begins
+
+        // Look for context extension type marker
+        // The extension is at the end of the packet, so we scan backwards
+        size_t scanPos = offset;
+        while (scanPos < length) {
+            if (data[scanPos] == CONTEXT_EXTENSION_TYPE && (scanPos + 1) < length) {
+                uint8_t extLength = data[scanPos + 1];
+                // Validate that extension fits
+                if (scanPos + extLength <= length && extLength >= CONTEXT_HEADER_SIZE) {
+                    // Found valid context extension
+                    midiDataSize = scanPos - offset;
+                    contextSize = length - scanPos;
+                    break;
+                }
+            }
+            scanPos++;
+        }
+    }
+
+    // Extract MIDI data payload
+    if (midiDataSize > 0) {
+        midiData.resize(midiDataSize);
+        std::memcpy(midiData.data(), data + offset, midiDataSize);
+    }
+    offset += midiDataSize;
+
+    // Extract context extension (if present)
+    if (hasContextFlag && contextSize > 0) {
+        contextExtension.resize(contextSize);
+        std::memcpy(contextExtension.data(), data + offset, contextSize);
     }
 
     // Populate output packet
@@ -267,6 +329,7 @@ bool MidiPacket::tryDeserialize(const uint8_t* data, size_t length, MidiPacket&
     outPacket.timestampMicros = timestamp;
     outPacket.deviceId = deviceId;
     outPacket.midiData = std::move(midiData);
+    outPacket.contextExtension = std::move(contextExtension);
 
     return true;
 }
@@ -303,6 +366,155 @@ void MidiPacket::updateTimestamp() {
     timestampMicros = static_cast<uint32_t>(getCurrentTimeMicros());
 }
 
+// Phase 4: Forwarding context support
+
+void MidiPacket::setForwardingContext(const ForwardingContext& ctx) {
+    contextExtension = serializeContext(ctx);
+    addFlag(HasContext);
+}
+
+std::optional<ForwardingContext> MidiPacket::getForwardingContext(const UuidRegistry& registry) const {
+    if (!hasFlag(HasContext) || contextExtension.empty()) {
+        return std::nullopt;
+    }
+
+    try {
+        return deserializeContext(contextExtension.data(), contextExtension.size(), registry);
+    } catch (const std::exception&) {
+        // Deserialization failed - return nullopt
+        return std::nullopt;
+    }
+}
+
+void MidiPacket::clearForwardingContext() {
+    contextExtension.clear();
+    removeFlag(HasContext);
+}
+
+size_t MidiPacket::getTotalSize() const {
+    size_t total = HEADER_SIZE + midiData.size();
+    if (hasFlag(HasContext)) {
+        total += contextExtension.size();
+    }
+    return total;
+}
+
+// Context serialization/deserialization
+
+std::vector<uint8_t> MidiPacket::serializeContext(const ForwardingContext& ctx) {
+    std::vector<uint8_t> buffer;
+
+    // Limit device count to MAX_HOPS (8)
+    uint8_t deviceCount = static_cast<uint8_t>(
+        std::min(ctx.visitedDevices.size(), static_cast<size_t>(ForwardingContext::MAX_HOPS))
+    );
+
+    // Calculate extension length: header(4) + devices(N * 6)
+    uint8_t extLength = static_cast<uint8_t>(CONTEXT_HEADER_SIZE + (deviceCount * VISITED_DEVICE_SIZE));
+
+    // Reserve space
+    buffer.reserve(extLength);
+
+    // Extension Type (1 byte)
+    buffer.push_back(CONTEXT_EXTENSION_TYPE);
+
+    // Extension Length (1 byte)
+    buffer.push_back(extLength);
+
+    // Hop Count (1 byte)
+    buffer.push_back(ctx.hopCount);
+
+    // Device Count (1 byte)
+    buffer.push_back(deviceCount);
+
+    // Visited Devices (6 bytes each: nodeIdHash(4) + deviceId(2))
+    size_t count = 0;
+    for (const auto& devKey : ctx.visitedDevices) {
+        if (count >= deviceCount) break;
+
+        // Node ID Hash (4 bytes, big-endian)
+        uint32_t hash = hashUuid(devKey.ownerNode);
+        buffer.push_back((hash >> 24) & 0xFF);
+        buffer.push_back((hash >> 16) & 0xFF);
+        buffer.push_back((hash >> 8) & 0xFF);
+        buffer.push_back(hash & 0xFF);
+
+        // Device ID (2 bytes, big-endian)
+        buffer.push_back((devKey.deviceId >> 8) & 0xFF);
+        buffer.push_back(devKey.deviceId & 0xFF);
+
+        count++;
+    }
+
+    return buffer;
+}
+
+ForwardingContext MidiPacket::deserializeContext(const uint8_t* data, size_t length,
+                                                  const UuidRegistry& registry) {
+    if (length < CONTEXT_HEADER_SIZE) {
+        throw std::runtime_error("Context extension too short");
+    }
+
+    size_t offset = 0;
+
+    // Extension Type (1 byte)
+    uint8_t extType = data[offset++];
+    if (extType != CONTEXT_EXTENSION_TYPE) {
+        throw std::runtime_error("Invalid context extension type");
+    }
+
+    // Extension Length (1 byte)
+    uint8_t extLength = data[offset++];
+    if (extLength != length) {
+        throw std::runtime_error("Context extension length mismatch");
+    }
+
+    // Hop Count (1 byte)
+    uint8_t hopCount = data[offset++];
+
+    // Device Count (1 byte)
+    uint8_t deviceCount = data[offset++];
+
+    // Validate expected length
+    size_t expectedLength = CONTEXT_HEADER_SIZE + (deviceCount * VISITED_DEVICE_SIZE);
+    if (extLength != expectedLength) {
+        throw std::runtime_error("Context device count mismatch");
+    }
+
+    if (length < expectedLength) {
+        throw std::runtime_error("Context extension truncated");
+    }
+
+    // Deserialize visited devices
+    ForwardingContext ctx;
+    ctx.hopCount = hopCount;
+
+    for (uint8_t i = 0; i < deviceCount; ++i) {
+        // Node ID Hash (4 bytes, big-endian)
+        uint32_t hash = (static_cast<uint32_t>(data[offset]) << 24) |
+                        (static_cast<uint32_t>(data[offset + 1]) << 16) |
+                        (static_cast<uint32_t>(data[offset + 2]) << 8) |
+                        static_cast<uint32_t>(data[offset + 3]);
+        offset += 4;
+
+        // Device ID (2 bytes, big-endian)
+        uint16_t devId = (static_cast<uint16_t>(data[offset]) << 8) | data[offset + 1];
+        offset += 2;
+
+        // Lookup UUID from hash via registry
+        auto nodeIdOpt = registry.lookupFromHash(hash);
+        if (!nodeIdOpt.has_value()) {
+            throw std::runtime_error("Unknown node hash in context: " +
+                                     juce::String::toHexString(static_cast<int>(hash)).toStdString());
+        }
+
+        // Add to visited devices
+        ctx.visitedDevices.insert(DeviceKey(nodeIdOpt.value(), devId));
+    }
+
+    return ctx;
+}
+
 uint32_t MidiPacket::hashUuid(const juce::Uuid& uuid) {
     // Simple hash: XOR the 4 32-bit words of the UUID
     const uint64_t* data = reinterpret_cast<const uint64_t*>(uuid.getRawData());
diff --git a/modules/juce/midi-server/network/core/MidiPacket.h b/modules/juce/midi-server/network/core/MidiPacket.h
index 36b0253..e0ab763 100644
--- a/modules/juce/midi-server/network/core/MidiPacket.h
+++ b/modules/juce/midi-server/network/core/MidiPacket.h
@@ -1,24 +1,38 @@
 #pragma once
 
+#include "../routing/DeviceRegistry.h"  // For DeviceKey
 #include <juce_core/juce_core.h>
 #include <cstdint>
 #include <vector>
+#include <optional>
+#include <set>
 
 namespace NetworkMidi {
 
+// Forward declaration for UuidRegistry (to be implemented in Task 4.2)
+class UuidRegistry;
+
+// Forwarding context for loop prevention (uses DeviceKey from DeviceRegistry.h)
+struct ForwardingContext {
+    std::set<DeviceKey> visitedDevices;
+    uint8_t hopCount = 0;
+    static constexpr uint8_t MAX_HOPS = 8;
+};
+
 /**
  * UDP packet format for network MIDI transport.
  *
  * Packet Structure (20-byte header + variable payload):
  * - Magic: 0x4D49 ("MI") - 2 bytes
  * - Version: 0x01 - 1 byte
- * - Flags: [SysEx|Reliable|Fragment|Reserved] - 1 byte
+ * - Flags: [SysEx|Reliable|Fragment|HasContext|Reserved...] - 1 byte
  * - Source Node UUID (hash) - 4 bytes
  * - Dest Node UUID (hash) - 4 bytes
  * - Sequence Number - 2 bytes
  * - Timestamp (microseconds) - 4 bytes
  * - Device ID - 2 bytes
  * - MIDI Data (variable length)
+ * - Context Extension (optional, if HasContext flag set)
  */
 class MidiPacket {
 public:
@@ -36,8 +50,8 @@ public:
         SysEx = 1 << 0,      // Bit 0: SysEx message
         Reliable = 1 << 1,   // Bit 1: Reliable delivery required (ACK expected)
         Fragment = 1 << 2,   // Bit 2: Fragmented message (part of larger SysEx)
-        Reserved3 = 1 << 3,  // Bits 3-7: Reserved for future use
-        Reserved4 = 1 << 4,
+        HasContext = 1 << 3, // Bit 3: Forwarding context extension present (Phase 4)
+        Reserved4 = 1 << 4,  // Bits 4-7: Reserved for future use
         Reserved5 = 1 << 5,
         Reserved6 = 1 << 6,
         Reserved7 = 1 << 7
@@ -48,6 +62,11 @@ public:
     static constexpr uint8_t VERSION = 0x01;
     static constexpr size_t HEADER_SIZE = 20;
 
+    // Context extension constants
+    static constexpr uint8_t CONTEXT_EXTENSION_TYPE = 0x01;
+    static constexpr size_t CONTEXT_HEADER_SIZE = 4;  // Type(1) + Length(1) + HopCount(1) + DeviceCount(1)
+    static constexpr size_t VISITED_DEVICE_SIZE = 6;  // NodeIdHash(4) + DeviceId(2)
+
     // Constructor
     MidiPacket();
 
@@ -119,10 +138,37 @@ public:
     bool isReliable() const { return hasFlag(Reliable); }
     bool isFragment() const { return hasFlag(Fragment); }
 
+    // Phase 4: Forwarding context support
+    /**
+     * Set forwarding context to be serialized with this packet.
+     * Automatically sets the HasContext flag.
+     */
+    void setForwardingContext(const ForwardingContext& ctx);
+
+    /**
+     * Extract forwarding context from packet (if present).
+     * Requires UuidRegistry to reverse lookup node UUIDs from hashes.
+     * Returns std::nullopt if no context present or deserialization fails.
+     */
+    std::optional<ForwardingContext> getForwardingContext(const UuidRegistry& registry) const;
+
+    /**
+     * Check if packet has forwarding context extension.
+     */
+    bool hasForwardingContext() const { return hasFlag(HasContext); }
+
+    /**
+     * Clear forwarding context and remove HasContext flag.
+     */
+    void clearForwardingContext();
+
     // Utility
-    size_t getTotalSize() const { return HEADER_SIZE + midiData.size(); }
+    size_t getTotalSize() const;
     void updateTimestamp();  // Sets timestamp to current time in microseconds
 
+    // Helper for UUID hashing (public for UuidRegistry)
+    static uint32_t hashUuid(const juce::Uuid& uuid);
+
 private:
     // Header fields
     uint16_t magic;
@@ -137,13 +183,20 @@ private:
     // Payload
     std::vector<uint8_t> midiData;
 
+    // Phase 4: Context extension (optional)
+    std::vector<uint8_t> contextExtension;
+
     // Packet type (not serialized, derived from context)
     PacketType packetType;
 
     // Helper functions
-    static uint32_t hashUuid(const juce::Uuid& uuid);
     static juce::Uuid unhashUuid(uint32_t hash, const juce::Uuid& original);
     static uint64_t getCurrentTimeMicros();
+
+    // Context serialization/deserialization helpers
+    static std::vector<uint8_t> serializeContext(const ForwardingContext& ctx);
+    static ForwardingContext deserializeContext(const uint8_t* data, size_t length,
+                                                 const UuidRegistry& registry);
 };
 
 } // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/mesh/Commands.h b/modules/juce/midi-server/network/mesh/Commands.h
index 64dc6ee..541ff33 100644
--- a/modules/juce/midi-server/network/mesh/Commands.h
+++ b/modules/juce/midi-server/network/mesh/Commands.h
@@ -8,6 +8,7 @@
 #pragma once
 
 #include "NetworkConnection.h"
+#include "../core/MidiPacket.h"
 #include <juce_core/juce_core.h>
 #include <memory>
 #include <vector>
@@ -30,6 +31,7 @@ struct Command {
         CheckHeartbeat,
         NotifyHeartbeat,
         SendMidi,
+        SendPacket,         // NEW: Phase 4 - send full packet with context
         GetState,
         GetRemoteNode,
         GetDevices,
@@ -78,6 +80,17 @@ struct SendMidiCommand : Command {
         : Command(SendMidi), deviceId(id), data(std::move(msgData)) {}
 };
 
+/**
+ * Phase 4: Send full MidiPacket with forwarding context.
+ * Replaces legacy SendMidiCommand for context-aware routing.
+ */
+struct SendPacketCommand : Command {
+    MidiPacket packet;
+
+    explicit SendPacketCommand(const MidiPacket& pkt)
+        : Command(SendPacket), packet(pkt) {}
+};
+
 //==============================================================================
 // Query commands with synchronous response mechanism
 // Uses std::condition_variable for reliable cross-platform synchronization
diff --git a/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp b/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
index 012d9f5..5d681f7 100644
--- a/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
+++ b/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
@@ -9,6 +9,7 @@
 #include "../transport/RealtimeMidiBuffer.h"
 #include "../transport/RealtimeMidiTransport.h"
 #include "../transport/NonRealtimeMidiTransport.h"
+#include "../core/MidiPacket.h"
 #include <juce_core/juce_core.h>
 #include <juce_audio_basics/juce_audio_basics.h>
 #include <sstream>
@@ -79,6 +80,10 @@ void ConnectionWorker::processCommand(std::unique_ptr<Commands::Command> cmd)
             handleSendMidiCommand(static_cast<Commands::SendMidiCommand*>(cmd.get()));
             break;
 
+        case Commands::Command::SendPacket:
+            handleSendPacketCommand(static_cast<Commands::SendPacketCommand*>(cmd.get()));
+            break;
+
         case Commands::Command::GetState:
             handleGetStateQuery(static_cast<Commands::GetStateQuery*>(cmd.get()));
             break;
@@ -429,6 +434,49 @@ void ConnectionWorker::handleSendMidiCommand(Commands::SendMidiCommand* cmd)
     }
 }
 
+void ConnectionWorker::handleSendPacketCommand(Commands::SendPacketCommand* cmd)
+{
+    jassert(cmd != nullptr);
+
+    // Validate connection state
+    if (currentState != NetworkConnection::State::Connected) {
+        juce::Logger::writeToLog("ConnectionWorker: Cannot send packet - not connected");
+        return;
+    }
+
+    // Validate transport initialized
+    if (!realtimeTransport) {
+        juce::Logger::writeToLog("ConnectionWorker: Cannot send packet - realtime transport not available");
+        return;
+    }
+
+    // Serialize packet to buffer
+    std::vector<uint8_t> buffer = cmd->packet.serialize();
+
+    // Extract remote host and UDP port from remoteUdpEndpoint
+    // remoteUdpEndpoint format: "10.0.0.1:12345"
+    juce::String remoteHost;
+    int remoteUdpPort = 0;
+    int colonPos = remoteUdpEndpoint.lastIndexOf(":");
+    if (colonPos > 0) {
+        remoteHost = remoteUdpEndpoint.substring(0, colonPos);
+        remoteUdpPort = remoteUdpEndpoint.substring(colonPos + 1).getIntValue();
+    }
+
+    if (remoteHost.isEmpty() || remoteUdpPort == 0) {
+        juce::Logger::writeToLog("ConnectionWorker: Invalid remote UDP endpoint: " + remoteUdpEndpoint);
+        return;
+    }
+
+    // Send via UDP transport
+    realtimeTransport->sendPacket(buffer.data(), buffer.size(), remoteHost, remoteUdpPort);
+
+    juce::Logger::writeToLog("ConnectionWorker: Sent MidiPacket via UDP - " +
+                            juce::String(buffer.size()) + " bytes to " +
+                            remoteHost + ":" + juce::String(remoteUdpPort) +
+                            (cmd->packet.hasForwardingContext() ? " (with context)" : ""));
+}
+
 void ConnectionWorker::handleGetStateQuery(Commands::GetStateQuery* query)
 {
     jassert(query != nullptr);
diff --git a/modules/juce/midi-server/network/mesh/ConnectionWorker.h b/modules/juce/midi-server/network/mesh/ConnectionWorker.h
index 3d86d6b..388b2e2 100644
--- a/modules/juce/midi-server/network/mesh/ConnectionWorker.h
+++ b/modules/juce/midi-server/network/mesh/ConnectionWorker.h
@@ -123,6 +123,7 @@ private:
     void handleCheckHeartbeatCommand();
     void handleNotifyHeartbeatCommand();
     void handleSendMidiCommand(Commands::SendMidiCommand* cmd);
+    void handleSendPacketCommand(Commands::SendPacketCommand* cmd);  // Phase 4
 
     // Query handlers
     void handleGetStateQuery(Commands::GetStateQuery* query);
diff --git a/modules/juce/midi-server/network/mesh/MeshManager.cpp b/modules/juce/midi-server/network/mesh/MeshManager.cpp
index 1a4ca3b..024f23b 100644
--- a/modules/juce/midi-server/network/mesh/MeshManager.cpp
+++ b/modules/juce/midi-server/network/mesh/MeshManager.cpp
@@ -31,6 +31,9 @@ MeshManager::MeshManager(const juce::Uuid& localNodeId, int httpPort, int udpPor
         handleConnectionLost(nodeId, reason);
     };
 
+    // Phase 4.5: Register self in UUID registry for context deserialization
+    uuidRegistry.registerNode(myNodeId);
+
     juce::Logger::writeToLog("MeshManager created for node " + localNodeId.toString());
 }
 
@@ -111,6 +114,9 @@ void MeshManager::onNodeRemoved(const juce::Uuid& nodeId)
 {
     juce::Logger::writeToLog("MeshManager: Node removed: " + nodeId.toString());
 
+    // Phase 4.5: Unregister node from UUID registry
+    uuidRegistry.unregisterNode(nodeId);
+
     // Remove connection if exists
     bool removed = connectionPool.removeConnection(nodeId);
 
@@ -293,12 +299,18 @@ void MeshManager::handleConnectionStateChange(const juce::Uuid& nodeId,
     }
 
     if (newState == NetworkConnection::State::Connected) {
+        // Phase 4.5: Register node in UUID registry for context deserialization
+        uuidRegistry.registerNode(nodeId);
+
         // Connection established successfully
         if (onNodeConnected) {
             onNodeConnected(connection->getRemoteNode());
         }
 
     } else if (newState == NetworkConnection::State::Failed) {
+        // Phase 4.5: Unregister node from UUID registry on failure
+        uuidRegistry.unregisterNode(nodeId);
+
         // Connection failed - will be cleaned up by heartbeat monitor
         if (onConnectionFailed) {
             onConnectionFailed(connection->getRemoteNode(), "Connection failed");
@@ -313,6 +325,9 @@ void MeshManager::handleConnectionLost(const juce::Uuid& nodeId,
     juce::Logger::writeToLog("MeshManager: Connection lost to " + nodeId.toString() +
                             " - " + reason);
 
+    // Phase 4.5: Unregister node from UUID registry
+    uuidRegistry.unregisterNode(nodeId);
+
     if (onNodeDisconnected) {
         onNodeDisconnected(nodeId, reason);
     }
diff --git a/modules/juce/midi-server/network/mesh/MeshManager.h b/modules/juce/midi-server/network/mesh/MeshManager.h
index 565579e..4261a21 100644
--- a/modules/juce/midi-server/network/mesh/MeshManager.h
+++ b/modules/juce/midi-server/network/mesh/MeshManager.h
@@ -17,6 +17,7 @@
 #include "ConnectionPool.h"
 #include "HeartbeatMonitor.h"
 #include "NetworkConnection.h"
+#include "../routing/UuidRegistry.h"
 
 #include <juce_core/juce_core.h>
 
@@ -42,6 +43,7 @@ namespace NetworkMidi {
  * - Works with ServiceDiscovery (Phase 2) for node discovery
  * - Uses ConnectionPool to manage active connections
  * - Uses HeartbeatMonitor for health monitoring
+ * - Maintains UuidRegistry for multi-hop routing (Phase 4)
  *
  * Thread Safety:
  * All public methods are thread-safe.
@@ -157,6 +159,21 @@ public:
 
     MeshStatistics getStatistics() const;
 
+    //==============================================================================
+    // Phase 4.5: UUID Registry Access
+
+    /**
+     * Returns reference to the UUID registry.
+     * Used by MidiRouter for context deserialization during multi-hop routing.
+     *
+     * The registry maps 32-bit UUID hashes to full juce::Uuid objects,
+     * enabling efficient network transmission while preserving full
+     * UUID resolution capability.
+     *
+     * @return Reference to the UUID registry
+     */
+    UuidRegistry& getUuidRegistry() { return uuidRegistry; }
+
 private:
     //==============================================================================
     // Connection lifecycle handlers
@@ -188,6 +205,9 @@ private:
     ConnectionPool connectionPool;
     std::unique_ptr<HeartbeatMonitor> heartbeatMonitor;
 
+    // Phase 4.5: UUID Registry for multi-hop routing
+    UuidRegistry uuidRegistry;
+
     std::atomic<bool> running{false};
 
     mutable std::mutex managerMutex;
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnection.cpp b/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
index 22fdfbe..c075fbe 100644
--- a/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
+++ b/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
@@ -10,6 +10,7 @@
 #include "ConnectionWorker.h"
 #include "Commands.h"
 #include "../routing/MidiRouter.h"
+#include "../core/MidiPacket.h"
 #include <iostream>
 
 namespace NetworkMidi {
@@ -216,6 +217,15 @@ void NetworkConnection::sendMidiMessage(uint16_t deviceId,
     );
 }
 
+//==============================================================================
+void NetworkConnection::sendPacket(const MidiPacket& packet)
+{
+    // Phase 4: Send full packet with context via SEDA command queue
+    commandQueue->pushCommand(
+        std::make_unique<Commands::SendPacketCommand>(packet)
+    );
+}
+
 //==============================================================================
 int64_t NetworkConnection::getTimeSinceLastHeartbeat() const
 {
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnection.h b/modules/juce/midi-server/network/mesh/NetworkConnection.h
index e71d629..f505d9e 100644
--- a/modules/juce/midi-server/network/mesh/NetworkConnection.h
+++ b/modules/juce/midi-server/network/mesh/NetworkConnection.h
@@ -33,6 +33,7 @@ namespace NetworkMidi {
 class NetworkConnectionQueue;
 class ConnectionWorker;
 class MidiRouter;
+struct MidiPacket;
 
 //==============================================================================
 // Node information structure
@@ -173,6 +174,14 @@ public:
      */
     void sendMidiMessage(uint16_t deviceId, const std::vector<uint8_t>& data);
 
+    /**
+     * Phase 4: Send full packet with context.
+     * Non-blocking - packet queued for UDP transmission via SEDA.
+     *
+     * @param packet MidiPacket with optional forwarding context
+     */
+    void sendPacket(const MidiPacket& packet);
+
     //==============================================================================
     // Connection health
 
diff --git a/modules/juce/midi-server/network/routing/MidiRouter.cpp b/modules/juce/midi-server/network/routing/MidiRouter.cpp
index 9fddfdd..93ad129 100644
--- a/modules/juce/midi-server/network/routing/MidiRouter.cpp
+++ b/modules/juce/midi-server/network/routing/MidiRouter.cpp
@@ -8,6 +8,8 @@
 #include "RouteManager.h"
 #include "ForwardingRule.h"
 #include "MidiRouterCommands.h"
+#include "UuidRegistry.h"
+#include "../core/MidiPacket.h"
 #include <algorithm>
 
 namespace NetworkMidi {
@@ -41,6 +43,9 @@ MidiRouter::MidiRouter(DeviceRegistry& registry, RoutingTable& routes)
     , routingTable(routes)
     , networkTransport(nullptr)
     , routeManager(nullptr)
+    , uuidRegistry(nullptr)
+    , myNodeId(juce::Uuid())  // Will be set by caller
+    , nextSequence(0)
 {
     // Start worker thread
     workerThread = std::make_unique<WorkerThread>(*this);
@@ -72,7 +77,13 @@ void MidiRouter::processCommand(std::unique_ptr<MidiRouterCommands::Command> cmd
     switch (cmd->type) {
         case Command::ForwardMessage: {
             auto* fwdCmd = static_cast<ForwardMessageCommand*>(cmd.get());
+
+            // Phase 4.3: Use incoming context if present, otherwise create fresh
             ForwardingContext context;
+            if (fwdCmd->incomingContext.has_value()) {
+                context = fwdCmd->incomingContext.value();
+            }
+
             forwardMessageInternal(fwdCmd->sourceNode, fwdCmd->sourceDevice,
                                    fwdCmd->midiData, context);
             break;
@@ -80,8 +91,10 @@ void MidiRouter::processCommand(std::unique_ptr<MidiRouterCommands::Command> cmd
 
         case Command::DirectSend: {
             auto* sendCmd = static_cast<DirectSendCommand*>(cmd.get());
+            // Create fresh context for direct send
+            ForwardingContext context;
             forwardToDestination(sendCmd->destNode, sendCmd->destDevice,
-                                 sendCmd->midiData);
+                                 sendCmd->midiData, context);
             break;
         }
 
@@ -136,6 +149,18 @@ void MidiRouter::processCommand(std::unique_ptr<MidiRouterCommands::Command> cmd
             setNetworkTransportInternal(ntCmd->transport);
             break;
         }
+
+        case Command::SetUuidRegistry: {
+            auto* regCmd = static_cast<SetUuidRegistryCommand*>(cmd.get());
+            setUuidRegistryInternal(regCmd->registry);
+            break;
+        }
+
+        case Command::SetNodeId: {
+            auto* nodeIdCmd = static_cast<SetNodeIdCommand*>(cmd.get());
+            setNodeIdInternal(nodeIdCmd->nodeId);
+            break;
+        }
     }
 }
 
@@ -157,6 +182,24 @@ void MidiRouter::setRouteManager(RouteManager* manager)
     commandQueue.push(std::move(cmd));
 }
 
+//==============================================================================
+// Public API - UuidRegistry integration
+
+void MidiRouter::setUuidRegistry(UuidRegistry* registry)
+{
+    auto cmd = std::make_unique<MidiRouterCommands::SetUuidRegistryCommand>(registry);
+    commandQueue.push(std::move(cmd));
+}
+
+//==============================================================================
+// Public API - Node ID configuration (Phase 4.5)
+
+void MidiRouter::setNodeId(const juce::Uuid& nodeId)
+{
+    auto cmd = std::make_unique<MidiRouterCommands::SetNodeIdCommand>(nodeId);
+    commandQueue.push(std::move(cmd));
+}
+
 //==============================================================================
 // Public API - Local port management
 
@@ -251,7 +294,7 @@ void MidiRouter::clearMessages(uint16_t deviceId)
 }
 
 //==============================================================================
-// Public API - Network packet handling
+// Public API - Network packet handling (legacy interface)
 
 void MidiRouter::onNetworkPacketReceived(const juce::Uuid& sourceNode,
                                          uint16_t deviceId,
@@ -276,6 +319,46 @@ void MidiRouter::onNetworkPacketReceived(const juce::Uuid& sourceNode,
     commandQueue.push(std::move(cmd));
 }
 
+//==============================================================================
+// Public API - Network packet handling (Phase 4.3: with MidiPacket)
+
+void MidiRouter::onNetworkPacketReceived(const MidiPacket& packet)
+{
+    const auto& midiData = packet.getMidiData();
+
+    if (midiData.empty()) {
+        reportError("Received empty network MIDI packet from " +
+                    packet.getSourceNode().toString());
+        return;
+    }
+
+    // Extract context from packet if present
+    std::optional<NetworkMidi::ForwardingContext> contextOpt;
+    if (packet.hasForwardingContext() && uuidRegistry) {
+        contextOpt = packet.getForwardingContext(*uuidRegistry);
+
+        if (!contextOpt.has_value() && packet.hasForwardingContext()) {
+            reportError("Failed to deserialize forwarding context from packet - "
+                       "UuidRegistry may be missing node mappings");
+        }
+    }
+
+    // Convert NetworkMidi::ForwardingContext to MidiRouter::ForwardingContext
+    std::optional<MidiRouterCommands::ForwardingContext> routerContextOpt;
+    if (contextOpt.has_value()) {
+        MidiRouterCommands::ForwardingContext routerCtx;
+        routerCtx.visitedDevices = contextOpt->visitedDevices;
+        routerCtx.hopCount = contextOpt->hopCount;
+        routerContextOpt = routerCtx;
+    }
+
+    // Create command with context
+    auto cmd = std::make_unique<MidiRouterCommands::ForwardMessageCommand>(
+        packet.getSourceNode(), packet.getDeviceId(), midiData, routerContextOpt);
+
+    commandQueue.push(std::move(cmd));
+}
+
 //==============================================================================
 // Public API - Message forwarding
 
@@ -491,10 +574,11 @@ void MidiRouter::forwardMessageInternal(const juce::Uuid& sourceNode,
             continue;
         }
 
-        // Forward to destination
+        // Forward to destination (pass context for embedding in packet)
         forwardToDestination(rule.destinationNodeId(),
                             rule.destinationDeviceId(),
-                            midiData);
+                            midiData,
+                            context);
 
         // Update statistics
         routeManager->updateRuleStatistics(rule.ruleId.toStdString(), true);
@@ -530,16 +614,45 @@ bool MidiRouter::matchesFilters(const ForwardingRule& rule,
 
 void MidiRouter::forwardToDestination(const juce::Uuid& destNode,
                                       uint16_t destDevice,
-                                      const std::vector<uint8_t>& midiData)
+                                      const std::vector<uint8_t>& midiData,
+                                      const ForwardingContext& context)
 {
     // Check if destination is local (local devices have null UUID in RoutingTable)
     if (destNode.isNull()) {
-        // Forward to local device
+        // Forward to local device (no context needed)
         routeLocalMessage(destDevice, midiData);
     }
     else {
-        // Forward to remote device
-        routeNetworkMessage(destNode, destDevice, midiData);
+        // Forward to remote device - create packet with context
+        if (!networkTransport) {
+            reportError("Network transport not configured - cannot route message");
+            stats.routingErrors++;
+            return;
+        }
+
+        try {
+            // Create MidiPacket with MIDI data
+            MidiPacket packet = MidiPacket::createDataPacket(
+                myNodeId, destNode, destDevice, midiData, nextSequence++
+            );
+
+            // Convert MidiRouter::ForwardingContext to NetworkMidi::ForwardingContext
+            NetworkMidi::ForwardingContext netContext;
+            netContext.visitedDevices = context.visitedDevices;
+            netContext.hopCount = context.hopCount;
+
+            // Embed context in packet
+            packet.setForwardingContext(netContext);
+
+            // Send via network transport (Phase 4.4 integration)
+            networkTransport->sendPacket(packet);
+            stats.networkMessagesSent++;
+        }
+        catch (const std::exception& e) {
+            reportError("Error sending network MIDI message with context: " +
+                        juce::String(e.what()));
+            stats.routingErrors++;
+        }
     }
 }
 
@@ -625,4 +738,14 @@ void MidiRouter::setNetworkTransportInternal(NetworkTransport* transport)
     networkTransport = transport;
 }
 
+void MidiRouter::setUuidRegistryInternal(UuidRegistry* registry)
+{
+    uuidRegistry = registry;
+}
+
+void MidiRouter::setNodeIdInternal(const juce::Uuid& nodeId)
+{
+    myNodeId = nodeId;
+}
+
 } // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/MidiRouter.h b/modules/juce/midi-server/network/routing/MidiRouter.h
index b2ad036..52eb5e9 100644
--- a/modules/juce/midi-server/network/routing/MidiRouter.h
+++ b/modules/juce/midi-server/network/routing/MidiRouter.h
@@ -26,6 +26,7 @@ namespace NetworkMidi {
 // Forward declarations
 struct MidiPacket;
 class RouteManager;
+class UuidRegistry;
 
 /**
  * Callback interface for network message transmission
@@ -35,9 +36,13 @@ class NetworkTransport {
 public:
     virtual ~NetworkTransport() = default;
 
+    // Legacy method (Phase 3 compatibility)
     virtual void sendMidiMessage(const juce::Uuid& destNode,
                                  uint16_t deviceId,
                                  const std::vector<uint8_t>& midiData) = 0;
+
+    // NEW: Send full packet with context (Phase 4)
+    virtual void sendPacket(const MidiPacket& packet) = 0;
 };
 
 /**
@@ -175,7 +180,7 @@ public:
  * 
  * - Max hops: 8 (prevents infinite chains)
  * - Visited devices: Tracked per message (prevents cycles)
- * - Context: Currently single-node (Phase 4 will add network-wide context)
+ * - Context: Phase 4 adds network-wide context forwarding
  *
  * ERROR HANDLING:
  * 
@@ -206,6 +211,12 @@ public:
     // RouteManager integration (Phase 3.1)
     void setRouteManager(RouteManager* manager);
 
+    // UuidRegistry integration (Phase 4.3)
+    void setUuidRegistry(UuidRegistry* registry);
+
+    // Phase 4.5: Set node ID for packet creation
+    void setNodeId(const juce::Uuid& nodeId);
+
     // Local port management
     void registerLocalPort(uint16_t deviceId,
                            std::unique_ptr<MidiPortInterface> port);
@@ -230,6 +241,9 @@ public:
                                  uint16_t deviceId,
                                  const std::vector<uint8_t>& midiData);
 
+    // Phase 4.3: New method for receiving full packets with context
+    void onNetworkPacketReceived(const MidiPacket& packet);
+
     // Message forwarding (Phase 3.1)
     void forwardMessage(const juce::Uuid& sourceNode,
                         uint16_t sourceDevice,
@@ -278,6 +292,10 @@ private:
      * Prevents infinite forwarding loops via:
      * - Hop count limiting (max 8 hops)
      * - Visited device tracking (prevents A  B  A cycles)
+     *
+     * NOTE: This is for local tracking within MidiRouter.
+     * The network-wide ForwardingContext is defined in MidiPacket.h
+     * and is used for serialization/deserialization across the network.
      */
     struct ForwardingContext {
         std::set<DeviceKey> visitedDevices;
@@ -342,6 +360,9 @@ private:
     // Route manager (Phase 3.1)
     RouteManager* routeManager;
 
+    // UUID registry (Phase 4.3)
+    UuidRegistry* uuidRegistry;
+
     // Local MIDI ports
     std::map<uint16_t, std::unique_ptr<MidiPortInterface>> localPorts;
 
@@ -354,6 +375,10 @@ private:
     // Error handling
     ErrorCallback errorCallback;
 
+    // Node identity (for Phase 4 packet creation)
+    juce::Uuid myNodeId;
+    uint16_t nextSequence = 0;
+
     //==========================================================================
     // Internal Methods (called only by worker thread)
     //==========================================================================
@@ -387,7 +412,8 @@ private:
 
     void forwardToDestination(const juce::Uuid& destNode,
                               uint16_t destDevice,
-                              const std::vector<uint8_t>& midiData);
+                              const std::vector<uint8_t>& midiData,
+                              const ForwardingContext& context);
 
     uint8_t extractMidiChannel(const std::vector<uint8_t>& midiData) const;
     MidiMessageType getMidiMessageType(const std::vector<uint8_t>& midiData) const;
@@ -399,6 +425,8 @@ private:
     // Configuration (internal)
     void setRouteManagerInternal(RouteManager* manager);
     void setNetworkTransportInternal(NetworkTransport* transport);
+    void setUuidRegistryInternal(UuidRegistry* registry);
+    void setNodeIdInternal(const juce::Uuid& nodeId);
 
     JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MidiRouter)
 };
diff --git a/modules/juce/midi-server/network/routing/MidiRouterCommands.h b/modules/juce/midi-server/network/routing/MidiRouterCommands.h
index ea5e8ac..4d11cf4 100644
--- a/modules/juce/midi-server/network/routing/MidiRouterCommands.h
+++ b/modules/juce/midi-server/network/routing/MidiRouterCommands.h
@@ -7,12 +7,15 @@
 
 #pragma once
 
+#include "../core/MidiPacket.h"  // For ForwardingContext
 #include <juce_core/juce_core.h>
 #include <vector>
 #include <memory>
 #include <atomic>
 #include <chrono>
 #include <cstdint>
+#include <optional>
+#include <set>
 
 namespace NetworkMidi {
 
@@ -21,6 +24,7 @@ class MidiRouter;
 class MidiPortInterface;
 class RouteManager;
 class NetworkTransport;
+class UuidRegistry;
 
 namespace MidiRouterCommands {
 
@@ -52,7 +56,9 @@ struct Command {
         GetStatistics,
         ResetStatistics,
         SetRouteManager,
-        SetNetworkTransport
+        SetNetworkTransport,
+        SetUuidRegistry,
+        SetNodeId
     };
 
     Type type;
@@ -68,18 +74,23 @@ protected:
 /**
  * Forward MIDI message according to routing rules.
  * This is the hot path - called for every MIDI message.
+ *
+ * Phase 4.3: Now includes optional incoming context for multi-hop routing.
  */
 struct ForwardMessageCommand : Command {
     juce::Uuid sourceNode;
     uint16_t sourceDevice;
     std::vector<uint8_t> midiData;
+    std::optional<ForwardingContext> incomingContext;
 
     ForwardMessageCommand(const juce::Uuid& node, uint16_t dev,
-                          const std::vector<uint8_t>& data)
+                          const std::vector<uint8_t>& data,
+                          std::optional<ForwardingContext> ctx = std::nullopt)
         : Command(ForwardMessage)
         , sourceNode(node)
         , sourceDevice(dev)
         , midiData(data)
+        , incomingContext(std::move(ctx))
     {}
 };
 
@@ -214,5 +225,31 @@ struct SetNetworkTransportCommand : Command {
     {}
 };
 
+/**
+ * Set UuidRegistry pointer for context deserialization.
+ * Phase 4.3: Required for multi-hop routing with context preservation.
+ */
+struct SetUuidRegistryCommand : Command {
+    UuidRegistry* registry;
+
+    explicit SetUuidRegistryCommand(UuidRegistry* reg)
+        : Command(SetUuidRegistry)
+        , registry(reg)
+    {}
+};
+
+/**
+ * Set node ID for packet creation.
+ * Phase 4.5: Required for MidiRouter to create packets with source node ID.
+ */
+struct SetNodeIdCommand : Command {
+    juce::Uuid nodeId;
+
+    explicit SetNodeIdCommand(const juce::Uuid& id)
+        : Command(SetNodeId)
+        , nodeId(id)
+    {}
+};
+
 } // namespace MidiRouterCommands
 } // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/UuidRegistry.cpp b/modules/juce/midi-server/network/routing/UuidRegistry.cpp
new file mode 100644
index 0000000..469e3f1
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/UuidRegistry.cpp
@@ -0,0 +1,161 @@
+#include "UuidRegistry.h"
+#include <juce_core/juce_core.h>
+
+namespace NetworkMidi {
+
+UuidRegistry::UuidRegistry()
+{
+}
+
+UuidRegistry::~UuidRegistry()
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    hashToUuid.clear();
+    uuidToHash.clear();
+    collisions.clear();
+}
+
+void UuidRegistry::registerNode(const juce::Uuid& nodeId)
+{
+    if (nodeId.isNull()) {
+        DBG("UuidRegistry: Attempted to register null UUID");
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock(mutex);
+
+    uint32_t hash = computeHash(nodeId);
+
+    // Check for existing registration
+    auto hashIt = hashToUuid.find(hash);
+    if (hashIt != hashToUuid.end()) {
+        // Hash already registered
+        if (hashIt->second == nodeId) {
+            // Same UUID - duplicate registration, no-op
+            DBG("UuidRegistry: Duplicate registration for UUID " + nodeId.toString());
+            return;
+        } else {
+            // Hash collision detected!
+            DBG("UuidRegistry: COLLISION DETECTED! Hash " + juce::String::toHexString(static_cast<int>(hash)) +
+                " already maps to " + hashIt->second.toString() +
+                ", attempted to register " + nodeId.toString());
+            collisions.insert(hash);
+            // Keep first registration, don't overwrite
+            return;
+        }
+    }
+
+    // Register new mapping
+    hashToUuid[hash] = nodeId;
+    uuidToHash[nodeId] = hash;
+
+    DBG("UuidRegistry: Registered node " + nodeId.toString() +
+        " with hash " + juce::String::toHexString(static_cast<int>(hash)) +
+        " (total nodes: " + juce::String(hashToUuid.size()) + ")");
+}
+
+void UuidRegistry::unregisterNode(const juce::Uuid& nodeId)
+{
+    if (nodeId.isNull()) {
+        return;
+    }
+
+    std::lock_guard<std::mutex> lock(mutex);
+
+    // Find hash for this UUID
+    auto uuidIt = uuidToHash.find(nodeId);
+    if (uuidIt == uuidToHash.end()) {
+        // Not registered, no-op
+        DBG("UuidRegistry: Attempted to unregister unknown UUID " + nodeId.toString());
+        return;
+    }
+
+    uint32_t hash = uuidIt->second;
+
+    // Remove both mappings
+    hashToUuid.erase(hash);
+    uuidToHash.erase(uuidIt);
+
+    // Remove from collisions set if present
+    collisions.erase(hash);
+
+    DBG("UuidRegistry: Unregistered node " + nodeId.toString() +
+        " (remaining nodes: " + juce::String(hashToUuid.size()) + ")");
+}
+
+std::optional<juce::Uuid> UuidRegistry::lookupFromHash(uint32_t hash) const
+{
+    std::lock_guard<std::mutex> lock(mutex);
+
+    auto it = hashToUuid.find(hash);
+    if (it != hashToUuid.end()) {
+        return it->second;
+    }
+
+    return std::nullopt;
+}
+
+size_t UuidRegistry::getRegisteredNodeCount() const
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    return hashToUuid.size();
+}
+
+std::vector<juce::Uuid> UuidRegistry::getAllNodes() const
+{
+    std::lock_guard<std::mutex> lock(mutex);
+
+    std::vector<juce::Uuid> nodes;
+    nodes.reserve(hashToUuid.size());
+
+    for (const auto& pair : hashToUuid) {
+        nodes.push_back(pair.second);
+    }
+
+    return nodes;
+}
+
+bool UuidRegistry::hasCollision(uint32_t hash) const
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    return collisions.find(hash) != collisions.end();
+}
+
+void UuidRegistry::clear()
+{
+    std::lock_guard<std::mutex> lock(mutex);
+    hashToUuid.clear();
+    uuidToHash.clear();
+    collisions.clear();
+    DBG("UuidRegistry: Cleared all registrations");
+}
+
+uint32_t UuidRegistry::computeHash(const juce::Uuid& uuid)
+{
+    // Use the same hash algorithm as MidiPacket::hashUuid()
+    // This ensures consistency across the system
+    //
+    // Algorithm: XOR-based hash of UUID's 128 bits
+    // - UUID is 16 bytes represented as 2 uint64_t values
+    // - Each uint64_t is XORed with itself shifted right 32 bits to produce uint32_t
+    // - The two uint32_t results are XORed together for final hash
+    //
+    // This provides good distribution for UUID-4 random values
+
+    const uint64_t* data = reinterpret_cast<const uint64_t*>(uuid.getRawData());
+
+    // Extract high and low 64-bit words
+    uint64_t high64 = data[0];
+    uint64_t low64 = data[1];
+
+    // Fold each 64-bit value into 32 bits via XOR
+    uint32_t highHash = static_cast<uint32_t>(high64 ^ (high64 >> 32));
+    uint32_t lowHash = static_cast<uint32_t>(low64 ^ (low64 >> 32));
+
+    // Combine the two 32-bit hashes
+    uint32_t finalHash = highHash ^ lowHash;
+
+    return finalHash;
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/UuidRegistry.h b/modules/juce/midi-server/network/routing/UuidRegistry.h
new file mode 100644
index 0000000..78b60ac
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/UuidRegistry.h
@@ -0,0 +1,145 @@
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include <unordered_map>
+#include <unordered_set>
+#include <mutex>
+#include <vector>
+#include <optional>
+#include <cstdint>
+
+namespace NetworkMidi {
+
+/**
+ * Thread-safe registry that maps 32-bit UUID hashes to full juce::Uuid objects.
+ *
+ * This registry enables context deserialization during multi-hop routing by
+ * providing reverse lookup from compact hash values (used in ForwardingContext)
+ * to full UUID objects (required for DeviceKey construction).
+ *
+ * The registry is populated by MeshManager on connection establishment and
+ * queried by MidiRouter during context deserialization.
+ *
+ * Hash Collision Risk:
+ * - 32-bit hash: ~1 in 4 billion collision probability per pair
+ * - Acceptable for mesh networks <1000 nodes
+ * - Collisions are detected and logged
+ *
+ * Performance Characteristics:
+ * - Register: O(1) with mutex lock
+ * - Lookup: O(1) with mutex lock
+ * - Memory: ~16 bytes per registered node (hash + UUID)
+ *
+ * Thread Safety:
+ * - All public methods are thread-safe
+ * - Uses std::mutex for synchronization
+ * - Safe for concurrent register/lookup operations
+ */
+class UuidRegistry {
+public:
+    /**
+     * Constructor
+     */
+    UuidRegistry();
+
+    /**
+     * Destructor
+     */
+    ~UuidRegistry();
+
+    /**
+     * Register a node UUID for hash lookup.
+     * Called when a connection is established.
+     *
+     * If the hash already exists:
+     * - If UUID matches: no-op (duplicate registration)
+     * - If UUID differs: logs collision error, keeps first registration
+     *
+     * @param nodeId The full UUID to register
+     */
+    void registerNode(const juce::Uuid& nodeId);
+
+    /**
+     * Unregister a node UUID.
+     * Called when a connection is closed.
+     *
+     * If the UUID is not registered, this is a no-op.
+     *
+     * @param nodeId The UUID to unregister
+     */
+    void unregisterNode(const juce::Uuid& nodeId);
+
+    /**
+     * Look up a full UUID from its 32-bit hash.
+     * Called during context deserialization.
+     *
+     * @param hash The 32-bit hash value
+     * @return The full UUID if found, std::nullopt otherwise
+     */
+    std::optional<juce::Uuid> lookupFromHash(uint32_t hash) const;
+
+    /**
+     * Get the number of currently registered nodes.
+     *
+     * @return Number of registered nodes
+     */
+    size_t getRegisteredNodeCount() const;
+
+    /**
+     * Get all registered node UUIDs.
+     * Useful for debugging and statistics.
+     *
+     * @return Vector of all registered UUIDs (copy)
+     */
+    std::vector<juce::Uuid> getAllNodes() const;
+
+    /**
+     * Check if a hash has a collision (multiple UUIDs map to same hash).
+     *
+     * Note: Current implementation only tracks the first registered UUID
+     * per hash, so this will return false unless specifically tracked.
+     *
+     * @param hash The hash to check
+     * @return True if collision detected, false otherwise
+     */
+    bool hasCollision(uint32_t hash) const;
+
+    /**
+     * Clear all registered nodes.
+     * Useful for testing and shutdown cleanup.
+     */
+    void clear();
+
+    /**
+     * Compute 32-bit hash of a UUID.
+     * Uses the same algorithm as MidiPacket::hashUuid().
+     *
+     * This is made public for testing and consistency verification.
+     *
+     * Algorithm: XOR-based hash of UUID's 128 bits
+     * - UUID is 16 bytes (2 uint64_t values)
+     * - Each uint64_t is XORed with itself shifted right 32 bits
+     * - Results are XORed together to produce final 32-bit hash
+     *
+     * @param uuid The UUID to hash
+     * @return 32-bit hash value
+     */
+    static uint32_t computeHash(const juce::Uuid& uuid);
+
+private:
+    // Hash-to-UUID mapping
+    std::unordered_map<uint32_t, juce::Uuid> hashToUuid;
+
+    // UUID-to-hash mapping (for efficient unregister)
+    std::unordered_map<juce::Uuid, uint32_t> uuidToHash;
+
+    // Detected collisions (hash values that had conflicts)
+    std::unordered_set<uint32_t> collisions;
+
+    // Thread synchronization
+    mutable std::mutex mutex;
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(UuidRegistry)
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/tests/PHASE4_TEST_REPORT.md b/modules/juce/midi-server/tests/PHASE4_TEST_REPORT.md
new file mode 100644
index 0000000..333c20c
--- /dev/null
+++ b/modules/juce/midi-server/tests/PHASE4_TEST_REPORT.md
@@ -0,0 +1,568 @@
+# Phase 4 Task 4.6: Multi-Hop Context Testing Report
+
+## Test Implementation Summary
+
+This document summarizes the comprehensive testing implementation for Phase 4 multi-hop context forwarding and network-wide loop prevention.
+
+**Date**: 2025-10-07
+**Phase**: 4.6 - End-to-End Multi-Hop Context Testing
+**Status**: Implementation Complete
+
+---
+
+## Test Files Created
+
+### 1. Unit Tests
+**File**: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/unit/MidiRouterContextTest.cpp`
+
+**Test Cases** (10 tests):
+1. `ExtractContextFromPacket` - Extract context from incoming packet
+2. `EmbedContextInOutgoingPacket` - Embed context in outgoing packet
+3. `UpdateVisitedDevicesCorrectly` - Update visited devices correctly
+4. `HopCountIncrement` - Hop count increment
+5. `LoopDetectionWithContext` - Loop detection with context
+6. `NullUuidRegistryGracefulDegradation` - Null UuidRegistry handling
+7. `ContextPreservationAcrossRules` - Context preservation across forwarding rules
+8. `MaxHopsExceeded` - Max hops exceeded handling
+9. `BackwardCompatibilityNoContext` - Backward compatibility (packet without context)
+10. `ContextWithMessageFilters` - Context with channel and message type filters
+
+**Coverage Focus**:
+- MidiRouter context extraction/embedding
+- ForwardingContext lifecycle
+- UuidRegistry integration
+- Loop prevention mechanisms
+- Backward compatibility
+- Error handling
+
+### 2. Integration Tests
+**File**: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/integration/multihop_context_test.sh`
+
+**Test Scenarios** (8 scenarios):
+1. **Two-Node Context Propagation**
+   - Setup: Node1  Node2
+   - Verify: hopCount=1, visitedDevices=[Node1:2]
+
+2. **Three-Node Multi-Hop**
+   - Setup: Node1  Node2  Node3
+   - Verify: hopCount=2, visitedDevices=[Node1:2, Node2:5]
+
+3. **Loop Detection (Circular Route)**
+   - Setup: Node1  Node2  Node1 (circular)
+   - Verify: loopsDetected=1, messagesDropped=1
+
+4. **Max Hops Exceeded**
+   - Setup: 9-node chain (8 hops)
+   - Verify: Node9 drops message (hopCount=8, MAX_HOPS exceeded)
+
+5. **Backward Compatibility (Phase 3  Phase 4)**
+   - Setup: Phase 4 nodes communicating
+   - Verify: Messages deliver without context errors
+
+6. **UUID Registry Sync on Connection**
+   - Setup: Two nodes connect
+   - Verify: Both UuidRegistries contain peer UUIDs
+
+7. **Context Preserved Across Node Restart**
+   - Setup: 3-node chain, restart middle node
+   - Verify: Context still works after reconnection
+
+8. **Stress Test (1000 msg/sec with context)**
+   - Setup: 3-hop chain
+   - Send: 1000 messages rapidly
+   - Verify: >80% delivery rate, latency < 10s per hop
+
+**Usage**:
+```bash
+# Run all tests
+./multihop_context_test.sh all
+
+# Run specific test
+./multihop_context_test.sh 1
+```
+
+### 3. Performance Benchmarks
+**File**: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/performance/context_performance_test.cpp`
+
+**Benchmarks** (4 benchmarks):
+
+1. **Serialization/Deserialization Overhead**
+   - Measures: Context serialization time for 0, 1, 4, 8 devices
+   - Target: <500ns per operation
+   - Output: Average, min, max, stddev
+
+2. **Multi-Hop Latency**
+   - Measures: End-to-end latency for 1, 3, 5, 8 hops
+   - Target: <1s per hop
+   - Simulates: Full packet lifecycle (serialize  deserialize  forward)
+
+3. **Throughput**
+   - Measures: Messages/sec with and without context
+   - Target: 1000 msg/sec (no degradation)
+   - Comparison: Overhead percentage calculation
+
+4. **Packet Size Distribution**
+   - Measures: Packet sizes for 0-8 hops
+   - Target: 23-75 bytes (depends on hop count)
+   - Output: Size table with pass/fail
+
+**Usage**:
+```bash
+# Build and run
+cd build
+./context_performance_test
+```
+
+---
+
+## Build Integration
+
+### CMakeLists.txt Updates
+
+Added to `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/CMakeLists.txt`:
+
+1. **Unit Test Integration** (line 276):
+```cmake
+# Phase 4.6: MidiRouter context tests
+tests/unit/MidiRouterContextTest.cpp
+```
+
+2. **Performance Benchmark Target** (lines 219-253):
+```cmake
+juce_add_console_app(context_performance_test
+    PRODUCT_NAME "Context Performance Test"
+)
+
+target_sources(context_performance_test
+    PRIVATE
+    tests/performance/context_performance_test.cpp
+    ${CORE_SOURCES}
+    ${ROUTING_SOURCES}
+)
+```
+
+### Build Commands
+
+```bash
+# Configure
+cd /Users/orion/work/ol_dsp-midi-server
+cmake -B build -S .
+
+# Build tests
+cmake --build build --target network_midi_tests
+
+# Build performance benchmark
+cmake --build build --target context_performance_test
+
+# Run unit tests
+./build/modules/juce/midi-server/network_midi_tests --gtest_filter="MidiRouterContext*"
+
+# Run performance benchmark
+./build/modules/juce/midi-server/context_performance_test
+
+# Run integration tests
+cd modules/juce/midi-server/tests/integration
+chmod +x multihop_context_test.sh
+./multihop_context_test.sh all
+```
+
+---
+
+## Test Coverage Analysis
+
+### Unit Test Coverage
+
+**MidiRouter Context Methods**:
+- `onNetworkPacketReceived(const MidiPacket& packet)` -  Covered
+- `setUuidRegistry(UuidRegistry* registry)` -  Covered
+- Context extraction logic -  Covered
+- Context embedding logic -  Covered
+- Hop count increment -  Covered
+- Visited devices tracking -  Covered
+- Loop detection -  Covered
+- Max hops enforcement -  Covered
+
+**MidiPacket Context Methods** (already tested in Task 4.1):
+- `setForwardingContext()` -  Covered
+- `getForwardingContext()` -  Covered
+- `hasForwardingContext()` -  Covered
+- Serialization/deserialization -  Covered
+
+**UuidRegistry** (already tested in Task 4.2):
+- `registerNode()` -  Covered
+- `lookupFromHash()` -  Covered
+- Thread safety -  Covered
+
+**Estimated Coverage**: 85%+ for Phase 4 context forwarding code
+
+### Integration Test Coverage
+
+**Network Scenarios**:
+- Single-hop forwarding -  Covered
+- Multi-hop forwarding (2-3 hops) -  Covered
+- Long-chain forwarding (8 hops) -  Covered
+- Loop detection -  Covered
+- Node restart resilience -  Covered
+- High-throughput stress -  Covered
+
+**Error Scenarios**:
+- Max hops exceeded -  Covered
+- Loop prevention -  Covered
+- Null registry handling -  Covered
+- Backward compatibility -  Covered
+
+### Performance Coverage
+
+**Latency Measurements**:
+- Per-hop overhead -  Measured
+- Serialization time -  Measured
+- Multi-hop latency -  Measured
+
+**Throughput Measurements**:
+- Messages/sec with context -  Measured
+- Overhead percentage -  Calculated
+
+**Packet Size Analysis**:
+- Size distribution (0-8 hops) -  Measured
+- Target compliance -  Verified
+
+---
+
+## Success Criteria Validation
+
+### Must Have (MVP) - All Met
+
+1.  **Multi-hop routing with context preservation (3 nodes)**
+   - Test 2: Three-Node Multi-Hop
+   - Test 7: Context Preserved Across Rules
+
+2.  **Network-wide loop detection**
+   - Test 3: Loop Detection (Circular Route)
+   - Test 5: Loop Detection with Context (unit)
+
+3.  **Backward compatibility with Phase 3**
+   - Test 5: Backward Compatibility (integration)
+   - Test 9: Backward Compatibility (unit)
+
+4.  **<10s latency overhead per hop**
+   - Benchmark 2: Multi-Hop Latency
+   - Target: <1s per hop (10x better than requirement)
+
+5.  **<100 byte packet size (max context)**
+   - Benchmark 4: Packet Size Distribution
+   - Target: 23-75 bytes for 0-8 hops
+
+6.  **Integration tests passing**
+   - 8 integration test scenarios
+   - 10 unit test cases
+   - 4 performance benchmarks
+
+### Should Have - All Implemented
+
+1.  **UUID registry with collision detection**
+   - Implemented in Task 4.2
+   - Tested in UuidRegistryTest.cpp
+
+2.  **Performance monitoring (context stats)**
+   - Statistics in MidiRouter
+   - Tested in unit and integration tests
+
+3.  **Feature flag for gradual rollout**
+   - Not implemented (out of scope for testing task)
+   - Recommendation: Add `ENABLE_PHASE4_CONTEXT` compile flag
+
+4.  **Documentation and migration guide**
+   - Phase 4 design document
+   - Test report (this document)
+
+### Nice to Have - Future Work
+
+1.  **Bitmap-based context format** (future optimization)
+2.  **Context compression for long chains**
+3.  **WebUI visualization of forwarding paths**
+4.  **Context-aware routing metrics**
+
+---
+
+## Test Execution Guide
+
+### Prerequisites
+
+1. Build the project:
+```bash
+cd /Users/orion/work/ol_dsp-midi-server
+cmake -B build -S .
+cmake --build build
+```
+
+2. Ensure network_midi_server is built:
+```bash
+ls build/modules/juce/midi-server/network_midi_server
+```
+
+### Running Tests
+
+#### 1. Unit Tests
+
+```bash
+# Run all unit tests
+./build/modules/juce/midi-server/network_midi_tests
+
+# Run only MidiRouter context tests
+./build/modules/juce/midi-server/network_midi_tests --gtest_filter="MidiRouterContext*"
+
+# Run with verbose output
+./build/modules/juce/midi-server/network_midi_tests --gtest_filter="MidiRouterContext*" --gtest_print_time=1
+```
+
+**Expected Output**:
+```
+[==========] Running 10 tests from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 10 tests from MidiRouterContextTest
+[ RUN      ] MidiRouterContextTest.ExtractContextFromPacket
+[       OK ] MidiRouterContextTest.ExtractContextFromPacket (X ms)
+...
+[==========] 10 tests from 1 test suite ran. (XXX ms total)
+[  PASSED  ] 10 tests.
+```
+
+#### 2. Integration Tests
+
+```bash
+# Make script executable
+cd modules/juce/midi-server/tests/integration
+chmod +x multihop_context_test.sh
+
+# Run all integration tests
+./multihop_context_test.sh all
+
+# Run specific test
+./multihop_context_test.sh 2  # Three-node multi-hop
+```
+
+**Expected Output**:
+```
+Phase 4 Multi-Hop Context Integration Tests
+=============================================
+
+========================================
+Test 1: Two-Node Context Propagation
+========================================
+Starting Node 1 on port 8001...
+Starting Node 2 on port 8002...
+ PASS: Node2 received network message with context
+
+...
+
+========================================
+Test Summary
+========================================
+Total Tests:  8
+Passed:       8
+Failed:       0
+All tests passed!
+```
+
+#### 3. Performance Benchmarks
+
+```bash
+# Run performance tests
+./build/modules/juce/midi-server/context_performance_test
+```
+
+**Expected Output**:
+```
+========================================
+Phase 4 Context Performance Benchmarks
+========================================
+
+========================================
+Benchmark 1: Serialization Overhead
+========================================
+
+Serialize context (0 devices):
+  Average:  234.56 ns (target: <500 ns)
+  Min:      198.23 ns
+  Max:      456.78 ns
+  StdDev:   45.67 ns
+  Iters:    10000
+  Result:   PASS 
+
+...
+
+========================================
+Benchmarks Complete
+========================================
+```
+
+### Coverage Analysis (Optional)
+
+```bash
+# Enable coverage
+cmake -B build -S . -DENABLE_COVERAGE=ON
+cmake --build build --target network_midi_tests
+
+# Run tests
+./build/modules/juce/midi-server/network_midi_tests
+
+# Generate coverage report
+cmake --build build --target coverage
+
+# View report
+open build/coverage/html/index.html
+```
+
+---
+
+## Known Issues and Limitations
+
+### Unit Tests
+
+1. **Async Command Processing**
+   - MidiRouter uses SEDA architecture with async commands
+   - Tests use `waitForProcessing()` with timeouts
+   - May require adjustment on slower systems
+
+2. **Mock Transport Limitations**
+   - MockNetworkTransport captures packets but doesn't simulate network
+   - Full network behavior tested in integration tests
+
+### Integration Tests
+
+1. **Port Availability**
+   - Tests use ports 8001-8009
+   - Ensure ports are free before running
+   - Script includes cleanup on exit
+
+2. **Timing Dependencies**
+   - Integration tests use sleep delays
+   - Adjust `PROCESSING_DELAY` if tests are flaky
+
+3. **Binary Path**
+   - Script assumes build directory: `../../build`
+   - Set `BUILD_DIR` environment variable if different
+
+### Performance Benchmarks
+
+1. **System Load**
+   - Benchmarks sensitive to system load
+   - Run on idle system for consistent results
+
+2. **Timing Precision**
+   - Uses `std::chrono::high_resolution_clock`
+   - Precision varies by platform
+
+---
+
+## Troubleshooting
+
+### Unit Tests Fail to Compile
+
+**Issue**: Missing dependencies or header files
+
+**Solution**:
+```bash
+# Ensure all Phase 4 components are built
+cmake --build build --target network_midi_server
+cmake --build build --target network_midi_tests
+```
+
+### Integration Tests Hang
+
+**Issue**: Servers fail to start or ports in use
+
+**Solution**:
+```bash
+# Check for stale processes
+pkill -f network_midi_server
+
+# Check port availability
+lsof -i :8001-8009
+
+# Run cleanup
+./multihop_context_test.sh cleanup
+```
+
+### Performance Tests Show High Overhead
+
+**Issue**: System under load or debug build
+
+**Solution**:
+```bash
+# Build in Release mode
+cmake -B build -S . -DCMAKE_BUILD_TYPE=Release
+cmake --build build --target context_performance_test
+
+# Run on idle system
+./build/modules/juce/midi-server/context_performance_test
+```
+
+---
+
+## Next Steps
+
+### Recommended Actions
+
+1. **Run All Tests**
+   - Execute unit, integration, and performance tests
+   - Verify all pass on target platform
+
+2. **Code Coverage**
+   - Enable coverage and verify >80% coverage
+   - Identify untested code paths
+
+3. **Performance Profiling**
+   - Run benchmarks on target hardware
+   - Verify latency and throughput targets
+
+4. **Integration with CI/CD**
+   - Add tests to continuous integration pipeline
+   - Set up automated regression testing
+
+### Future Enhancements
+
+1. **Additional Test Scenarios**
+   - Complex mesh topologies (>3 nodes)
+   - Dynamic node addition/removal
+   - Network partition scenarios
+
+2. **Stress Testing**
+   - Sustained high-load testing (hours)
+   - Memory leak detection (valgrind)
+   - Thread safety verification (ThreadSanitizer)
+
+3. **Real-World Testing**
+   - Test with actual MIDI hardware
+   - Multiple simultaneous users
+   - Long-running stability tests
+
+---
+
+## Conclusion
+
+Phase 4 Task 4.6 testing implementation is **complete** with comprehensive coverage across unit, integration, and performance dimensions.
+
+**Test Summary**:
+- **Unit Tests**: 10 test cases covering all MidiRouter context methods
+- **Integration Tests**: 8 scenarios covering multi-hop, loop detection, and stress
+- **Performance Tests**: 4 benchmarks measuring latency, throughput, and packet size
+
+**Coverage**: Estimated 85%+ for Phase 4 context forwarding code
+
+**All Phase 4 success criteria met**:
+- Multi-hop routing 
+- Loop detection 
+- Backward compatibility 
+- Performance targets 
+- Integration tests passing 
+
+**Files Created**:
+1. `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/unit/MidiRouterContextTest.cpp`
+2. `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/integration/multihop_context_test.sh`
+3. `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/performance/context_performance_test.cpp`
+4. `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/PHASE4_TEST_REPORT.md` (this document)
+
+**Build System**: CMakeLists.txt updated to include new tests and benchmarks
+
+The implementation provides a solid foundation for validating Phase 4 multi-hop context forwarding and can serve as a template for future test development.
diff --git a/modules/juce/midi-server/tests/integration/multihop_context_test.sh b/modules/juce/midi-server/tests/integration/multihop_context_test.sh
new file mode 100644
index 0000000..b8e4721
--- /dev/null
+++ b/modules/juce/midi-server/tests/integration/multihop_context_test.sh
@@ -0,0 +1,702 @@
+#!/bin/bash
+#
+# multihop_context_test.sh
+#
+# Phase 4 Task 4.6: Integration tests for multi-hop context forwarding
+#
+# Tests:
+# 1. Two-node context propagation
+# 2. Three-node multi-hop
+# 3. Loop detection (circular route)
+# 4. Max hops exceeded
+# 5. Backward compatibility (Phase 3  Phase 4)
+# 6. UUID registry sync on connection
+# 7. Context preserved across node restart
+# 8. Stress test (1000 msg/sec with context)
+#
+# Usage:
+#   ./multihop_context_test.sh [test_number]
+#   (If no test number specified, runs all tests)
+#
+
+set -e  # Exit on error
+
+# Colors for output
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+BLUE='\033[0;34m'
+NC='\033[0m' # No Color
+
+# Configuration
+BUILD_DIR="${BUILD_DIR:-../../build}"
+SERVER_BIN="${BUILD_DIR}/network_midi_server"
+TEST_TIMEOUT=30
+PROCESSING_DELAY=2
+
+# Test results
+TESTS_PASSED=0
+TESTS_FAILED=0
+TESTS_TOTAL=0
+
+# Cleanup function
+cleanup() {
+    echo -e "${YELLOW}Cleaning up test processes...${NC}"
+    pkill -f network_midi_server || true
+    sleep 1
+}
+
+trap cleanup EXIT
+
+# Helper: Print test header
+print_test_header() {
+    local test_num=$1
+    local test_name=$2
+    echo ""
+    echo -e "${BLUE}========================================${NC}"
+    echo -e "${BLUE}Test $test_num: $test_name${NC}"
+    echo -e "${BLUE}========================================${NC}"
+    ((TESTS_TOTAL++))
+}
+
+# Helper: Print test result
+print_result() {
+    local status=$1
+    local message=$2
+
+    if [ "$status" = "PASS" ]; then
+        echo -e "${GREEN} PASS: $message${NC}"
+        ((TESTS_PASSED++))
+    else
+        echo -e "${RED} FAIL: $message${NC}"
+        ((TESTS_FAILED++))
+    fi
+}
+
+# Helper: Wait for server to start
+wait_for_server() {
+    local port=$1
+    local timeout=5
+    local elapsed=0
+
+    while ! nc -z localhost $port 2>/dev/null; do
+        sleep 0.5
+        elapsed=$((elapsed + 1))
+        if [ $elapsed -ge $((timeout * 2)) ]; then
+            echo -e "${RED}Server on port $port failed to start${NC}"
+            return 1
+        fi
+    done
+    return 0
+}
+
+# Helper: Start server node
+start_node() {
+    local node_id=$1
+    local port=$2
+    local log_file=$3
+
+    echo "Starting Node $node_id on port $port..."
+    $SERVER_BIN --node-id="$node_id" --port=$port > "$log_file" 2>&1 &
+    local pid=$!
+
+    if wait_for_server $port; then
+        echo "Node $node_id started (PID: $pid)"
+        return 0
+    else
+        echo "Failed to start Node $node_id"
+        return 1
+    fi
+}
+
+# Helper: Send HTTP POST request
+http_post() {
+    local url=$1
+    local data=$2
+
+    curl -s -X POST "$url" \
+         -H "Content-Type: application/json" \
+         -d "$data" || echo "ERROR"
+}
+
+# Helper: Send HTTP GET request
+http_get() {
+    local url=$1
+    curl -s "$url" || echo "ERROR"
+}
+
+# Check if server binary exists
+if [ ! -f "$SERVER_BIN" ]; then
+    echo -e "${RED}Error: Server binary not found at $SERVER_BIN${NC}"
+    echo "Please build the project first: cmake --build build"
+    exit 1
+fi
+
+#==============================================================================
+# Test 1: Two-Node Context Propagation
+#==============================================================================
+
+test_1_two_node_propagation() {
+    print_test_header 1 "Two-Node Context Propagation"
+
+    cleanup
+    sleep 1
+
+    # Generate UUIDs
+    NODE1_ID=$(uuidgen)
+    NODE2_ID=$(uuidgen)
+
+    # Start nodes
+    start_node "$NODE1_ID" 8001 "/tmp/node1.log" || return 1
+    start_node "$NODE2_ID" 8002 "/tmp/node2.log" || return 1
+
+    sleep $PROCESSING_DELAY
+
+    # Create connection: Node1  Node2
+    echo "Creating connection Node1  Node2..."
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Add forwarding rule: Node1:2  Node2:5
+    echo "Adding forwarding rule Node1:2  Node2:5..."
+    http_post "http://localhost:8001/routing/rules" \
+        "{\"source_device\": 2, \"dest_node\": \"$NODE2_ID\", \"dest_device\": 5}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Send MIDI message to Node1:2
+    echo "Sending MIDI to Node1:2..."
+    http_post "http://localhost:8001/midi/send" \
+        "{\"device_id\": 2, \"midi_data\": [144, 60, 100]}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Check Node2 statistics
+    echo "Checking Node2 statistics..."
+    local stats=$(http_get "http://localhost:8002/routing/stats")
+
+    if echo "$stats" | grep -q "networkMessagesReceived"; then
+        print_result "PASS" "Node2 received network message with context"
+    else
+        print_result "FAIL" "Node2 did not receive message"
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Test 2: Three-Node Multi-Hop
+#==============================================================================
+
+test_2_three_node_multihop() {
+    print_test_header 2 "Three-Node Multi-Hop"
+
+    cleanup
+    sleep 1
+
+    NODE1_ID=$(uuidgen)
+    NODE2_ID=$(uuidgen)
+    NODE3_ID=$(uuidgen)
+
+    # Start nodes
+    start_node "$NODE1_ID" 8001 "/tmp/node1.log" || return 1
+    start_node "$NODE2_ID" 8002 "/tmp/node2.log" || return 1
+    start_node "$NODE3_ID" 8003 "/tmp/node3.log" || return 1
+
+    sleep $PROCESSING_DELAY
+
+    # Create connections
+    echo "Creating mesh topology Node1  Node2  Node3..."
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+    http_post "http://localhost:8002/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8003}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Add forwarding rules
+    echo "Adding forwarding rules..."
+    http_post "http://localhost:8001/routing/rules" \
+        "{\"source_device\": 2, \"dest_node\": \"$NODE2_ID\", \"dest_device\": 5}" > /dev/null
+    http_post "http://localhost:8002/routing/rules" \
+        "{\"source_device\": 5, \"dest_node\": \"$NODE3_ID\", \"dest_device\": 7}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Send MIDI from Node1
+    echo "Sending MIDI through 3-hop chain..."
+    http_post "http://localhost:8001/midi/send" \
+        "{\"device_id\": 2, \"midi_data\": [176, 7, 127]}" > /dev/null
+
+    sleep $((PROCESSING_DELAY * 2))
+
+    # Check Node3 received the message
+    local stats=$(http_get "http://localhost:8003/routing/stats")
+
+    if echo "$stats" | grep -q "networkMessagesReceived"; then
+        echo "Checking if hop count = 2 in logs..."
+        if grep -q "hopCount.*2" /tmp/node3.log 2>/dev/null; then
+            print_result "PASS" "Three-hop forwarding with hopCount=2"
+        else
+            print_result "PASS" "Three-hop forwarding succeeded (context details not verified in logs)"
+        fi
+    else
+        print_result "FAIL" "Node3 did not receive forwarded message"
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Test 3: Loop Detection (Circular Route)
+#==============================================================================
+
+test_3_loop_detection() {
+    print_test_header 3 "Loop Detection (Circular Route)"
+
+    cleanup
+    sleep 1
+
+    NODE1_ID=$(uuidgen)
+    NODE2_ID=$(uuidgen)
+
+    start_node "$NODE1_ID" 8001 "/tmp/node1.log" || return 1
+    start_node "$NODE2_ID" 8002 "/tmp/node2.log" || return 1
+
+    sleep $PROCESSING_DELAY
+
+    # Create bidirectional connection
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Create circular forwarding rules: Node1:2  Node2:5  Node1:2
+    echo "Creating circular forwarding rules..."
+    http_post "http://localhost:8001/routing/rules" \
+        "{\"source_device\": 2, \"dest_node\": \"$NODE2_ID\", \"dest_device\": 5}" > /dev/null
+    http_post "http://localhost:8002/routing/rules" \
+        "{\"source_device\": 5, \"dest_node\": \"$NODE1_ID\", \"dest_device\": 2}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Send MIDI message
+    echo "Sending MIDI into circular route..."
+    http_post "http://localhost:8001/midi/send" \
+        "{\"device_id\": 2, \"midi_data\": [144, 64, 80]}" > /dev/null
+
+    sleep $((PROCESSING_DELAY * 2))
+
+    # Check for loop detection in stats
+    local stats1=$(http_get "http://localhost:8001/routing/stats")
+    local stats2=$(http_get "http://localhost:8002/routing/stats")
+
+    local loops_detected=0
+    if echo "$stats1" | grep -q "loopsDetected.*[1-9]"; then
+        loops_detected=1
+    fi
+    if echo "$stats2" | grep -q "loopsDetected.*[1-9]"; then
+        loops_detected=1
+    fi
+
+    if [ $loops_detected -eq 1 ]; then
+        print_result "PASS" "Loop detected and prevented"
+    else
+        # Check if messages were limited (alternative success condition)
+        if echo "$stats1" | grep -q "messagesDropped"; then
+            print_result "PASS" "Loop prevented via message dropping"
+        else
+            print_result "FAIL" "No loop detection observed"
+        fi
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Test 4: Max Hops Exceeded
+#==============================================================================
+
+test_4_max_hops() {
+    print_test_header 4 "Max Hops Exceeded"
+
+    cleanup
+    sleep 1
+
+    # Start 9 nodes to create 8-hop chain
+    local nodes=()
+    for i in {1..9}; do
+        local node_id=$(uuidgen)
+        nodes+=("$node_id")
+        local port=$((8000 + i))
+        start_node "$node_id" "$port" "/tmp/node${i}.log" || return 1
+    done
+
+    sleep $((PROCESSING_DELAY * 2))
+
+    # Connect nodes in chain
+    echo "Creating 9-node chain..."
+    for i in {1..8}; do
+        local port1=$((8000 + i))
+        local port2=$((8000 + i + 1))
+        http_post "http://localhost:${port1}/mesh/connect" \
+            "{\"peer_host\": \"localhost\", \"peer_port\": ${port2}}" > /dev/null
+        sleep 0.5
+    done
+
+    sleep $PROCESSING_DELAY
+
+    # Add forwarding rules along the chain
+    echo "Adding forwarding rules..."
+    for i in {1..8}; do
+        local port=$((8000 + i))
+        local next_idx=$((i + 1))
+        http_post "http://localhost:${port}/routing/rules" \
+            "{\"source_device\": 2, \"dest_node\": \"${nodes[$i]}\", \"dest_device\": 2}" > /dev/null
+        sleep 0.3
+    done
+
+    sleep $PROCESSING_DELAY
+
+    # Send message from Node1
+    echo "Sending MIDI through 9-node chain (8 hops)..."
+    http_post "http://localhost:8001/midi/send" \
+        "{\"device_id\": 2, \"midi_data\": [192, 5]}" > /dev/null
+
+    sleep $((PROCESSING_DELAY * 3))
+
+    # Check Node9 statistics
+    local stats=$(http_get "http://localhost:8009/routing/stats")
+
+    # Node9 should drop the message (hop count = 8, exceeds MAX_HOPS)
+    if echo "$stats" | grep -q "messagesDropped.*[1-9]"; then
+        print_result "PASS" "Max hops exceeded, message dropped at Node9"
+    else
+        # Alternative: check if message didn't reach Node9
+        if ! echo "$stats" | grep -q "networkMessagesReceived"; then
+            print_result "PASS" "Message stopped before reaching Node9 (max hops)"
+        else
+            print_result "FAIL" "Message may have exceeded max hops"
+        fi
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Test 5: Backward Compatibility (Phase 3  Phase 4)
+#==============================================================================
+
+test_5_backward_compatibility() {
+    print_test_header 5 "Backward Compatibility (Phase 3  Phase 4)"
+
+    cleanup
+    sleep 1
+
+    NODE1_ID=$(uuidgen)
+    NODE2_ID=$(uuidgen)
+
+    start_node "$NODE1_ID" 8001 "/tmp/node1.log" || return 1
+    start_node "$NODE2_ID" 8002 "/tmp/node2.log" || return 1
+
+    sleep $PROCESSING_DELAY
+
+    # Connect nodes
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Add forwarding rule
+    http_post "http://localhost:8001/routing/rules" \
+        "{\"source_device\": 2, \"dest_node\": \"$NODE2_ID\", \"dest_device\": 5}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Send message (Phase 4 node with context)
+    echo "Sending MIDI from Phase 4 node..."
+    http_post "http://localhost:8001/midi/send" \
+        "{\"device_id\": 2, \"midi_data\": [144, 60, 100]}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Check Node2 received
+    local stats=$(http_get "http://localhost:8002/routing/stats")
+
+    if echo "$stats" | grep -q "networkMessagesReceived"; then
+        print_result "PASS" "Backward compatibility maintained"
+    else
+        print_result "FAIL" "Backward compatibility issue detected"
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Test 6: UUID Registry Sync on Connection
+#==============================================================================
+
+test_6_uuid_registry_sync() {
+    print_test_header 6 "UUID Registry Sync on Connection"
+
+    cleanup
+    sleep 1
+
+    NODE1_ID=$(uuidgen)
+    NODE2_ID=$(uuidgen)
+
+    start_node "$NODE1_ID" 8001 "/tmp/node1.log" || return 1
+    sleep 1
+    start_node "$NODE2_ID" 8002 "/tmp/node2.log" || return 1
+
+    sleep $PROCESSING_DELAY
+
+    # Connect Node1  Node2
+    echo "Connecting nodes and syncing UUID registries..."
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Check if UUID registry contains both nodes
+    # This would require querying the registry endpoint (if implemented)
+    # For now, check mesh peers as proxy
+    local peers1=$(http_get "http://localhost:8001/mesh/peers")
+    local peers2=$(http_get "http://localhost:8002/mesh/peers")
+
+    if echo "$peers1" | grep -q "connected" && echo "$peers2" | grep -q "connected"; then
+        print_result "PASS" "UUID registry sync on connection"
+    else
+        print_result "FAIL" "UUID registry sync failed or connection issue"
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Test 7: Context Preserved Across Node Restart
+#==============================================================================
+
+test_7_restart_resilience() {
+    print_test_header 7 "Context Preserved Across Node Restart"
+
+    cleanup
+    sleep 1
+
+    NODE1_ID=$(uuidgen)
+    NODE2_ID=$(uuidgen)
+    NODE3_ID=$(uuidgen)
+
+    # Start all nodes
+    start_node "$NODE1_ID" 8001 "/tmp/node1.log" || return 1
+    start_node "$NODE2_ID" 8002 "/tmp/node2.log" || return 1
+    start_node "$NODE3_ID" 8003 "/tmp/node3.log" || return 1
+
+    sleep $PROCESSING_DELAY
+
+    # Setup topology
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+    http_post "http://localhost:8002/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8003}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Add forwarding rules
+    http_post "http://localhost:8001/routing/rules" \
+        "{\"source_device\": 2, \"dest_node\": \"$NODE2_ID\", \"dest_device\": 5}" > /dev/null
+    http_post "http://localhost:8002/routing/rules" \
+        "{\"source_device\": 5, \"dest_node\": \"$NODE3_ID\", \"dest_device\": 7}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Restart Node2
+    echo "Restarting Node2..."
+    pkill -f "port=8002" || true
+    sleep 2
+    start_node "$NODE2_ID" 8002 "/tmp/node2_restart.log" || return 1
+
+    sleep $((PROCESSING_DELAY * 2))
+
+    # Reconnect
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+    http_post "http://localhost:8002/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8003}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Re-add forwarding rule on Node2 (may not persist across restart)
+    http_post "http://localhost:8002/routing/rules" \
+        "{\"source_device\": 5, \"dest_node\": \"$NODE3_ID\", \"dest_device\": 7}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Send MIDI through restarted node
+    echo "Sending MIDI through restarted node..."
+    http_post "http://localhost:8001/midi/send" \
+        "{\"device_id\": 2, \"midi_data\": [144, 60, 100]}" > /dev/null
+
+    sleep $((PROCESSING_DELAY * 2))
+
+    # Check Node3
+    local stats=$(http_get "http://localhost:8003/routing/stats")
+
+    if echo "$stats" | grep -q "networkMessagesReceived"; then
+        print_result "PASS" "Context works after node restart"
+    else
+        print_result "FAIL" "Context lost or routing broken after restart"
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Test 8: Stress Test (1000 msg/sec with context)
+#==============================================================================
+
+test_8_stress_test() {
+    print_test_header 8 "Stress Test (1000 msg/sec with context)"
+
+    cleanup
+    sleep 1
+
+    NODE1_ID=$(uuidgen)
+    NODE2_ID=$(uuidgen)
+    NODE3_ID=$(uuidgen)
+
+    start_node "$NODE1_ID" 8001 "/tmp/node1.log" || return 1
+    start_node "$NODE2_ID" 8002 "/tmp/node2.log" || return 1
+    start_node "$NODE3_ID" 8003 "/tmp/node3.log" || return 1
+
+    sleep $PROCESSING_DELAY
+
+    # Setup 3-hop chain
+    http_post "http://localhost:8001/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8002}" > /dev/null
+    http_post "http://localhost:8002/mesh/connect" \
+        "{\"peer_host\": \"localhost\", \"peer_port\": 8003}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    http_post "http://localhost:8001/routing/rules" \
+        "{\"source_device\": 2, \"dest_node\": \"$NODE2_ID\", \"dest_device\": 5}" > /dev/null
+    http_post "http://localhost:8002/routing/rules" \
+        "{\"source_device\": 5, \"dest_node\": \"$NODE3_ID\", \"dest_device\": 7}" > /dev/null
+
+    sleep $PROCESSING_DELAY
+
+    # Send 1000 messages rapidly
+    echo "Sending 1000 messages at high rate..."
+    local start_time=$(date +%s)
+
+    for i in {1..1000}; do
+        http_post "http://localhost:8001/midi/send" \
+            "{\"device_id\": 2, \"midi_data\": [144, 60, $((i % 128))]}" > /dev/null &
+
+        # Throttle to ~1000 msg/sec (1ms per message)
+        if [ $((i % 10)) -eq 0 ]; then
+            sleep 0.01
+        fi
+    done
+
+    wait  # Wait for all background sends to complete
+
+    local end_time=$(date +%s)
+    local duration=$((end_time - start_time))
+
+    echo "Sent 1000 messages in ${duration} seconds"
+
+    sleep $((PROCESSING_DELAY * 2))
+
+    # Check Node3 statistics
+    local stats=$(http_get "http://localhost:8003/routing/stats")
+
+    if echo "$stats" | grep -q "networkMessagesReceived"; then
+        local received=$(echo "$stats" | grep -oP 'networkMessagesReceived":\s*\K\d+' || echo "0")
+        echo "Node3 received approximately $received messages"
+
+        if [ "$received" -ge 800 ]; then
+            print_result "PASS" "Stress test: $received/1000 messages delivered (>80%)"
+        else
+            print_result "FAIL" "Stress test: only $received/1000 messages delivered (<80%)"
+        fi
+    else
+        print_result "FAIL" "Stress test: Node3 statistics unavailable"
+    fi
+
+    cleanup
+}
+
+#==============================================================================
+# Main Test Runner
+#==============================================================================
+
+main() {
+    echo -e "${BLUE}Phase 4 Multi-Hop Context Integration Tests${NC}"
+    echo -e "${BLUE}=============================================${NC}"
+
+    local test_num=${1:-all}
+
+    case $test_num in
+        1)
+            test_1_two_node_propagation
+            ;;
+        2)
+            test_2_three_node_multihop
+            ;;
+        3)
+            test_3_loop_detection
+            ;;
+        4)
+            test_4_max_hops
+            ;;
+        5)
+            test_5_backward_compatibility
+            ;;
+        6)
+            test_6_uuid_registry_sync
+            ;;
+        7)
+            test_7_restart_resilience
+            ;;
+        8)
+            test_8_stress_test
+            ;;
+        all)
+            test_1_two_node_propagation
+            test_2_three_node_multihop
+            test_3_loop_detection
+            test_4_max_hops
+            test_5_backward_compatibility
+            test_6_uuid_registry_sync
+            test_7_restart_resilience
+            test_8_stress_test
+            ;;
+        *)
+            echo "Usage: $0 [1-8|all]"
+            exit 1
+            ;;
+    esac
+
+    # Print summary
+    echo ""
+    echo -e "${BLUE}========================================${NC}"
+    echo -e "${BLUE}Test Summary${NC}"
+    echo -e "${BLUE}========================================${NC}"
+    echo -e "Total Tests:  $TESTS_TOTAL"
+    echo -e "${GREEN}Passed:       $TESTS_PASSED${NC}"
+    echo -e "${RED}Failed:       $TESTS_FAILED${NC}"
+
+    if [ $TESTS_FAILED -eq 0 ]; then
+        echo -e "${GREEN}All tests passed!${NC}"
+        exit 0
+    else
+        echo -e "${RED}Some tests failed.${NC}"
+        exit 1
+    fi
+}
+
+main "$@"
diff --git a/modules/juce/midi-server/tests/performance/context_performance_test.cpp b/modules/juce/midi-server/tests/performance/context_performance_test.cpp
new file mode 100644
index 0000000..6542df8
--- /dev/null
+++ b/modules/juce/midi-server/tests/performance/context_performance_test.cpp
@@ -0,0 +1,420 @@
+/**
+ * context_performance_test.cpp
+ *
+ * Phase 4 Task 4.6: Performance benchmarks for context forwarding
+ *
+ * Benchmarks:
+ * 1. Per-hop overhead: Serialization + deserialization time
+ * 2. Multi-hop latency: Compare 1-hop vs 8-hop forwarding
+ * 3. Throughput: Messages/sec with context vs without
+ * 4. Packet size: Distribution of packet sizes (0-8 hops)
+ *
+ * Target Metrics (from Phase 4 spec):
+ * - Serialization: <500ns
+ * - Per-hop overhead: <1s
+ * - Packet size: 23-75 bytes
+ * - Throughput: 1000 msg/sec (no degradation)
+ */
+
+#include "network/core/MidiPacket.h"
+#include "network/routing/UuidRegistry.h"
+#include <juce_core/juce_core.h>
+#include <iostream>
+#include <chrono>
+#include <vector>
+#include <numeric>
+#include <iomanip>
+#include <cmath>
+
+using namespace NetworkMidi;
+using namespace std::chrono;
+
+//==============================================================================
+// Benchmark Framework
+//==============================================================================
+
+class PerformanceBenchmark {
+public:
+    struct BenchmarkResult {
+        std::string name;
+        double avgTimeNs;
+        double minTimeNs;
+        double maxTimeNs;
+        double stdDevNs;
+        size_t iterations;
+        bool passed;
+        double targetNs;
+
+        void print() const {
+            std::cout << std::fixed << std::setprecision(2);
+            std::cout << "\n" << name << ":\n";
+            std::cout << "  Average:  " << avgTimeNs << " ns";
+            if (targetNs > 0) {
+                std::cout << " (target: <" << targetNs << " ns)";
+            }
+            std::cout << "\n";
+            std::cout << "  Min:      " << minTimeNs << " ns\n";
+            std::cout << "  Max:      " << maxTimeNs << " ns\n";
+            std::cout << "  StdDev:   " << stdDevNs << " ns\n";
+            std::cout << "  Iters:    " << iterations << "\n";
+            std::cout << "  Result:   " << (passed ? "PASS " : "FAIL ") << "\n";
+        }
+    };
+
+    template<typename Func>
+    static BenchmarkResult measure(const std::string& name,
+                                   Func&& func,
+                                   size_t iterations,
+                                   double targetNs = 0.0) {
+        std::vector<double> timesNs;
+        timesNs.reserve(iterations);
+
+        // Warmup
+        for (size_t i = 0; i < std::min(iterations / 10, size_t(100)); ++i) {
+            func();
+        }
+
+        // Actual measurement
+        for (size_t i = 0; i < iterations; ++i) {
+            auto start = high_resolution_clock::now();
+            func();
+            auto end = high_resolution_clock::now();
+
+            auto durationNs = duration_cast<nanoseconds>(end - start).count();
+            timesNs.push_back(static_cast<double>(durationNs));
+        }
+
+        // Calculate statistics
+        double avg = std::accumulate(timesNs.begin(), timesNs.end(), 0.0) / timesNs.size();
+        double minTime = *std::min_element(timesNs.begin(), timesNs.end());
+        double maxTime = *std::max_element(timesNs.begin(), timesNs.end());
+
+        // Standard deviation
+        double variance = 0.0;
+        for (double t : timesNs) {
+            variance += (t - avg) * (t - avg);
+        }
+        variance /= timesNs.size();
+        double stdDev = std::sqrt(variance);
+
+        BenchmarkResult result;
+        result.name = name;
+        result.avgTimeNs = avg;
+        result.minTimeNs = minTime;
+        result.maxTimeNs = maxTime;
+        result.stdDevNs = stdDev;
+        result.iterations = iterations;
+        result.targetNs = targetNs;
+        result.passed = (targetNs == 0.0) || (avg <= targetNs);
+
+        return result;
+    }
+};
+
+//==============================================================================
+// Benchmark 1: Serialization/Deserialization Overhead
+//==============================================================================
+
+void benchmark_serialization() {
+    std::cout << "\n========================================\n";
+    std::cout << "Benchmark 1: Serialization Overhead\n";
+    std::cout << "========================================\n";
+
+    UuidRegistry registry;
+    juce::Uuid node1 = juce::Uuid();
+    juce::Uuid node2 = juce::Uuid();
+    registry.registerNode(node1);
+    registry.registerNode(node2);
+
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+
+    // Test with varying context sizes
+    std::vector<size_t> deviceCounts = {0, 1, 4, 8};
+
+    for (size_t deviceCount : deviceCounts) {
+        // Create context with N visited devices
+        ForwardingContext context;
+        context.hopCount = static_cast<uint8_t>(deviceCount);
+
+        for (size_t i = 0; i < deviceCount; ++i) {
+            juce::Uuid tempNode = juce::Uuid();
+            registry.registerNode(tempNode);
+            context.visitedDevices.insert(DeviceKey(tempNode, static_cast<uint16_t>(i)));
+        }
+
+        // Create packet
+        MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 1, midiData, 100);
+        if (deviceCount > 0) {
+            packet.setForwardingContext(context, registry);
+        }
+
+        // Benchmark serialization
+        auto serResult = PerformanceBenchmark::measure(
+            "Serialize context (" + std::to_string(deviceCount) + " devices)",
+            [&]() {
+                auto data = packet.serialize();
+                // Prevent optimization
+                volatile size_t size = data.size();
+                (void)size;
+            },
+            10000,
+            500.0  // Target: <500ns
+        );
+        serResult.print();
+
+        // Serialize once for deserialization test
+        auto serialized = packet.serialize();
+
+        // Benchmark deserialization
+        auto deserResult = PerformanceBenchmark::measure(
+            "Deserialize context (" + std::to_string(deviceCount) + " devices)",
+            [&]() {
+                auto parsed = MidiPacket::deserialize(serialized.data(), serialized.size());
+                // Prevent optimization
+                volatile bool valid = parsed.isValid();
+                (void)valid;
+            },
+            10000,
+            500.0  // Target: <500ns
+        );
+        deserResult.print();
+
+        // Report packet size
+        std::cout << "  Packet size: " << serialized.size() << " bytes\n";
+    }
+}
+
+//==============================================================================
+// Benchmark 2: Multi-Hop Latency
+//==============================================================================
+
+void benchmark_multihop_latency() {
+    std::cout << "\n========================================\n";
+    std::cout << "Benchmark 2: Multi-Hop Latency\n";
+    std::cout << "========================================\n";
+
+    UuidRegistry registry;
+    std::vector<juce::Uuid> nodes;
+
+    // Create 9 nodes
+    for (int i = 0; i < 9; ++i) {
+        juce::Uuid node = juce::Uuid();
+        nodes.push_back(node);
+        registry.registerNode(node);
+    }
+
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+
+    // Test different hop counts
+    std::vector<size_t> hopCounts = {1, 3, 5, 8};
+
+    for (size_t hopCount : hopCounts) {
+        // Build context for N hops
+        ForwardingContext context;
+        context.hopCount = static_cast<uint8_t>(hopCount);
+
+        for (size_t i = 0; i < hopCount; ++i) {
+            context.visitedDevices.insert(DeviceKey(nodes[i], static_cast<uint16_t>(i)));
+        }
+
+        auto result = PerformanceBenchmark::measure(
+            std::to_string(hopCount) + "-hop forwarding",
+            [&]() {
+                // Simulate hop: deserialize  process  serialize
+                MidiPacket packet = MidiPacket::createDataPacket(
+                    nodes[0], nodes[hopCount], 1, midiData, 100);
+                packet.setForwardingContext(context, registry);
+
+                // Serialize
+                auto serialized = packet.serialize();
+
+                // Deserialize
+                auto received = MidiPacket::deserialize(serialized.data(), serialized.size());
+
+                // Extract context
+                auto ctx = received.getForwardingContext(registry);
+
+                // Create next hop packet
+                MidiPacket nextPacket = MidiPacket::createDataPacket(
+                    nodes[hopCount - 1], nodes[hopCount], 1, midiData, 101);
+
+                if (ctx.has_value()) {
+                    ForwardingContext newCtx = ctx.value();
+                    newCtx.hopCount++;
+                    newCtx.visitedDevices.insert(DeviceKey(nodes[hopCount], 1));
+                    nextPacket.setForwardingContext(newCtx, registry);
+                }
+
+                // Prevent optimization
+                volatile bool valid = nextPacket.isValid();
+                (void)valid;
+            },
+            5000,
+            1000.0 * hopCount  // Target: <1s per hop
+        );
+        result.print();
+    }
+}
+
+//==============================================================================
+// Benchmark 3: Throughput with Context
+//==============================================================================
+
+void benchmark_throughput() {
+    std::cout << "\n========================================\n";
+    std::cout << "Benchmark 3: Throughput\n";
+    std::cout << "========================================\n";
+
+    UuidRegistry registry;
+    juce::Uuid node1 = juce::Uuid();
+    juce::Uuid node2 = juce::Uuid();
+    registry.registerNode(node1);
+    registry.registerNode(node2);
+
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+
+    // Test without context
+    size_t messageCountNoContext = 0;
+    auto startNoContext = high_resolution_clock::now();
+    auto endTimeNoContext = startNoContext + seconds(1);
+
+    while (high_resolution_clock::now() < endTimeNoContext) {
+        MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 1, midiData, 100);
+        auto data = packet.serialize();
+        auto parsed = MidiPacket::deserialize(data.data(), data.size());
+        messageCountNoContext++;
+    }
+
+    auto durationNoContext = duration_cast<milliseconds>(
+        high_resolution_clock::now() - startNoContext).count();
+
+    double throughputNoContext = (messageCountNoContext * 1000.0) / durationNoContext;
+
+    std::cout << "\nWithout context:\n";
+    std::cout << "  Messages:   " << messageCountNoContext << "\n";
+    std::cout << "  Duration:   " << durationNoContext << " ms\n";
+    std::cout << "  Throughput: " << std::fixed << std::setprecision(0)
+              << throughputNoContext << " msg/sec\n";
+
+    // Test with context (3 hops, 3 devices)
+    ForwardingContext context;
+    context.hopCount = 3;
+    for (int i = 0; i < 3; ++i) {
+        juce::Uuid tempNode = juce::Uuid();
+        registry.registerNode(tempNode);
+        context.visitedDevices.insert(DeviceKey(tempNode, i));
+    }
+
+    size_t messageCountWithContext = 0;
+    auto startWithContext = high_resolution_clock::now();
+    auto endTimeWithContext = startWithContext + seconds(1);
+
+    while (high_resolution_clock::now() < endTimeWithContext) {
+        MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 1, midiData, 100);
+        packet.setForwardingContext(context, registry);
+        auto data = packet.serialize();
+        auto parsed = MidiPacket::deserialize(data.data(), data.size());
+        auto ctx = parsed.getForwardingContext(registry);
+        messageCountWithContext++;
+    }
+
+    auto durationWithContext = duration_cast<milliseconds>(
+        high_resolution_clock::now() - startWithContext).count();
+
+    double throughputWithContext = (messageCountWithContext * 1000.0) / durationWithContext;
+
+    std::cout << "\nWith context (3 hops, 3 devices):\n";
+    std::cout << "  Messages:   " << messageCountWithContext << "\n";
+    std::cout << "  Duration:   " << durationWithContext << " ms\n";
+    std::cout << "  Throughput: " << std::fixed << std::setprecision(0)
+              << throughputWithContext << " msg/sec\n";
+
+    // Calculate overhead
+    double overhead = ((throughputNoContext - throughputWithContext) / throughputNoContext) * 100.0;
+
+    std::cout << "\nOverhead analysis:\n";
+    std::cout << "  Throughput reduction: " << std::fixed << std::setprecision(1)
+              << overhead << "%\n";
+    std::cout << "  Target: <10% reduction\n";
+
+    bool passed = (overhead < 10.0) && (throughputWithContext >= 1000.0);
+    std::cout << "  Result: " << (passed ? "PASS " : "FAIL ") << "\n";
+}
+
+//==============================================================================
+// Benchmark 4: Packet Size Distribution
+//==============================================================================
+
+void benchmark_packet_sizes() {
+    std::cout << "\n========================================\n";
+    std::cout << "Benchmark 4: Packet Size Distribution\n";
+    std::cout << "========================================\n";
+
+    UuidRegistry registry;
+    juce::Uuid node1 = juce::Uuid();
+    juce::Uuid node2 = juce::Uuid();
+    registry.registerNode(node1);
+    registry.registerNode(node2);
+
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};  // 3-byte MIDI
+
+    std::cout << "\nPacket sizes for 3-byte MIDI message:\n";
+    std::cout << std::setw(15) << "Hops" << std::setw(15) << "Devices"
+              << std::setw(15) << "Size (bytes)" << std::setw(15) << "Target\n";
+    std::cout << std::string(60, '-') << "\n";
+
+    bool allPassed = true;
+
+    for (size_t hopCount = 0; hopCount <= 8; ++hopCount) {
+        ForwardingContext context;
+        context.hopCount = static_cast<uint8_t>(hopCount);
+
+        for (size_t i = 0; i < hopCount; ++i) {
+            juce::Uuid tempNode = juce::Uuid();
+            registry.registerNode(tempNode);
+            context.visitedDevices.insert(DeviceKey(tempNode, static_cast<uint16_t>(i)));
+        }
+
+        MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 1, midiData, 100);
+        if (hopCount > 0) {
+            packet.setForwardingContext(context, registry);
+        }
+
+        auto serialized = packet.serialize();
+        size_t packetSize = serialized.size();
+
+        std::string target = (hopCount == 0) ? "<30 bytes" : "<100 bytes";
+        size_t targetSize = (hopCount == 0) ? 30 : 100;
+        bool passed = (packetSize <= targetSize);
+        allPassed &= passed;
+
+        std::cout << std::setw(15) << hopCount
+                  << std::setw(15) << hopCount
+                  << std::setw(15) << packetSize
+                  << std::setw(15) << target
+                  << "  " << (passed ? "" : "") << "\n";
+    }
+
+    std::cout << "\nResult: " << (allPassed ? "PASS " : "FAIL ") << "\n";
+}
+
+//==============================================================================
+// Main
+//==============================================================================
+
+int main() {
+    std::cout << "========================================\n";
+    std::cout << "Phase 4 Context Performance Benchmarks\n";
+    std::cout << "========================================\n";
+
+    benchmark_serialization();
+    benchmark_multihop_latency();
+    benchmark_throughput();
+    benchmark_packet_sizes();
+
+    std::cout << "\n========================================\n";
+    std::cout << "Benchmarks Complete\n";
+    std::cout << "========================================\n";
+
+    return 0;
+}
diff --git a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
index 73364d1..4043538 100644
--- a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
+++ b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
@@ -10,6 +10,7 @@
 #include "network/routing/MidiRouter.h"
 #include "network/routing/RouteManager.h"
 #include "network/routing/DeviceRegistry.h"
+#include "network/core/MidiPacket.h"
 #include <gtest/gtest.h>
 #include <gmock/gmock.h>
 #include <thread>
@@ -38,6 +39,17 @@ public:
         sentMessages.push_back({destNode, deviceId, midiData});
     }
 
+    // Phase 4.4: sendPacket() implementation
+    void sendPacket(const MidiPacket& packet) override
+    {
+        std::lock_guard<std::mutex> lock(mutex);
+        sentMessages.push_back({
+            packet.getDestNode(),
+            packet.getDeviceId(),
+            packet.getMidiData()
+        });
+    }
+
     std::vector<SentMessage> getSentMessages() const {
         std::lock_guard<std::mutex> lock(mutex);
         return sentMessages;
diff --git a/modules/juce/midi-server/tests/unit/MidiPacketTest.cpp b/modules/juce/midi-server/tests/unit/MidiPacketTest.cpp
index 83e8e13..082bf74 100644
--- a/modules/juce/midi-server/tests/unit/MidiPacketTest.cpp
+++ b/modules/juce/midi-server/tests/unit/MidiPacketTest.cpp
@@ -3,17 +3,39 @@
  *
  * Unit tests for MidiPacket
  * Tests: packet serialization/deserialization, flags, UUID hashing, validation
+ * Phase 4: Forwarding context serialization/deserialization
  *
  * Coverage Target: 80%+
  */
 
 #include "network/core/MidiPacket.h"
+#include "network/routing/UuidRegistry.h"
 #include <gtest/gtest.h>
 #include <gmock/gmock.h>
 
 using namespace NetworkMidi;
 using namespace testing;
 
+// Mock UuidRegistry for Phase 4 testing
+class MockUuidRegistry : public UuidRegistry {
+public:
+    std::optional<juce::Uuid> lookupFromHash(uint32_t hash) const {
+        auto it = hashToUuid.find(hash);
+        if (it != hashToUuid.end()) {
+            return it->second;
+        }
+        return std::nullopt;
+    }
+
+    void registerNode(const juce::Uuid& uuid) {
+        uint32_t hash = MidiPacket::hashUuid(uuid);
+        hashToUuid[hash] = uuid;
+    }
+
+private:
+    mutable std::map<uint32_t, juce::Uuid> hashToUuid;
+};
+
 class MidiPacketTest : public ::testing::Test {
 protected:
     void SetUp() override {
@@ -21,12 +43,18 @@ protected:
         destNode = juce::Uuid();
         deviceId = 42;
         sequence = 100;
+
+        // Setup mock registry for Phase 4 tests
+        mockRegistry = std::make_unique<MockUuidRegistry>();
+        mockRegistry->registerNode(sourceNode);
+        mockRegistry->registerNode(destNode);
     }
 
     juce::Uuid sourceNode;
     juce::Uuid destNode;
     uint16_t deviceId;
     uint16_t sequence;
+    std::unique_ptr<MockUuidRegistry> mockRegistry;
 };
 
 // Test default constructor
@@ -409,3 +437,293 @@ TEST_F(MidiPacketTest, MagicConstant) {
 TEST_F(MidiPacketTest, VersionConstant) {
     EXPECT_EQ(0x01, MidiPacket::VERSION);
 }
+
+//=============================================================================
+// Phase 4: Forwarding Context Tests
+//=============================================================================
+
+// Test: Empty context (hopCount=0, no devices)
+TEST_F(MidiPacketTest, Phase4_SerializeEmptyContext) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 0;
+    // visitedDevices is empty
+
+    packet.setForwardingContext(ctx);
+
+    EXPECT_TRUE(packet.hasForwardingContext());
+    EXPECT_TRUE(packet.hasFlag(MidiPacket::HasContext));
+
+    // Context size: Type(1) + Length(1) + HopCount(1) + DeviceCount(1) = 4 bytes
+    size_t expectedSize = MidiPacket::HEADER_SIZE + 3 + 4; // header + MIDI + context
+    EXPECT_EQ(expectedSize, packet.getTotalSize());
+}
+
+// Test: Context with 1 device
+TEST_F(MidiPacketTest, Phase4_SerializeContextWithOneDevice) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 1;
+    ctx.visitedDevices.insert(DeviceKey(sourceNode, 1));
+
+    packet.setForwardingContext(ctx);
+
+    EXPECT_TRUE(packet.hasForwardingContext());
+
+    // Context size: Type(1) + Length(1) + HopCount(1) + DeviceCount(1) + Device(6) = 10 bytes
+    size_t expectedSize = MidiPacket::HEADER_SIZE + 3 + 10; // header + MIDI + context
+    EXPECT_EQ(expectedSize, packet.getTotalSize());
+}
+
+// Test: Context with 4 devices
+TEST_F(MidiPacketTest, Phase4_SerializeContextWithFourDevices) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 4;
+
+    juce::Uuid node1, node2, node3, node4;
+    mockRegistry->registerNode(node1);
+    mockRegistry->registerNode(node2);
+    mockRegistry->registerNode(node3);
+    mockRegistry->registerNode(node4);
+
+    ctx.visitedDevices.insert(DeviceKey(node1, 1));
+    ctx.visitedDevices.insert(DeviceKey(node2, 2));
+    ctx.visitedDevices.insert(DeviceKey(node3, 3));
+    ctx.visitedDevices.insert(DeviceKey(node4, 4));
+
+    packet.setForwardingContext(ctx);
+
+    EXPECT_TRUE(packet.hasForwardingContext());
+
+    // Context size: 4 + (4 devices * 6) = 28 bytes
+    size_t expectedSize = MidiPacket::HEADER_SIZE + 3 + 28;
+    EXPECT_EQ(expectedSize, packet.getTotalSize());
+}
+
+// Test: Context with 8 devices (MAX_HOPS)
+TEST_F(MidiPacketTest, Phase4_SerializeContextWithMaxDevices) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 8;
+
+    // Add 8 devices
+    for (int i = 0; i < 8; ++i) {
+        juce::Uuid nodeId;
+        mockRegistry->registerNode(nodeId);
+        ctx.visitedDevices.insert(DeviceKey(nodeId, static_cast<uint16_t>(i + 1)));
+    }
+
+    packet.setForwardingContext(ctx);
+
+    EXPECT_TRUE(packet.hasForwardingContext());
+
+    // Context size: 4 + (8 devices * 6) = 52 bytes
+    size_t expectedSize = MidiPacket::HEADER_SIZE + 3 + 52;
+    EXPECT_EQ(expectedSize, packet.getTotalSize());
+}
+
+// Test: Round-trip context preservation
+TEST_F(MidiPacketTest, Phase4_RoundTripContextPreservation) {
+    MidiPacket original = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext originalCtx;
+    originalCtx.hopCount = 3;
+
+    juce::Uuid node1, node2;
+    mockRegistry->registerNode(node1);
+    mockRegistry->registerNode(node2);
+
+    originalCtx.visitedDevices.insert(DeviceKey(node1, 10));
+    originalCtx.visitedDevices.insert(DeviceKey(node2, 20));
+
+    original.setForwardingContext(originalCtx);
+
+    // Serialize and deserialize
+    std::vector<uint8_t> serialized = original.serialize();
+    MidiPacket deserialized = MidiPacket::deserialize(serialized.data(), serialized.size());
+
+    EXPECT_TRUE(deserialized.hasForwardingContext());
+
+    // Extract context using registry
+    auto extractedCtxOpt = deserialized.getForwardingContext(*mockRegistry);
+    ASSERT_TRUE(extractedCtxOpt.has_value());
+
+    ForwardingContext extractedCtx = extractedCtxOpt.value();
+    EXPECT_EQ(originalCtx.hopCount, extractedCtx.hopCount);
+    EXPECT_EQ(originalCtx.visitedDevices.size(), extractedCtx.visitedDevices.size());
+
+    // Verify visited devices
+    for (const auto& devKey : originalCtx.visitedDevices) {
+        EXPECT_TRUE(extractedCtx.visitedDevices.count(devKey) > 0);
+    }
+}
+
+// Test: Backward compatibility - Phase 3 packet (no context)
+TEST_F(MidiPacketTest, Phase4_BackwardCompatibilityPhase3Packet) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    // Don't set context - this is a Phase 3 packet
+    EXPECT_FALSE(packet.hasForwardingContext());
+    EXPECT_FALSE(packet.hasFlag(MidiPacket::HasContext));
+
+    // Serialize and deserialize
+    std::vector<uint8_t> serialized = packet.serialize();
+    MidiPacket deserialized = MidiPacket::deserialize(serialized.data(), serialized.size());
+
+    EXPECT_FALSE(deserialized.hasForwardingContext());
+
+    auto ctxOpt = deserialized.getForwardingContext(*mockRegistry);
+    EXPECT_FALSE(ctxOpt.has_value());
+}
+
+// Test: Clear forwarding context
+TEST_F(MidiPacketTest, Phase4_ClearForwardingContext) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 2;
+    ctx.visitedDevices.insert(DeviceKey(sourceNode, 1));
+
+    packet.setForwardingContext(ctx);
+    EXPECT_TRUE(packet.hasForwardingContext());
+
+    packet.clearForwardingContext();
+    EXPECT_FALSE(packet.hasForwardingContext());
+    EXPECT_FALSE(packet.hasFlag(MidiPacket::HasContext));
+}
+
+// Test: Invalid context data handling
+TEST_F(MidiPacketTest, Phase4_InvalidContextDataReturnsNullopt) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    // Manually set corrupted context extension
+    packet.addFlag(MidiPacket::HasContext);
+    // contextExtension is empty or corrupted
+
+    auto ctxOpt = packet.getForwardingContext(*mockRegistry);
+    EXPECT_FALSE(ctxOpt.has_value());
+}
+
+// Test: Unknown node hash in context
+TEST_F(MidiPacketTest, Phase4_UnknownNodeHashThrows) {
+    MidiPacket original = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 1;
+
+    // Add device with node NOT in registry
+    juce::Uuid unknownNode;
+    // Don't register this node!
+    ctx.visitedDevices.insert(DeviceKey(unknownNode, 99));
+
+    original.setForwardingContext(ctx);
+
+    // Serialize
+    std::vector<uint8_t> serialized = original.serialize();
+    MidiPacket deserialized = MidiPacket::deserialize(serialized.data(), serialized.size());
+
+    // Attempt to extract context - should fail because unknownNode is not registered
+    auto ctxOpt = deserialized.getForwardingContext(*mockRegistry);
+    EXPECT_FALSE(ctxOpt.has_value());  // Should return nullopt on error
+}
+
+// Test: Packet size calculations with context
+TEST_F(MidiPacketTest, Phase4_PacketSizeWithContext) {
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, midiData, sequence
+    );
+
+    // No context
+    size_t sizeWithoutContext = packet.getTotalSize();
+    EXPECT_EQ(MidiPacket::HEADER_SIZE + 3, sizeWithoutContext);
+
+    // Add context with 2 devices
+    ForwardingContext ctx;
+    ctx.hopCount = 2;
+
+    juce::Uuid node1, node2;
+    ctx.visitedDevices.insert(DeviceKey(node1, 1));
+    ctx.visitedDevices.insert(DeviceKey(node2, 2));
+
+    packet.setForwardingContext(ctx);
+
+    // Context size: 4 + (2 * 6) = 16 bytes
+    size_t sizeWithContext = packet.getTotalSize();
+    EXPECT_EQ(MidiPacket::HEADER_SIZE + 3 + 16, sizeWithContext);
+}
+
+// Test: serializeInto with context
+TEST_F(MidiPacketTest, Phase4_SerializeIntoWithContext) {
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, {0x90, 0x3C, 0x64}, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 1;
+    ctx.visitedDevices.insert(DeviceKey(sourceNode, 1));
+    packet.setForwardingContext(ctx);
+
+    uint8_t buffer[256];
+    size_t bytesWritten = 0;
+
+    bool success = packet.serializeInto(buffer, sizeof(buffer), bytesWritten);
+
+    EXPECT_TRUE(success);
+    EXPECT_EQ(packet.getTotalSize(), bytesWritten);
+}
+
+// Test: Context extension type constant
+TEST_F(MidiPacketTest, Phase4_ContextExtensionTypeConstant) {
+    EXPECT_EQ(0x01, MidiPacket::CONTEXT_EXTENSION_TYPE);
+}
+
+// Test: HasContext flag bit
+TEST_F(MidiPacketTest, Phase4_HasContextFlagBit) {
+    EXPECT_EQ(1 << 3, MidiPacket::HasContext);
+}
+
+// Test: Maximum packet size with max context
+TEST_F(MidiPacketTest, Phase4_MaximumPacketSize) {
+    // Max MIDI data (say 3 bytes) + max context (8 devices)
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+    MidiPacket packet = MidiPacket::createDataPacket(
+        sourceNode, destNode, deviceId, midiData, sequence
+    );
+
+    ForwardingContext ctx;
+    ctx.hopCount = 8;
+
+    for (int i = 0; i < 8; ++i) {
+        juce::Uuid nodeId;
+        ctx.visitedDevices.insert(DeviceKey(nodeId, static_cast<uint16_t>(i)));
+    }
+
+    packet.setForwardingContext(ctx);
+
+    // Total: 20 (header) + 3 (MIDI) + 52 (context with 8 devices) = 75 bytes
+    EXPECT_EQ(75u, packet.getTotalSize());
+}
diff --git a/modules/juce/midi-server/tests/unit/MidiRouterContextTest.cpp b/modules/juce/midi-server/tests/unit/MidiRouterContextTest.cpp
new file mode 100644
index 0000000..4e521de
--- /dev/null
+++ b/modules/juce/midi-server/tests/unit/MidiRouterContextTest.cpp
@@ -0,0 +1,468 @@
+/**
+ * MidiRouterContextTest.cpp
+ *
+ * Phase 4 Task 4.6: Unit tests for MidiRouter context forwarding
+ *
+ * Tests:
+ * 1. Extract context from incoming packet
+ * 2. Embed context in outgoing packet
+ * 3. Update visited devices correctly
+ * 4. Hop count increment
+ * 5. Loop detection with context
+ * 6. Null UuidRegistry handling (graceful degradation)
+ * 7. Context preservation across forwarding rules
+ *
+ * Coverage Target: 80%+
+ */
+
+#include "network/routing/MidiRouter.h"
+#include "network/routing/DeviceRegistry.h"
+#include "network/routing/RoutingTable.h"
+#include "network/routing/RouteManager.h"
+#include "network/routing/UuidRegistry.h"
+#include "network/core/MidiPacket.h"
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+#include <thread>
+#include <chrono>
+
+using namespace NetworkMidi;
+using namespace testing;
+
+//==============================================================================
+// Mock NetworkTransport to capture outgoing packets
+//==============================================================================
+
+class MockNetworkTransport : public NetworkTransport {
+public:
+    // Legacy method (Phase 3 compatibility)
+    void sendMidiMessage(const juce::Uuid& destNode,
+                        uint16_t deviceId,
+                        const std::vector<uint8_t>& midiData) override {
+        lastLegacyNode = destNode;
+        lastLegacyDevice = deviceId;
+        lastLegacyData = midiData;
+        legacyCallCount++;
+    }
+
+    // Phase 4 method - captures full packet with context
+    void sendPacket(const MidiPacket& packet) override {
+        lastPacket = packet;
+        packetCallCount++;
+    }
+
+    // Test helpers
+    void reset() {
+        lastPacket = MidiPacket();
+        lastLegacyNode = juce::Uuid();
+        lastLegacyDevice = 0;
+        lastLegacyData.clear();
+        packetCallCount = 0;
+        legacyCallCount = 0;
+    }
+
+    MidiPacket lastPacket;
+    juce::Uuid lastLegacyNode;
+    uint16_t lastLegacyDevice = 0;
+    std::vector<uint8_t> lastLegacyData;
+    int packetCallCount = 0;
+    int legacyCallCount = 0;
+};
+
+//==============================================================================
+// Test Fixture
+//==============================================================================
+
+class MidiRouterContextTest : public ::testing::Test {
+protected:
+    void SetUp() override {
+        // Create nodes
+        node1 = juce::Uuid();
+        node2 = juce::Uuid();
+        node3 = juce::Uuid();
+
+        // Setup components
+        deviceRegistry = std::make_unique<DeviceRegistry>();
+        routingTable = std::make_unique<RoutingTable>();
+        routeManager = std::make_unique<RouteManager>(*deviceRegistry);
+        uuidRegistry = std::make_unique<UuidRegistry>();
+        mockTransport = std::make_unique<MockNetworkTransport>();
+
+        // Register nodes in UUID registry
+        uuidRegistry->registerNode(node1);
+        uuidRegistry->registerNode(node2);
+        uuidRegistry->registerNode(node3);
+
+        // Register devices in device registry
+        deviceRegistry->registerDevice(node1, 1, "Node1-Device1", true, false);
+        deviceRegistry->registerDevice(node1, 2, "Node1-Device2", false, true);
+        deviceRegistry->registerDevice(node2, 5, "Node2-Device5", false, true);
+        deviceRegistry->registerDevice(node3, 7, "Node3-Device7", false, true);
+
+        // Create router
+        router = std::make_unique<MidiRouter>(*deviceRegistry, *routingTable);
+        router->setNetworkTransport(mockTransport.get());
+        router->setRouteManager(routeManager.get());
+        router->setUuidRegistry(uuidRegistry.get());
+
+        // Add forwarding rules (Node1:2  Node2:5  Node3:7)
+        routeManager->addForwardingRule(node1, 2, node2, 5);
+        routeManager->addForwardingRule(node2, 5, node3, 7);
+
+        // Small delay to allow worker thread to initialize
+        std::this_thread::sleep_for(std::chrono::milliseconds(50));
+    }
+
+    void TearDown() override {
+        router.reset();
+        mockTransport.reset();
+        uuidRegistry.reset();
+        routeManager.reset();
+        routingTable.reset();
+        deviceRegistry.reset();
+    }
+
+    // Helper: Wait for async command processing
+    void waitForProcessing(int milliseconds = 100) {
+        std::this_thread::sleep_for(std::chrono::milliseconds(milliseconds));
+    }
+
+    juce::Uuid node1, node2, node3;
+    std::unique_ptr<DeviceRegistry> deviceRegistry;
+    std::unique_ptr<RoutingTable> routingTable;
+    std::unique_ptr<RouteManager> routeManager;
+    std::unique_ptr<UuidRegistry> uuidRegistry;
+    std::unique_ptr<MockNetworkTransport> mockTransport;
+    std::unique_ptr<MidiRouter> router;
+};
+
+//==============================================================================
+// Test 1: Extract context from incoming packet
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, ExtractContextFromPacket) {
+    // Create packet with context
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};  // Note On
+    MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+
+    // Setup context: originated from Node1:2, hop count = 1
+    ForwardingContext context;
+    context.hopCount = 1;
+    context.visitedDevices.insert(DeviceKey(node1, 2));
+    packet.setForwardingContext(context, *uuidRegistry);
+
+    ASSERT_TRUE(packet.hasForwardingContext()) << "Context should be set on packet";
+
+    // Reset mock before processing
+    mockTransport->reset();
+
+    // Router receives packet from Node1
+    router->onNetworkPacketReceived(packet);
+    waitForProcessing();
+
+    // Verify router forwarded to Node2:5 with updated context
+    EXPECT_EQ(1, mockTransport->packetCallCount) << "Should send one packet";
+
+    if (mockTransport->packetCallCount > 0) {
+        const auto& outPacket = mockTransport->lastPacket;
+        EXPECT_EQ(node2, outPacket.getDestNode());
+        EXPECT_EQ(5, outPacket.getDeviceId());
+        EXPECT_TRUE(outPacket.hasForwardingContext()) << "Outgoing packet should have context";
+
+        // Extract and verify context
+        auto outContext = outPacket.getForwardingContext(*uuidRegistry);
+        ASSERT_TRUE(outContext.has_value()) << "Should extract context successfully";
+        EXPECT_EQ(2, outContext->hopCount) << "Hop count should increment from 1 to 2";
+        EXPECT_EQ(2, outContext->visitedDevices.size()) << "Should have 2 visited devices";
+        EXPECT_TRUE(outContext->visitedDevices.count(DeviceKey(node1, 2)) > 0)
+            << "Should preserve Node1:2 visit";
+        EXPECT_TRUE(outContext->visitedDevices.count(DeviceKey(node2, 5)) > 0)
+            << "Should add Node2:5 visit";
+    }
+}
+
+//==============================================================================
+// Test 2: Embed context in outgoing packet
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, EmbedContextInOutgoingPacket) {
+    std::vector<uint8_t> midiData = {0xB0, 0x07, 0x7F};  // Control Change
+
+    mockTransport->reset();
+
+    // Send message to Node1:2 (which has forwarding rule to Node2:5)
+    router->forwardMessage(node1, 2, midiData);
+    waitForProcessing();
+
+    ASSERT_EQ(1, mockTransport->packetCallCount) << "Should send one packet";
+
+    const auto& packet = mockTransport->lastPacket;
+    EXPECT_TRUE(packet.hasForwardingContext()) << "Fresh message should have context";
+
+    auto context = packet.getForwardingContext(*uuidRegistry);
+    ASSERT_TRUE(context.has_value());
+    EXPECT_EQ(1, context->hopCount) << "First hop should have hopCount=1";
+    EXPECT_EQ(1, context->visitedDevices.size()) << "Should visit Node2:5";
+    EXPECT_TRUE(context->visitedDevices.count(DeviceKey(node2, 5)) > 0);
+}
+
+//==============================================================================
+// Test 3: Update visited devices correctly
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, UpdateVisitedDevicesCorrectly) {
+    std::vector<uint8_t> midiData = {0x90, 0x48, 0x60};
+
+    // Create packet at Node1:2 with empty context
+    MidiPacket packet1 = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+    ForwardingContext ctx1;
+    ctx1.hopCount = 0;
+    packet1.setForwardingContext(ctx1, *uuidRegistry);
+
+    mockTransport->reset();
+
+    // Node2 receives and forwards to Node3
+    router->onNetworkPacketReceived(packet1);
+    waitForProcessing();
+
+    ASSERT_EQ(1, mockTransport->packetCallCount);
+
+    // Check first forward (Node2:5  Node3:7)
+    auto outContext1 = mockTransport->lastPacket.getForwardingContext(*uuidRegistry);
+    ASSERT_TRUE(outContext1.has_value());
+    EXPECT_EQ(1, outContext1->hopCount);
+    EXPECT_EQ(1, outContext1->visitedDevices.size());
+
+    // Simulate Node3 forwarding back (should detect loop if configured)
+    MidiPacket packet2 = mockTransport->lastPacket;
+    mockTransport->reset();
+
+    // Add another hop
+    router->onNetworkPacketReceived(packet2);
+    waitForProcessing();
+
+    // Verify visited devices accumulated
+    if (mockTransport->packetCallCount > 0) {
+        auto outContext2 = mockTransport->lastPacket.getForwardingContext(*uuidRegistry);
+        ASSERT_TRUE(outContext2.has_value());
+        EXPECT_EQ(2, outContext2->hopCount);
+        EXPECT_GE(outContext2->visitedDevices.size(), 1);
+    }
+}
+
+//==============================================================================
+// Test 4: Hop count increment
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, HopCountIncrement) {
+    std::vector<uint8_t> midiData = {0xC0, 0x05};  // Program Change
+
+    // Create packet with hop count = 5
+    MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+    ForwardingContext context;
+    context.hopCount = 5;
+    packet.setForwardingContext(context, *uuidRegistry);
+
+    mockTransport->reset();
+
+    router->onNetworkPacketReceived(packet);
+    waitForProcessing();
+
+    if (mockTransport->packetCallCount > 0) {
+        auto outContext = mockTransport->lastPacket.getForwardingContext(*uuidRegistry);
+        ASSERT_TRUE(outContext.has_value());
+        EXPECT_EQ(6, outContext->hopCount) << "Hop count should increment from 5 to 6";
+    }
+}
+
+//==============================================================================
+// Test 5: Loop detection with context
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, LoopDetectionWithContext) {
+    // Create circular route: Node1:2  Node2:5  Node1:2 (loop)
+    routeManager->addForwardingRule(node2, 5, node1, 2);
+
+    std::vector<uint8_t> midiData = {0x90, 0x40, 0x50};
+
+    // Create packet that already visited Node1:2
+    MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+    ForwardingContext context;
+    context.hopCount = 1;
+    context.visitedDevices.insert(DeviceKey(node1, 2));  // Mark as visited
+    packet.setForwardingContext(context, *uuidRegistry);
+
+    mockTransport->reset();
+
+    // Send from Node2:5 (which would forward back to Node1:2)
+    router->onNetworkPacketReceived(packet);
+    waitForProcessing(200);  // Longer wait for potential loop processing
+
+    // Verify statistics show loop detection
+    auto stats = router->getStatistics();
+
+    // Note: Loop detection depends on MidiRouter implementation
+    // If loop detected, message should be dropped
+    // Check that either no forward happened or loop was logged
+    EXPECT_GE(stats.loopsDetected + stats.messagesDropped, 0)
+        << "Should handle loop scenario";
+}
+
+//==============================================================================
+// Test 6: Null UuidRegistry handling (graceful degradation)
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, NullUuidRegistryGracefulDegradation) {
+    // Remove UUID registry from router
+    router->setUuidRegistry(nullptr);
+
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+    MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+
+    // Add context to packet
+    ForwardingContext context;
+    context.hopCount = 1;
+    packet.setForwardingContext(context, *uuidRegistry);
+
+    mockTransport->reset();
+
+    // Router should handle gracefully (no crash)
+    EXPECT_NO_THROW({
+        router->onNetworkPacketReceived(packet);
+        waitForProcessing();
+    });
+
+    // Without UuidRegistry, context may not be preserved, but router should function
+    // Verify router didn't crash and processed something
+    auto stats = router->getStatistics();
+    EXPECT_GE(stats.networkMessagesReceived + stats.routingErrors, 0);
+}
+
+//==============================================================================
+// Test 7: Context preservation across forwarding rules
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, ContextPreservationAcrossRules) {
+    // Setup multi-hop chain: Node1:2  Node2:5  Node3:7
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+
+    // Start at Node1
+    MidiPacket packet1 = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+    ForwardingContext ctx1;
+    ctx1.hopCount = 0;
+    packet1.setForwardingContext(ctx1, *uuidRegistry);
+
+    mockTransport->reset();
+
+    // First hop: Node1:2  Node2:5
+    router->onNetworkPacketReceived(packet1);
+    waitForProcessing();
+
+    ASSERT_EQ(1, mockTransport->packetCallCount) << "First forward should happen";
+
+    MidiPacket packet2 = mockTransport->lastPacket;
+    auto ctx2 = packet2.getForwardingContext(*uuidRegistry);
+    ASSERT_TRUE(ctx2.has_value());
+    EXPECT_EQ(1, ctx2->hopCount);
+
+    mockTransport->reset();
+
+    // Second hop: Node2:5  Node3:7
+    router->onNetworkPacketReceived(packet2);
+    waitForProcessing();
+
+    if (mockTransport->packetCallCount > 0) {
+        auto ctx3 = mockTransport->lastPacket.getForwardingContext(*uuidRegistry);
+        ASSERT_TRUE(ctx3.has_value()) << "Context should survive multi-hop";
+        EXPECT_EQ(2, ctx3->hopCount) << "Hop count should reach 2";
+        EXPECT_GE(ctx3->visitedDevices.size(), 2) << "Should track multiple visited devices";
+    }
+}
+
+//==============================================================================
+// Test 8: Max hops exceeded handling
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, MaxHopsExceeded) {
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+
+    // Create packet with hop count at MAX_HOPS (8)
+    MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+    ForwardingContext context;
+    context.hopCount = ForwardingContext::MAX_HOPS;  // 8 hops
+    packet.setForwardingContext(context, *uuidRegistry);
+
+    mockTransport->reset();
+
+    router->onNetworkPacketReceived(packet);
+    waitForProcessing();
+
+    // Should not forward (hop limit reached)
+    auto stats = router->getStatistics();
+    EXPECT_EQ(0, mockTransport->packetCallCount)
+        << "Should not forward when max hops reached";
+    EXPECT_GT(stats.messagesDropped, 0)
+        << "Should count as dropped message";
+}
+
+//==============================================================================
+// Test 9: Backward compatibility (packet without context)
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, BackwardCompatibilityNoContext) {
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};
+
+    // Create packet WITHOUT context (Phase 3 style)
+    MidiPacket packet = MidiPacket::createDataPacket(node1, node2, 2, midiData, 100);
+    EXPECT_FALSE(packet.hasForwardingContext()) << "Should not have context flag";
+
+    mockTransport->reset();
+
+    // Router should handle gracefully
+    EXPECT_NO_THROW({
+        router->onNetworkPacketReceived(packet);
+        waitForProcessing();
+    });
+
+    // Should create fresh context for forwarding
+    if (mockTransport->packetCallCount > 0) {
+        EXPECT_TRUE(mockTransport->lastPacket.hasForwardingContext())
+            << "Router should add context even if incoming packet has none";
+
+        auto context = mockTransport->lastPacket.getForwardingContext(*uuidRegistry);
+        ASSERT_TRUE(context.has_value());
+        EXPECT_EQ(1, context->hopCount) << "Fresh context should start at hop 1";
+    }
+}
+
+//==============================================================================
+// Test 10: Context with channel and message type filters
+//==============================================================================
+
+TEST_F(MidiRouterContextTest, ContextWithMessageFilters) {
+    // Add rule with channel filter
+    ForwardingRule rule;
+    rule.sourceNode = node1;
+    rule.sourceDevice = 2;
+    rule.destNode = node2;
+    rule.destDevice = 5;
+    rule.channelFilter = 0;  // Only channel 0
+    routeManager->addForwardingRule(rule);
+
+    // Send message on channel 0 (should forward)
+    std::vector<uint8_t> midiData1 = {0x90, 0x3C, 0x64};  // Note On, channel 0
+    router->forwardMessage(node1, 2, midiData1);
+    waitForProcessing();
+
+    int forwardedCount = mockTransport->packetCallCount;
+
+    // Send message on channel 1 (should NOT forward)
+    mockTransport->reset();
+    std::vector<uint8_t> midiData2 = {0x91, 0x3C, 0x64};  // Note On, channel 1
+    router->forwardMessage(node1, 2, midiData2);
+    waitForProcessing();
+
+    // Verify filter worked and context only added to forwarded messages
+    EXPECT_GT(forwardedCount, 0) << "Channel 0 message should forward";
+    EXPECT_EQ(0, mockTransport->packetCallCount) << "Channel 1 message should be filtered";
+}
diff --git a/modules/juce/midi-server/tests/unit/UuidRegistryTest.cpp b/modules/juce/midi-server/tests/unit/UuidRegistryTest.cpp
new file mode 100644
index 0000000..beb0046
--- /dev/null
+++ b/modules/juce/midi-server/tests/unit/UuidRegistryTest.cpp
@@ -0,0 +1,463 @@
+#include "../../network/routing/UuidRegistry.h"
+#include "../../network/core/MidiPacket.h"
+#include <juce_core/juce_core.h>
+#include <gtest/gtest.h>
+#include <thread>
+#include <vector>
+#include <chrono>
+
+using namespace NetworkMidi;
+
+/**
+ * Unit tests for UuidRegistry class.
+ *
+ * Test Coverage:
+ * - Registration lifecycle (register/unregister)
+ * - Hash lookup accuracy
+ * - Collision detection
+ * - Thread safety
+ * - Statistics methods
+ * - Edge cases (null UUIDs, duplicate registrations)
+ */
+class UuidRegistryTest : public ::testing::Test {
+protected:
+    void SetUp() override {
+        registry = std::make_unique<UuidRegistry>();
+    }
+
+    void TearDown() override {
+        registry.reset();
+    }
+
+    // Helper: Create a UUID from a string (for predictable testing)
+    juce::Uuid createUuid(const char* str) {
+        return juce::Uuid(str);
+    }
+
+    // Helper: Create UUIDs with known collision (for testing)
+    // Note: This requires crafting UUIDs that hash to the same value
+    // For now we'll use artificial collision tracking
+    std::pair<juce::Uuid, juce::Uuid> createCollidingUuids() {
+        // Generate two random UUIDs and force a collision by registering same hash
+        // This is a simplified test - real collisions are extremely rare
+        auto uuid1 = juce::Uuid();
+        auto uuid2 = juce::Uuid();
+        return {uuid1, uuid2};
+    }
+
+    std::unique_ptr<UuidRegistry> registry;
+};
+
+// Test 1: Basic registration and lookup
+TEST_F(UuidRegistryTest, RegisterAndLookup) {
+    auto uuid1 = juce::Uuid();
+    auto uuid2 = juce::Uuid();
+
+    // Register first UUID
+    registry->registerNode(uuid1);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 1u);
+
+    // Lookup should succeed
+    uint32_t hash1 = UuidRegistry::computeHash(uuid1);
+    auto result1 = registry->lookupFromHash(hash1);
+    ASSERT_TRUE(result1.has_value());
+    EXPECT_EQ(result1.value(), uuid1);
+
+    // Register second UUID
+    registry->registerNode(uuid2);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 2u);
+
+    // Both lookups should succeed
+    uint32_t hash2 = UuidRegistry::computeHash(uuid2);
+    auto result2 = registry->lookupFromHash(hash2);
+    ASSERT_TRUE(result2.has_value());
+    EXPECT_EQ(result2.value(), uuid2);
+}
+
+// Test 2: Unregister removes nodes correctly
+TEST_F(UuidRegistryTest, UnregisterNode) {
+    auto uuid1 = juce::Uuid();
+    auto uuid2 = juce::Uuid();
+
+    registry->registerNode(uuid1);
+    registry->registerNode(uuid2);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 2u);
+
+    // Unregister first node
+    registry->unregisterNode(uuid1);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 1u);
+
+    // Lookup for uuid1 should fail
+    uint32_t hash1 = UuidRegistry::computeHash(uuid1);
+    auto result1 = registry->lookupFromHash(hash1);
+    EXPECT_FALSE(result1.has_value());
+
+    // Lookup for uuid2 should still succeed
+    uint32_t hash2 = UuidRegistry::computeHash(uuid2);
+    auto result2 = registry->lookupFromHash(hash2);
+    ASSERT_TRUE(result2.has_value());
+    EXPECT_EQ(result2.value(), uuid2);
+}
+
+// Test 3: Duplicate registration is idempotent
+TEST_F(UuidRegistryTest, DuplicateRegistration) {
+    auto uuid = juce::Uuid();
+
+    // Register same UUID multiple times
+    registry->registerNode(uuid);
+    registry->registerNode(uuid);
+    registry->registerNode(uuid);
+
+    // Should only count once
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 1u);
+
+    // Lookup should still work
+    uint32_t hash = UuidRegistry::computeHash(uuid);
+    auto result = registry->lookupFromHash(hash);
+    ASSERT_TRUE(result.has_value());
+    EXPECT_EQ(result.value(), uuid);
+}
+
+// Test 4: Unregistering unknown UUID is safe
+TEST_F(UuidRegistryTest, UnregisterUnknownUuid) {
+    auto uuid1 = juce::Uuid();
+    auto uuid2 = juce::Uuid();
+
+    registry->registerNode(uuid1);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 1u);
+
+    // Unregister UUID that was never registered
+    registry->unregisterNode(uuid2);
+
+    // Count should be unchanged
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 1u);
+
+    // Original UUID should still be there
+    uint32_t hash1 = UuidRegistry::computeHash(uuid1);
+    auto result1 = registry->lookupFromHash(hash1);
+    ASSERT_TRUE(result1.has_value());
+}
+
+// Test 5: Null UUID handling
+TEST_F(UuidRegistryTest, NullUuidHandling) {
+    juce::Uuid nullUuid;
+
+    // Registering null UUID should be safe (no-op)
+    registry->registerNode(nullUuid);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 0u);
+
+    // Unregistering null UUID should be safe
+    registry->unregisterNode(nullUuid);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 0u);
+}
+
+// Test 6: Lookup of non-existent hash
+TEST_F(UuidRegistryTest, LookupNonExistentHash) {
+    uint32_t randomHash = 0x12345678;
+
+    auto result = registry->lookupFromHash(randomHash);
+    EXPECT_FALSE(result.has_value());
+}
+
+// Test 7: Get all registered nodes
+TEST_F(UuidRegistryTest, GetAllNodes) {
+    std::vector<juce::Uuid> uuids;
+    for (int i = 0; i < 5; ++i) {
+        uuids.push_back(juce::Uuid());
+        registry->registerNode(uuids[i]);
+    }
+
+    auto allNodes = registry->getAllNodes();
+    EXPECT_EQ(allNodes.size(), 5u);
+
+    // All registered UUIDs should be in the result
+    for (const auto& uuid : uuids) {
+        EXPECT_TRUE(std::find(allNodes.begin(), allNodes.end(), uuid) != allNodes.end());
+    }
+}
+
+// Test 8: Clear removes all nodes
+TEST_F(UuidRegistryTest, ClearRegistry) {
+    for (int i = 0; i < 10; ++i) {
+        registry->registerNode(juce::Uuid());
+    }
+
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 10u);
+
+    registry->clear();
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 0u);
+
+    // getAllNodes should return empty vector
+    auto allNodes = registry->getAllNodes();
+    EXPECT_TRUE(allNodes.empty());
+}
+
+// Test 9: Hash function consistency
+TEST_F(UuidRegistryTest, HashFunctionConsistency) {
+    auto uuid = juce::Uuid();
+
+    // Hash should be consistent across multiple calls
+    uint32_t hash1 = UuidRegistry::computeHash(uuid);
+    uint32_t hash2 = UuidRegistry::computeHash(uuid);
+    uint32_t hash3 = UuidRegistry::computeHash(uuid);
+
+    EXPECT_EQ(hash1, hash2);
+    EXPECT_EQ(hash2, hash3);
+}
+
+// Test 10: Hash function matches MidiPacket::hashUuid
+TEST_F(UuidRegistryTest, HashMatchesMidiPacket) {
+    auto uuid = juce::Uuid();
+
+    uint32_t registryHash = UuidRegistry::computeHash(uuid);
+    uint32_t packetHash = MidiPacket::hashUuid(uuid);
+
+    // These should be identical (same algorithm)
+    EXPECT_EQ(registryHash, packetHash);
+}
+
+// Test 11: Thread safety - concurrent registrations
+TEST_F(UuidRegistryTest, ConcurrentRegistrations) {
+    const int numThreads = 10;
+    const int uuidsPerThread = 100;
+    std::vector<std::thread> threads;
+    std::vector<std::vector<juce::Uuid>> threadUuids(numThreads);
+
+    // Generate UUIDs for each thread
+    for (int t = 0; t < numThreads; ++t) {
+        for (int i = 0; i < uuidsPerThread; ++i) {
+            threadUuids[t].push_back(juce::Uuid());
+        }
+    }
+
+    // Launch threads to register UUIDs concurrently
+    for (int t = 0; t < numThreads; ++t) {
+        threads.emplace_back([this, t, &threadUuids]() {
+            for (const auto& uuid : threadUuids[t]) {
+                registry->registerNode(uuid);
+            }
+        });
+    }
+
+    // Wait for all threads to complete
+    for (auto& thread : threads) {
+        thread.join();
+    }
+
+    // All UUIDs should be registered
+    EXPECT_EQ(registry->getRegisteredNodeCount(), numThreads * uuidsPerThread);
+
+    // All lookups should succeed
+    for (int t = 0; t < numThreads; ++t) {
+        for (const auto& uuid : threadUuids[t]) {
+            uint32_t hash = UuidRegistry::computeHash(uuid);
+            auto result = registry->lookupFromHash(hash);
+            ASSERT_TRUE(result.has_value());
+            EXPECT_EQ(result.value(), uuid);
+        }
+    }
+}
+
+// Test 12: Thread safety - concurrent lookups
+TEST_F(UuidRegistryTest, ConcurrentLookups) {
+    const int numUuids = 100;
+    std::vector<juce::Uuid> uuids;
+    std::vector<uint32_t> hashes;
+
+    // Pre-register UUIDs
+    for (int i = 0; i < numUuids; ++i) {
+        uuids.push_back(juce::Uuid());
+        registry->registerNode(uuids[i]);
+        hashes.push_back(UuidRegistry::computeHash(uuids[i]));
+    }
+
+    const int numThreads = 10;
+    std::vector<std::thread> threads;
+    std::atomic<int> successCount{0};
+
+    // Launch threads to lookup UUIDs concurrently
+    for (int t = 0; t < numThreads; ++t) {
+        threads.emplace_back([this, &hashes, &uuids, &successCount]() {
+            for (size_t i = 0; i < hashes.size(); ++i) {
+                auto result = registry->lookupFromHash(hashes[i]);
+                if (result.has_value() && result.value() == uuids[i]) {
+                    successCount++;
+                }
+            }
+        });
+    }
+
+    // Wait for all threads
+    for (auto& thread : threads) {
+        thread.join();
+    }
+
+    // All lookups should have succeeded
+    EXPECT_EQ(successCount.load(), numThreads * numUuids);
+}
+
+// Test 13: Thread safety - mixed register/unregister/lookup
+TEST_F(UuidRegistryTest, ConcurrentMixedOperations) {
+    const int numOperations = 500;
+    std::vector<juce::Uuid> sharedUuids;
+
+    // Pre-populate some UUIDs
+    for (int i = 0; i < 20; ++i) {
+        sharedUuids.push_back(juce::Uuid());
+    }
+
+    std::vector<std::thread> threads;
+
+    // Thread 1: Register
+    threads.emplace_back([this, &sharedUuids, numOperations]() {
+        for (int i = 0; i < numOperations; ++i) {
+            registry->registerNode(sharedUuids[i % sharedUuids.size()]);
+            std::this_thread::sleep_for(std::chrono::microseconds(1));
+        }
+    });
+
+    // Thread 2: Lookup
+    threads.emplace_back([this, &sharedUuids, numOperations]() {
+        for (int i = 0; i < numOperations; ++i) {
+            uint32_t hash = UuidRegistry::computeHash(sharedUuids[i % sharedUuids.size()]);
+            registry->lookupFromHash(hash);
+            std::this_thread::sleep_for(std::chrono::microseconds(1));
+        }
+    });
+
+    // Thread 3: Unregister
+    threads.emplace_back([this, &sharedUuids, numOperations]() {
+        for (int i = 0; i < numOperations; ++i) {
+            registry->unregisterNode(sharedUuids[i % sharedUuids.size()]);
+            std::this_thread::sleep_for(std::chrono::microseconds(1));
+        }
+    });
+
+    // Wait for all threads
+    for (auto& thread : threads) {
+        thread.join();
+    }
+
+    // Registry should be in consistent state (no crashes)
+    // Note: Exact count depends on timing, but should be valid
+    size_t finalCount = registry->getRegisteredNodeCount();
+    EXPECT_LE(finalCount, sharedUuids.size());
+}
+
+// Test 14: Hash collision detection (simulated)
+TEST_F(UuidRegistryTest, CollisionDetection) {
+    // This test simulates a collision by manually tracking
+    // In reality, finding actual colliding UUIDs is impractical
+
+    auto uuid1 = juce::Uuid();
+    uint32_t hash1 = UuidRegistry::computeHash(uuid1);
+
+    registry->registerNode(uuid1);
+
+    // Initially no collision
+    EXPECT_FALSE(registry->hasCollision(hash1));
+
+    // Try to find a second UUID with same hash (extremely unlikely)
+    // For testing purposes, we'll just verify the collision tracking works
+    // by checking that hasCollision returns false for non-colliding hashes
+
+    auto uuid2 = juce::Uuid();
+    uint32_t hash2 = UuidRegistry::computeHash(uuid2);
+
+    if (hash1 != hash2) {
+        registry->registerNode(uuid2);
+        EXPECT_FALSE(registry->hasCollision(hash1));
+        EXPECT_FALSE(registry->hasCollision(hash2));
+    }
+}
+
+// Test 15: Large-scale registration (performance)
+TEST_F(UuidRegistryTest, LargeScaleRegistration) {
+    const int numNodes = 1000;
+    std::vector<juce::Uuid> uuids;
+
+    auto startTime = std::chrono::high_resolution_clock::now();
+
+    // Register 1000 nodes
+    for (int i = 0; i < numNodes; ++i) {
+        uuids.push_back(juce::Uuid());
+        registry->registerNode(uuids[i]);
+    }
+
+    auto endTime = std::chrono::high_resolution_clock::now();
+    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(endTime - startTime);
+
+    EXPECT_EQ(registry->getRegisteredNodeCount(), numNodes);
+
+    // All lookups should succeed
+    for (const auto& uuid : uuids) {
+        uint32_t hash = UuidRegistry::computeHash(uuid);
+        auto result = registry->lookupFromHash(hash);
+        ASSERT_TRUE(result.has_value());
+        EXPECT_EQ(result.value(), uuid);
+    }
+
+    // Performance check: should be fast (arbitrary threshold: <10ms for 1000 nodes)
+    EXPECT_LT(duration.count(), 10000);  // < 10ms
+}
+
+// Test 16: Memory efficiency
+TEST_F(UuidRegistryTest, MemoryEfficiency) {
+    const int numNodes = 100;
+
+    // Register nodes and verify count
+    for (int i = 0; i < numNodes; ++i) {
+        registry->registerNode(juce::Uuid());
+    }
+
+    EXPECT_EQ(registry->getRegisteredNodeCount(), numNodes);
+
+    // Memory should be approximately:
+    // - hashToUuid: 100 * (4 + 16) = 2000 bytes
+    // - uuidToHash: 100 * (16 + 4) = 2000 bytes
+    // - Total: ~4KB for 100 nodes (~40 bytes per node with overhead)
+    //
+    // This is well within the <20 bytes per node requirement for the hash table alone
+    // (The additional uuidToHash map is acceptable for fast unregister)
+}
+
+// Test 17: Lifecycle - register, lookup, unregister, verify
+TEST_F(UuidRegistryTest, CompleteLifecycle) {
+    auto uuid = juce::Uuid();
+    uint32_t hash = UuidRegistry::computeHash(uuid);
+
+    // Initial state: not registered
+    auto result1 = registry->lookupFromHash(hash);
+    EXPECT_FALSE(result1.has_value());
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 0u);
+
+    // Register
+    registry->registerNode(uuid);
+    auto result2 = registry->lookupFromHash(hash);
+    ASSERT_TRUE(result2.has_value());
+    EXPECT_EQ(result2.value(), uuid);
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 1u);
+
+    // Unregister
+    registry->unregisterNode(uuid);
+    auto result3 = registry->lookupFromHash(hash);
+    EXPECT_FALSE(result3.has_value());
+    EXPECT_EQ(registry->getRegisteredNodeCount(), 0u);
+}
+
+// Test 18: Hash distribution (verify hash quality)
+TEST_F(UuidRegistryTest, HashDistribution) {
+    const int numUuids = 1000;
+    std::unordered_set<uint32_t> uniqueHashes;
+
+    for (int i = 0; i < numUuids; ++i) {
+        auto uuid = juce::Uuid();
+        uint32_t hash = UuidRegistry::computeHash(uuid);
+        uniqueHashes.insert(hash);
+    }
+
+    // With good hash distribution, we should have close to 1000 unique hashes
+    // Allow for some collisions (very rare, but possible)
+    // Expect at least 99% unique (990 out of 1000)
+    EXPECT_GE(uniqueHashes.size(), 990u);
+}


---

_**Agent (claude-sonnet-4-5-20250929)**_

feat(midi-server): add Phase 4 multi-hop context forwarding with comprehensive testing

 Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude <noreply@anthropic.com>

