<!-- Generated by SpecStory -->

# 2025-10-06 19:14:46Z

<!-- Claude Code Session 12da289d-f951-4f03-84f8-596188276efe (2025-10-06_19-14-46Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/CMakeLists.txt b/modules/juce/midi-server/CMakeLists.txt
index 719852f..9222435 100644
--- a/modules/juce/midi-server/CMakeLists.txt
+++ b/modules/juce/midi-server/CMakeLists.txt
@@ -48,6 +48,8 @@ endif()
 # Exclude test programs from main server
 list(FILTER DISCOVERY_SOURCES EXCLUDE REGEX ".*DiscoveryTest\\.cpp$")
 list(FILTER TRANSPORT_SOURCES EXCLUDE REGEX ".*TransportTest\\.cpp$")
+list(FILTER MESH_SOURCES EXCLUDE REGEX ".*/tests/.*Test\\.cpp$")
+list(FILTER TRANSPORT_SOURCES EXCLUDE REGEX ".*/tests/.*Test\\.cpp$")
 
 target_sources(network_midi_server
     PRIVATE
@@ -199,6 +201,13 @@ add_executable(network_midi_tests
     tests/unit/MessageBufferTest.cpp
     tests/unit/UdpMidiTransportTest.cpp
     tests/unit/ConnectionPoolTest.cpp
+    tests/unit/MidiClassifierTest.cpp
+    tests/unit/MidiMessageRouterTest.cpp
+    # SEDA infrastructure tests (Phase B.1)
+    network/mesh/tests/NetworkConnectionQueueTest.cpp
+    # Dual-transport tests (Phase C.1-C.3)
+    network/transport/tests/RealtimeMidiBufferTest.cpp
+    network/transport/tests/DualTransportTest.cpp
     # Add sources under test
     ${CORE_SOURCES}
     ${MESH_SOURCES}
diff --git a/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md b/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md
index 6a5cdc2..84fd743 100644
--- a/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md
+++ b/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md
@@ -1,12 +1,208 @@
 # SEDA Implementation Workplan
 
-**Document Version**: 1.1
+**Document Version**: 1.3
 **Date**: 2025-10-06
-**Status**: Ready for Execution
+**Status**: In Progress - Phase B.2 COMPLETED
 **Related Design**: [design.md](../planning/design.md)
 
 ---
 
+## Progress Log
+
+### Phase B.1: SEDA Infrastructure - COMPLETED (2025-10-06)
+
+**Status**: ✅ COMPLETED
+
+**Files Created**:
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/Commands.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/ConnectionWorker.h`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp`
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp`
+
+**Files Modified**:
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnection.h` - Added SEDA infrastructure members
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnection.cpp` - Integrated queue and worker
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/CMakeLists.txt` - Added test file, excluded tests from server build
+
+**Implementation Summary**:
+1. **Command Hierarchy** - Created polymorphic command base class with 9 command types
+   - Simple commands: Connect, Disconnect, CheckHeartbeat, NotifyHeartbeat, Shutdown
+   - Parametrized commands: SendMidiCommand
+   - Query commands with blocking response: GetStateQuery, GetRemoteNodeQuery, GetDevicesQuery
+
+2. **NetworkConnectionQueue** - Thread-safe multi-producer, single-consumer queue
+   - Uses `juce::WaitableEvent` for efficient blocking wait
+   - `std::deque` for unbounded capacity
+   - `pushCommand()` - Thread-safe push (any thread)
+   - `waitAndPop(timeout)` - Blocking pop with timeout (worker thread only)
+
+3. **ConnectionWorker** - Event loop thread for command processing
+   - Extends `juce::Thread`
+   - Processes commands via `processCommand()` dispatcher
+   - Stub handlers for all command types (to be implemented in Phase B.2)
+   - Clean shutdown via `ShutdownCommand`
+
+4. **NetworkConnection Integration**
+   - Added `commandQueue` and `worker` members
+   - Initialize and start worker thread in constructor
+   - Graceful shutdown in destructor (push ShutdownCommand, wait for exit)
+   - Existing mutex-based methods retained for backward compatibility
+
+5. **Unit Tests** - Comprehensive test suite (8 test cases)
+   - Basic push/pop functionality
+   - Timeout behavior
+   - Command polymorphism
+   - Multi-producer stress test (10 producers, 1 consumer, 1000 commands total)
+   - High-frequency operations (measures throughput)
+   - Query command with response mechanism
+   - Concurrent queries (50 simultaneous)
+   - Shutdown command handling
+
+**Build Status**:
+- ✅ All SEDA source files compile successfully
+- ✅ Object files generated: `ConnectionWorker.cpp.o` (14K), `NetworkConnectionQueue.cpp.o` (58K)
+- ✅ No compilation errors in SEDA infrastructure
+- ⚠️ Pre-existing test errors in other modules (unrelated to SEDA)
+- ⚠️ Pre-existing build errors in NonRealtimeMidiTransport (unrelated to SEDA)
+
+**Test Status**:
+- Tests created but not yet run due to pre-existing test framework issues
+- Test file compiles successfully
+- Ready for execution once test framework is fixed
+
+**Next Steps** (Phase B.2):
+1. Implement actual command handlers in `ConnectionWorker`
+2. Move state ownership from `NetworkConnection` to `ConnectionWorker`
+3. Use atomic snapshots for fast state queries
+4. Add integration tests with actual connection lifecycle
+5. Benchmark performance vs. current mutex-based implementation
+
+**Estimated Time for Phase B.2**: 2-3 hours
+
+---
+
+### Phase B.2: Command Handler Implementation - COMPLETED (2025-10-06)
+
+**Status**: ✅ COMPLETED
+
+**Files Modified**:
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/ConnectionWorker.h` (148 lines)
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp` (367 lines)
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnection.h` (226 lines)
+- `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnection.cpp` (167 lines)
+
+**Implementation Summary**:
+
+1. **State Migration to ConnectionWorker**
+   - Moved all mutable state from NetworkConnection to ConnectionWorker
+   - State now single-threaded (worker thread owns all state)
+   - State variables: `currentState`, `remoteDevices`, `lastHeartbeatTime`, `running`
+   - Network resources: `httpClient`, `udpSocket`, `localUdpEndpoint`, `remoteUdpEndpoint`
+   - Message queue: `receivedMessages`
+
+2. **Atomic Snapshots for Lock-Free Queries**
+   - Added `std::atomic<State> stateSnapshot`
+   - Added `std::atomic<int64_t> heartbeatSnapshot`
+   - `updateSnapshots()` method synchronizes atomic variables
+   - External threads can read snapshots without blocking worker
+
+3. **Command Handler Implementations**
+   - **handleConnectCommand()**: Full HTTP handshake with UDP socket binding
+     - Initializes httpClient with remote node endpoint
+     - Binds UDP socket to any available port
+     - Sends POST to `/network/handshake` with local UDP endpoint
+     - Parses response for remote UDP endpoint and device list
+     - Transitions state: Disconnected → Connecting → Connected (or Failed)
+     - Invokes callbacks for state changes and device list
+
+   - **handleDisconnectCommand()**: Complete resource cleanup
+     - Shuts down UDP socket
+     - Resets httpClient and udpSocket
+     - Clears received messages
+     - Transitions state to Disconnected
+
+   - **handleCheckHeartbeatCommand()**: Timeout detection
+     - Calculates time since last heartbeat
+     - Transitions to Failed state if timeout exceeded (>3000ms)
+     - Invokes error callback
+
+   - **handleNotifyHeartbeatCommand()**: Timestamp update
+     - Updates lastHeartbeatTime
+     - Updates atomic heartbeatSnapshot
+
+   - **handleSendMidiCommand()**: MIDI message validation
+     - Validates connection state
+     - Validates message data
+     - TODO: Actual UDP transmission (pending MidiPacket protocol)
+
+   - **Query Handlers**: Synchronous state queries
+     - handleGetStateQuery(): Returns currentState via WaitableEvent
+     - handleGetRemoteNodeQuery(): Returns remoteNodeInfo via WaitableEvent
+     - handleGetDevicesQuery(): Returns remoteDevices via WaitableEvent
+
+4. **Mutex Elimination from NetworkConnection**
+   - **Removed** `std::mutex stateMutex`
+   - **Removed** `std::mutex messageMutex`
+   - **Removed** `std::mutex heartbeatMutex`
+   - **Removed** `std::atomic<bool> running`
+   - **Removed** `std::atomic<State> currentState`
+   - NetworkConnection now a thin command-queuing facade
+
+5. **NetworkConnection Method Updates**
+   - `connect()`: Simple command queue push
+   - `disconnect()`: Simple command queue push
+   - `getState()`: Query command with 1s timeout
+   - `getRemoteNode()`: Query command with 1s timeout
+   - `getRemoteDevices()`: Query command with 1s timeout
+   - `sendMidiMessage()`: Command queue push with validation
+   - `checkHeartbeat()`: Command queue push
+   - `getTimeSinceLastHeartbeat()`: Temporary implementation (TODO: add query or atomic snapshot)
+
+6. **Helper Methods**
+   - `setState(State newState)`: State change with logging and callback invocation
+   - `updateSnapshots()`: Synchronize atomic snapshots with worker state
+   - `handleUdpPacket()`: Stub for UDP packet handling (pending MidiPacket implementation)
+
+**Architecture Quality**:
+- **Zero Mutex Contention**: All state single-threaded in worker
+- **Lock-Free Command Queue**: Non-blocking command submission
+- **Type-Safe Commands**: Polymorphic command hierarchy
+- **Clear Threading Model**: Single-threaded worker, multi-threaded clients
+- **Callback Invocation**: All callbacks invoked from worker thread (consistent context)
+
+**File Size Compliance**:
+- ✅ All files under 500-line limit
+- ConnectionWorker.h: 148 lines
+- ConnectionWorker.cpp: 367 lines
+- NetworkConnection.h: 226 lines
+- NetworkConnection.cpp: 167 lines
+
+**Build Status**:
+- ✅ All files compile without errors
+- ✅ Main target `network_midi_server` builds successfully
+- ⚠️ Unit test failures (looking for removed `getInstance()` method - needs test updates)
+
+**Performance Benefits**:
+- Zero mutex contention in state access
+- Lock-free command submission
+- Fast atomic snapshots (when used)
+- Predictable single-threaded execution
+
+**Next Steps** (Phase B.3: Dual-Transport Integration):
+1. Integrate MidiMessageRouter with ConnectionWorker
+2. Wire MIDI input callbacks through classifier to appropriate transport
+3. Connect RealtimeMidiTransport and NonRealtimeMidiTransport with mesh
+4. Add UDP receive loop in ConnectionWorker
+5. Implement MidiPacket protocol for actual transmission
+6. Update MeshManager to work with SEDA architecture
+7. Performance benchmarking and latency measurements
+
+**Estimated Time for Phase B.3**: 2-3 hours
+
+---
+
 ## Table of Contents
 
 1. [Executive Summary](#executive-summary)
@@ -102,2759 +298,11 @@ Based on the design document analysis:
 2. **Approach C in parallel** (address MIDI QoS requirements)
 3. **Approach B if needed** (based on production metrics)
 
----
-
-## Approach A: Mutex Fixes (Recommended Start)
-
-### Overview
-
-Eliminate the three primary deadlock scenarios with minimal code changes:
-
-1. Fix callback-under-lock pattern in `setState()`
-2. Protect `remoteDevices` with proper synchronization
-3. Move callback dispatch to message thread
-4. Add defensive timeouts on mutex acquisitions
-
-**Effort Estimate**: 2-4 hours
-**Risk Level**: Low
-**Rollback Complexity**: Trivial (git revert)
-
----
-
-### Phase A.1: Fix Callback-Under-Lock
-
-**Objective**: Ensure callbacks are never invoked while holding mutexes.
-
-**Duration**: 30-45 minutes
-
-#### Tasks
-
-1. **Modify `NetworkConnection::setState()`**
-   - File: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkConnection.cpp`
-   - Change callback invocation pattern
-
-2. **Implementation**:
-
-```cpp
-// BEFORE (NetworkConnection.cpp:255-271)
-void NetworkConnection::setState(State newState)
-{
-    State oldState = currentState.load();
-    // ...
-    currentState = newState;
-    // ...
-    if (onStateChanged) {
-        onStateChanged(oldState, newState);  // ⚠️ UNDER LOCK
-    }
-}
-
-// AFTER
-void NetworkConnection::setState(State newState)
-{
-    State oldState = currentState.load();
-
-    // Update state under lock (if needed)
-    {
-        std::lock_guard<std::mutex> lock(stateMutex);
-        currentState = newState;
-        // ... other state updates ...
-    }
-
-    // Dispatch callback OUTSIDE lock via message thread
-    if (onStateChanged) {
-        auto callback = onStateChanged;  // Copy callback
-        juce::MessageManager::callAsync([callback, oldState, newState]() {
-            callback(oldState, newState);
-        });
-    }
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] `setState()` releases all mutexes before callback invocation
-- [ ] Callbacks dispatched via `juce::MessageManager::callAsync()`
-- [ ] Existing state transition tests still pass
-- [ ] No compiler warnings
-
-#### Testing
-
-```cpp
-// New test: Ensure callbacks are async
-TEST(NetworkConnectionMutexFix, CallbackNotUnderLock) {
-    NetworkConnection conn(testNodeInfo);
-
-    std::atomic<bool> callbackExecuted{false};
-    std::thread::id callbackThread;
-
-    conn.onStateChanged = [&](auto oldState, auto newState) {
-        callbackThread = std::this_thread::get_id();
-        callbackExecuted = true;
-    };
-
-    conn.connect();
-
-    // Wait for callback
-    for (int i = 0; i < 100 && !callbackExecuted; ++i) {
-        juce::MessageManager::getInstance()->runDispatchLoopUntil(10);
-    }
-
-    EXPECT_TRUE(callbackExecuted);
-    EXPECT_NE(callbackThread, std::this_thread::get_id());  // Different thread
-}
-```
-
----
-
-### Phase A.2: Protect remoteDevices Access
-
-**Objective**: Eliminate Race #3 (device list read without protection).
-
-**Duration**: 45-60 minutes
-
-#### Tasks
-
-1. **Add mutex protection to device list operations**
-   - File: `NetworkConnection.cpp` and `NetworkConnection.h`
-
-2. **Implementation**:
-
-```cpp
-// NetworkConnection.h - Add new mutex
-private:
-    mutable std::mutex devicesMutex;  // Protects remoteDevices
-
-// NetworkConnection.cpp:91-96 - Update getRemoteDevices()
-std::vector<DeviceInfo> NetworkConnection::getRemoteDevices() const
-{
-    std::lock_guard<std::mutex> lock(devicesMutex);
-    return remoteDevices;  // ✅ Now safe
-}
-
-// NetworkConnection.cpp:213-223 - Update performHandshake()
-void NetworkConnection::performHandshake()
-{
-    // ... HTTP request ...
-
-    if (success) {
-        {
-            std::lock_guard<std::mutex> lock(devicesMutex);
-            remoteDevices = parsedDevices;  // ✅ Protected write
-        }
-
-        setState(State::Connected);
-    }
-}
-```
-
-#### Alternative: Use Atomic Shared Pointer (Zero-Copy Reads)
-
-```cpp
-// NetworkConnection.h
-private:
-    std::atomic<std::shared_ptr<const std::vector<DeviceInfo>>> remoteDevicesPtr;
-
-// NetworkConnection.cpp
-std::vector<DeviceInfo> NetworkConnection::getRemoteDevices() const
-{
-    auto devices = remoteDevicesPtr.load(std::memory_order_acquire);
-    return devices ? *devices : std::vector<DeviceInfo>{};
-}
-
-void NetworkConnection::performHandshake()
-{
-    // ... parse devices ...
-
-    auto devices = std::make_shared<std::vector<DeviceInfo>>(parsedDevices);
-    remoteDevicesPtr.store(devices, std::memory_order_release);
-}
-```
-
-**Recommendation**: Use atomic shared pointer for better read performance.
-
-#### Acceptance Criteria
-
-- [ ] All `remoteDevices` reads are protected
-- [ ] All `remoteDevices` writes are protected
-- [ ] No data races detected by ThreadSanitizer
-- [ ] Device list tests pass
-
----
-
-### Phase A.3: Add Mutex Timeouts (Defensive)
-
-**Objective**: Prevent indefinite blocking in case of unforeseen contention.
-
-**Duration**: 30-45 minutes
-
-#### Tasks
-
-1. **Replace `std::mutex` with `std::timed_mutex`**
-   - File: `NetworkConnection.h`
-
-2. **Implementation**:
-
-```cpp
-// NetworkConnection.h
-private:
-    std::timed_mutex stateMutex;
-    std::timed_mutex heartbeatMutex;
-    std::timed_mutex devicesMutex;
-
-// NetworkConnection.cpp - Example with timeout
-State NetworkConnection::getState() const
-{
-    std::unique_lock<std::timed_mutex> lock(stateMutex, std::chrono::milliseconds(100));
-
-    if (!lock.owns_lock()) {
-        // Log warning - mutex contention detected
-        juce::Logger::writeToLog("WARNING: getState() mutex timeout - possible contention");
-
-        // Return atomic snapshot as fallback
-        return currentState.load(std::memory_order_acquire);
-    }
-
-    return currentState;
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] All mutex acquisitions have 100ms timeout
-- [ ] Timeouts logged to help identify contention
-- [ ] Fallback to atomic reads where possible
-- [ ] No false positives in normal operation
-
----
-
-### Phase A.4: Fix MeshManager Connection Lifecycle
-
-**Objective**: Resolve Race #4 (connection may be deleted between pool query and dereference).
-
-**Duration**: 45-60 minutes
-
-#### Tasks
-
-1. **Modify `MeshManager::getTotalDeviceCount()`**
-   - File: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/MeshManager.cpp`
-
-2. **Implementation**:
-
-```cpp
-// BEFORE (MeshManager.cpp:147-166)
-int MeshManager::getTotalDeviceCount() const
-{
-    auto connections = connectionPool.getAllConnections();  // ⚠️ Pool lock released
-
-    for (auto* connection : connections) {
-        if (connection && connection->getState() == NetworkConnection::State::Connected) {
-            total += (int)connection->getRemoteDevices().size();  // ⚠️ May be deleted!
-        }
-    }
-}
-
-// AFTER - Hold pool lock during iteration
-int MeshManager::getTotalDeviceCount() const
-{
-    return connectionPool.withAllConnections([](const auto& connections) {
-        int total = 0;
-        for (const auto* connection : connections) {
-            if (connection && connection->getState() == NetworkConnection::State::Connected) {
-                total += (int)connection->getRemoteDevices().size();
-            }
-        }
-        return total;
-    });
-}
-
-// ConnectionPool.h - Add withAllConnections helper
-template<typename Func>
-auto withAllConnections(Func&& func) const {
-    std::lock_guard<std::mutex> lock(poolMutex);
-    return func(connections);  // Callback executes under lock
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] Connection pool operations atomic
-- [ ] No use-after-free in iteration
-- [ ] All mesh manager tests pass
-- [ ] No deadlocks when querying pool
-
----
-
-### Phase A.5: Validation & Testing
-
-**Duration**: 30-45 minutes
-
-#### Validation Checklist
-
-- [ ] Build succeeds with no warnings: `cmake --build build`
-- [ ] All existing unit tests pass: `ctest --test-dir build`
-- [ ] ThreadSanitizer clean: `cmake -DCMAKE_CXX_FLAGS="-fsanitize=thread" ..`
-- [ ] Stress test: 100 threads querying concurrently for 60 seconds
-- [ ] Callback ordering test: Verify message thread execution
-- [ ] Performance baseline: Measure query latency before/after
-
-#### New Tests Required
-
-```cpp
-// Test 1: Concurrent queries with state changes
-TEST(NetworkConnectionMutexFix, ConcurrentQueriesDuringHandshake) {
-    // 50 reader threads + 1 connection thread
-    // Run for 10 seconds, verify no deadlocks
-}
-
-// Test 2: Callback reentrancy safety
-TEST(NetworkConnectionMutexFix, CallbackReentrancySafe) {
-    // Callback calls getRemoteNode() - should not deadlock
-}
-
-// Test 3: Device list consistency
-TEST(NetworkConnectionMutexFix, DeviceListReadDuringWrite) {
-    // Read devices while handshake updates list
-    // Verify no crashes, no partial data
-}
-
-// Test 4: Pool iteration safety
-TEST(MeshManagerFix, PoolIterationDuringDisconnect) {
-    // Disconnect connection while getTotalDeviceCount() iterating
-    // Verify no use-after-free
-}
-```
-
----
-
-## Approach B: Full SEDA Migration
-
-### Overview
-
-Complete architectural transformation to staged event-driven design with zero shared mutexes.
-
-**Effort Estimate**: 8-14 hours
-**Risk Level**: Medium
-**Rollback Complexity**: Moderate (feature branch required)
-
-**Note**: Only proceed if Approach A proves insufficient OR if production metrics show >5% mutex contention.
-
----
-
-### Phase B.1: Infrastructure Setup
-
-**Objective**: Create command queue and worker thread infrastructure.
-
-**Duration**: 2-3 hours
-
-#### Tasks
-
-1. **Create command hierarchy**
-   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/NetworkCommands.h`
-
-```cpp
-#pragma once
-
-#include <juce_core/juce_core.h>
-#include <juce_events/juce_events.h>
-#include <memory>
-#include <vector>
-
-namespace NetworkMidi {
-namespace Commands {
-
-// Base command
-struct Command {
-    enum Type {
-        Connect,
-        Disconnect,
-        CheckHeartbeat,
-        NotifyHeartbeat,
-        SendMidi,
-        GetRemoteNode,
-        GetDevices,
-        Shutdown
-    };
-
-    Type type;
-    virtual ~Command() = default;
-};
-
-// Simple commands
-struct ConnectCommand : Command {
-    ConnectCommand() { type = Connect; }
-};
-
-struct DisconnectCommand : Command {
-    DisconnectCommand() { type = Disconnect; }
-};
-
-struct CheckHeartbeatCommand : Command {
-    CheckHeartbeatCommand() { type = CheckHeartbeat; }
-};
-
-struct NotifyHeartbeatCommand : Command {
-    NotifyHeartbeatCommand() { type = NotifyHeartbeat; }
-};
-
-// Query commands with synchronous response
-struct GetRemoteNodeQuery : Command {
-    juce::WaitableEvent responseReady;
-    NodeInfo result;
-
-    GetRemoteNodeQuery() { type = GetRemoteNode; }
-};
-
-struct GetDevicesQuery : Command {
-    juce::WaitableEvent responseReady;
-    std::vector<DeviceInfo> result;
-
-    GetDevicesQuery() { type = GetDevices; }
-};
-
-struct ShutdownCommand : Command {
-    ShutdownCommand() { type = Shutdown; }
-};
-
-} // namespace Commands
-} // namespace NetworkMidi
-```
-
-2. **Create command queue**
-   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/CommandQueue.h`
-
-```cpp
-#pragma once
-
-#include "NetworkCommands.h"
-#include <juce_events/juce_events.h>
-#include <deque>
-#include <mutex>
-
-namespace NetworkMidi {
-
-class CommandQueue {
-public:
-    void push(std::unique_ptr<Commands::Command> cmd) {
-        {
-            std::lock_guard<std::mutex> lock(queueMutex);
-            queue.push_back(std::move(cmd));
-        }
-        queueEvent.signal();
-    }
-
-    std::unique_ptr<Commands::Command> pop(int timeoutMs) {
-        if (!queueEvent.wait(timeoutMs)) {
-            return nullptr;
-        }
-
-        std::lock_guard<std::mutex> lock(queueMutex);
-        if (queue.empty()) {
-            return nullptr;
-        }
-
-        auto cmd = std::move(queue.front());
-        queue.pop_front();
-
-        if (!queue.empty()) {
-            queueEvent.signal();
-        }
-
-        return cmd;
-    }
-
-    size_t size() const {
-        std::lock_guard<std::mutex> lock(queueMutex);
-        return queue.size();
-    }
-
-private:
-    mutable std::mutex queueMutex;
-    std::deque<std::unique_ptr<Commands::Command>> queue;
-    juce::WaitableEvent queueEvent;
-};
-
-} // namespace NetworkMidi
-```
-
-3. **Create worker thread**
-   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/mesh/ConnectionWorker.h`
-
-```cpp
-#pragma once
-
-#include "CommandQueue.h"
-#include "NetworkCommands.h"
-#include <juce_core/juce_core.h>
-#include <atomic>
-
-namespace NetworkMidi {
-
-class ConnectionWorker : public juce::Thread {
-public:
-    ConnectionWorker(CommandQueue& queue);
-    ~ConnectionWorker() override;
-
-    void run() override;
-
-    // Atomic snapshots for fast queries
-    State getStateSnapshot() const {
-        return stateSnapshot.load(std::memory_order_acquire);
-    }
-
-    int64_t getHeartbeatSnapshot() const {
-        return heartbeatSnapshot.load(std::memory_order_acquire);
-    }
-
-private:
-    CommandQueue& commandQueue;
-
-    // Worker-owned state (no mutexes needed)
-    State currentState{State::Disconnected};
-    int64_t lastHeartbeatTime{0};
-    NodeInfo remoteNodeInfo;
-    std::vector<DeviceInfo> remoteDevices;
-    std::unique_ptr<httplib::Client> httpClient;
-
-    // Atomic snapshots for queries
-    std::atomic<State> stateSnapshot{State::Disconnected};
-    std::atomic<int64_t> heartbeatSnapshot{0};
-
-    // Command handlers
-    void processCommand(std::unique_ptr<Commands::Command> cmd);
-    void handleConnect();
-    void handleDisconnect();
-    void handleCheckHeartbeat();
-    void handleNotifyHeartbeat();
-    void handleGetRemoteNodeQuery(Commands::GetRemoteNodeQuery* query);
-    void handleGetDevicesQuery(Commands::GetDevicesQuery* query);
-
-    // Helper methods
-    void updateSnapshots();
-    void dispatchStateChangedCallback(State oldState, State newState);
-    bool performHandshake();
-};
-
-} // namespace NetworkMidi
-```
-
-#### Acceptance Criteria
-
-- [ ] CommandQueue tests pass (push/pop operations)
-- [ ] Worker thread starts and stops cleanly
-- [ ] Command dispatch works (send Connect, verify handleConnect called)
-- [ ] No memory leaks (valgrind clean)
-
----
-
-### Phase B.2: State Migration
-
-**Objective**: Move state ownership to worker thread, use atomic snapshots for queries.
-
-**Duration**: 2-3 hours
-
-#### Tasks
-
-1. **Modify NetworkConnection to use worker**
-   - File: `NetworkConnection.h`
-
-```cpp
-class NetworkConnection {
-public:
-    NetworkConnection(const NodeInfo& remoteNode);
-    ~NetworkConnection();
-
-    // Public API - dispatch commands
-    void connect();
-    void disconnect();
-
-    // Fast queries via atomic snapshots
-    State getState() const {
-        return worker.getStateSnapshot();
-    }
-
-    int64_t getTimeSinceLastHeartbeat() const {
-        int64_t last = worker.getHeartbeatSnapshot();
-        return juce::Time::getCurrentTime().toMilliseconds() - last;
-    }
-
-    // Complex queries via command queue
-    NodeInfo getRemoteNode() const;
-    std::vector<DeviceInfo> getRemoteDevices() const;
-
-    // Callbacks
-    std::function<void(State, State)> onStateChanged;
-    std::function<void(const juce::String&)> onError;
-
-private:
-    CommandQueue commandQueue;
-    ConnectionWorker worker;
-
-    // NO MUTEXES - all state owned by worker
-};
-```
-
-2. **Implement query methods**
-   - File: `NetworkConnection.cpp`
-
-```cpp
-NetworkConnection::NetworkConnection(const NodeInfo& remoteNode)
-    : worker(commandQueue, remoteNode)
-{
-    worker.startThread();
-}
-
-NetworkConnection::~NetworkConnection()
-{
-    commandQueue.push(std::make_unique<Commands::ShutdownCommand>());
-    worker.stopThread(2000);  // 2 second timeout
-}
-
-void NetworkConnection::connect()
-{
-    commandQueue.push(std::make_unique<Commands::ConnectCommand>());
-}
-
-void NetworkConnection::disconnect()
-{
-    commandQueue.push(std::make_unique<Commands::DisconnectCommand>());
-}
-
-NodeInfo NetworkConnection::getRemoteNode() const
-{
-    auto query = std::make_unique<Commands::GetRemoteNodeQuery>();
-    auto* queryPtr = query.get();
-
-    commandQueue.push(std::move(query));
-    queryPtr->responseReady.wait();
-
-    return queryPtr->result;
-}
-
-std::vector<DeviceInfo> NetworkConnection::getRemoteDevices() const
-{
-    auto query = std::make_unique<Commands::GetDevicesQuery>();
-    auto* queryPtr = query.get();
-
-    commandQueue.push(std::move(query));
-    queryPtr->responseReady.wait();
-
-    return queryPtr->result;
-}
-```
-
-3. **Implement worker command handlers**
-   - File: `ConnectionWorker.cpp`
-
-```cpp
-void ConnectionWorker::processCommand(std::unique_ptr<Commands::Command> cmd)
-{
-    switch (cmd->type) {
-        case Commands::Command::Connect:
-            handleConnect();
-            break;
-
-        case Commands::Command::Disconnect:
-            handleDisconnect();
-            break;
-
-        case Commands::Command::CheckHeartbeat:
-            handleCheckHeartbeat();
-            break;
-
-        case Commands::Command::GetRemoteNode:
-            handleGetRemoteNodeQuery(
-                static_cast<Commands::GetRemoteNodeQuery*>(cmd.get()));
-            break;
-
-        case Commands::Command::GetDevices:
-            handleGetDevicesQuery(
-                static_cast<Commands::GetDevicesQuery*>(cmd.get()));
-            break;
-
-        case Commands::Command::Shutdown:
-            signalThreadShouldExit();
-            break;
-    }
-}
-
-void ConnectionWorker::handleConnect()
-{
-    State oldState = currentState;
-    currentState = State::Connecting;
-    updateSnapshots();
-
-    bool success = performHandshake();
-
-    if (success) {
-        currentState = State::Connected;
-        lastHeartbeatTime = juce::Time::getCurrentTime().toMilliseconds();
-        updateSnapshots();
-
-        dispatchStateChangedCallback(oldState, State::Connected);
-    } else {
-        currentState = State::Failed;
-        updateSnapshots();
-
-        dispatchStateChangedCallback(oldState, State::Failed);
-    }
-}
-
-void ConnectionWorker::handleGetRemoteNodeQuery(Commands::GetRemoteNodeQuery* query)
-{
-    query->result = remoteNodeInfo;
-    query->responseReady.signal();
-}
-
-void ConnectionWorker::handleGetDevicesQuery(Commands::GetDevicesQuery* query)
-{
-    query->result = remoteDevices;
-    query->responseReady.signal();
-}
-
-void ConnectionWorker::updateSnapshots()
-{
-    stateSnapshot.store(currentState, std::memory_order_release);
-    heartbeatSnapshot.store(lastHeartbeatTime, std::memory_order_release);
-}
-
-void ConnectionWorker::dispatchStateChangedCallback(State oldState, State newState)
-{
-    if (onStateChanged) {
-        juce::MessageManager::callAsync([this, oldState, newState]() {
-            if (onStateChanged) {
-                onStateChanged(oldState, newState);
-            }
-        });
-    }
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] All state mutations happen on worker thread
-- [ ] getState() uses atomic snapshot (no blocking)
-- [ ] getRemoteNode() uses query command (blocking)
-- [ ] No mutexes in NetworkConnection class
-- [ ] ThreadSanitizer reports zero data races
-
----
-
-### Phase B.3: Mutex Removal
-
-**Objective**: Remove all mutex fields from NetworkConnection.
-
-**Duration**: 1-2 hours
-
-#### Tasks
-
-1. **Remove mutex declarations**
-   - File: `NetworkConnection.h`
-
-```cpp
-// REMOVE these lines:
-// std::mutex stateMutex;
-// std::mutex heartbeatMutex;
-// std::mutex messageMutex;
-// std::mutex devicesMutex;
-```
-
-2. **Remove all lock_guard usage**
-   - File: `NetworkConnection.cpp`
-   - Search for `std::lock_guard` and verify all removed
-
-3. **Update HeartbeatMonitor integration**
-   - File: `HeartbeatMonitor.cpp`
-
-```cpp
-void HeartbeatMonitor::checkTimeouts()
-{
-    // Now uses atomic snapshot - no blocking
-    for (auto* connection : connections) {
-        if (connection->getTimeSinceLastHeartbeat() > timeoutMs) {
-            // Post check command instead of direct call
-            connection->checkHeartbeat();
-        }
-    }
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] Zero `std::mutex` or `std::lock_guard` in NetworkConnection
-- [ ] Build succeeds
-- [ ] All tests pass
-- [ ] No performance regression in benchmarks
-
----
-
-### Phase B.4: Integration Updates
-
-**Objective**: Update MeshManager and HTTP handlers to work with new API.
-
-**Duration**: 2-3 hours
-
-#### Tasks
-
-1. **Update MeshManager**
-   - File: `MeshManager.cpp`
-   - No changes needed if only using public API
-   - Verify `getTotalDeviceCount()` still works
-
-2. **Update HTTP handlers**
-   - File: HTTP server implementation
-   - Verify `/network/mesh` endpoint works
-   - Ensure no blocking on main thread
-
-3. **Update tests**
-   - Modify existing tests to account for async callback dispatch
-   - Add delays/polling where needed
-
-```cpp
-// OLD TEST
-TEST(NetworkConnection, ConnectSetsState) {
-    connection.connect();
-    EXPECT_EQ(connection.getState(), State::Connecting);  // ❌ May be immediate
-}
-
-// NEW TEST
-TEST(NetworkConnection, ConnectSetsState) {
-    connection.connect();
-
-    // Poll for state change
-    for (int i = 0; i < 100; ++i) {
-        if (connection.getState() == State::Connecting) {
-            break;
-        }
-        std::this_thread::sleep_for(std::chrono::milliseconds(10));
-    }
-
-    EXPECT_EQ(connection.getState(), State::Connecting);
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] MeshManager compiles and runs
-- [ ] HTTP endpoints return correct data
-- [ ] All integration tests pass
-- [ ] No deadlocks in manual testing
-
----
-
-### Phase B.5: Performance Benchmarking
-
-**Objective**: Verify performance improvements match design estimates.
-
-**Duration**: 1-2 hours
-
-#### Tasks
-
-1. **Create benchmark suite**
-   - New file: `tests/performance/NetworkConnectionBenchmark.cpp`
-
-```cpp
-#include <benchmark/benchmark.h>
-
-static void BM_GetState(benchmark::State& state) {
-    NetworkConnection conn(testNode);
-
-    for (auto _ : state) {
-        auto s = conn.getState();  // Should be ~10ns
-        benchmark::DoNotOptimize(s);
-    }
-}
-BENCHMARK(BM_GetState);
-
-static void BM_GetDevices(benchmark::State& state) {
-    NetworkConnection conn(testNode);
-    conn.connect();
-
-    for (auto _ : state) {
-        auto devices = conn.getRemoteDevices();  // Should be <1ms
-        benchmark::DoNotOptimize(devices);
-    }
-}
-BENCHMARK(BM_GetDevices);
-
-static void BM_ConcurrentQueries(benchmark::State& state) {
-    NetworkConnection conn(testNode);
-
-    std::vector<std::thread> threads;
-    for (int i = 0; i < state.range(0); ++i) {
-        threads.emplace_back([&conn] {
-            for (int j = 0; j < 1000; ++j) {
-                conn.getState();
-            }
-        });
-    }
-
-    for (auto& t : threads) {
-        t.join();
-    }
-}
-BENCHMARK(BM_ConcurrentQueries)->Range(1, 128);
-```
-
-2. **Run benchmarks**
-
-```bash
-cmake --build build --target NetworkConnectionBenchmark
-./build/tests/performance/NetworkConnectionBenchmark --benchmark_format=json > results.json
-```
-
-3. **Compare metrics**
-
-| Operation | Current | Target | Actual | Pass/Fail |
-|-----------|---------|--------|--------|-----------|
-| getState() latency | 120ns | <20ns | ??? | ??? |
-| getRemoteDevices() latency| 150ns | <1ms | ??? | ??? |
-| 100 threads querying | 10ms | <1ms | ??? | ??? |
-
-#### Acceptance Criteria
-
-- [ ] getState() <20ns (atomic read)
-- [ ] getRemoteDevices() <1ms (command latency)
-- [ ] 100 concurrent threads <1ms total
-- [ ] No deadlocks in stress tests
-
----
-
-### Phase B.6: TSAN & Stress Testing
-
-**Objective**: Prove zero race conditions and deadlocks.
-
-**Duration**: 1-2 hours
-
-#### Tasks
-
-1. **Build with ThreadSanitizer**
-
-```bash
-cmake -B build-tsan -DCMAKE_CXX_FLAGS="-fsanitize=thread -g -O1" -DCMAKE_EXE_LINKER_FLAGS="-fsanitize=thread"
-cmake --build build-tsan
-```
-
-2. **Run stress tests**
-
-```bash
-./build-tsan/tests/unit/NetworkConnectionTest --gtest_filter="*Stress*"
-```
-
-3. **Create dedicated stress test**
-
-```cpp
-TEST(NetworkConnectionSEDA, StressTest_100Threads_60Seconds) {
-    NetworkConnection conn(testNode);
-    conn.connect();
-
-    std::atomic<bool> stop{false};
-    std::atomic<int> totalQueries{0};
-
-    std::vector<std::thread> readers;
-    for (int i = 0; i < 100; ++i) {
-        readers.emplace_back([&] {
-            while (!stop) {
-                conn.getState();
-                conn.getRemoteNode();
-                conn.getRemoteDevices();
-                ++totalQueries;
-            }
-        });
-    }
-
-    std::this_thread::sleep_for(std::chrono::seconds(60));
-    stop = true;
-
-    for (auto& t : readers) {
-        t.join();
-    }
-
-    std::cout << "Total queries: " << totalQueries << std::endl;
-    // Should be >1M queries in 60 seconds
-    EXPECT_GT(totalQueries, 1000000);
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] ThreadSanitizer reports zero warnings
-- [ ] Stress test runs for 60 seconds without crash
-- [ ] >1M queries/minute throughput
-- [ ] Memory usage stable (no leaks)
-
----
-
-## Approach C: Dual-Transport MIDI (Independent)
-
-### Overview
-
-**NEW APPROACH**: Separate real-time and non-real-time MIDI into independent transport paths with purpose-built QoS.
-
-**Key Insight**: This approach addresses **different requirements** than Approaches A and B:
-- Approaches A/B solve **threading/mutex issues**
-- Approach C solves **MIDI quality-of-service requirements**
-
-**Therefore: Approach C can be implemented INDEPENDENTLY** of whether you choose mutex fixes (A) or full SEDA (B).
-
-**Effort Estimate**: 8-12 hours
-**Risk Level**: Medium
-**Rollback Complexity**: Moderate (feature branch required)
-**Prerequisites**: None (can be done alongside A or B)
-
----
-
-### When to Implement Approach C
-
-**Implement dual-transport if:**
-
-- ✅ Need to support burst MIDI traffic (>500 msg/sec)
-- ✅ Need reliable SysEx delivery (100% guaranteed)
-- ✅ Latency requirements differ by message type (real-time <1ms, bulk <100ms)
-- ✅ Planning for real-time performance scenarios (live music, controllers)
-- ✅ Network mesh will handle intensive MIDI traffic
-
-**Skip dual-transport if:**
-
-- ❌ Only sending low-frequency MIDI (<50 msg/sec)
-- ❌ No SysEx or bulk transfers needed
-- ❌ All MIDI can tolerate 100ms+ latency
-- ❌ Single-transport simplicity preferred
-
----
-
-### Architecture Overview
-
-```
-┌─────────────────────────────────────────────────────────────────────────────┐
-│                          MIDI Message Router                                 │
-│                                                                               │
-│  Input: juce::MidiMessage                                                    │
-│  ┌───────────────────────────────────────────────────────────┐              │
-│  │  Message Classifier: classifyMidiMessage()                │              │
-│  │  - Route by message type (0x80-0xFF)                     │              │
-│  └───────────┬────────────────────────────────┬──────────────┘              │
-│              │                                 │                              │
-│              │ Real-Time                       │ Non-Real-Time                │
-│              │ (Note On/Off, CC, Clock)        │ (SysEx, Bulk Transfer)       │
-│              v                                 v                              │
-│   ┌──────────────────────┐         ┌──────────────────────┐                 │
-│   │  REAL-TIME STAGE     │         │ NON-REAL-TIME STAGE  │                 │
-│   │  (Lock-Free)         │         │ (Standard Queue)     │                 │
-│   ├──────────────────────┤         ├──────────────────────┤                 │
-│   │ juce::AbstractFifo   │         │ std::mutex +         │                 │
-│   │ Ring Buffer          │         │ std::deque           │                 │
-│   │                      │         │                      │                 │
-│   │ Capacity: 2048 msgs  │         │ Unbounded capacity   │                 │
-│   │ Policy: Drop oldest  │         │ Policy: Block/Retry  │                 │
-│   │                      │         │                      │                 │
-│   │ Thread Priority:     │         │ Thread Priority:     │                 │
-│   │ realtimeAudio (9)    │         │ normal (5)           │                 │
-│   └──────────┬───────────┘         └──────────┬───────────┘                 │
-│              │                                 │                              │
-│              │ UDP Packets                     │ TCP Stream                   │
-│              │ (Best-effort)                   │ (Reliable)                   │
-│              v                                 v                              │
-│   ┌──────────────────────┐         ┌──────────────────────┐                 │
-│   │  UDP I/O THREAD      │         │  TCP I/O THREAD      │                 │
-│   │  (Non-blocking)      │         │  (Blocking OK)       │                 │
-│   └──────────────────────┘         └──────────────────────┘                 │
-│              │                                 │                              │
-│              v                                 v                              │
-│        UDP Socket (port 5004)           TCP Socket (port 5005)               │
-└─────────────────────────────────────────────────────────────────────────────┘
-```
-
----
-
-### Phase C.1: Implement Real-Time Ring Buffer
-
-**Objective**: Create lock-free ring buffer for real-time MIDI messages.
-
-**Duration**: 2-3 hours
-
-#### Tasks
-
-1. **Create RealtimeMidiBuffer class**
-   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.h`
-
-```cpp
-#pragma once
-
-#include <juce_core/juce_core.h>
-#include <atomic>
-
-namespace NetworkMidi {
-
-/**
- * Lock-free ring buffer for real-time MIDI messages.
- *
- * Features:
- * - Single producer, single consumer (lock-free)
- * - Fixed capacity with drop-oldest overflow policy
- * - ~50ns write latency, ~200ns batch read latency
- * - Thread-safe without mutexes
- */
-class RealtimeMidiBuffer {
-public:
-    static constexpr int CAPACITY = 2048;  // Power of 2
-
-    struct MidiPacket {
-        uint8_t data[4];     // Max 4 bytes for channel voice messages
-        uint8_t length;
-        uint16_t deviceId;
-        uint32_t timestamp;  // Microseconds since epoch
-    };
-
-    /**
-     * Write message to buffer (called from MIDI input thread).
-     *
-     * @param packet MIDI message to enqueue
-     * @return true if written, false if buffer full (message dropped)
-     */
-    bool write(const MidiPacket& packet);
-
-    /**
-     * Read batch of messages (called from UDP sender thread).
-     *
-     * @param dest Destination array (caller-owned)
-     * @param maxCount Maximum messages to read
-     * @return Number of messages actually read
-     */
-    int readBatch(MidiPacket* dest, int maxCount);
-
-    /**
-     * Get buffer statistics (lock-free).
-     */
-    struct Stats {
-        int numReady;        // Messages currently in buffer
-        int freeSpace;       // Available capacity
-        uint64_t dropped;    // Total messages dropped
-        uint64_t written;    // Total messages written
-        uint64_t read;       // Total messages read
-        float dropRate;      // Percentage of messages dropped
-    };
-
-    Stats getStats() const;
-
-private:
-    juce::AbstractFifo fifo{CAPACITY};
-    MidiPacket buffer[CAPACITY];
-
-    std::atomic<uint64_t> droppedCount{0};
-    std::atomic<uint64_t> totalWritten{0};
-    std::atomic<uint64_t> totalRead{0};
-};
-
-} // namespace NetworkMidi
-```
-
-2. **Implement write() with drop-oldest policy**
-   - File: `RealtimeMidiBuffer.cpp`
-
-```cpp
-bool RealtimeMidiBuffer::write(const MidiPacket& packet) {
-    int start1, size1, start2, size2;
-    fifo.prepareToWrite(1, start1, size1, start2, size2);
-
-    if (size1 == 0) {
-        // Buffer full - implement drop-oldest policy
-        droppedCount.fetch_add(1, std::memory_order_relaxed);
-
-        // Force-advance read pointer to make space
-        int readStart, readSize, dummy1, dummy2;
-        fifo.prepareToRead(1, readStart, readSize, dummy1, dummy2);
-        if (readSize > 0) {
-            fifo.finishedRead(1);  // Discard oldest
-        }
-
-        // Try again
-        fifo.prepareToWrite(1, start1, size1, start2, size2);
-        if (size1 == 0) {
-            return false;  // Still can't write (shouldn't happen)
-        }
-    }
-
-    buffer[start1] = packet;
-    fifo.finishedWrite(1);
-    totalWritten.fetch_add(1, std::memory_order_relaxed);
-    return true;
-}
-```
-
-3. **Implement readBatch() for efficient UDP batching**
-
-```cpp
-int RealtimeMidiBuffer::readBatch(MidiPacket* dest, int maxCount) {
-    int start1, size1, start2, size2;
-    fifo.prepareToRead(maxCount, start1, size1, start2, size2);
-
-    int totalRead = 0;
-
-    // Copy first contiguous block
-    for (int i = 0; i < size1; ++i) {
-        dest[totalRead++] = buffer[start1 + i];
-    }
-
-    // Copy second block if ring wraps around
-    for (int i = 0; i < size2; ++i) {
-        dest[totalRead++] = buffer[start2 + i];
-    }
-
-    if (totalRead > 0) {
-        fifo.finishedRead(totalRead);
-        this->totalRead.fetch_add(totalRead, std::memory_order_relaxed);
-    }
-
-    return totalRead;
-}
-```
-
-4. **Unit tests**
-
-```cpp
-TEST(RealtimeMidiBuffer, WriteAndRead) {
-    RealtimeMidiBuffer buffer;
-    RealtimeMidiBuffer::MidiPacket packet;
-    packet.data[0] = 0x90;  // Note On
-    packet.data[1] = 60;    // Middle C
-    packet.data[2] = 100;   // Velocity
-    packet.length = 3;
-
-    EXPECT_TRUE(buffer.write(packet));
-
-    RealtimeMidiBuffer::MidiPacket readPackets[1];
-    int count = buffer.readBatch(readPackets, 1);
-    EXPECT_EQ(count, 1);
-    EXPECT_EQ(readPackets[0].data[0], 0x90);
-}
-
-TEST(RealtimeMidiBuffer, BurstHandling) {
-    RealtimeMidiBuffer buffer;
-
-    // Write 2000 messages (burst scenario)
-    for (int i = 0; i < 2000; ++i) {
-        RealtimeMidiBuffer::MidiPacket packet;
-        packet.data[0] = 0x90;
-        packet.data[1] = 60 + (i % 12);
-        packet.data[2] = 100;
-        packet.length = 3;
-        buffer.write(packet);
-    }
-
-    auto stats = buffer.getStats();
-    // Should handle 2000 messages with <1% drops
-    EXPECT_LT(stats.dropRate, 1.0f);
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] RealtimeMidiBuffer compiles successfully
-- [ ] write() handles overflow with drop-oldest policy
-- [ ] readBatch() efficiently reads multiple messages
-- [ ] Burst handling test passes (2000 msg/sec)
-- [ ] ThreadSanitizer clean
-
----
-
-### Phase C.2: Create UDP Real-Time Transport
-
-**Objective**: Implement UDP transport thread for real-time MIDI.
-
-**Duration**: 2-3 hours
-
-#### Tasks
-
-1. **Create RealtimeMidiTransport class**
-   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/UdpMidiTransport.h`
-
-```cpp
-#pragma once
-
-#include "RealtimeMidiBuffer.h"
-#include <juce_core/juce_core.h>
-
-namespace NetworkMidi {
-
-/**
- * Real-time MIDI UDP transport thread.
- *
- * Priority: realtimeAudio (highest user-space priority)
- * Latency target: <1ms end-to-end
- * Delivery: Best-effort (no retries)
- */
-class RealtimeMidiTransport : public juce::Thread {
-public:
-    RealtimeMidiTransport(RealtimeMidiBuffer& buf, juce::String host, int port);
-    ~RealtimeMidiTransport() override;
-
-    void run() override;
-
-    struct Stats {
-        std::atomic<uint64_t> packetsSent{0};
-        std::atomic<uint64_t> packetsReceived{0};
-        std::atomic<uint64_t> sendFailures{0};
-    };
-
-    Stats getStats() const { return stats; }
-
-private:
-    RealtimeMidiBuffer& buffer;
-    juce::DatagramSocket udpSocket;
-    juce::String remoteHost;
-    int remotePort;
-    Stats stats;
-
-    void sendPacket(const RealtimeMidiBuffer::MidiPacket& packet);
-    void receivePackets();
-};
-
-} // namespace NetworkMidi
-```
-
-2. **Implement UDP send/receive loop**
-   - File: `UdpMidiTransport.cpp`
-
-```cpp
-RealtimeMidiTransport::RealtimeMidiTransport(RealtimeMidiBuffer& buf,
-                                              juce::String host, int port)
-    : juce::Thread("RealtimeMidiUDP"), buffer(buf),
-      remoteHost(host), remotePort(port)
-{
-    // Set real-time priority
-    setPriority(9);  // realtimeAudio priority
-}
-
-void RealtimeMidiTransport::run() {
-    // Bind socket (non-blocking)
-    if (!udpSocket.bindToPort(0)) {  // Let OS assign port
-        DBG("Failed to bind UDP socket");
-        return;
-    }
-
-    RealtimeMidiBuffer::MidiPacket packets[32];  // Batch buffer
-
-    while (!threadShouldExit()) {
-        // Read batch from ring buffer (lock-free)
-        int count = buffer.readBatch(packets, 32);
-
-        if (count > 0) {
-            // Send each packet via UDP (non-blocking)
-            for (int i = 0; i < count; ++i) {
-                sendPacket(packets[i]);
-            }
-        } else {
-            // No messages - yield CPU briefly
-            juce::Thread::sleep(1);  // 1ms sleep (acceptable latency)
-        }
-
-        // Also receive incoming UDP messages (non-blocking)
-        receivePackets();
-    }
-}
-
-void RealtimeMidiTransport::sendPacket(const RealtimeMidiBuffer::MidiPacket& packet) {
-    // Serialize packet (fixed-size binary format)
-    uint8_t wireFormat[16];
-    wireFormat[0] = 'M';  // Magic byte
-    wireFormat[1] = 'R';  // Real-time marker
-    wireFormat[2] = packet.length;
-    wireFormat[3] = (packet.deviceId >> 8) & 0xFF;
-    wireFormat[4] = packet.deviceId & 0xFF;
-    std::memcpy(&wireFormat[5], &packet.timestamp, 4);
-    std::memcpy(&wireFormat[9], packet.data, packet.length);
-
-    int totalSize = 9 + packet.length;
-
-    // Send UDP (best-effort, no retry)
-    int sent = udpSocket.write(remoteHost, remotePort, wireFormat, totalSize);
-    if (sent == totalSize) {
-        stats.packetsSent.fetch_add(1, std::memory_order_relaxed);
-    } else {
-        stats.sendFailures.fetch_add(1, std::memory_order_relaxed);
-    }
-}
-```
-
-3. **Unit tests**
-
-```cpp
-TEST(RealtimeMidiTransport, SendReceive) {
-    RealtimeMidiBuffer buffer;
-    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
-
-    transport.startThread();
-
-    // Write messages to buffer
-    for (int i = 0; i < 100; ++i) {
-        RealtimeMidiBuffer::MidiPacket packet;
-        packet.data[0] = 0x90;
-        packet.data[1] = 60;
-        packet.data[2] = 100;
-        packet.length = 3;
-        buffer.write(packet);
-    }
-
-    // Wait for transmission
-    juce::Thread::sleep(100);
-
-    auto stats = transport.getStats();
-    EXPECT_GT(stats.packetsSent, 90);  // At least 90% sent
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] UDP transport thread starts successfully
-- [ ] Real-time priority set (priority 9)
-- [ ] Non-blocking send/receive implemented
-- [ ] Latency <1ms (measure with timestamps)
-- [ ] Unit tests pass
-
----
-
-### Phase C.3: Create TCP Non-Real-Time Transport
-
-**Objective**: Implement TCP transport for reliable SysEx delivery.
-
-**Duration**: 2-3 hours
-
-#### Tasks
-
-1. **Create NonRealtimeMidiTransport class**
-   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/TcpMidiTransport.h`
-
-```cpp
-#pragma once
-
-#include <juce_core/juce_core.h>
-#include <deque>
-#include <mutex>
-#include <map>
-
-namespace NetworkMidi {
-
-/**
- * Non-real-time MIDI transport using TCP for reliable delivery.
- *
- * Features:
- * - Guaranteed delivery (ACK/retry)
- * - SysEx fragmentation (1KB chunks)
- * - Flow control
- * - 100% reliability target
- */
-class NonRealtimeMidiTransport : public juce::Thread {
-public:
-    struct MidiPacket {
-        std::vector<uint8_t> data;
-        uint16_t deviceId;
-        uint32_t sequenceNumber;
-        bool requiresAck;
-    };
-
-    NonRealtimeMidiTransport(juce::String host, int port);
-    ~NonRealtimeMidiTransport() override;
-
-    void sendMessage(const juce::MidiMessage& msg, uint16_t deviceId);
-    std::vector<MidiPacket> getReceivedMessages();
-
-    void run() override;
-
-private:
-    std::mutex queueMutex;
-    std::deque<MidiPacket> sendQueue;
-    std::deque<MidiPacket> receiveQueue;
-    juce::WaitableEvent dataAvailable;
-
-    juce::StreamingSocket tcpSocket;
-    juce::String remoteHost;
-    int remotePort;
-    bool connected{false};
-
-    uint32_t nextSequenceNumber{0};
-    std::map<uint32_t, MidiPacket> pendingAcks;
-
-    void attemptConnection();
-    void processSendQueue();
-    void sendTcpPacket(const MidiPacket& packet);
-    void receiveData();
-    void sendAck(uint32_t seqNum);
-    void retryUnacknowledged();
-};
-
-} // namespace NetworkMidi
-```
-
-2. **Implement SysEx fragmentation**
-   - File: `TcpMidiTransport.cpp`
-
-```cpp
-void NonRealtimeMidiTransport::sendTcpPacket(const MidiPacket& packet) {
-    // Fragment if SysEx is too large (>1KB chunks)
-    const size_t MAX_FRAGMENT = 1024;
-    size_t offset = 0;
-
-    while (offset < packet.data.size()) {
-        size_t fragmentSize = std::min(MAX_FRAGMENT, packet.data.size() - offset);
-
-        // Build TCP frame: [header][fragment]
-        std::vector<uint8_t> frame;
-        frame.push_back('M');  // Magic
-        frame.push_back('N');  // Non-real-time
-        frame.push_back((packet.sequenceNumber >> 24) & 0xFF);
-        frame.push_back((packet.sequenceNumber >> 16) & 0xFF);
-        frame.push_back((packet.sequenceNumber >> 8) & 0xFF);
-        frame.push_back(packet.sequenceNumber & 0xFF);
-        frame.push_back((fragmentSize >> 8) & 0xFF);
-        frame.push_back(fragmentSize & 0xFF);
-        frame.insert(frame.end(), packet.data.begin() + offset,
-                    packet.data.begin() + offset + fragmentSize);
-
-        int sent = tcpSocket.write(frame.data(), (int)frame.size());
-        if (sent != (int)frame.size()) {
-            connected = false;
-            return;
-        }
-
-        offset += fragmentSize;
-    }
-}
-```
-
-3. **Implement ACK/retry mechanism**
-
-```cpp
-void NonRealtimeMidiTransport::retryUnacknowledged() {
-    auto now = juce::Time::getCurrentTime();
-    std::vector<uint32_t> toRetry;
-
-    for (auto& [seqNum, pending] : pendingAcks) {
-        auto elapsed = now.toMilliseconds() - pending.sentTime.toMilliseconds();
-
-        if (elapsed > 1000 && pending.retryCount < 3) {  // 1s timeout, 3 retries
-            toRetry.push_back(seqNum);
-        } else if (pending.retryCount >= 3) {
-            // Give up - log error
-            DBG("Failed to deliver packet " << seqNum << " after 3 retries");
-            pendingAcks.erase(seqNum);
-        }
-    }
-
-    for (uint32_t seqNum : toRetry) {
-        auto& pending = pendingAcks[seqNum];
-        pending.retryCount++;
-        pending.sentTime = juce::Time::getCurrentTime();
-        sendTcpPacket(pending.packet);
-    }
-}
-```
-
-4. **Unit tests**
-
-```cpp
-TEST(NonRealtimeMidiTransport, SysExReliability) {
-    NonRealtimeMidiTransport transport("127.0.0.1", 5005);
-    transport.startThread();
-
-    // Send 100 large SysEx messages
-    for (int i = 0; i < 100; ++i) {
-        std::vector<uint8_t> sysex(5000);
-        sysex[0] = 0xF0;  // SysEx start
-        for (size_t j = 1; j < sysex.size() - 1; ++j) {
-            sysex[j] = rand() % 128;
-        }
-        sysex.back() = 0xF7;  // SysEx end
-
-        juce::MidiMessage msg(sysex.data(), (int)sysex.size());
-        transport.sendMessage(msg, 0);
-    }
-
-    // Wait for delivery
-    juce::Thread::sleep(10000);
-
-    // Verify 100% delivery
-    auto received = transport.getReceivedMessages();
-    EXPECT_EQ(received.size(), 100);
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] TCP transport thread starts successfully
-- [ ] SysEx fragmentation works (1KB chunks)
-- [ ] ACK/retry mechanism implemented
-- [ ] 100% delivery in reliability test
-- [ ] Latency <100ms for large SysEx
-
----
-
-### Phase C.4: Message Classification and Routing
-
-**Objective**: Route MIDI messages to appropriate transport based on type.
-
-**Duration**: 1-2 hours
-
-#### Tasks
-
-1. **Create message classifier**
-   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/MidiClassifier.h`
-
-```cpp
-#pragma once
-
-#include <juce_audio_basics/juce_audio_basics.h>
-
-namespace NetworkMidi {
-
-enum class MidiMessageClass {
-    RealTime,      // Needs UDP transport
-    NonRealTime    // Needs TCP transport
-};
-
-/**
- * Classify MIDI message by QoS requirements.
- *
- * Real-Time (UDP):
- * - Note On/Off, CC, Pitch Bend (0x80-0xEF)
- * - MIDI Clock, Start, Stop (0xF8-0xFF)
- * - Active Sensing
- *
- * Non-Real-Time (TCP):
- * - System Exclusive (0xF0...0xF7)
- * - Bulk transfers
- */
-inline MidiMessageClass classifyMidiMessage(const juce::MidiMessage& msg) {
-    // System Real-Time messages (0xF8 - 0xFF)
-    if (msg.getRawData()[0] >= 0xF8) {
-        return MidiMessageClass::RealTime;
-    }
-
-    // System Exclusive (0xF0 ... 0xF7)
-    if (msg.isSysEx()) {
-        return MidiMessageClass::NonRealTime;
-    }
-
-    // Channel Voice messages (0x80 - 0xEF)
-    if (msg.getRawData()[0] >= 0x80 && msg.getRawData()[0] < 0xF0) {
-        return MidiMessageClass::RealTime;
-    }
-
-    // Default to non-real-time for safety
-    return MidiMessageClass::NonRealTime;
-}
-
-} // namespace NetworkMidi
-```
-
-2. **Update MIDI input callback to route messages**
-
-```cpp
-void MidiInputCallback::handleIncomingMidiMessage(juce::MidiInput* source,
-                                                   const juce::MidiMessage& msg) {
-    auto messageClass = classifyMidiMessage(msg);
-
-    if (messageClass == MidiMessageClass::RealTime) {
-        // Route to real-time buffer (lock-free)
-        RealtimeMidiBuffer::MidiPacket packet;
-        packet.data[0] = msg.getRawData()[0];
-        packet.data[1] = msg.getRawData()[1];
-        packet.data[2] = msg.getRawData()[2];
-        packet.length = std::min(msg.getRawDataSize(), 4);
-        packet.deviceId = 0;
-        packet.timestamp = juce::Time::getMillisecondCounterHiRes();
-
-        bool success = realtimeBuffer.write(packet);
-        if (!success) {
-            inputDrops.fetch_add(1, std::memory_order_relaxed);
-        }
-    } else {
-        // Route to non-real-time transport (TCP)
-        nonRealtimeTransport.sendMessage(msg, 0);
-    }
-}
-```
-
-3. **Unit tests**
-
-```cpp
-TEST(MidiClassifier, ClassifyNoteOn) {
-    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 100.0f);
-    EXPECT_EQ(classifyMidiMessage(noteOn), MidiMessageClass::RealTime);
-}
-
-TEST(MidiClassifier, ClassifySysEx) {
-    uint8_t sysex[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
-    juce::MidiMessage msg(sysex, 5);
-    EXPECT_EQ(classifyMidiMessage(msg), MidiMessageClass::NonRealTime);
-}
-
-TEST(MidiClassifier, ClassifyMidiClock) {
-    juce::MidiMessage clock(0xF8);
-    EXPECT_EQ(classifyMidiMessage(clock), MidiMessageClass::RealTime);
-}
-```
-
-#### Acceptance Criteria
-
-- [ ] classifyMidiMessage() correctly identifies all message types
-- [ ] MIDI routing works (real-time to UDP, non-real-time to TCP)
-- [ ] Unit tests pass
-- [ ] No classification errors in manual testing
-
----
-
-### Phase C.5: Testing and Validation
-
-**Objective**: Validate dual-transport performance and reliability.
-
-**Duration**: 2-3 hours
-
-#### Tasks
-
-1. **Burst handling test**
-
-```cpp
-TEST(DualTransport, BurstHandling_2000MsgPerSec) {
-    RealtimeMidiBuffer buffer;
-    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
-    transport.startThread();
-
-    // Simulate 2000 msg/sec burst for 1 second
-    for (int i = 0; i < 2000; ++i) {
-        RealtimeMidiBuffer::MidiPacket packet;
-        packet.data[0] = 0x90;
-        packet.data[1] = 60 + (i % 12);
-        packet.data[2] = 100;
-        packet.length = 3;
-        buffer.write(packet);
-
-        // 500µs between messages = 2000 msg/sec
-        std::this_thread::sleep_for(std::chrono::microseconds(500));
-    }
-
-    auto stats = buffer.getStats();
-    EXPECT_LT(stats.dropRate, 1.0f);  // <1% drops
-}
-```
-
-2. **SysEx reliability test**
-
-```cpp
-TEST(DualTransport, SysExReliability_100Percent) {
-    NonRealtimeMidiTransport transport("127.0.0.1", 5005);
-    transport.startThread();
-
-    // Send 100 SysEx messages
-    for (int i = 0; i < 100; ++i) {
-        std::vector<uint8_t> sysex(1000);
-        sysex[0] = 0xF0;
-        for (size_t j = 1; j < sysex.size() - 1; ++j) {
-            sysex[j] = (i * 10 + j) % 128;
-        }
-        sysex.back() = 0xF7;
-
-        juce::MidiMessage msg(sysex.data(), (int)sysex.size());
-        transport.sendMessage(msg, 0);
-    }
-
-    juce::Thread::sleep(5000);
-
-    auto received = transport.getReceivedMessages();
-    EXPECT_EQ(received.size(), 100);  // 100% delivery
-}
-```
-
-3. **Latency measurement test**
-
-```cpp
-TEST(DualTransport, LatencyMeasurement) {
-    RealtimeMidiBuffer buffer;
-    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
-    transport.startThread();
-
-    // Measure round-trip latency
-    auto start = juce::Time::getMillisecondCounterHiRes();
-
-    RealtimeMidiBuffer::MidiPacket packet;
-    packet.data[0] = 0x90;
-    packet.data[1] = 60;
-    packet.data[2] = 100;
-    packet.length = 3;
-    packet.timestamp = start;
-    buffer.write(packet);
-
-    // Wait for response (implementation-specific)
-    juce::Thread::sleep(10);
-
-    auto elapsed = juce::Time::getMillisecondCounterHiRes() - start;
-    EXPECT_LT(elapsed, 1.0);  // <1ms latency
-}
-```
-
-4. **Create metrics endpoint**
-
-```cpp
-// Add to HTTP server
-svr.Get("/metrics", [](const auto& req, auto& res) {
-    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
-
-    auto rtStats = realtimeBuffer.getStats();
-    obj->setProperty("realtime_messages_sent", (int)rtStats.written);
-    obj->setProperty("realtime_messages_dropped", (int)rtStats.dropped);
-    obj->setProperty("realtime_drop_rate", (double)rtStats.dropRate);
-
-    auto nrtStats = nonRealtimeTransport.getStats();
-    obj->setProperty("nonrealtime_messages_sent", (int)nrtStats.sent);
-    obj->setProperty("nonrealtime_retries", (int)nrtStats.retries);
-
-    res.set_content(juce::JSON::toString(juce::var(obj)), "application/json");
-});
-```
-
-#### Acceptance Criteria
-
-- [ ] Burst handling: <1% drops at 2000 msg/sec
-- [ ] SysEx reliability: 100% delivery
-- [ ] Real-time latency: <1ms
-- [ ] Non-real-time latency: <100ms
-- [ ] Metrics endpoint functional
-
----
-
-### Integration with Approaches A and B
-
-#### Integration with Approach A (Mutex Fixes)
-
-**Scenario**: Dual-transport + mutex fixes
-
-**Compatibility**: ✅ **Fully compatible**
-
-- Dual-transport uses its own lock-free buffer (real-time path)
-- TCP path can use mutexes safely (non-real-time)
-- No conflicts with mutex fixes in NetworkConnection
-
-**Implementation notes**:
-- Real-time buffer is lock-free (no mutex issues)
-- TCP queue uses mutex but only for low-frequency SysEx
-- Message routing layer sits above NetworkConnection
-
-#### Integration with Approach B (Full SEDA)
-
-**Scenario**: Dual-transport + SEDA architecture
-
-**Compatibility**: ✅ **Natural fit**
-
-- Real-time MIDI becomes Stage 3A (UDP worker)
-- Non-real-time MIDI becomes Stage 3B (TCP worker)
-- Both integrate cleanly with SEDA command queue pattern
-
-**Implementation notes**:
-- Real-time buffer can be part of SEDA Stage 3A
-- Non-real-time transport can be SEDA Stage 3B
-- Classification layer routes messages to appropriate stage
-
----
-
-## Decision Criteria
-
-### When to Use Each Approach
-
-#### Choose Approach A (Mutex Fixes) if:
-
-- ✅ No confirmed deadlocks in production
-- ✅ Mesh size expected <20 connections
-- ✅ Query latency <1ms acceptable
-- ✅ Development time limited
-- ✅ Lower risk tolerance
-
-#### Choose Approach B (Full SEDA) if:
-
-- ✅ Deadlocks occurring in production
-- ✅ Metrics show >5% mutex contention
-- ✅ Mesh size expected >50 connections
-- ✅ Query latency <100µs required
-- ✅ Long-term scalability critical
-
-#### Choose Approach C (Dual-Transport) if:
-
-- ✅ Need burst MIDI handling (>500 msg/sec)
-- ✅ Need reliable SysEx delivery (100%)
-- ✅ Latency requirements differ by message type
-- ✅ Planning for real-time performance scenarios
-- ✅ Network mesh will carry intensive MIDI traffic
-
-**Key Insight**: Approach C is **orthogonal** to A and B - you can implement dual-transport with either mutex fixes or SEDA.
-
-#### Metrics to Collect After Approach A
-
-```cpp
-// Add instrumentation to NetworkConnection
-class NetworkConnection {
-private:
-    // Contention metrics
-    std::atomic<uint64_t> mutexContentionCount{0};
-    std::atomic<uint64_t> totalMutexAcquisitions{0};
-
-    State getState() const {
-        totalMutexAcquisitions.fetch_add(1);
-
-        std::unique_lock<std::timed_mutex> lock(stateMutex, std::chrono::milliseconds(10));
-        if (!lock.owns_lock()) {
-            mutexContentionCount.fetch_add(1);
-            // ... fallback ...
-        }
-        // ...
-    }
-
-public:
-    double getContentionPercentage() const {
-        uint64_t total = totalMutexAcquisitions.load();
-        return total > 0 ? (100.0 * mutexContentionCount / total) : 0.0;
-    }
-};
-```
-
-**Decision Point**: If contention >5% after 1 week of monitoring → Proceed to Approach B.
-
----
-
-## Integration with Current Phase 6
-
-### Phase 6 Context
-
-According to the project workplan, Phase 6 focuses on:
-- Network mesh topology management
-- Heartbeat monitoring for connection health
-- HTTP endpoints for mesh queries
-- **UDP transport for MIDI messages** (partially implemented)
-
-### Integration Points
-
-#### 1. MeshManager Integration
-
-**Current State**: MeshManager uses ConnectionPool to manage NetworkConnection instances.
-
-**Approach A Impact**:
-- No API changes needed
-- MeshManager continues to call `getState()`, `getRemoteDevices()` as before
-- Callbacks dispatch via message thread (may need test updates)
-
-**Approach B Impact**:
-- No API changes needed (same public interface)
-- Query performance improves significantly
-- May need to update tests for async behavior
-
-**Approach C Impact**:
-- MeshManager routes MIDI messages through classifier
-- Needs to track dual-transport statistics
-- May add `/metrics/midi` endpoint
-
-#### 2. HeartbeatMonitor Integration
-
-**Current State**: HeartbeatMonitor timer calls `getTimeSinceLastHeartbeat()` every 1 second.
-
-**Approach A Impact**:
-- Minor: Callback dispatch becomes async
-- Test update needed to poll for state changes
-
-**Approach B Impact**:
-- Significant performance improvement (atomic read vs mutex)
-- Must post CheckHeartbeatCommand instead of direct setState()
-
-**Approach C Impact**:
-- No direct impact (heartbeats can use existing mechanism)
-- Could optionally use UDP real-time path for heartbeat packets
-
-**Required Change for Approach B**:
-
-```cpp
-// HeartbeatMonitor.cpp
-void HeartbeatMonitor::checkTimeouts()
-{
-    for (auto* connection : connections) {
-        if (connection->getTimeSinceLastHeartbeat() > timeoutMs) {
-            // APPROACH A: Direct call works (async callback)
-            connection->setState(State::Failed);
-
-            // APPROACH B: Post command
-            connection->checkHeartbeat();  // Posts CheckHeartbeatCommand
-        }
-    }
-}
-```
-
-#### 3. HTTP Endpoint Integration
-
-**Current State**: HTTP handlers call `MeshManager::getStatistics()` which queries all connections.
-
-**Approach A Impact**:
-- None - queries work identically
-- Potential latency improvement from reduced contention
-
-**Approach B Impact**:
-- Complex queries (getRemoteDevices) may add <1ms latency
-- Simple queries (getState) become 100x faster
-
-**Approach C Impact**:
-- Add `/metrics/midi` endpoint for transport statistics
-- Show real-time vs non-real-time message counts
-- Display drop rates and latency histograms
-
-**No changes needed for A/B** - public API remains identical.
-
-#### 4. UDP Transport Integration (Phase 6)
-
-**Current State**: UDP transport partially implemented for MIDI messages.
-
-**Approach C Integration**:
-- Existing UDP transport becomes **real-time MIDI path**
-- Add TCP transport as **non-real-time path**
-- Message classifier routes between the two
-- Minimal changes to existing UDP code
-
-**Migration path**:
-1. Wrap existing UDP code in `RealtimeMidiTransport`
-2. Add `RealtimeMidiBuffer` in front of UDP sender
-3. Create parallel `NonRealtimeMidiTransport` for TCP
-4. Add `classifyMidiMessage()` router
-
----
-
-## Testing & Validation Strategy
-
-### Test Matrix
-
-| Test Category | Approach A | Approach B | Approach C | Purpose |
-|--------------|------------|------------|------------|---------|
-| Unit Tests | Update callbacks | Update callbacks + async | MIDI routing | Verify correctness |
-| Integration Tests | Minor updates | Moderate updates | Dual-transport integration | Verify subsystem interaction |
-| Concurrency Tests | New: 100 threads | New: stress test | Burst handling | Verify no deadlocks / overflow |
-| Performance Tests | Baseline only | Full benchmarks | Latency measurement | Verify improvements |
-| Regression Tests | Full suite | Full suite | Full suite | Verify no breakage |
-| TSAN Tests | Required | Required | Required | Verify no races |
-
-### Validation Plan
-
-#### Pre-Implementation Baseline
-
-1. **Capture current metrics**
-
-```bash
-# Build baseline
-cmake -B build-baseline
-cmake --build build-baseline
-
-# Run baseline tests
-./build-baseline/tests/unit/NetworkConnectionTest
-
-# Run baseline benchmarks
-./build-baseline/tests/performance/NetworkConnectionBenchmark > baseline.json
-```
-
-2. **Create test checklist**
-
-```markdown
-- [ ] All 47 existing unit tests pass
-- [ ] Integration test suite passes (mesh topology)
-- [ ] Manual test: Connect 5 nodes, query mesh 100 times
-- [ ] No crashes in 5-minute stress test
-- [ ] ThreadSanitizer clean
-```
-
-#### Post-Implementation Validation
-
-1. **Regression testing**
-
-```bash
-# Build with fixes
-cmake -B build-fixed
-cmake --build build-fixed
-
-# Run all tests
-ctest --test-dir build-fixed --output-on-failure
-
-# Compare results
-diff baseline-results.txt fixed-results.txt
-```
-
-2. **Performance validation**
-
-```bash
-# Run benchmarks
-./build-fixed/tests/performance/NetworkConnectionBenchmark > fixed.json
-
-# Compare
-python3 scripts/compare_benchmarks.py baseline.json fixed.json
-```
-
-Expected output:
-```
-Metric              | Baseline | Fixed   | Change
---------------------|----------|---------|--------
-getState() latency  | 120ns    | 115ns   | -4.2%  ✅
-getDevices() latency| 150ns    | 145ns   | -3.3%  ✅
-Contention rate     | 0.8%     | 0.1%    | -87.5% ✅
-```
-
-3. **Deadlock validation**
-
-```bash
-# ThreadSanitizer build
-cmake -B build-tsan -DCMAKE_CXX_FLAGS="-fsanitize=thread"
-cmake --build build-tsan
-
-# Run concurrency tests
-./build-tsan/tests/unit/NetworkConnectionTest --gtest_filter="*Concurrent*"
-
-# Expected: No TSAN warnings
-```
-
-### Load Testing Strategy
-
-#### Scenario 1: Single Node Under Load
-
-```cpp
-TEST(NetworkConnection, LoadTest_SingleNode_1000QPS) {
-    NetworkConnection conn(testNode);
-    conn.connect();
-
-    auto start = std::chrono::steady_clock::now();
-    int queries = 0;
-
-    while (queries < 10000) {
-        conn.getState();
-        conn.getRemoteDevices();
-        ++queries;
-    }
-
-    auto elapsed = std::chrono::steady_clock::now() - start;
-    auto qps = queries / std::chrono::duration<double>(elapsed).count();
-
-    EXPECT_GT(qps, 1000);  // Should achieve >1000 QPS
-}
-```
-
-#### Scenario 2: Mesh Under Load
-
-```cpp
-TEST(MeshManager, LoadTest_10Nodes_100QPS_Each) {
-    MeshManager mesh;
-
-    // Add 10 nodes
-    for (int i = 0; i < 10; ++i) {
-        mesh.addPeer(createTestNode(i));
-    }
-
-    // Query all nodes 1000 times (100 QPS × 10 nodes)
-    auto start = std::chrono::steady_clock::now();
-
-    for (int i = 0; i < 1000; ++i) {
-        auto stats = mesh.getStatistics();  // Queries all 10 nodes
-        EXPECT_EQ(stats.totalConnections, 10);
-    }
-
-    auto elapsed = std::chrono::steady_clock::now() - start;
-
-    // Should complete in <10 seconds (1000 queries / 100 QPS)
-    EXPECT_LT(elapsed, std::chrono::seconds(10));
-}
-```
-
-#### Scenario 3: Chaos Testing
-
-```cpp
-TEST(NetworkConnection, ChaosTest_RandomOperations) {
-    NetworkConnection conn(testNode);
-
-    std::random_device rd;
-    std::mt19937 gen(rd());
-    std::uniform_int_distribution<> dis(0, 5);
-
-    for (int i = 0; i < 10000; ++i) {
-        switch (dis(gen)) {
-            case 0: conn.connect(); break;
-            case 1: conn.disconnect(); break;
-            case 2: conn.getState(); break;
-            case 3: conn.getRemoteNode(); break;
-            case 4: conn.getRemoteDevices(); break;
-            case 5: conn.checkHeartbeat(); break;
-        }
-
-        // Random delay 0-10ms
-        std::this_thread::sleep_for(
-            std::chrono::milliseconds(dis(gen) * 2));
-    }
-
-    // Should survive chaos without crash
-}
-```
-
-#### Scenario 4: MIDI Burst Testing (NEW - Approach C)
-
-```cpp
-TEST(DualTransport, MIDIBurstTest_2000MsgPerSec) {
-    RealtimeMidiBuffer buffer;
-    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
-    transport.startThread();
-
-    // Simulate intense performance (2000 msg/sec for 5 seconds)
-    for (int second = 0; second < 5; ++second) {
-        for (int i = 0; i < 2000; ++i) {
-            RealtimeMidiBuffer::MidiPacket packet;
-            packet.data[0] = 0x90;  // Note On
-            packet.data[1] = 60 + (i % 12);
-            packet.data[2] = 100;
-            packet.length = 3;
-            buffer.write(packet);
-
-            std::this_thread::sleep_for(std::chrono::microseconds(500));
-        }
-    }
-
-    auto stats = buffer.getStats();
-    EXPECT_LT(stats.dropRate, 1.0f);  // <1% drops over 5 seconds
-}
-```
-
----
-
-## Timeline & Resources
-
-### Approach A: Mutex Fixes Timeline
-
-| Phase | Duration | Developer Hours | Dependencies |
-|-------|----------|----------------|--------------|
-| A.1: Fix callback-under-lock | 30-45 min | 0.75h | None |
-| A.2: Protect remoteDevices | 45-60 min | 1.0h | None |
-| A.3: Add mutex timeouts | 30-45 min | 0.75h | None |
-| A.4: Fix MeshManager lifecycle | 45-60 min | 1.0h | None |
-| A.5: Validation & testing | 30-45 min | 0.75h | All previous |
-| **Total** | **3-4 hours** | **4.25h** | - |
-
-**Critical Path**: Linear (each phase builds on previous)
-**Parallelization**: Minimal (single developer)
-**Calendar Time**: 1 day (with buffer for testing)
-
-### Approach B: Full SEDA Timeline
-
-| Phase | Duration | Developer Hours | Dependencies |
-|-------|----------|----------------|--------------|
-| B.1: Infrastructure setup | 2-3 hours | 2.5h | None |
-| B.2: State migration | 2-3 hours | 2.5h | B.1 |
-| B.3: Mutex removal | 1-2 hours | 1.5h | B.2 |
-| B.4: Integration updates | 2-3 hours | 2.5h | B.3 |
-| B.5: Performance benchmarking | 1-2 hours | 1.5h | B.4 |
-| B.6: TSAN & stress testing | 1-2 hours | 1.5h | B.4 |
-| **Total** | **9-15 hours** | **12h** | - |
-
-**Critical Path**: B.1 → B.2 → B.3 → B.4 → (B.5 + B.6 parallel)
-**Parallelization**: B.5 and B.6 can run in parallel
-**Calendar Time**: 2-3 days (with buffer for debugging)
-
-### Approach C: Dual-Transport Timeline (NEW)
-
-| Phase | Duration | Developer Hours | Dependencies |
-|-------|----------|----------------|--------------|
-| C.1: Real-time ring buffer | 2-3 hours | 2.5h | None |
-| C.2: UDP real-time transport | 2-3 hours | 2.5h | C.1 |
-| C.3: TCP non-real-time transport | 2-3 hours | 2.5h | None (parallel) |
-| C.4: Message classification | 1-2 hours | 1.5h | C.2, C.3 |
-| C.5: Testing & validation | 2-3 hours | 2.5h | All previous |
-| **Total** | **9-14 hours** | **11.5h** | - |
-
-**Critical Path**: C.1 → C.2 → C.4 → C.5 (C.3 can be parallel with C.1/C.2)
-**Parallelization**: C.3 independent of C.1/C.2
-**Calendar Time**: 2 days (with buffer for testing)
-
-### Combined Timeline: A + C (Recommended)
-
-| Phase | Duration | Developer Hours | Dependencies |
-|-------|----------|----------------|--------------|
-| **Week 1** | | | |
-| A.1-A.5: Mutex fixes | 3-4 hours | 4.25h | None |
-| **Week 2** | | | |
-| C.1-C.2: Real-time path | 4-6 hours | 5h | None |
-| C.3: Non-real-time path | 2-3 hours | 2.5h | Parallel |
-| **Week 3** | | | |
-| C.4-C.5: Integration & testing | 3-5 hours | 4h | C.1-C.3 |
-| **Total** | **12-18 hours** | **15.75h** | - |
-
-**Calendar Time**: 3 weeks (relaxed schedule with testing)
-
-### Resource Requirements
-
-#### Approach A
-
-- **Developers**: 1 senior C++ developer
-- **Skills Required**:
-  - C++17 threading (std::mutex, std::atomic)
-  - JUCE framework (MessageManager)
-  - Unit testing (GTest)
-- **Infrastructure**:
-  - Development machine with TSAN support
-  - CI/CD pipeline with sanitizer builds
-
-#### Approach B
-
-- **Developers**: 1 senior C++ developer + 1 reviewer
-- **Skills Required**:
-  - Advanced C++ concurrency patterns
-  - JUCE threading model (juce::Thread, juce::WaitableEvent)
-  - Event-driven architecture design
-  - Performance profiling tools
-- **Infrastructure**:
-  - Development machine with TSAN support
-  - Benchmarking environment (isolated CPU cores)
-  - CI/CD with performance regression detection
-
-#### Approach C (NEW)
-
-- **Developers**: 1 senior C++ developer
-- **Skills Required**:
-  - Lock-free data structures (juce::AbstractFifo)
-  - Network programming (UDP/TCP)
-  - MIDI protocol knowledge
-  - Real-time systems experience
-- **Infrastructure**:
-  - Development machine with network access
-  - MIDI hardware for testing (optional)
-  - Packet capture tools (Wireshark)
-  - Latency measurement tools
-
-### External Dependencies
-
-- **JUCE Framework**: Version 6.0+ (for modern threading primitives)
-- **httplib**: Version 0.14.3 (already integrated)
-- **GTest**: For unit testing
-- **Google Benchmark**: For performance testing (optional for Approach A, required for B)
-- **ThreadSanitizer**: Part of Clang/GCC toolchain
-
----
-
-## Risk Assessment
-
-### Approach A Risks
-
-| Risk | Probability | Impact | Mitigation |
-|------|------------|--------|------------|
-| Callback timing breaks tests | Medium | Low | Update tests to poll for callbacks |
-| Atomic shared_ptr not available in C++17 | Low | Medium | Use C++20 or mutex fallback |
-| Mutex timeouts cause false alarms | Low | Low | Tune timeout values (100-500ms) |
-| Contention persists after fixes | Medium | Medium | Be prepared to escalate to Approach B |
-| Performance regression | Low | Low | Run baseline benchmarks first |
-
-**Overall Risk**: Low
-
-### Approach B Risks
-
-| Risk | Probability | Impact | Mitigation |
-|------|------------|--------|------------|
-| Command latency breaks real-time requirements | Low | High | Use atomic snapshots for hot paths |
-| Worker thread doesn't shut down cleanly | Medium | Medium | Implement robust shutdown with timeout |
-| Query commands deadlock | Low | Critical | Use WaitableEvent with timeout |
-| Increased memory usage (command queue) | Low | Low | Monitor queue depth, add bounds |
-| Complexity increases bug surface area | Medium | Medium | Comprehensive testing, code review |
-| Migration breaks existing tests | High | Medium | Update tests incrementally, maintain backward compat |
-| Performance doesn't meet targets | Low | High | Benchmark early (Phase B.1), pivot if needed |
-
-**Overall Risk**: Medium
-
-### Approach C Risks (NEW)
-
-| Risk | Probability | Impact | Mitigation |
-|------|------------|--------|------------|
-| Ring buffer sizing inadequate for bursts | Low | Medium | Monitor drop rates, increase capacity if needed |
-| UDP packet loss in network | Medium | Low | Expected - monitor drop rates, acceptable for real-time |
-| TCP connection failures | Medium | Medium | Retry logic (3 retries, 1s timeout) |
-| Message classification errors | Low | High | Comprehensive unit tests, manual validation |
-| Real-time priority not available on platform | Low | Medium | Graceful fallback to normal priority |
-| Latency targets not met | Medium | High | Benchmark early, optimize UDP path |
-| SysEx fragmentation bugs | Medium | Medium | Test with large SysEx messages (10KB+) |
-
-**Overall Risk**: Medium
-
-### Mitigation Strategies
-
-#### For All Approaches
-
-1. **Feature Branch Development**
-   - Create `feature/mutex-fixes`, `feature/seda-migration`, or `feature/dual-transport` branch
-   - No direct commits to main
-   - Require PR review before merge
-
-2. **Incremental Testing**
-   - Run tests after each phase
-   - Use CI/CD to catch regressions early
-   - Maintain passing tests at all times
-
-3. **Performance Monitoring**
-   - Establish baseline metrics before changes
-   - Monitor metrics after each phase
-   - Rollback if regressions >10%
-
-4. **Canary Deployment**
-   - Deploy to test environment first
-   - Monitor for 24-48 hours
-   - Gradual rollout to production
-
----
-
-## Rollback Procedures
-
-### Approach A Rollback
-
-**Simplicity**: Trivial (single commit revert)
-
-```bash
-# If issues detected after merge
-git revert <commit-hash>
-git push origin main
-
-# Rebuild
-cmake --build build
-ctest --test-dir build
-```
-
-**Recovery Time**: <10 minutes
-
-**Data Loss**: None (no state migration)
-
-### Approach B Rollback
-
-**Complexity**: Moderate (may span multiple commits)
-
-#### Option 1: Clean Revert (If Single Merge Commit)
-
-```bash
-git revert -m 1 <merge-commit>
-git push origin main
-```
-
-#### Option 2: Branch Revert (If Multiple Commits)
-
-```bash
-# Create rollback branch
-git checkout -b rollback/seda-migration
-
-# Revert range of commits
-git revert <first-commit>..<last-commit>
-
-# Test rollback
-cmake --build build
-ctest --test-dir build
-
-# Push rollback
-git push origin rollback/seda-migration
-```
-
-#### Option 3: Forward Fix (If Partial Issues)
-
-If only specific components broken:
-
-```bash
-# Fix individual issues without full rollback
-git checkout main
-git cherry-pick <working-commit>
-```
-
-**Recovery Time**: 30-60 minutes
-
-**Data Loss**: None (runtime state only)
-
-### Approach C Rollback (NEW)
-
-**Complexity**: Moderate (independent feature)
-
-#### Option 1: Feature Flag Disable
-
-```cpp
-// Add feature flag in configuration
-static constexpr bool ENABLE_DUAL_TRANSPORT = false;
-
-if (ENABLE_DUAL_TRANSPORT) {
-    // Use dual-transport
-    auto msgClass = classifyMidiMessage(msg);
-    // ...
-} else {
-    // Use original single transport
-    sendViaSingleTransport(msg);
-}
-```
-
-**Recovery Time**: <5 minutes (config change)
-
-#### Option 2: Git Revert
-
-```bash
-git revert <dual-transport-merge-commit>
-git push origin main
-```
-
-**Recovery Time**: 15-30 minutes
-
-**Data Loss**: None (transport layer only)
-
-### Rollback Decision Criteria
-
-| Severity | Symptom | Action | Timeline |
-|----------|---------|--------|----------|
-| P0 | Production deadlocks | Immediate rollback | <15 min |
-| P1 | Crashes in <1% of requests | Rollback within 1 hour | <1 hour |
-| P2 | Performance regression >20% | Rollback within 4 hours | <4 hours |
-| P3 | Minor test failures | Forward fix | <1 day |
-
-### Rollback Testing
-
-Before deploying any approach, verify rollback procedure:
-
-```bash
-# Simulate rollback in test environment
-git checkout test-environment
-git merge feature/mutex-fixes
-# ... deploy, verify working ...
-git revert HEAD
-# ... verify rollback successful ...
-```
-
----
-
-## Appendix A: Command Reference
-
-### Build Commands
-
-```bash
-# Clean build
-rm -rf build && cmake -B build && cmake --build build
-
-# Build with sanitizers
-cmake -B build-tsan -DCMAKE_CXX_FLAGS="-fsanitize=thread -g"
-cmake --build build-tsan
-
-# Build with optimizations
-cmake -B build-release -DCMAKE_BUILD_TYPE=Release
-cmake --build build-release
-
-# Run tests
-ctest --test-dir build --output-on-failure
-
-# Run specific test
-./build/tests/unit/NetworkConnectionTest --gtest_filter="*Concurrent*"
-```
-
-### Monitoring Commands
-
-```bash
-# Check for deadlocks (requires gdb)
-gdb -batch -ex "thread apply all bt" ./build/MidiHttpServer
-
-# Monitor queue depth (add to ConnectionWorker)
-watch -n 1 "grep 'Queue depth' /var/log/midi-server.log"
-
-# Check contention percentage
-curl http://localhost:8080/debug/metrics | jq '.contention_percent'
-
-# Monitor MIDI transport metrics (Approach C)
-curl http://localhost:8080/metrics/midi | jq '.realtime_drop_rate'
-```
-
----
-
-## Appendix B: Checklist Summary
-
-### Approach A Checklist
-
-- [ ] Phase A.1: Callback-under-lock fixed
-  - [ ] setState() releases locks before callback
-  - [ ] Callbacks dispatched via MessageManager
-  - [ ] Tests updated for async callbacks
-- [ ] Phase A.2: remoteDevices protected
-  - [ ] Mutex or atomic shared_ptr protecting reads/writes
-  - [ ] No TSAN warnings
-- [ ] Phase A.3: Mutex timeouts added
-  - [ ] All mutexes use std::timed_mutex
-  - [ ] Timeouts logged
-  - [ ] Fallback to atomics where possible
-- [ ] Phase A.4: MeshManager fixed
-  - [ ] Pool iteration protected from use-after-free
-  - [ ] withAllConnections helper implemented
-- [ ] Phase A.5: Validation complete
-  - [ ] All tests pass
-  - [ ] Benchmarks show no regression
-  - [ ] TSAN clean
-  - [ ] Contention metrics <1%
-
-### Approach B Checklist
-
-- [ ] Phase B.1: Infrastructure
-  - [ ] NetworkCommands.h created
-  - [ ] CommandQueue.h created and tested
-  - [ ] ConnectionWorker.h created
-  - [ ] Worker thread lifecycle tested
-- [ ] Phase B.2: State migration
-  - [ ] NetworkConnection uses worker
-  - [ ] Atomic snapshots for getState(), getHeartbeat()
-  - [ ] Query commands for complex data
-  - [ ] All handlers implemented
-- [ ] Phase B.3: Mutex removal
-  - [ ] All mutex fields removed
-  - [ ] All lock_guard removed
-  - [ ] TSAN clean
-- [ ] Phase B.4: Integration
-  - [ ] MeshManager works with new API
-  - [ ] HeartbeatMonitor works with new API
-  - [ ] HTTP handlers work with new API
-  - [ ] All integration tests pass
-- [ ] Phase B.5: Performance
-  - [ ] Benchmarks created
-  - [ ] getState() <20ns
-  - [ ] getRemoteDevices() <1ms
-  - [ ] 100 threads <1ms total
-- [ ] Phase B.6: Stress testing
-  - [ ] TSAN build passes
-  - [ ] 60-second stress test passes
-  - [ ] >1M queries/minute achieved
-  - [ ] No memory leaks
-
-### Approach C Checklist (NEW)
-
-- [ ] Phase C.1: Real-time ring buffer
-  - [ ] RealtimeMidiBuffer.h created
-  - [ ] write() with drop-oldest policy implemented
-  - [ ] readBatch() for efficient reading
-  - [ ] getStats() for monitoring
-  - [ ] Unit tests pass
-  - [ ] Burst handling test passes (2000 msg/sec)
-- [ ] Phase C.2: UDP real-time transport
-  - [ ] RealtimeMidiTransport thread created
-  - [ ] Real-time priority set (9)
-  - [ ] Non-blocking UDP send/receive
-  - [ ] Packet serialization implemented
-  - [ ] Latency <1ms verified
-- [ ] Phase C.3: TCP non-real-time transport
-  - [ ] NonRealtimeMidiTransport thread created
-  - [ ] TCP connection management
-  - [ ] SysEx fragmentation (1KB chunks)
-  - [ ] SysEx reassembly with sequence numbers
-  - [ ] ACK/retry mechanism (1s timeout, 3 retries)
-  - [ ] 100% delivery verified
-- [ ] Phase C.4: Message classification
-  - [ ] classifyMidiMessage() implemented
-  - [ ] Message routing works correctly
-  - [ ] Unit tests for all MIDI message types
-- [ ] Phase C.5: Testing & validation
-  - [ ] Burst handling test passes (<1% drops)
-  - [ ] SysEx reliability test passes (100%)
-  - [ ] Latency tests pass (RT <1ms, NRT <100ms)
-  - [ ] /metrics/midi endpoint functional
-  - [ ] Integration with existing code complete
-
----
-
-## Appendix C: Metrics Dashboard
-
-### Recommended Metrics to Track
-
-```cpp
-// Add to NetworkConnection (both approaches)
-struct ConnectionMetrics {
-    std::atomic<uint64_t> totalQueries{0};
-    std::atomic<uint64_t> mutexContentions{0};
-    std::atomic<uint64_t> callbacksDispatched{0};
-    std::atomic<uint64_t> commandsProcessed{0};  // SEDA only
-
-    void recordQuery(int64_t latencyNs) {
-        totalQueries.fetch_add(1);
-    }
-
-    nlohmann::json toJson() const {
-        return {
-            {"total_queries", totalQueries.load()},
-            {"mutex_contentions", mutexContentions.load()},
-            {"contention_percent", getContentionPercent()},
-            {"callbacks_dispatched", callbacksDispatched.load()},
-            {"commands_processed", commandsProcessed.load()}
-        };
-    }
-
-    double getContentionPercent() const {
-        uint64_t total = totalQueries.load();
-        return total > 0 ? (100.0 * mutexContentions / total) : 0.0;
-    }
-};
-```
-
-### MIDI Transport Metrics (Approach C - NEW)
-
-```cpp
-struct MidiTransportMetrics {
-    // Real-time path (UDP)
-    std::atomic<uint64_t> realtimeMessagesSent{0};
-    std::atomic<uint64_t> realtimeMessagesReceived{0};
-    std::atomic<uint64_t> realtimeMessagesDropped{0};
-    std::atomic<uint64_t> udpSendFailures{0};
-
-    // Non-real-time path (TCP)
-    std::atomic<uint64_t> nonRealtimeMessagesSent{0};
-    std::atomic<uint64_t> nonRealtimeMessagesReceived{0};
-    std::atomic<uint64_t> tcpRetries{0};
-    std::atomic<uint64_t> tcpFragmentsSent{0};
-
-    nlohmann::json toJson() const {
-        return {
-            {"realtime_sent", realtimeMessagesSent.load()},
-            {"realtime_received", realtimeMessagesReceived.load()},
-            {"realtime_dropped", realtimeMessagesDropped.load()},
-            {"realtime_drop_rate", calculateDropRate()},
-            {"nonrealtime_sent", nonRealtimeMessagesSent.load()},
-            {"nonrealtime_received", nonRealtimeMessagesReceived.load()},
-            {"tcp_retries", tcpRetries.load()},
-            {"tcp_retry_rate", calculateRetryRate()}
-        };
-    }
-
-    double calculateDropRate() const {
-        uint64_t sent = realtimeMessagesSent.load();
-        uint64_t dropped = realtimeMessagesDropped.load();
-        return sent > 0 ? (100.0 * dropped / sent) : 0.0;
-    }
-
-    double calculateRetryRate() const {
-        uint64_t sent = nonRealtimeMessagesSent.load();
-        uint64_t retries = tcpRetries.load();
-        return sent > 0 ? (100.0 * retries / sent) : 0.0;
-    }
-};
-```
-
-### HTTP Debug Endpoint
-
-```cpp
-// Add to HTTP server
-svr.Get("/debug/connection/:uuid/metrics", [](const auto& req, auto& res) {
-    auto uuid = req.path_params.at("uuid");
-    auto* conn = meshManager.getConnection(uuid);
-
-    if (!conn) {
-        res.status = 404;
-        return;
-    }
-
-    res.set_content(conn->getMetrics().toJson().dump(), "application/json");
-});
-
-// Approach C: Add MIDI transport metrics
-svr.Get("/metrics/midi", [](const auto& req, auto& res) {
-    auto metrics = midiTransportMetrics.toJson();
-    res.set_content(metrics.dump(), "application/json");
-});
-```
+**Current Implementation Status**:
+- ✅ **Phase B.1 COMPLETED** - SEDA infrastructure in place
+- ⏸️ **Phase B.2 READY** - Command handlers ready for implementation
+- 📊 **Monitoring Plan** - Collect metrics before proceeding with full migration
 
 ---
 
-**Document Status**: Ready for Execution
-**Recommended Start**: Approach A (Mutex Fixes) + Approach C (Dual-Transport) in parallel or sequence
-**Decision Point**: Re-evaluate Approach B after 1 week of production monitoring
-**Next Steps**:
-1. Create feature branch for Approach A
-2. Create feature branch for Approach C (can be parallel)
-3. Begin Phase A.1 and/or Phase C.1
+_The rest of the workplan continues with detailed implementation steps for each approach..._
diff --git a/modules/juce/midi-server/network/mesh/Commands.h b/modules/juce/midi-server/network/mesh/Commands.h
new file mode 100644
index 0000000..4edbb49
--- /dev/null
+++ b/modules/juce/midi-server/network/mesh/Commands.h
@@ -0,0 +1,103 @@
+/**
+ * Commands.h
+ *
+ * Command hierarchy for SEDA architecture in NetworkConnection.
+ * Provides type-safe commands for the connection worker thread.
+ */
+
+#pragma once
+
+#include "NetworkConnection.h"
+#include <juce_events/juce_events.h>
+#include <memory>
+#include <vector>
+
+namespace NetworkMidi {
+namespace Commands {
+
+//==============================================================================
+/**
+ * Base command class for all NetworkConnection commands.
+ * Uses polymorphism for type-safe command dispatch.
+ */
+struct Command {
+    enum Type {
+        Connect,
+        Disconnect,
+        CheckHeartbeat,
+        NotifyHeartbeat,
+        SendMidi,
+        GetState,
+        GetRemoteNode,
+        GetDevices,
+        Shutdown
+    };
+
+    Type type;
+    virtual ~Command() = default;
+
+protected:
+    explicit Command(Type t) : type(t) {}
+};
+
+//==============================================================================
+// Simple commands (no parameters)
+
+struct ConnectCommand : Command {
+    ConnectCommand() : Command(Connect) {}
+};
+
+struct DisconnectCommand : Command {
+    DisconnectCommand() : Command(Disconnect) {}
+};
+
+struct CheckHeartbeatCommand : Command {
+    CheckHeartbeatCommand() : Command(CheckHeartbeat) {}
+};
+
+struct NotifyHeartbeatCommand : Command {
+    NotifyHeartbeatCommand() : Command(NotifyHeartbeat) {}
+};
+
+struct ShutdownCommand : Command {
+    ShutdownCommand() : Command(Shutdown) {}
+};
+
+//==============================================================================
+// Commands with parameters
+
+struct SendMidiCommand : Command {
+    uint16_t deviceId;
+    std::vector<uint8_t> data;
+
+    SendMidiCommand(uint16_t id, std::vector<uint8_t> msgData)
+        : Command(SendMidi), deviceId(id), data(std::move(msgData)) {}
+};
+
+//==============================================================================
+// Query commands with synchronous response mechanism
+// Uses juce::WaitableEvent to block caller until worker responds
+
+struct GetStateQuery : Command {
+    juce::WaitableEvent responseReady;
+    NetworkConnection::State result{NetworkConnection::State::Disconnected};
+
+    GetStateQuery() : Command(GetState) {}
+};
+
+struct GetRemoteNodeQuery : Command {
+    juce::WaitableEvent responseReady;
+    NodeInfo result;
+
+    GetRemoteNodeQuery() : Command(GetRemoteNode) {}
+};
+
+struct GetDevicesQuery : Command {
+    juce::WaitableEvent responseReady;
+    std::vector<DeviceInfo> result;
+
+    GetDevicesQuery() : Command(GetDevices) {}
+};
+
+} // namespace Commands
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp b/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
new file mode 100644
index 0000000..7a762bc
--- /dev/null
+++ b/modules/juce/midi-server/network/mesh/ConnectionWorker.cpp
@@ -0,0 +1,367 @@
+/**
+ * ConnectionWorker.cpp
+ *
+ * Implementation of worker thread for NetworkConnection SEDA architecture.
+ */
+
+#include "ConnectionWorker.h"
+#include <juce_core/juce_core.h>
+#include <sstream>
+
+namespace NetworkMidi {
+
+ConnectionWorker::ConnectionWorker(NetworkConnectionQueue& queue,
+                                   const NodeInfo& remoteNode,
+                                   std::function<void(NetworkConnection::State, NetworkConnection::State)> stateCallback,
+                                   std::function<void(const std::vector<DeviceInfo>&)> devicesCallback,
+                                   std::function<void(const MidiMessage&)> midiCallback,
+                                   std::function<void(const juce::String&)> errorCallback)
+    : juce::Thread("ConnectionWorker")
+    , commandQueue(queue)
+    , remoteNodeInfo(remoteNode)
+    , onStateChanged(std::move(stateCallback))
+    , onDevicesReceived(std::move(devicesCallback))
+    , onMidiMessageReceived(std::move(midiCallback))
+    , onError(std::move(errorCallback))
+{
+}
+
+ConnectionWorker::~ConnectionWorker()
+{
+    // Ensure thread stops before destruction
+    stopThread(2000);  // 2 second timeout
+}
+
+void ConnectionWorker::run()
+{
+    juce::Logger::writeToLog("ConnectionWorker: Thread started for " + remoteNodeInfo.name);
+
+    while (!threadShouldExit()) {
+        // Wait for command with 100ms timeout
+        // Timeout allows periodic checks of threadShouldExit()
+        auto cmd = commandQueue.waitAndPop(100);
+
+        if (cmd) {
+            processCommand(std::move(cmd));
+        }
+    }
+
+    juce::Logger::writeToLog("ConnectionWorker: Thread exiting");
+}
+
+void ConnectionWorker::processCommand(std::unique_ptr<Commands::Command> cmd)
+{
+    jassert(cmd != nullptr);
+
+    switch (cmd->type) {
+        case Commands::Command::Connect:
+            handleConnectCommand();
+            break;
+
+        case Commands::Command::Disconnect:
+            handleDisconnectCommand();
+            break;
+
+        case Commands::Command::CheckHeartbeat:
+            handleCheckHeartbeatCommand();
+            break;
+
+        case Commands::Command::NotifyHeartbeat:
+            handleNotifyHeartbeatCommand();
+            break;
+
+        case Commands::Command::SendMidi:
+            handleSendMidiCommand(static_cast<Commands::SendMidiCommand*>(cmd.get()));
+            break;
+
+        case Commands::Command::GetState:
+            handleGetStateQuery(static_cast<Commands::GetStateQuery*>(cmd.get()));
+            break;
+
+        case Commands::Command::GetRemoteNode:
+            handleGetRemoteNodeQuery(static_cast<Commands::GetRemoteNodeQuery*>(cmd.get()));
+            break;
+
+        case Commands::Command::GetDevices:
+            handleGetDevicesQuery(static_cast<Commands::GetDevicesQuery*>(cmd.get()));
+            break;
+
+        case Commands::Command::Shutdown:
+            juce::Logger::writeToLog("ConnectionWorker: Shutdown command received");
+            signalThreadShouldExit();
+            break;
+
+        default:
+            juce::Logger::writeToLog("ConnectionWorker: Unknown command type: " +
+                                    juce::String(static_cast<int>(cmd->type)));
+            jassertfalse;
+            break;
+    }
+}
+
+//==============================================================================
+// Command handlers
+
+void ConnectionWorker::handleConnectCommand()
+{
+    // Check if already connecting or connected
+    if (currentState == NetworkConnection::State::Connecting ||
+        currentState == NetworkConnection::State::Connected) {
+        juce::Logger::writeToLog("ConnectionWorker: Already connecting/connected, ignoring connect command");
+        return;
+    }
+
+    setState(NetworkConnection::State::Connecting);
+
+    try {
+        // Initialize HTTP client
+        std::string baseUrl = "http://" + remoteNodeInfo.ipAddress.toStdString() + ":" +
+                             std::to_string(remoteNodeInfo.httpPort);
+        httpClient = std::make_unique<httplib::Client>(baseUrl);
+        httpClient->set_connection_timeout(5, 0);  // 5 seconds
+        httpClient->set_read_timeout(5, 0);
+
+        // Initialize and bind UDP socket to any available port
+        udpSocket = std::make_unique<juce::DatagramSocket>();
+        if (!udpSocket->bindToPort(0)) {  // 0 = any available port
+            throw std::runtime_error("Failed to bind UDP socket");
+        }
+
+        // Get local UDP endpoint
+        int localUdpPort = udpSocket->getBoundPort();
+        localUdpEndpoint = juce::IPAddress::getLocalAddress().toString() + ":" +
+                          juce::String(localUdpPort);
+
+        // Prepare handshake JSON request body
+        std::ostringstream requestBody;
+        requestBody << "{"
+                   << "\"node_id\":\"" << juce::Uuid().toString().toStdString() << "\","
+                   << "\"node_name\":\"local-node\","  // TODO: Get from NodeIdentity
+                   << "\"udp_endpoint\":\"" << localUdpEndpoint.toStdString() << "\","
+                   << "\"version\":\"1.0\""
+                   << "}";
+
+        // Send handshake request
+        auto res = httpClient->Post("/network/handshake",
+                                   requestBody.str(),
+                                   "application/json");
+
+        if (!res) {
+            throw std::runtime_error("Failed to send handshake request: " +
+                                   httplib::to_string(res.error()));
+        }
+
+        if (res->status != 200) {
+            throw std::runtime_error("Handshake failed with HTTP " +
+                                   std::to_string(res->status));
+        }
+
+        // Parse response - extract UDP endpoint
+        std::string responseBody = res->body;
+        size_t udpPos = responseBody.find("\"udp_endpoint\":\"");
+        if (udpPos != std::string::npos) {
+            udpPos += 16;
+            size_t endPos = responseBody.find("\"", udpPos);
+            remoteUdpEndpoint = juce::String(responseBody.substr(udpPos, endPos - udpPos));
+        } else {
+            throw std::runtime_error("Handshake response missing udp_endpoint");
+        }
+
+        // Parse devices array (basic parsing for now)
+        size_t devicesPos = responseBody.find("\"devices\":[");
+        if (devicesPos != std::string::npos) {
+            // TODO: Implement proper JSON parsing for device list
+            juce::Logger::writeToLog("Received device list from " + remoteNodeInfo.name);
+
+            // Notify callback if devices were received
+            if (onDevicesReceived) {
+                onDevicesReceived(remoteDevices);
+            }
+        }
+
+        // Connection successful
+        running = true;
+        setState(NetworkConnection::State::Connected);
+
+        // Initialize heartbeat timestamp
+        lastHeartbeatTime = juce::Time::getCurrentTime().toMilliseconds();
+        updateSnapshots();
+
+        juce::Logger::writeToLog("Successfully connected to " + remoteNodeInfo.name +
+                                " (UDP: " + remoteUdpEndpoint + ")");
+
+    } catch (const std::exception& e) {
+        juce::Logger::writeToLog("Handshake failed: " + juce::String(e.what()));
+
+        setState(NetworkConnection::State::Failed);
+        updateSnapshots();
+
+        if (onError) {
+            onError(juce::String("Handshake failed: ") + e.what());
+        }
+    }
+}
+
+void ConnectionWorker::handleDisconnectCommand()
+{
+    juce::Logger::writeToLog("ConnectionWorker: Disconnecting from " + remoteNodeInfo.name);
+
+    // Set running flag to false
+    running = false;
+
+    // Shutdown and reset network resources
+    if (udpSocket) {
+        udpSocket->shutdown();
+        udpSocket.reset();
+    }
+
+    httpClient.reset();
+
+    // Clear received messages
+    receivedMessages.clear();
+
+    // Reset endpoints
+    localUdpEndpoint.clear();
+    remoteUdpEndpoint.clear();
+
+    // Update state
+    setState(NetworkConnection::State::Disconnected);
+    updateSnapshots();
+}
+
+void ConnectionWorker::handleCheckHeartbeatCommand()
+{
+    if (currentState != NetworkConnection::State::Connected) {
+        return;
+    }
+
+    // Calculate time since last heartbeat
+    juce::int64 currentTime = juce::Time::getCurrentTime().toMilliseconds();
+    juce::int64 timeSinceHeartbeat = currentTime - lastHeartbeatTime;
+
+    if (timeSinceHeartbeat > HEARTBEAT_TIMEOUT_MS) {
+        juce::Logger::writeToLog("ConnectionWorker: Heartbeat timeout for " +
+                                remoteNodeInfo.name + " (" +
+                                juce::String(timeSinceHeartbeat) + "ms)");
+
+        setState(NetworkConnection::State::Failed);
+        updateSnapshots();
+
+        if (onError) {
+            onError("Heartbeat timeout - connection lost");
+        }
+    }
+}
+
+void ConnectionWorker::handleNotifyHeartbeatCommand()
+{
+    // Update heartbeat timestamp
+    lastHeartbeatTime = juce::Time::getCurrentTime().toMilliseconds();
+    heartbeatSnapshot.store(lastHeartbeatTime);
+
+    juce::Logger::writeToLog("ConnectionWorker: Heartbeat received from " + remoteNodeInfo.name);
+}
+
+void ConnectionWorker::handleSendMidiCommand(Commands::SendMidiCommand* cmd)
+{
+    jassert(cmd != nullptr);
+
+    // Validate connection state
+    if (currentState != NetworkConnection::State::Connected) {
+        juce::Logger::writeToLog("ConnectionWorker: Cannot send MIDI - not connected");
+        return;
+    }
+
+    // Validate data
+    if (cmd->data.empty()) {
+        juce::Logger::writeToLog("ConnectionWorker: Cannot send empty MIDI message");
+        return;
+    }
+
+    // TODO: Implement actual UDP MIDI packet transmission
+    // This will use MidiPacket protocol when implemented
+    juce::Logger::writeToLog("ConnectionWorker: Sending MIDI message - deviceId=" +
+                            juce::String(cmd->deviceId) +
+                            ", bytes=" + juce::String((int)cmd->data.size()));
+}
+
+void ConnectionWorker::handleGetStateQuery(Commands::GetStateQuery* query)
+{
+    jassert(query != nullptr);
+
+    // Return current state
+    query->result = currentState;
+
+    // Signal response ready
+    query->responseReady.signal();
+}
+
+void ConnectionWorker::handleGetRemoteNodeQuery(Commands::GetRemoteNodeQuery* query)
+{
+    jassert(query != nullptr);
+
+    // Return remote node info
+    query->result = remoteNodeInfo;
+
+    // Signal response ready
+    query->responseReady.signal();
+}
+
+void ConnectionWorker::handleGetDevicesQuery(Commands::GetDevicesQuery* query)
+{
+    jassert(query != nullptr);
+
+    // Return device list
+    query->result = remoteDevices;
+
+    // Signal response ready
+    query->responseReady.signal();
+}
+
+//==============================================================================
+// Helper methods
+
+void ConnectionWorker::setState(NetworkConnection::State newState)
+{
+    NetworkConnection::State oldState = currentState;
+
+    // Check if state actually changed
+    if (oldState == newState) {
+        return;
+    }
+
+    // Update state
+    currentState = newState;
+    stateSnapshot.store(newState);
+
+    // Log state transition
+    juce::Logger::writeToLog("ConnectionWorker: State changed: " +
+                            toString(oldState) + " -> " + toString(newState));
+
+    // Invoke callback if set
+    if (onStateChanged) {
+        onStateChanged(oldState, newState);
+    }
+}
+
+void ConnectionWorker::updateSnapshots()
+{
+    stateSnapshot.store(currentState);
+    heartbeatSnapshot.store(lastHeartbeatTime);
+}
+
+void ConnectionWorker::handleUdpPacket(const void* data, int size,
+                                      const juce::String& sender, int port)
+{
+    // TODO: Implement UDP packet handling with MidiPacket protocol
+    // For now, just log receipt
+    juce::Logger::writeToLog("ConnectionWorker: Received UDP packet: " +
+                            juce::String(size) + " bytes from " +
+                            sender + ":" + juce::String(port));
+
+    // Update heartbeat timestamp
+    lastHeartbeatTime = juce::Time::getCurrentTime().toMilliseconds();
+    heartbeatSnapshot.store(lastHeartbeatTime);
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/mesh/ConnectionWorker.h b/modules/juce/midi-server/network/mesh/ConnectionWorker.h
new file mode 100644
index 0000000..533547c
--- /dev/null
+++ b/modules/juce/midi-server/network/mesh/ConnectionWorker.h
@@ -0,0 +1,148 @@
+/**
+ * ConnectionWorker.h
+ *
+ * Worker thread for NetworkConnection SEDA architecture.
+ * Processes commands from queue in dedicated thread.
+ */
+
+#pragma once
+
+#include "NetworkConnectionQueue.h"
+#include "NetworkConnection.h"
+#include "Commands.h"
+#include "../../httplib.h"
+#include <juce_core/juce_core.h>
+#include <atomic>
+#include <functional>
+#include <memory>
+#include <vector>
+
+namespace NetworkMidi {
+
+//==============================================================================
+/**
+ * ConnectionWorker is the single-threaded event loop for NetworkConnection.
+ *
+ * Design Principles:
+ * - Single thread owns all mutable state (no mutexes needed)
+ * - Commands received via lock-free queue
+ * - State queries use atomic snapshots for fast reads
+ * - Complex queries use command pattern with blocking response
+ *
+ * Thread Safety:
+ * - run() executes on worker thread
+ * - All state access happens on worker thread
+ * - Snapshot methods use atomics (callable from any thread)
+ */
+class ConnectionWorker : public juce::Thread {
+public:
+    /**
+     * Creates worker thread for processing connection commands.
+     *
+     * @param queue Command queue to process
+     * @param remoteNode Information about the remote node
+     * @param stateCallback Called when connection state changes
+     * @param devicesCallback Called when device list is received
+     * @param midiCallback Called when MIDI message is received
+     * @param errorCallback Called when an error occurs
+     */
+    explicit ConnectionWorker(NetworkConnectionQueue& queue,
+                             const NodeInfo& remoteNode,
+                             std::function<void(NetworkConnection::State, NetworkConnection::State)> stateCallback,
+                             std::function<void(const std::vector<DeviceInfo>&)> devicesCallback,
+                             std::function<void(const MidiMessage&)> midiCallback,
+                             std::function<void(const juce::String&)> errorCallback);
+
+    ~ConnectionWorker() override;
+
+    /**
+     * Main worker thread loop.
+     * Processes commands until shutdown requested.
+     */
+    void run() override;
+
+private:
+    //==============================================================================
+    // Command processing
+
+    /**
+     * Process a single command from the queue.
+     * Dispatches to appropriate handler based on command type.
+     *
+     * @param cmd Command to process (ownership transferred)
+     */
+    void processCommand(std::unique_ptr<Commands::Command> cmd);
+
+    //==============================================================================
+    // Command handlers
+
+    void handleConnectCommand();
+    void handleDisconnectCommand();
+    void handleCheckHeartbeatCommand();
+    void handleNotifyHeartbeatCommand();
+    void handleSendMidiCommand(Commands::SendMidiCommand* cmd);
+
+    // Query handlers
+    void handleGetStateQuery(Commands::GetStateQuery* query);
+    void handleGetRemoteNodeQuery(Commands::GetRemoteNodeQuery* query);
+    void handleGetDevicesQuery(Commands::GetDevicesQuery* query);
+
+    //==============================================================================
+    // Helper methods
+
+    /**
+     * Updates connection state and invokes callback.
+     * @param newState New state to transition to
+     */
+    void setState(NetworkConnection::State newState);
+
+    /**
+     * Updates atomic snapshots for lock-free queries.
+     */
+    void updateSnapshots();
+
+    /**
+     * Handles received UDP packet.
+     * @param data Packet data
+     * @param size Packet size in bytes
+     * @param sender Sender IP address
+     * @param port Sender port number
+     */
+    void handleUdpPacket(const void* data, int size,
+                        const juce::String& sender, int port);
+
+    //==============================================================================
+    // Member variables
+
+    NetworkConnectionQueue& commandQueue;
+
+    // State owned by worker thread (no mutex needed - single-threaded)
+    NodeInfo remoteNodeInfo;
+    std::vector<DeviceInfo> remoteDevices;
+    NetworkConnection::State currentState{NetworkConnection::State::Disconnected};
+    juce::int64 lastHeartbeatTime{0};
+    bool running{false};
+
+    // Network resources
+    std::unique_ptr<httplib::Client> httpClient;
+    std::unique_ptr<juce::DatagramSocket> udpSocket;
+    juce::String localUdpEndpoint;
+    juce::String remoteUdpEndpoint;
+    std::vector<MidiMessage> receivedMessages;
+
+    // Atomic snapshots for fast lock-free queries from external threads
+    std::atomic<NetworkConnection::State> stateSnapshot{NetworkConnection::State::Disconnected};
+    std::atomic<int64_t> heartbeatSnapshot{0};
+
+    // Callbacks (passed from NetworkConnection)
+    std::function<void(NetworkConnection::State, NetworkConnection::State)> onStateChanged;
+    std::function<void(const std::vector<DeviceInfo>&)> onDevicesReceived;
+    std::function<void(const MidiMessage&)> onMidiMessageReceived;
+    std::function<void(const juce::String&)> onError;
+
+    static constexpr int64_t HEARTBEAT_TIMEOUT_MS = 3000;
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(ConnectionWorker)
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnection.cpp b/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
index 1bd1cf7..5722695 100644
--- a/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
+++ b/modules/juce/midi-server/network/mesh/NetworkConnection.cpp
@@ -2,12 +2,13 @@
  * NetworkConnection.cpp
  *
  * Implementation of NetworkConnection class for peer-to-peer MIDI node connections.
+ * Uses SEDA architecture with ConnectionWorker thread for all state management.
  */
 
 #include "NetworkConnection.h"
-#include "../../httplib.h"
-
-#include <sstream>
+#include "NetworkConnectionQueue.h"
+#include "ConnectionWorker.h"
+#include "Commands.h"
 
 namespace NetworkMidi {
 
@@ -19,289 +20,148 @@ NetworkConnection::NetworkConnection(const NodeInfo& remoteNode)
         throw std::invalid_argument("Invalid NodeInfo provided to NetworkConnection");
     }
 
-    // Initialize HTTP client
-    std::string baseUrl = "http://" + remoteNode.ipAddress.toStdString() + ":" +
-                         std::to_string(remoteNode.httpPort);
-    httpClient = std::make_unique<httplib::Client>(baseUrl);
-    httpClient->set_connection_timeout(5, 0);  // 5 seconds
-    httpClient->set_read_timeout(5, 0);
+    // Initialize SEDA infrastructure
+    commandQueue = std::make_unique<NetworkConnectionQueue>();
+    worker = std::make_unique<ConnectionWorker>(
+        *commandQueue,
+        remoteNode,
+        onStateChanged,
+        onDevicesReceived,
+        onMidiMessageReceived,
+        onError
+    );
 
-    // Initialize UDP socket
-    udpSocket = std::make_unique<juce::DatagramSocket>();
-}
+    // Start worker thread
+    worker->startThread();
 
-//==============================================================================
-NetworkConnection::~NetworkConnection()
-{
-    disconnect();
+    juce::Logger::writeToLog("NetworkConnection: SEDA infrastructure initialized for " +
+                            remoteNode.name);
 }
 
 //==============================================================================
-void NetworkConnection::connect()
-{
-    std::lock_guard<std::mutex> lock(stateMutex);
-
-    if (currentState != State::Disconnected) {
-        juce::Logger::writeToLog("NetworkConnection::connect() called in invalid state: " +
-                                toString(currentState));
-        return;
-    }
-
-    setState(State::Connecting);
-
-    // Perform handshake in background to avoid blocking
-    juce::Thread::launch([this]() {
-        performHandshake();
-    });
-}
-
-//==============================================================================
-void NetworkConnection::disconnect()
+NetworkConnection::~NetworkConnection()
 {
-    std::lock_guard<std::mutex> lock(stateMutex);
-
-    running = false;
-
-    if (udpSocket) {
-        udpSocket->shutdown();
-    }
+    // Shutdown worker thread gracefully
+    if (worker && commandQueue) {
+        juce::Logger::writeToLog("NetworkConnection: Shutting down worker thread for " +
+                                remoteNodeInfo.name);
 
-    httpClient.reset();
-    udpSocket.reset();
+        // Push shutdown command
+        commandQueue->pushCommand(std::make_unique<Commands::ShutdownCommand>());
 
-    if (currentState != State::Disconnected) {
-        setState(State::Disconnected);
+        // Wait for worker to exit (with timeout)
+        worker->stopThread(2000);  // 2 second timeout
     }
 }
 
 //==============================================================================
-NetworkConnection::State NetworkConnection::getState() const
+void NetworkConnection::connect()
 {
-    return currentState.load();
+    juce::Logger::writeToLog("NetworkConnection::connect() - Queuing connect command");
+    commandQueue->pushCommand(std::make_unique<Commands::ConnectCommand>());
 }
 
 //==============================================================================
-NodeInfo NetworkConnection::getRemoteNode() const
+void NetworkConnection::disconnect()
 {
-    std::lock_guard<std::mutex> lock(stateMutex);
-    return remoteNodeInfo;
+    juce::Logger::writeToLog("NetworkConnection::disconnect() - Queuing disconnect command");
+    commandQueue->pushCommand(std::make_unique<Commands::DisconnectCommand>());
 }
 
 //==============================================================================
-std::vector<DeviceInfo> NetworkConnection::getRemoteDevices() const
+NetworkConnection::State NetworkConnection::getState() const
 {
-    // No mutex needed: remoteDevices is only written once during handshake
-    // and this is a read-only copy operation
-    return remoteDevices;
-}
+    // Use query command for thread-safe state access
+    auto query = std::make_unique<Commands::GetStateQuery>();
+    auto* queryPtr = query.get();
 
-//==============================================================================
-void NetworkConnection::sendMidiMessage(uint16_t deviceId,
-                                       const std::vector<uint8_t>& data)
-{
-    if (currentState != State::Connected) {
-        throw std::runtime_error("Cannot send MIDI message: not connected");
-    }
+    commandQueue->pushCommand(std::move(query));
 
-    if (data.empty()) {
-        throw std::invalid_argument("Cannot send empty MIDI message");
+    // Wait for response (with timeout)
+    if (queryPtr->responseReady.wait(1000)) {
+        return queryPtr->result;
     }
 
-    // TODO: Implement actual UDP MIDI packet transmission
-    // For now, this is a placeholder that will be implemented with MidiPacket
-    juce::Logger::writeToLog("NetworkConnection::sendMidiMessage() - "
-                            "deviceId=" + juce::String(deviceId) +
-                            ", bytes=" + juce::String((int)data.size()));
+    // Timeout - return Disconnected as safe default
+    juce::Logger::writeToLog("NetworkConnection::getState() - Query timeout, returning Disconnected");
+    return State::Disconnected;
 }
 
 //==============================================================================
-std::vector<MidiMessage> NetworkConnection::getReceivedMessages()
+NodeInfo NetworkConnection::getRemoteNode() const
 {
-    std::lock_guard<std::mutex> lock(messageMutex);
-    std::vector<MidiMessage> result = std::move(receivedMessages);
-    receivedMessages.clear();
-    return result;
-}
+    auto query = std::make_unique<Commands::GetRemoteNodeQuery>();
+    auto* queryPtr = query.get();
 
-//==============================================================================
-int64_t NetworkConnection::getTimeSinceLastHeartbeat() const
-{
-    std::lock_guard<std::mutex> lock(heartbeatMutex);
-    return juce::Time::getCurrentTime().toMilliseconds() - lastHeartbeatTime;
-}
+    commandQueue->pushCommand(std::move(query));
 
-//==============================================================================
-bool NetworkConnection::isAlive() const
-{
-    return getTimeSinceLastHeartbeat() < HEARTBEAT_TIMEOUT_MS;
-}
-
-//==============================================================================
-void NetworkConnection::checkHeartbeat()
-{
-    if (currentState != State::Connected) {
-        return;
+    if (queryPtr->responseReady.wait(1000)) {
+        return queryPtr->result;
     }
 
-    if (!isAlive()) {
-        juce::Logger::writeToLog("NetworkConnection: Heartbeat timeout for " +
-                                remoteNodeInfo.name);
-
-        std::lock_guard<std::mutex> lock(stateMutex);
-        setState(State::Failed);
-
-        if (onError) {
-            onError("Heartbeat timeout - connection lost");
-        }
-    }
+    // Timeout - return initial node info
+    juce::Logger::writeToLog("NetworkConnection::getRemoteNode() - Query timeout, returning initial info");
+    return remoteNodeInfo;
 }
 
 //==============================================================================
-// Private methods
-//==============================================================================
-
-void NetworkConnection::performHandshake()
+std::vector<DeviceInfo> NetworkConnection::getRemoteDevices() const
 {
-    try {
-        // Bind UDP socket to any available port
-        if (!udpSocket->bindToPort(0)) {  // 0 = any available port
-            throw std::runtime_error("Failed to bind UDP socket");
-        }
-
-        int localUdpPort = udpSocket->getBoundPort();
-        localUdpEndpoint = juce::IPAddress::getLocalAddress().toString() + ":" +
-                          juce::String(localUdpPort);
-
-        // Prepare handshake request
-        std::ostringstream requestBody;
-        requestBody << "{"
-                   << "\"node_id\":\"" << juce::Uuid().toString().toStdString() << "\","
-                   << "\"node_name\":\"local-node\","  // TODO: Get from NodeIdentity
-                   << "\"udp_endpoint\":\"" << localUdpEndpoint.toStdString() << "\","
-                   << "\"version\":\"1.0\""
-                   << "}";
-
-        // Send handshake request
-        auto res = httpClient->Post("/network/handshake",
-                                   requestBody.str(),
-                                   "application/json");
-
-        if (!res) {
-            throw std::runtime_error("Failed to send handshake request: " +
-                                   httplib::to_string(res.error()));
-        }
-
-        if (res->status != 200) {
-            throw std::runtime_error("Handshake failed with HTTP " +
-                                   std::to_string(res->status));
-        }
-
-        // Parse response (simple JSON parsing for MVP)
-        std::string responseBody = res->body;
-
-        // Extract UDP endpoint
-        size_t udpPos = responseBody.find("\"udp_endpoint\":\"");
-        if (udpPos != std::string::npos) {
-            udpPos += 16;
-            size_t endPos = responseBody.find("\"", udpPos);
-            remoteUdpEndpoint = juce::String(responseBody.substr(udpPos, endPos - udpPos));
-        } else {
-            throw std::runtime_error("Handshake response missing udp_endpoint");
-        }
-
-        // Extract devices array (basic parsing)
-        size_t devicesPos = responseBody.find("\"devices\":[");
-        if (devicesPos != std::string::npos) {
-            // TODO: Implement proper JSON parsing for device list
-            // For now, we'll just note that devices were received
-            juce::Logger::writeToLog("Received device list from " + remoteNodeInfo.name);
-
-            // Notify callback
-            if (onDevicesReceived) {
-                onDevicesReceived(remoteDevices);
-            }
-        }
+    auto query = std::make_unique<Commands::GetDevicesQuery>();
+    auto* queryPtr = query.get();
 
-        // Handshake successful
-        running = true;
+    commandQueue->pushCommand(std::move(query));
 
-        {
-            std::lock_guard<std::mutex> lock(stateMutex);
-            setState(State::Connected);
-        }
-
-        // Initialize heartbeat
-        {
-            std::lock_guard<std::mutex> lock(heartbeatMutex);
-            lastHeartbeatTime = juce::Time::getCurrentTime().toMilliseconds();
-        }
-
-        juce::Logger::writeToLog("Successfully connected to " + remoteNodeInfo.name +
-                                " (UDP: " + remoteUdpEndpoint + ")");
-
-    } catch (const std::exception& e) {
-        juce::Logger::writeToLog("Handshake failed: " + juce::String(e.what()));
-
-        std::lock_guard<std::mutex> lock(stateMutex);
-        setState(State::Failed);
-
-        if (onError) {
-            onError(juce::String("Handshake failed: ") + e.what());
-        }
+    if (queryPtr->responseReady.wait(1000)) {
+        return queryPtr->result;
     }
+
+    // Timeout - return empty vector
+    juce::Logger::writeToLog("NetworkConnection::getRemoteDevices() - Query timeout, returning empty list");
+    return {};
 }
 
 //==============================================================================
-void NetworkConnection::setState(State newState)
+void NetworkConnection::sendMidiMessage(uint16_t deviceId,
+                                       const std::vector<uint8_t>& data)
 {
-    State oldState = currentState.load();
-
-    if (oldState == newState) {
-        return;
+    if (data.empty()) {
+        throw std::invalid_argument("Cannot send empty MIDI message");
     }
 
-    currentState = newState;
-
-    juce::Logger::writeToLog("NetworkConnection state changed: " +
-                            toString(oldState) + " -> " + toString(newState));
-
-    if (onStateChanged) {
-        onStateChanged(oldState, newState);
-    }
+    commandQueue->pushCommand(
+        std::make_unique<Commands::SendMidiCommand>(deviceId, data)
+    );
 }
 
 //==============================================================================
-void NetworkConnection::handleUdpPacket(const void* data, int size,
-                                       const juce::String& senderAddress,
-                                       int senderPort)
+int64_t NetworkConnection::getTimeSinceLastHeartbeat() const
 {
-    // TODO: Implement UDP packet handling with MidiPacket protocol
-    // For now, just log receipt
-    juce::Logger::writeToLog("Received UDP packet: " + juce::String(size) +
-                            " bytes from " + senderAddress + ":" +
-                            juce::String(senderPort));
+    // For now, we need to add a query command for this
+    // or use atomic snapshot from worker
+    // TODO: Add GetHeartbeatQuery command or expose atomic snapshot
+
+    // As a temporary solution, we'll check if we're connected
+    State state = getState();
+    if (state != State::Connected) {
+        return HEARTBEAT_TIMEOUT_MS + 1;  // Return value > timeout if not connected
+    }
 
-    // Update heartbeat timestamp
-    notifyHeartbeatReceived();
+    // Return 0 for now (heartbeat OK)
+    // This will be properly implemented with atomic snapshot or query command
+    return 0;
 }
 
 //==============================================================================
-void NetworkConnection::sendHeartbeat()
+bool NetworkConnection::isAlive() const
 {
-    if (currentState != State::Connected) {
-        return;
-    }
-
-    // TODO: Implement actual heartbeat packet transmission
-    // For now, this is a placeholder
-    juce::Logger::writeToLog("Sending heartbeat to " + remoteNodeInfo.name);
+    return getTimeSinceLastHeartbeat() < HEARTBEAT_TIMEOUT_MS;
 }
 
 //==============================================================================
-void NetworkConnection::notifyHeartbeatReceived()
+void NetworkConnection::checkHeartbeat()
 {
-    std::lock_guard<std::mutex> lock(heartbeatMutex);
-    lastHeartbeatTime = juce::Time::getCurrentTime().toMilliseconds();
+    commandQueue->pushCommand(std::make_unique<Commands::CheckHeartbeatCommand>());
 }
 
 } // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnection.h b/modules/juce/midi-server/network/mesh/NetworkConnection.h
index e18f874..8b32da9 100644
--- a/modules/juce/midi-server/network/mesh/NetworkConnection.h
+++ b/modules/juce/midi-server/network/mesh/NetworkConnection.h
@@ -8,6 +8,12 @@
  * Disconnected -> Connecting -> Connected -> Disconnected
  *                      |             |
  *                   Failed <---------+
+ *
+ * SEDA Architecture (Phase B.2 Complete):
+ * - All mutable state owned by ConnectionWorker thread
+ * - Commands sent via lock-free queue
+ * - No mutexes needed (single-threaded worker)
+ * - Query commands use blocking WaitableEvent for synchronous results
  */
 
 #pragma once
@@ -18,17 +24,15 @@
 #include <atomic>
 #include <functional>
 #include <memory>
-#include <mutex>
 #include <string>
 #include <vector>
 
-// Forward declarations
-namespace httplib {
-    class Client;
-}
-
 namespace NetworkMidi {
 
+// Forward declarations for SEDA infrastructure
+class NetworkConnectionQueue;
+class ConnectionWorker;
+
 //==============================================================================
 // Node information structure
 struct NodeInfo {
@@ -87,10 +91,16 @@ struct MidiMessage {
  * - HTTP handshake to exchange UDP endpoints and device lists
  * - UDP-based MIDI message transport
  * - Connection health monitoring via heartbeat
- * - Thread-safe message queuing
+ * - Thread-safe command queuing
+ *
+ * SEDA Architecture:
+ * - All state owned by ConnectionWorker thread (no mutexes)
+ * - Commands sent via lock-free queue
+ * - Queries use blocking WaitableEvent pattern
+ * - Callbacks invoked from worker thread
  *
  * Thread Safety:
- * All public methods are thread-safe. Internal state protected by mutex.
+ * All public methods are thread-safe (use command queue internally).
  */
 class NetworkConnection {
 public:
@@ -133,19 +143,19 @@ public:
 
     /**
      * Returns current connection state.
-     * Thread-safe.
+     * Thread-safe via query command.
      */
     State getState() const;
 
     /**
      * Returns information about the remote node.
-     * Thread-safe.
+     * Thread-safe via query command.
      */
     NodeInfo getRemoteNode() const;
 
     /**
      * Returns list of devices advertised by remote node.
-     * Thread-safe.
+     * Thread-safe via query command.
      */
     std::vector<DeviceInfo> getRemoteDevices() const;
 
@@ -158,19 +168,10 @@ public:
      *
      * @param deviceId Remote device identifier
      * @param data MIDI message bytes (1-N bytes)
-     * @throws std::runtime_error if not connected
+     * @throws std::invalid_argument if data is empty
      */
     void sendMidiMessage(uint16_t deviceId, const std::vector<uint8_t>& data);
 
-    /**
-     * Retrieves received MIDI messages from remote node.
-     * Clears internal receive queue.
-     * Thread-safe.
-     *
-     * @return Vector of received MIDI messages
-     */
-    std::vector<MidiMessage> getReceivedMessages();
-
     //==============================================================================
     // Connection health
 
@@ -192,62 +193,18 @@ public:
     void checkHeartbeat();
 
 private:
-    //==============================================================================
-    // Internal methods
-
-    /**
-     * Performs HTTP handshake with remote node.
-     * Exchanges UDP endpoints and device lists.
-     * Updates state based on success/failure.
-     */
-    void performHandshake();
-
-    /**
-     * Changes connection state and notifies listeners.
-     * Must be called with stateMutex locked.
-     */
-    void setState(State newState);
-
-    /**
-     * Handles received UDP packet.
-     * Parses and routes MIDI messages or heartbeat packets.
-     */
-    void handleUdpPacket(const void* data, int size,
-                        const juce::String& senderAddress, int senderPort);
-
-    /**
-     * Sends heartbeat packet to remote node.
-     */
-    void sendHeartbeat();
-
-    /**
-     * Updates last heartbeat timestamp.
-     */
-    void notifyHeartbeatReceived();
-
     //==============================================================================
     // Member variables
 
+    // Read-only node info (initialized in constructor)
     NodeInfo remoteNodeInfo;
-    std::vector<DeviceInfo> remoteDevices;
-
-    std::atomic<State> currentState{State::Disconnected};
-
-    std::unique_ptr<httplib::Client> httpClient;
-    std::unique_ptr<juce::DatagramSocket> udpSocket;
 
-    juce::String localUdpEndpoint;
-    juce::String remoteUdpEndpoint;
-
-    std::vector<MidiMessage> receivedMessages;
-    mutable std::mutex messageMutex;
-
-    mutable std::mutex stateMutex;
-
-    juce::int64 lastHeartbeatTime{0};
-    mutable std::mutex heartbeatMutex;
+    //==============================================================================
+    // SEDA Infrastructure
+    // All mutable state is owned by ConnectionWorker thread
 
-    std::atomic<bool> running{false};
+    std::unique_ptr<NetworkConnectionQueue> commandQueue;
+    std::unique_ptr<ConnectionWorker> worker;
 
     static constexpr int64_t HEARTBEAT_TIMEOUT_MS = 3000;  // 3 seconds
 
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp
new file mode 100644
index 0000000..9423f52
--- /dev/null
+++ b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.cpp
@@ -0,0 +1,53 @@
+/**
+ * NetworkConnectionQueue.cpp
+ *
+ * Implementation of thread-safe command queue for SEDA architecture.
+ */
+
+#include "NetworkConnectionQueue.h"
+
+namespace NetworkMidi {
+
+void NetworkConnectionQueue::pushCommand(std::unique_ptr<Commands::Command> cmd)
+{
+    {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        commandQueue.push_back(std::move(cmd));
+    }
+
+    // Signal event AFTER releasing lock to avoid waking worker while we hold lock
+    queueEvent.signal();
+}
+
+std::unique_ptr<Commands::Command> NetworkConnectionQueue::waitAndPop(int timeoutMs)
+{
+    // Wait for signal with timeout
+    if (!queueEvent.wait(timeoutMs)) {
+        return nullptr;  // Timeout - no command available
+    }
+
+    std::lock_guard<std::mutex> lock(queueMutex);
+
+    if (commandQueue.empty()) {
+        return nullptr;  // Spurious wakeup - no command
+    }
+
+    // Move command out of queue
+    auto cmd = std::move(commandQueue.front());
+    commandQueue.pop_front();
+
+    // If more commands remain, re-signal event
+    if (!commandQueue.empty()) {
+        queueEvent.signal();
+    }
+
+    return cmd;
+}
+
+size_t NetworkConnectionQueue::size() const
+{
+    std::lock_guard<std::mutex> lock(queueMutex);
+    return commandQueue.size();
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h
new file mode 100644
index 0000000..941d18a
--- /dev/null
+++ b/modules/juce/midi-server/network/mesh/NetworkConnectionQueue.h
@@ -0,0 +1,70 @@
+/**
+ * NetworkConnectionQueue.h
+ *
+ * Thread-safe command queue for SEDA architecture.
+ * Provides multi-producer, single-consumer command queuing with blocking wait.
+ */
+
+#pragma once
+
+#include "Commands.h"
+#include <juce_events/juce_events.h>
+#include <deque>
+#include <memory>
+#include <mutex>
+
+namespace NetworkMidi {
+
+//==============================================================================
+/**
+ * Thread-safe command queue using juce::WaitableEvent for blocking operations.
+ *
+ * Design:
+ * - Multi-producer safe: Any thread can push commands
+ * - Single consumer: Only worker thread should pop
+ * - Blocking wait: Consumer blocks until command available
+ * - Unbounded capacity: Uses std::deque (grows as needed)
+ *
+ * Thread Safety:
+ * - pushCommand() can be called from any thread
+ * - waitAndPop() should only be called from worker thread
+ * - size() can be called from any thread
+ */
+class NetworkConnectionQueue {
+public:
+    NetworkConnectionQueue() = default;
+    ~NetworkConnectionQueue() = default;
+
+    /**
+     * Push command to queue (thread-safe, non-blocking).
+     * Called by any thread that needs to send a command to the worker.
+     *
+     * @param cmd Command to enqueue (ownership transferred)
+     */
+    void pushCommand(std::unique_ptr<Commands::Command> cmd);
+
+    /**
+     * Wait for and pop command from queue (blocking).
+     * Should only be called by worker thread.
+     *
+     * @param timeoutMs Maximum time to wait for command (milliseconds)
+     * @return Command or nullptr if timeout occurred
+     */
+    std::unique_ptr<Commands::Command> waitAndPop(int timeoutMs);
+
+    /**
+     * Get current queue size (thread-safe).
+     *
+     * @return Number of commands in queue
+     */
+    size_t size() const;
+
+private:
+    mutable std::mutex queueMutex;
+    std::deque<std::unique_ptr<Commands::Command>> commandQueue;
+    juce::WaitableEvent queueEvent;
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(NetworkConnectionQueue)
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp b/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp
new file mode 100644
index 0000000..44339e1
--- /dev/null
+++ b/modules/juce/midi-server/network/mesh/tests/NetworkConnectionQueueTest.cpp
@@ -0,0 +1,297 @@
+/**
+ * NetworkConnectionQueueTest.cpp
+ *
+ * Unit tests for NetworkConnectionQueue (SEDA infrastructure).
+ */
+
+#include "../NetworkConnectionQueue.h"
+#include "../Commands.h"
+#include <gtest/gtest.h>
+#include <thread>
+#include <vector>
+#include <atomic>
+
+using namespace NetworkMidi;
+
+//==============================================================================
+// Basic functionality tests
+
+TEST(NetworkConnectionQueueTest, PushAndPop) {
+    NetworkConnectionQueue queue;
+
+    // Push a command
+    queue.pushCommand(std::make_unique<Commands::ConnectCommand>());
+
+    // Verify size
+    EXPECT_EQ(queue.size(), 1u);
+
+    // Pop command
+    auto cmd = queue.waitAndPop(100);
+    ASSERT_NE(cmd, nullptr);
+    EXPECT_EQ(cmd->type, Commands::Command::Connect);
+
+    // Queue should be empty
+    EXPECT_EQ(queue.size(), 0u);
+}
+
+TEST(NetworkConnectionQueueTest, MultipleCommands) {
+    NetworkConnectionQueue queue;
+
+    // Push multiple commands
+    queue.pushCommand(std::make_unique<Commands::ConnectCommand>());
+    queue.pushCommand(std::make_unique<Commands::DisconnectCommand>());
+    queue.pushCommand(std::make_unique<Commands::ShutdownCommand>());
+
+    EXPECT_EQ(queue.size(), 3u);
+
+    // Pop in FIFO order
+    auto cmd1 = queue.waitAndPop(100);
+    ASSERT_NE(cmd1, nullptr);
+    EXPECT_EQ(cmd1->type, Commands::Command::Connect);
+
+    auto cmd2 = queue.waitAndPop(100);
+    ASSERT_NE(cmd2, nullptr);
+    EXPECT_EQ(cmd2->type, Commands::Command::Disconnect);
+
+    auto cmd3 = queue.waitAndPop(100);
+    ASSERT_NE(cmd3, nullptr);
+    EXPECT_EQ(cmd3->type, Commands::Command::Shutdown);
+
+    EXPECT_EQ(queue.size(), 0u);
+}
+
+TEST(NetworkConnectionQueueTest, TimeoutOnEmptyQueue) {
+    NetworkConnectionQueue queue;
+
+    // Attempt to pop from empty queue with timeout
+    auto start = std::chrono::high_resolution_clock::now();
+    auto cmd = queue.waitAndPop(50);  // 50ms timeout
+    auto end = std::chrono::high_resolution_clock::now();
+
+    EXPECT_EQ(cmd, nullptr);  // Should return nullptr
+
+    // Verify timeout occurred (allow 10ms tolerance)
+    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
+    EXPECT_GE(duration.count(), 45);
+    EXPECT_LE(duration.count(), 100);
+}
+
+TEST(NetworkConnectionQueueTest, CommandPolymorphism) {
+    NetworkConnectionQueue queue;
+
+    // Push command with parameters
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};  // Note On
+    queue.pushCommand(std::make_unique<Commands::SendMidiCommand>(1, midiData));
+
+    auto cmd = queue.waitAndPop(100);
+    ASSERT_NE(cmd, nullptr);
+    EXPECT_EQ(cmd->type, Commands::Command::SendMidi);
+
+    // Downcast to specific type
+    auto* midiCmd = static_cast<Commands::SendMidiCommand*>(cmd.get());
+    EXPECT_EQ(midiCmd->deviceId, 1u);
+    EXPECT_EQ(midiCmd->data, midiData);
+}
+
+//==============================================================================
+// Multi-threaded stress tests
+
+TEST(NetworkConnectionQueueTest, MultiProducerSingleConsumer) {
+    NetworkConnectionQueue queue;
+    std::atomic<int> commandsProduced{0};
+    std::atomic<int> commandsConsumed{0};
+
+    const int NUM_PRODUCERS = 10;
+    const int COMMANDS_PER_PRODUCER = 100;
+    const int TOTAL_COMMANDS = NUM_PRODUCERS * COMMANDS_PER_PRODUCER;
+
+    // Start producer threads
+    std::vector<std::thread> producers;
+    for (int i = 0; i < NUM_PRODUCERS; ++i) {
+        producers.emplace_back([&queue, &commandsProduced, COMMANDS_PER_PRODUCER]() {
+            for (int j = 0; j < COMMANDS_PER_PRODUCER; ++j) {
+                queue.pushCommand(std::make_unique<Commands::ConnectCommand>());
+                commandsProduced.fetch_add(1, std::memory_order_relaxed);
+            }
+        });
+    }
+
+    // Consumer thread
+    std::thread consumer([&queue, &commandsConsumed, TOTAL_COMMANDS]() {
+        for (int i = 0; i < TOTAL_COMMANDS; ++i) {
+            auto cmd = queue.waitAndPop(1000);  // 1 second timeout
+            if (cmd) {
+                commandsConsumed.fetch_add(1, std::memory_order_relaxed);
+            } else {
+                // Timeout - should not happen
+                break;
+            }
+        }
+    });
+
+    // Wait for all threads
+    for (auto& t : producers) {
+        t.join();
+    }
+    consumer.join();
+
+    // Verify all commands produced and consumed
+    EXPECT_EQ(commandsProduced.load(), TOTAL_COMMANDS);
+    EXPECT_EQ(commandsConsumed.load(), TOTAL_COMMANDS);
+    EXPECT_EQ(queue.size(), 0u);
+}
+
+TEST(NetworkConnectionQueueTest, HighFrequencyOperations) {
+    NetworkConnectionQueue queue;
+    std::atomic<bool> stopFlag{false};
+    std::atomic<int> pushCount{0};
+    std::atomic<int> popCount{0};
+
+    // Producer thread - push commands rapidly
+    std::thread producer([&]() {
+        while (!stopFlag.load(std::memory_order_acquire)) {
+            queue.pushCommand(std::make_unique<Commands::ConnectCommand>());
+            pushCount.fetch_add(1, std::memory_order_relaxed);
+        }
+    });
+
+    // Consumer thread - pop commands rapidly
+    std::thread consumer([&]() {
+        while (!stopFlag.load(std::memory_order_acquire)) {
+            auto cmd = queue.waitAndPop(10);  // 10ms timeout
+            if (cmd) {
+                popCount.fetch_add(1, std::memory_order_relaxed);
+            }
+        }
+
+        // Drain remaining commands
+        while (queue.size() > 0) {
+            auto cmd = queue.waitAndPop(10);
+            if (cmd) {
+                popCount.fetch_add(1, std::memory_order_relaxed);
+            }
+        }
+    });
+
+    // Run for 1 second
+    std::this_thread::sleep_for(std::chrono::milliseconds(1000));
+    stopFlag.store(true, std::memory_order_release);
+
+    producer.join();
+    consumer.join();
+
+    // Verify balance
+    EXPECT_EQ(pushCount.load(), popCount.load());
+    EXPECT_GT(pushCount.load(), 1000);  // Should have processed many commands
+
+    std::cout << "High frequency test: " << pushCount.load()
+              << " commands processed in 1 second" << std::endl;
+}
+
+//==============================================================================
+// Query command with response mechanism
+
+TEST(NetworkConnectionQueueTest, QueryCommandWithResponse) {
+    NetworkConnectionQueue queue;
+
+    // Worker thread simulating command processing
+    std::thread worker([&queue]() {
+        auto cmd = queue.waitAndPop(1000);
+        ASSERT_NE(cmd, nullptr);
+        EXPECT_EQ(cmd->type, Commands::Command::GetState);
+
+        // Process query
+        auto* query = static_cast<Commands::GetStateQuery*>(cmd.get());
+        query->result = NetworkConnection::State::Connected;
+        query->responseReady.signal();
+    });
+
+    // Main thread sends query and waits for response
+    auto query = std::make_unique<Commands::GetStateQuery>();
+    auto* queryPtr = query.get();
+
+    queue.pushCommand(std::move(query));
+
+    // Wait for response (with timeout)
+    bool gotResponse = queryPtr->responseReady.wait(1000);
+    EXPECT_TRUE(gotResponse);
+    EXPECT_EQ(queryPtr->result, NetworkConnection::State::Connected);
+
+    worker.join();
+}
+
+TEST(NetworkConnectionQueueTest, MultipleQueriesConcurrent) {
+    NetworkConnectionQueue queue;
+    const int NUM_QUERIES = 50;
+    std::atomic<int> queriesProcessed{0};
+
+    // Worker thread processes queries
+    std::thread worker([&]() {
+        while (queriesProcessed.load() < NUM_QUERIES) {
+            auto cmd = queue.waitAndPop(100);
+            if (cmd && cmd->type == Commands::Command::GetRemoteNode) {
+                auto* query = static_cast<Commands::GetRemoteNodeQuery*>(cmd.get());
+
+                // Simulate some processing
+                query->result.name = "TestNode";
+                query->result.uuid = juce::Uuid();
+
+                query->responseReady.signal();
+                queriesProcessed.fetch_add(1, std::memory_order_relaxed);
+            }
+        }
+    });
+
+    // Multiple threads send queries
+    std::vector<std::thread> queryThreads;
+    for (int i = 0; i < NUM_QUERIES; ++i) {
+        queryThreads.emplace_back([&queue]() {
+            auto query = std::make_unique<Commands::GetRemoteNodeQuery>();
+            auto* queryPtr = query.get();
+
+            queue.pushCommand(std::move(query));
+
+            bool gotResponse = queryPtr->responseReady.wait(2000);
+            EXPECT_TRUE(gotResponse);
+            EXPECT_EQ(queryPtr->result.name, "TestNode");
+        });
+    }
+
+    for (auto& t : queryThreads) {
+        t.join();
+    }
+
+    worker.join();
+
+    EXPECT_EQ(queriesProcessed.load(), NUM_QUERIES);
+}
+
+//==============================================================================
+// Shutdown behavior
+
+TEST(NetworkConnectionQueueTest, ShutdownCommand) {
+    NetworkConnectionQueue queue;
+    std::atomic<bool> workerStopped{false};
+
+    // Worker thread waits for shutdown
+    std::thread worker([&]() {
+        while (true) {
+            auto cmd = queue.waitAndPop(100);
+            if (cmd && cmd->type == Commands::Command::Shutdown) {
+                break;
+            }
+        }
+        workerStopped.store(true);
+    });
+
+    // Push some commands
+    queue.pushCommand(std::make_unique<Commands::ConnectCommand>());
+    queue.pushCommand(std::make_unique<Commands::DisconnectCommand>());
+
+    // Push shutdown command
+    queue.pushCommand(std::make_unique<Commands::ShutdownCommand>());
+
+    worker.join();
+
+    EXPECT_TRUE(workerStopped.load());
+}
diff --git a/modules/juce/midi-server/network/transport/MidiClassifier.h b/modules/juce/midi-server/network/transport/MidiClassifier.h
new file mode 100644
index 0000000..dee1805
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/MidiClassifier.h
@@ -0,0 +1,137 @@
+#pragma once
+
+#include <juce_audio_basics/juce_audio_basics.h>
+
+namespace NetworkMidi {
+
+/**
+ * Classification of MIDI messages by QoS requirements.
+ *
+ * Real-Time messages require ultra-low latency (<1ms) and can tolerate
+ * occasional packet loss. Non-Real-Time messages require guaranteed
+ * delivery but can tolerate higher latency (10-100ms).
+ */
+enum class MidiMessageClass {
+    RealTime,      // Needs UDP transport (low latency, best-effort)
+    NonRealTime    // Needs TCP transport (reliable, higher latency OK)
+};
+
+/**
+ * Classify a MIDI message by its QoS requirements.
+ *
+ * Classification Rules:
+ * - System Real-Time (0xF8-0xFF) -> RealTime
+ *   Examples: MIDI Clock (0xF8), Start (0xFA), Stop (0xFC), Active Sensing (0xFE)
+ *
+ * - System Exclusive (0xF0...0xF7) -> NonRealTime
+ *   Examples: SysEx messages, patch dumps, sample dumps
+ *
+ * - Channel Voice (0x80-0xEF) -> RealTime
+ *   Examples: Note On/Off, Control Change, Pitch Bend, Aftertouch, Program Change
+ *
+ * - Default -> NonRealTime (for safety)
+ *
+ * Performance Considerations:
+ * - This function is called on the MIDI input thread for every message
+ * - Must be extremely fast (target: <100ns)
+ * - No memory allocation
+ * - No blocking operations
+ * - Thread-safe (pure function)
+ *
+ * @param msg The MIDI message to classify
+ * @return MidiMessageClass indicating appropriate transport
+ */
+inline MidiMessageClass classifyMidiMessage(const juce::MidiMessage& msg)
+{
+    // Safety check: ensure message has data
+    if (msg.getRawDataSize() == 0) {
+        return MidiMessageClass::NonRealTime;
+    }
+
+    const uint8_t statusByte = msg.getRawData()[0];
+
+    // System Real-Time messages (0xF8 - 0xFF)
+    // These are single-byte messages that can appear at any time
+    if (statusByte >= 0xF8) {
+        return MidiMessageClass::RealTime;
+    }
+
+    // System Exclusive (0xF0 ... 0xF7)
+    // These can be very large (KB+) and require reliable delivery
+    if (msg.isSysEx()) {
+        return MidiMessageClass::NonRealTime;
+    }
+
+    // Channel Voice messages (0x80 - 0xEF)
+    // Note On/Off, CC, Pitch Bend, Aftertouch, Program Change
+    // These are time-critical performance messages
+    if (statusByte >= 0x80 && statusByte < 0xF0) {
+        return MidiMessageClass::RealTime;
+    }
+
+    // System Common messages (0xF1 - 0xF7, except 0xF0 SysEx)
+    // Examples: MTC Quarter Frame (0xF1), Song Position (0xF2), etc.
+    // Default to non-real-time for safety - these are less common
+    return MidiMessageClass::NonRealTime;
+}
+
+/**
+ * Get a human-readable description of the message class.
+ *
+ * Useful for debugging and logging.
+ *
+ * @param msgClass The message class
+ * @return String description
+ */
+inline juce::String getMidiMessageClassName(MidiMessageClass msgClass)
+{
+    switch (msgClass) {
+        case MidiMessageClass::RealTime:
+            return "RealTime";
+        case MidiMessageClass::NonRealTime:
+            return "NonRealTime";
+        default:
+            return "Unknown";
+    }
+}
+
+/**
+ * Get detailed description of why a message was classified as it was.
+ *
+ * Useful for debugging classification logic.
+ *
+ * @param msg The MIDI message
+ * @return String describing the classification reasoning
+ */
+inline juce::String explainClassification(const juce::MidiMessage& msg)
+{
+    if (msg.getRawDataSize() == 0) {
+        return "Empty message -> NonRealTime (safety)";
+    }
+
+    const uint8_t statusByte = msg.getRawData()[0];
+
+    if (statusByte >= 0xF8) {
+        return juce::String("System Real-Time (0x") +
+               juce::String::toHexString(statusByte) +
+               ") -> RealTime";
+    }
+
+    if (msg.isSysEx()) {
+        return juce::String("System Exclusive (size: ") +
+               juce::String(msg.getRawDataSize()) +
+               " bytes) -> NonRealTime";
+    }
+
+    if (statusByte >= 0x80 && statusByte < 0xF0) {
+        return juce::String("Channel Voice (0x") +
+               juce::String::toHexString(statusByte) +
+               ") -> RealTime";
+    }
+
+    return juce::String("System Common (0x") +
+           juce::String::toHexString(statusByte) +
+           ") -> NonRealTime (safety)";
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/MidiClassifier_Example.cpp b/modules/juce/midi-server/network/transport/MidiClassifier_Example.cpp
new file mode 100644
index 0000000..01a64ac
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/MidiClassifier_Example.cpp
@@ -0,0 +1,235 @@
+/**
+ * Integration Example: Using MidiClassifier and MidiMessageRouter
+ *
+ * This example demonstrates how to integrate message classification and routing
+ * into a MIDI input callback for dual-transport MIDI architecture.
+ */
+
+#include "MidiClassifier.h"
+#include "MidiMessageRouter.h"
+#include "UdpMidiTransport.h"
+#include "ReliableTransport.h"
+#include <juce_audio_devices/juce_audio_devices.h>
+
+using namespace NetworkMidi;
+
+/**
+ * Example MIDI input handler that routes messages to appropriate transports.
+ *
+ * This class demonstrates the integration point for Phase C.4 of the
+ * dual-transport MIDI architecture.
+ */
+class MidiInputHandler : public juce::MidiInputCallback {
+public:
+    /**
+     * Constructor.
+     *
+     * @param router Message router that handles classification and transport selection
+     * @param destNode Destination node UUID for outgoing messages
+     * @param destAddress Destination IP address
+     * @param destPort Destination port number
+     */
+    MidiInputHandler(
+        MidiMessageRouter& router,
+        const juce::Uuid& destNode,
+        const juce::String& destAddress,
+        int destPort
+    )
+        : router(router)
+        , destNode(destNode)
+        , destAddress(destAddress)
+        , destPort(destPort)
+    {
+    }
+
+    /**
+     * MIDI input callback - called on MIDI input thread.
+     *
+     * This is where we integrate the classifier and router:
+     * 1. Receive MIDI message from input device
+     * 2. Router classifies message (real-time vs non-real-time)
+     * 3. Router sends to appropriate transport (UDP vs TCP)
+     *
+     * Thread-safe: Can be called from multiple MIDI input threads.
+     * Real-time safe: No allocation, no locks, no blocking.
+     */
+    void handleIncomingMidiMessage(
+        juce::MidiInput* source,
+        const juce::MidiMessage& message
+    ) override {
+        // Get device ID from source (implementation-specific)
+        uint16_t deviceId = getDeviceIdForSource(source);
+
+        // Route message - classification and transport selection happen automatically
+        bool success = router.routeMessage(
+            message,
+            deviceId,
+            destNode,
+            destAddress,
+            destPort
+        );
+
+        if (!success) {
+            // Log error (optional)
+            messagesDropped++;
+        }
+    }
+
+    /**
+     * Get statistics.
+     */
+    uint64_t getMessagesDropped() const {
+        return messagesDropped.load();
+    }
+
+private:
+    /**
+     * Map MIDI input source to device ID.
+     *
+     * Implementation-specific - could use:
+     * - Device registry lookup
+     * - Source identifier hash
+     * - Pre-configured mapping
+     */
+    uint16_t getDeviceIdForSource(juce::MidiInput* source) const {
+        // Example implementation: use index as device ID
+        auto devices = juce::MidiInput::getAvailableDevices();
+        for (int i = 0; i < devices.size(); ++i) {
+            if (devices[i].identifier == source->getIdentifier()) {
+                return static_cast<uint16_t>(i);
+            }
+        }
+        return 0;  // Default device ID
+    }
+
+    MidiMessageRouter& router;
+    juce::Uuid destNode;
+    juce::String destAddress;
+    int destPort;
+
+    std::atomic<uint64_t> messagesDropped{0};
+};
+
+/**
+ * Example application showing complete setup.
+ */
+class MidiRoutingExample {
+public:
+    MidiRoutingExample() {
+        // Create transports
+        udpTransport = std::make_unique<UdpMidiTransport>(5004);
+        udpTransport->setNodeId(juce::Uuid());
+        udpTransport->start();
+
+        reliableTransport = std::make_unique<ReliableTransport>(*udpTransport);
+
+        // Create router
+        router = std::make_unique<MidiMessageRouter>(*udpTransport, *reliableTransport);
+
+        // Enable detailed statistics tracking
+        router->setDetailedTracking(true);
+
+        // Set up error callback
+        router->onRoutingError = [](const juce::String& error, const juce::MidiMessage& msg) {
+            DBG("Routing error: " << error);
+            DBG("Message: " << msg.getDescription());
+        };
+
+        // Create MIDI input handler
+        inputHandler = std::make_unique<MidiInputHandler>(
+            *router,
+            juce::Uuid(),  // Destination node UUID
+            "192.168.1.100",  // Destination IP
+            5004  // Destination port
+        );
+
+        // Open MIDI input device
+        auto devices = juce::MidiInput::getAvailableDevices();
+        if (!devices.isEmpty()) {
+            midiInput = juce::MidiInput::openDevice(devices[0].identifier, inputHandler.get());
+            if (midiInput) {
+                midiInput->start();
+                DBG("MIDI input started: " << devices[0].name);
+            }
+        }
+    }
+
+    ~MidiRoutingExample() {
+        if (midiInput) {
+            midiInput->stop();
+        }
+        udpTransport->stop();
+    }
+
+    /**
+     * Print statistics.
+     */
+    void printStatistics() {
+        auto stats = router->getStatistics();
+
+        DBG("===== MIDI Routing Statistics =====");
+        DBG("Real-time messages sent (UDP):  " << stats.realtimeMessagesSent);
+        DBG("Non-real-time messages sent (TCP): " << stats.nonRealtimeMessagesSent);
+        DBG("Routing errors:                 " << stats.routingErrors);
+        DBG("Total bytes sent:               " << stats.totalBytesSent);
+        DBG("");
+        DBG("Message type breakdown:");
+        DBG("  Note On/Off:      " << stats.noteMessages);
+        DBG("  Control Change:   " << stats.controlChangeMessages);
+        DBG("  MIDI Clock:       " << stats.clockMessages);
+        DBG("  SysEx:            " << stats.sysexMessages);
+        DBG("  Other:            " << stats.otherMessages);
+        DBG("");
+        DBG("Messages dropped:  " << inputHandler->getMessagesDropped());
+    }
+
+    /**
+     * Test message classification.
+     */
+    void testClassification() {
+        DBG("===== Testing Message Classification =====");
+
+        // Create test messages
+        juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+        juce::MidiMessage cc = juce::MidiMessage::controllerEvent(1, 7, 127);
+        juce::MidiMessage clock = juce::MidiMessage::midiClock();
+
+        uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+        juce::MidiMessage sysex(sysexData, 5);
+
+        // Classify and explain
+        DBG("Note On: " << explainClassification(noteOn));
+        DBG("Control Change: " << explainClassification(cc));
+        DBG("MIDI Clock: " << explainClassification(clock));
+        DBG("SysEx: " << explainClassification(sysex));
+    }
+
+private:
+    std::unique_ptr<UdpMidiTransport> udpTransport;
+    std::unique_ptr<ReliableTransport> reliableTransport;
+    std::unique_ptr<MidiMessageRouter> router;
+    std::unique_ptr<MidiInputHandler> inputHandler;
+    std::unique_ptr<juce::MidiInput> midiInput;
+};
+
+/**
+ * Usage Example:
+ *
+ * int main() {
+ *     juce::MessageManager::getInstance();
+ *
+ *     // Create and initialize
+ *     MidiRoutingExample example;
+ *
+ *     // Test classification
+ *     example.testClassification();
+ *
+ *     // Run for a while...
+ *     juce::Thread::sleep(10000);  // 10 seconds
+ *
+ *     // Print statistics
+ *     example.printStatistics();
+ *
+ *     return 0;
+ * }
+ */
diff --git a/modules/juce/midi-server/network/transport/MidiMessageRouter.cpp b/modules/juce/midi-server/network/transport/MidiMessageRouter.cpp
new file mode 100644
index 0000000..1e15ac8
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/MidiMessageRouter.cpp
@@ -0,0 +1,244 @@
+#include "MidiMessageRouter.h"
+#include "../core/MidiPacket.h"
+
+namespace NetworkMidi {
+
+MidiMessageRouter::MidiMessageRouter(
+    UdpMidiTransport& realtimeTransport,
+    ReliableTransport& nonRealtimeTransport
+)
+    : realtimeTransport(realtimeTransport)
+    , nonRealtimeTransport(nonRealtimeTransport)
+    , realtimeMessagesSent(0)
+    , nonRealtimeMessagesSent(0)
+    , routingErrors(0)
+    , totalBytesSent(0)
+    , detailedTracking(false)
+    , noteMessages(0)
+    , controlChangeMessages(0)
+    , clockMessages(0)
+    , sysexMessages(0)
+    , otherMessages(0)
+{
+}
+
+MidiMessageRouter::~MidiMessageRouter()
+{
+}
+
+bool MidiMessageRouter::routeMessage(
+    const juce::MidiMessage& msg,
+    uint16_t deviceId,
+    const juce::Uuid& destNode,
+    const juce::String& destAddress,
+    int destPort
+)
+{
+    // Classify the message
+    const auto msgClass = classifyMidiMessage(msg);
+
+    // Update detailed statistics if enabled
+    if (detailedTracking.load(std::memory_order_relaxed)) {
+        updateDetailedStats(msg);
+    }
+
+    // Update byte counter
+    totalBytesSent.fetch_add(msg.getRawDataSize(), std::memory_order_relaxed);
+
+    // Build packet
+    MidiPacket packet = buildPacket(msg, deviceId, destNode);
+
+    // Route based on classification
+    bool success = false;
+
+    if (msgClass == MidiMessageClass::RealTime) {
+        // Real-time path: UDP (best-effort, low latency)
+        success = realtimeTransport.sendPacket(packet, destAddress, destPort);
+
+        if (success) {
+            realtimeMessagesSent.fetch_add(1, std::memory_order_relaxed);
+        }
+    }
+    else {
+        // Non-real-time path: TCP (reliable, guaranteed delivery)
+        nonRealtimeTransport.sendUnreliable(packet, destAddress, destPort);
+        success = true;  // sendUnreliable queues the message
+
+        nonRealtimeMessagesSent.fetch_add(1, std::memory_order_relaxed);
+    }
+
+    // Handle routing errors
+    if (!success) {
+        routingErrors.fetch_add(1, std::memory_order_relaxed);
+
+        // Dispatch error callback asynchronously (don't block real-time thread)
+        if (onRoutingError) {
+            auto callback = onRoutingError;
+            auto msgCopy = msg;
+            juce::MessageManager::callAsync([callback, msgCopy]() {
+                callback("Transport send failed", msgCopy);
+            });
+        }
+    }
+
+    return success;
+}
+
+bool MidiMessageRouter::routeMessageWithCallback(
+    const juce::MidiMessage& msg,
+    uint16_t deviceId,
+    const juce::Uuid& destNode,
+    const juce::String& destAddress,
+    int destPort,
+    std::function<void()> onDelivered,
+    std::function<void(const juce::String& reason)> onFailed
+)
+{
+    // Classify the message
+    const auto msgClass = classifyMidiMessage(msg);
+
+    // Update detailed statistics if enabled
+    if (detailedTracking.load(std::memory_order_relaxed)) {
+        updateDetailedStats(msg);
+    }
+
+    // Update byte counter
+    totalBytesSent.fetch_add(msg.getRawDataSize(), std::memory_order_relaxed);
+
+    // Build packet
+    MidiPacket packet = buildPacket(msg, deviceId, destNode);
+
+    // Route based on classification
+    bool success = false;
+
+    if (msgClass == MidiMessageClass::RealTime) {
+        // Real-time path: UDP (best-effort, no callbacks)
+        success = realtimeTransport.sendPacket(packet, destAddress, destPort);
+
+        if (success) {
+            realtimeMessagesSent.fetch_add(1, std::memory_order_relaxed);
+
+            // Invoke success callback immediately for real-time messages
+            // (no delivery confirmation available with UDP)
+            if (onDelivered) {
+                juce::MessageManager::callAsync(onDelivered);
+            }
+        }
+        else if (onFailed) {
+            // Invoke failure callback
+            juce::MessageManager::callAsync([onFailed]() {
+                onFailed("UDP send failed");
+            });
+        }
+    }
+    else {
+        // Non-real-time path: TCP with delivery confirmation
+        nonRealtimeTransport.sendReliable(
+            packet,
+            destAddress,
+            destPort,
+            onDelivered,
+            onFailed
+        );
+        success = true;  // sendReliable queues the message
+
+        nonRealtimeMessagesSent.fetch_add(1, std::memory_order_relaxed);
+    }
+
+    // Handle routing errors
+    if (!success) {
+        routingErrors.fetch_add(1, std::memory_order_relaxed);
+
+        // Dispatch error callback asynchronously
+        if (onRoutingError) {
+            auto callback = onRoutingError;
+            auto msgCopy = msg;
+            juce::MessageManager::callAsync([callback, msgCopy]() {
+                callback("Transport send failed", msgCopy);
+            });
+        }
+    }
+
+    return success;
+}
+
+MidiMessageRouter::Statistics MidiMessageRouter::getStatistics() const
+{
+    Statistics stats;
+    stats.realtimeMessagesSent = realtimeMessagesSent.load(std::memory_order_relaxed);
+    stats.nonRealtimeMessagesSent = nonRealtimeMessagesSent.load(std::memory_order_relaxed);
+    stats.routingErrors = routingErrors.load(std::memory_order_relaxed);
+    stats.totalBytesSent = totalBytesSent.load(std::memory_order_relaxed);
+
+    // Detailed stats
+    stats.noteMessages = noteMessages.load(std::memory_order_relaxed);
+    stats.controlChangeMessages = controlChangeMessages.load(std::memory_order_relaxed);
+    stats.clockMessages = clockMessages.load(std::memory_order_relaxed);
+    stats.sysexMessages = sysexMessages.load(std::memory_order_relaxed);
+    stats.otherMessages = otherMessages.load(std::memory_order_relaxed);
+
+    return stats;
+}
+
+void MidiMessageRouter::resetStatistics()
+{
+    realtimeMessagesSent.store(0, std::memory_order_relaxed);
+    nonRealtimeMessagesSent.store(0, std::memory_order_relaxed);
+    routingErrors.store(0, std::memory_order_relaxed);
+    totalBytesSent.store(0, std::memory_order_relaxed);
+
+    noteMessages.store(0, std::memory_order_relaxed);
+    controlChangeMessages.store(0, std::memory_order_relaxed);
+    clockMessages.store(0, std::memory_order_relaxed);
+    sysexMessages.store(0, std::memory_order_relaxed);
+    otherMessages.store(0, std::memory_order_relaxed);
+}
+
+void MidiMessageRouter::updateDetailedStats(const juce::MidiMessage& msg)
+{
+    if (msg.isNoteOnOrOff()) {
+        noteMessages.fetch_add(1, std::memory_order_relaxed);
+    }
+    else if (msg.isController()) {
+        controlChangeMessages.fetch_add(1, std::memory_order_relaxed);
+    }
+    else if (msg.getRawDataSize() > 0 && msg.getRawData()[0] == 0xF8) {
+        clockMessages.fetch_add(1, std::memory_order_relaxed);
+    }
+    else if (msg.isSysEx()) {
+        sysexMessages.fetch_add(1, std::memory_order_relaxed);
+    }
+    else {
+        otherMessages.fetch_add(1, std::memory_order_relaxed);
+    }
+}
+
+MidiPacket MidiMessageRouter::buildPacket(
+    const juce::MidiMessage& msg,
+    uint16_t deviceId,
+    const juce::Uuid& destNode
+) const
+{
+    // Copy MIDI data
+    const int dataSize = msg.getRawDataSize();
+    std::vector<uint8_t> midiData(dataSize);
+    std::memcpy(midiData.data(), msg.getRawData(), dataSize);
+
+    // Create packet using factory method
+    MidiPacket packet = MidiPacket::createDataPacket(
+        realtimeTransport.getNodeId(),
+        destNode,
+        deviceId,
+        midiData,
+        0  // Sequence will be set by transport
+    );
+
+    // Set SysEx flag if applicable
+    if (msg.isSysEx()) {
+        packet.addFlag(MidiPacket::SysEx);
+    }
+
+    return packet;
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/MidiMessageRouter.h b/modules/juce/midi-server/network/transport/MidiMessageRouter.h
new file mode 100644
index 0000000..2a0831c
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/MidiMessageRouter.h
@@ -0,0 +1,183 @@
+#pragma once
+
+#include "MidiClassifier.h"
+#include "UdpMidiTransport.h"
+#include "ReliableTransport.h"
+#include <juce_audio_basics/juce_audio_basics.h>
+#include <juce_core/juce_core.h>
+#include <atomic>
+#include <functional>
+
+namespace NetworkMidi {
+
+/**
+ * Routes MIDI messages to appropriate transport based on message classification.
+ *
+ * This class is the integration point for dual-transport MIDI architecture.
+ * It examines each MIDI message and routes it to either:
+ * - Real-time path (UDP, low latency, best-effort)
+ * - Non-real-time path (TCP via ReliableTransport, guaranteed delivery)
+ *
+ * Thread Safety:
+ * - routeMessage() is thread-safe and can be called from MIDI input callbacks
+ * - Statistics are updated atomically
+ * - No locks on the routing hot path
+ *
+ * Performance:
+ * - Designed for real-time use (audio thread safe)
+ * - No memory allocation in routeMessage()
+ * - No blocking operations
+ * - Target latency: <1μs for routing decision + transport call
+ */
+class MidiMessageRouter {
+public:
+    /**
+     * Constructor.
+     *
+     * @param realtimeTransport UDP transport for real-time messages
+     * @param nonRealtimeTransport Reliable transport for non-real-time messages
+     */
+    MidiMessageRouter(
+        UdpMidiTransport& realtimeTransport,
+        ReliableTransport& nonRealtimeTransport
+    );
+
+    /**
+     * Destructor.
+     */
+    ~MidiMessageRouter();
+
+    // Non-copyable
+    MidiMessageRouter(const MidiMessageRouter&) = delete;
+    MidiMessageRouter& operator=(const MidiMessageRouter&) = delete;
+
+    /**
+     * Route a MIDI message to the appropriate transport.
+     *
+     * This is the main entry point called from MIDI input callbacks.
+     * The message is classified and sent to either UDP or TCP transport.
+     *
+     * Thread-safe: Can be called from multiple MIDI input threads simultaneously.
+     * Real-time safe: No allocation, no locks, no blocking.
+     *
+     * @param msg The MIDI message to route
+     * @param deviceId Source device ID
+     * @param destNode Destination node UUID
+     * @param destAddress Destination IP address
+     * @param destPort Destination port number
+     * @return true if message was successfully queued for transmission
+     */
+    bool routeMessage(
+        const juce::MidiMessage& msg,
+        uint16_t deviceId,
+        const juce::Uuid& destNode,
+        const juce::String& destAddress,
+        int destPort
+    );
+
+    /**
+     * Route a message with guaranteed delivery callback.
+     *
+     * Only applies to non-real-time messages (SysEx). Real-time messages
+     * are sent best-effort and callbacks are ignored.
+     *
+     * @param msg The MIDI message to route
+     * @param deviceId Source device ID
+     * @param destNode Destination node UUID
+     * @param destAddress Destination IP address
+     * @param destPort Destination port number
+     * @param onDelivered Callback invoked when message is acknowledged (non-real-time only)
+     * @param onFailed Callback invoked when delivery fails (non-real-time only)
+     * @return true if message was successfully queued
+     */
+    bool routeMessageWithCallback(
+        const juce::MidiMessage& msg,
+        uint16_t deviceId,
+        const juce::Uuid& destNode,
+        const juce::String& destAddress,
+        int destPort,
+        std::function<void()> onDelivered,
+        std::function<void(const juce::String& reason)> onFailed
+    );
+
+    /**
+     * Get routing statistics.
+     */
+    struct Statistics {
+        uint64_t realtimeMessagesSent = 0;
+        uint64_t nonRealtimeMessagesSent = 0;
+        uint64_t routingErrors = 0;
+        uint64_t totalBytesSent = 0;
+
+        // Breakdown by message type
+        uint64_t noteMessages = 0;
+        uint64_t controlChangeMessages = 0;
+        uint64_t clockMessages = 0;
+        uint64_t sysexMessages = 0;
+        uint64_t otherMessages = 0;
+    };
+
+    /**
+     * Get current statistics (thread-safe).
+     */
+    Statistics getStatistics() const;
+
+    /**
+     * Reset statistics counters.
+     */
+    void resetStatistics();
+
+    /**
+     * Enable/disable detailed message type tracking.
+     *
+     * When enabled, statistics include breakdown by message type.
+     * Slight performance overhead (~10ns per message).
+     *
+     * @param enabled true to enable detailed tracking
+     */
+    void setDetailedTracking(bool enabled) { detailedTracking.store(enabled); }
+
+    /**
+     * Check if detailed tracking is enabled.
+     */
+    bool isDetailedTrackingEnabled() const { return detailedTracking.load(); }
+
+    /**
+     * Error callback for routing failures.
+     *
+     * Called when a message cannot be routed (e.g., transport failure).
+     * Not called from real-time thread - dispatched asynchronously.
+     */
+    std::function<void(const juce::String& error, const juce::MidiMessage& msg)> onRoutingError;
+
+private:
+    // Helper to update detailed statistics
+    void updateDetailedStats(const juce::MidiMessage& msg);
+
+    // Helper to build MidiPacket from message
+    MidiPacket buildPacket(
+        const juce::MidiMessage& msg,
+        uint16_t deviceId,
+        const juce::Uuid& destNode
+    ) const;
+
+    // Transports
+    UdpMidiTransport& realtimeTransport;
+    ReliableTransport& nonRealtimeTransport;
+
+    // Statistics (atomic for lock-free access)
+    std::atomic<uint64_t> realtimeMessagesSent;
+    std::atomic<uint64_t> nonRealtimeMessagesSent;
+    std::atomic<uint64_t> routingErrors;
+    std::atomic<uint64_t> totalBytesSent;
+
+    // Detailed statistics (optional)
+    std::atomic<bool> detailedTracking;
+    std::atomic<uint64_t> noteMessages;
+    std::atomic<uint64_t> controlChangeMessages;
+    std::atomic<uint64_t> clockMessages;
+    std::atomic<uint64_t> sysexMessages;
+    std::atomic<uint64_t> otherMessages;
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/NonRealtimeMidiTransport.cpp b/modules/juce/midi-server/network/transport/NonRealtimeMidiTransport.cpp
new file mode 100644
index 0000000..c8ad27f
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/NonRealtimeMidiTransport.cpp
@@ -0,0 +1,259 @@
+#include "NonRealtimeMidiTransport.h"
+#include <algorithm>
+
+namespace NetworkMidi {
+
+NonRealtimeMidiTransport::NonRealtimeMidiTransport(juce::String host, int port)
+    : juce::Thread("NonRealtimeMidiTCP"), remoteHost(host), remotePort(port)
+{
+    // Normal priority (5) is fine for non-real-time
+    setPriority(juce::Thread::Priority::normal);
+}
+
+NonRealtimeMidiTransport::~NonRealtimeMidiTransport() {
+    signalThreadShouldExit();
+    dataAvailable.signal();  // Wake up if waiting
+    stopThread(2000);  // 2 second timeout
+}
+
+void NonRealtimeMidiTransport::sendMessage(const juce::MidiMessage& msg, uint16_t deviceId) {
+    MidiPacket packet;
+    packet.data.resize(msg.getRawDataSize());
+    std::memcpy(packet.data.data(), msg.getRawData(), msg.getRawDataSize());
+    packet.deviceId = deviceId;
+    packet.requiresAck = true;
+
+    {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        packet.sequenceNumber = nextSequenceNumber++;
+        sendQueue.push_back(std::move(packet));
+    }
+
+    dataAvailable.signal();
+}
+
+std::vector<NonRealtimeMidiTransport::MidiPacket>
+NonRealtimeMidiTransport::getReceivedMessages() {
+    std::lock_guard<std::mutex> lock(queueMutex);
+    std::vector<MidiPacket> result;
+    result.reserve(receiveQueue.size());
+
+    while (!receiveQueue.empty()) {
+        result.push_back(std::move(receiveQueue.front()));
+        receiveQueue.pop_front();
+    }
+
+    return result;
+}
+
+void NonRealtimeMidiTransport::run() {
+    juce::Logger::writeToLog("NonRealtimeMidiTransport: Started");
+
+    while (!threadShouldExit()) {
+        if (!connected) {
+            attemptConnection();
+            if (!connected) {
+                juce::Thread::sleep(1000);  // Retry every 1s
+                continue;
+            }
+        }
+
+        // Process send queue
+        processSendQueue();
+
+        // Receive incoming data (non-blocking with timeout)
+        receiveData();
+
+        // Check for ACK timeouts and retry
+        retryUnacknowledged();
+
+        // Wait for more data or timeout
+        dataAvailable.wait(10);  // 10ms poll interval
+    }
+
+    juce::Logger::writeToLog("NonRealtimeMidiTransport: Stopped");
+}
+
+void NonRealtimeMidiTransport::attemptConnection() {
+    juce::Logger::writeToLog("NonRealtimeMidiTransport: Connecting to " +
+                            remoteHost + ":" + juce::String(remotePort));
+
+    if (tcpSocket.connect(remoteHost, remotePort, 2000)) {  // 2s timeout
+        connected = true;
+        juce::Logger::writeToLog("NonRealtimeMidiTransport: Connected");
+    } else {
+        juce::Logger::writeToLog("NonRealtimeMidiTransport: Connection failed");
+    }
+}
+
+void NonRealtimeMidiTransport::processSendQueue() {
+    std::vector<MidiPacket> toSend;
+    {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        while (!sendQueue.empty() && toSend.size() < 16) {
+            toSend.push_back(std::move(sendQueue.front()));
+            sendQueue.pop_front();
+        }
+    }
+
+    for (auto& packet : toSend) {
+        packet.sentTime = juce::Time::getCurrentTime();
+        sendTcpPacket(packet);
+
+        if (packet.requiresAck) {
+            pendingAcks[packet.sequenceNumber] = packet;
+        }
+    }
+}
+
+void NonRealtimeMidiTransport::sendTcpPacket(const MidiPacket& packet) {
+    // Fragment if SysEx is too large (>1KB chunks)
+    const size_t MAX_FRAGMENT = 1024;
+    size_t offset = 0;
+
+    while (offset < packet.data.size()) {
+        size_t fragmentSize = std::min(MAX_FRAGMENT, packet.data.size() - offset);
+
+        // Build TCP frame: [header][fragment]
+        std::vector<uint8_t> frame;
+        frame.push_back('M');  // Magic
+        frame.push_back('N');  // Non-real-time
+        frame.push_back(static_cast<uint8_t>((packet.sequenceNumber >> 24) & 0xFF));
+        frame.push_back(static_cast<uint8_t>((packet.sequenceNumber >> 16) & 0xFF));
+        frame.push_back(static_cast<uint8_t>((packet.sequenceNumber >> 8) & 0xFF));
+        frame.push_back(static_cast<uint8_t>(packet.sequenceNumber & 0xFF));
+        frame.push_back(static_cast<uint8_t>((fragmentSize >> 8) & 0xFF));
+        frame.push_back(static_cast<uint8_t>(fragmentSize & 0xFF));
+        frame.insert(frame.end(), packet.data.begin() + offset,
+                    packet.data.begin() + offset + fragmentSize);
+
+        int sent = tcpSocket.write(frame.data(), static_cast<int>(frame.size()));
+        if (sent != static_cast<int>(frame.size())) {
+            // Connection error - mark for retry
+            juce::Logger::writeToLog("NonRealtimeMidiTransport: Send failed, disconnecting");
+            connected = false;
+            failures.fetch_add(1, std::memory_order_relaxed);
+            return;
+        }
+
+        fragmentsSent.fetch_add(1, std::memory_order_relaxed);
+        offset += fragmentSize;
+    }
+
+    messagesSent.fetch_add(1, std::memory_order_relaxed);
+}
+
+void NonRealtimeMidiTransport::receiveData() {
+    // Set socket to non-blocking for read
+    tcpSocket.waitUntilReady(false, 10);  // 10ms timeout
+
+    uint8_t headerBuffer[8];
+
+    // Read TCP frame header
+    int received = tcpSocket.read(headerBuffer, 8, false);
+    if (received != 8) {
+        if (received > 0) {
+            juce::Logger::writeToLog("NonRealtimeMidiTransport: Incomplete header");
+            connected = false;
+        }
+        return;
+    }
+
+    // Parse header
+    if (headerBuffer[0] != 'M' || headerBuffer[1] != 'N') {
+        // Protocol error
+        juce::Logger::writeToLog("NonRealtimeMidiTransport: Invalid magic bytes");
+        connected = false;
+        return;
+    }
+
+    uint32_t seqNum = (static_cast<uint32_t>(headerBuffer[2]) << 24) |
+                      (static_cast<uint32_t>(headerBuffer[3]) << 16) |
+                      (static_cast<uint32_t>(headerBuffer[4]) << 8) |
+                      static_cast<uint32_t>(headerBuffer[5]);
+    uint16_t fragmentSize = (static_cast<uint16_t>(headerBuffer[6]) << 8) |
+                            static_cast<uint16_t>(headerBuffer[7]);
+
+    // Read fragment data
+    std::vector<uint8_t> fragmentData(fragmentSize);
+    received = tcpSocket.read(fragmentData.data(), fragmentSize, true);  // Blocking read
+    if (received != fragmentSize) {
+        juce::Logger::writeToLog("NonRealtimeMidiTransport: Incomplete fragment");
+        connected = false;
+        return;
+    }
+
+    fragmentsReceived.fetch_add(1, std::memory_order_relaxed);
+
+    // Send ACK
+    sendAck(seqNum);
+
+    // Reassemble and enqueue
+    reassembleFragment(seqNum, std::move(fragmentData));
+}
+
+void NonRealtimeMidiTransport::sendAck(uint32_t seqNum) {
+    uint8_t ack[7] = {'A', 'C', 'K',
+                     static_cast<uint8_t>((seqNum >> 24) & 0xFF),
+                     static_cast<uint8_t>((seqNum >> 16) & 0xFF),
+                     static_cast<uint8_t>((seqNum >> 8) & 0xFF),
+                     static_cast<uint8_t>(seqNum & 0xFF)};
+    tcpSocket.write(ack, 7);
+}
+
+void NonRealtimeMidiTransport::retryUnacknowledged() {
+    auto now = juce::Time::getCurrentTime();
+    std::vector<uint32_t> toRetry;
+
+    for (auto& [seqNum, pending] : pendingAcks) {
+        auto elapsed = now.toMilliseconds() - pending.sentTime.toMilliseconds();
+
+        if (elapsed > 1000 && pending.retryCount < 3) {  // 1 second timeout, max 3 retries
+            toRetry.push_back(seqNum);
+        } else if (pending.retryCount >= 3) {
+            // Give up - log error
+            juce::Logger::writeToLog("NonRealtimeMidiTransport: Failed to deliver packet " +
+                                    juce::String(seqNum) + " after 3 retries");
+            pendingAcks.erase(seqNum);
+            failures.fetch_add(1, std::memory_order_relaxed);
+        }
+    }
+
+    for (uint32_t seqNum : toRetry) {
+        auto& pending = pendingAcks[seqNum];
+        pending.retryCount++;
+        pending.sentTime = juce::Time::getCurrentTime();
+        sendTcpPacket(pending);
+        retries.fetch_add(1, std::memory_order_relaxed);
+    }
+}
+
+void NonRealtimeMidiTransport::reassembleFragment(uint32_t seqNum,
+                                                   std::vector<uint8_t>&& fragmentData) {
+    // For simplicity, assume single-fragment messages for now
+    // Full implementation would track multi-fragment reassembly
+    MidiPacket packet;
+    packet.data = std::move(fragmentData);
+    packet.sequenceNumber = seqNum;
+    packet.deviceId = 0;  // TODO: Extract from packet
+
+    {
+        std::lock_guard<std::mutex> lock(queueMutex);
+        receiveQueue.push_back(std::move(packet));
+    }
+
+    messagesReceived.fetch_add(1, std::memory_order_relaxed);
+}
+
+NonRealtimeMidiTransport::Stats NonRealtimeMidiTransport::getStats() const {
+    Stats s;
+    s.messagesSent = messagesSent.load(std::memory_order_relaxed);
+    s.messagesReceived = messagesReceived.load(std::memory_order_relaxed);
+    s.fragmentsSent = fragmentsSent.load(std::memory_order_relaxed);
+    s.fragmentsReceived = fragmentsReceived.load(std::memory_order_relaxed);
+    s.retries = retries.load(std::memory_order_relaxed);
+    s.failures = failures.load(std::memory_order_relaxed);
+    return s;
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/NonRealtimeMidiTransport.h b/modules/juce/midi-server/network/transport/NonRealtimeMidiTransport.h
new file mode 100644
index 0000000..ac58845
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/NonRealtimeMidiTransport.h
@@ -0,0 +1,122 @@
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include <juce_audio_basics/juce_audio_basics.h>
+#include <deque>
+#include <mutex>
+#include <map>
+#include <vector>
+#include <atomic>
+
+namespace NetworkMidi {
+
+/**
+ * Non-real-time MIDI transport using TCP for reliable delivery.
+ *
+ * Features:
+ * - Guaranteed delivery (ACK/retry)
+ * - SysEx fragmentation (1KB chunks)
+ * - Flow control
+ * - 100% reliability target
+ *
+ * This transport uses TCP for reliable delivery of SysEx and bulk transfers.
+ * Large messages are fragmented into 1KB chunks and reassembled on the receiver.
+ * ACK/retry mechanism ensures 100% delivery (up to 3 retries with 1s timeout).
+ *
+ * Wire format:
+ * - 2 bytes magic: 'M' 'N' (MIDI Non-real-time)
+ * - 4 bytes sequence number (big-endian)
+ * - 2 bytes fragment size (big-endian)
+ * - N bytes fragment data
+ *
+ * ACK format:
+ * - 3 bytes: 'A' 'C' 'K'
+ * - 4 bytes sequence number
+ */
+class NonRealtimeMidiTransport : public juce::Thread {
+public:
+    struct MidiPacket {
+        std::vector<uint8_t> data;
+        uint16_t deviceId;
+        uint32_t sequenceNumber;
+        bool requiresAck;
+        juce::Time sentTime;
+        int retryCount{0};
+    };
+
+    /**
+     * Create non-real-time MIDI transport.
+     *
+     * @param host Remote host address
+     * @param port Remote TCP port
+     */
+    NonRealtimeMidiTransport(juce::String host, int port);
+    ~NonRealtimeMidiTransport() override;
+
+    /**
+     * Send MIDI message (thread-safe).
+     *
+     * @param msg MIDI message to send
+     * @param deviceId Device ID
+     */
+    void sendMessage(const juce::MidiMessage& msg, uint16_t deviceId);
+
+    /**
+     * Get received messages (thread-safe).
+     *
+     * @return Vector of received packets
+     */
+    std::vector<MidiPacket> getReceivedMessages();
+
+    void run() override;
+
+    struct Stats {
+        uint64_t messagesSent{0};
+        uint64_t messagesReceived{0};
+        uint64_t fragmentsSent{0};
+        uint64_t fragmentsReceived{0};
+        uint64_t retries{0};
+        uint64_t failures{0};
+    };
+
+    Stats getStats() const;
+
+private:
+    std::mutex queueMutex;
+    std::deque<MidiPacket> sendQueue;
+    std::deque<MidiPacket> receiveQueue;
+    juce::WaitableEvent dataAvailable;
+
+    juce::StreamingSocket tcpSocket;
+    juce::String remoteHost;
+    int remotePort;
+    bool connected{false};
+
+    uint32_t nextSequenceNumber{0};
+    std::map<uint32_t, MidiPacket> pendingAcks;
+
+    std::atomic<uint64_t> messagesSent{0};
+    std::atomic<uint64_t> messagesReceived{0};
+    std::atomic<uint64_t> fragmentsSent{0};
+    std::atomic<uint64_t> fragmentsReceived{0};
+    std::atomic<uint64_t> retries{0};
+    std::atomic<uint64_t> failures{0};
+
+    // Reassembly buffer for fragmented messages
+    struct ReassemblyState {
+        std::vector<uint8_t> data;
+        size_t expectedSize{0};
+        juce::Time firstFragmentTime;
+    };
+    std::map<uint32_t, ReassemblyState> reassemblyBuffer;
+
+    void attemptConnection();
+    void processSendQueue();
+    void sendTcpPacket(const MidiPacket& packet);
+    void receiveData();
+    void sendAck(uint32_t seqNum);
+    void retryUnacknowledged();
+    void reassembleFragment(uint32_t seqNum, std::vector<uint8_t>&& fragmentData);
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/PHASE_C4_REPORT.md b/modules/juce/midi-server/network/transport/PHASE_C4_REPORT.md
new file mode 100644
index 0000000..c46a591
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/PHASE_C4_REPORT.md
@@ -0,0 +1,569 @@
+# Phase C.4 Implementation Report: MIDI Message Classification and Routing
+
+**Date**: 2025-10-06
+**Phase**: C.4 - Message Classification and Routing
+**Status**: ✅ COMPLETE
+**Workplan**: `/docs/1.0/seda/implementation/workplan.md`
+
+---
+
+## Executive Summary
+
+Successfully implemented MIDI message classification and routing system (Phase C.4) for dual-transport MIDI architecture. The system automatically classifies incoming MIDI messages as either real-time or non-real-time and routes them to appropriate transports (UDP for real-time, TCP for non-real-time).
+
+### Key Deliverables
+
+1. **MidiClassifier.h** - Inline message classification with <100ns performance
+2. **MidiMessageRouter** - Thread-safe router with atomic statistics
+3. **Comprehensive test suite** - 30+ tests covering all MIDI message types
+4. **Integration example** - Complete working example showing usage
+
+### Performance Metrics
+
+- **Classification speed**: <100ns per message (target: <100ns) ✅
+- **Routing speed**: <10μs per message (target: <10μs) ✅
+- **Thread safety**: Multi-threaded tests pass with 1000+ messages ✅
+- **Zero allocation**: Real-time safe implementation ✅
+
+---
+
+## Files Created
+
+### Implementation Files
+
+| File | Lines | Description |
+|------|-------|-------------|
+| `network/transport/MidiClassifier.h` | 150 | Message classification logic (header-only) |
+| `network/transport/MidiMessageRouter.h` | 145 | Router class definition with statistics |
+| `network/transport/MidiMessageRouter.cpp` | 245 | Router implementation |
+| `network/transport/MidiClassifier_Example.cpp` | 280 | Complete integration example |
+
+### Test Files
+
+| File | Lines | Description |
+|------|-------|-------------|
+| `tests/unit/MidiClassifierTest.cpp` | 375 | Classifier tests (all MIDI message types) |
+| `tests/unit/MidiMessageRouterTest.cpp` | 400 | Router tests (threading, performance, stats) |
+
+### Updated Files
+
+| File | Changes | Description |
+|------|---------|-------------|
+| `CMakeLists.txt` | +2 lines | Added new test files to build |
+| `docs/1.0/seda/implementation/workplan.md` | 4 checkboxes | Marked Phase C.4 complete |
+
+**Total**: 1,595 lines of code and tests added
+
+---
+
+## Implementation Details
+
+### 1. Message Classification (`MidiClassifier.h`)
+
+**Design Philosophy**: Zero-overhead abstraction with inline functions
+
+#### Classification Rules
+
+```cpp
+enum class MidiMessageClass {
+    RealTime,      // UDP transport (low latency, best-effort)
+    NonRealTime    // TCP transport (reliable, higher latency OK)
+};
+```
+
+**Real-Time Messages** (UDP):
+- Channel Voice (0x80-0xEF): Note On/Off, CC, Pitch Bend, Aftertouch, Program Change
+- System Real-Time (0xF8-0xFF): MIDI Clock, Start, Stop, Continue, Active Sensing
+
+**Non-Real-Time Messages** (TCP):
+- System Exclusive (0xF0...0xF7): SysEx, patch dumps, sample dumps
+- System Common (0xF1-0xF7): MTC, Song Position, etc.
+- Default for safety: Unknown messages → NonRealTime
+
+#### Performance Characteristics
+
+```cpp
+inline MidiMessageClass classifyMidiMessage(const juce::MidiMessage& msg)
+{
+    if (msg.getRawDataSize() == 0) {
+        return MidiMessageClass::NonRealTime;  // Safety
+    }
+
+    const uint8_t statusByte = msg.getRawData()[0];
+
+    // Fast path: Status byte range checks
+    if (statusByte >= 0xF8) return MidiMessageClass::RealTime;
+    if (msg.isSysEx()) return MidiMessageClass::NonRealTime;
+    if (statusByte >= 0x80 && statusByte < 0xF0) return MidiMessageClass::RealTime;
+
+    return MidiMessageClass::NonRealTime;  // Default safety
+}
+```
+
+**Measured Performance**: 45ns average (100,000 iterations)
+
+#### Helper Functions
+
+```cpp
+// Human-readable class name
+juce::String getMidiMessageClassName(MidiMessageClass msgClass);
+
+// Detailed classification explanation (debugging)
+juce::String explainClassification(const juce::MidiMessage& msg);
+```
+
+### 2. Message Router (`MidiMessageRouter`)
+
+**Design Philosophy**: Lock-free statistics, thread-safe routing, real-time safe
+
+#### Architecture
+
+```
+┌────────────────────────────────────────────────┐
+│         MidiMessageRouter                       │
+├────────────────────────────────────────────────┤
+│  routeMessage(msg, deviceId, dest...)          │
+│  ├─> classifyMidiMessage(msg)                  │
+│  ├─> RealTime?                                 │
+│  │    ├─ Yes → UdpMidiTransport.sendPacket()  │
+│  │    └─ No  → ReliableTransport.sendReliable()│
+│  └─> updateStatistics() (atomic)               │
+└────────────────────────────────────────────────┘
+```
+
+#### Key Features
+
+**Thread Safety**:
+- All statistics use `std::atomic` operations
+- No locks on routing hot path
+- Safe for concurrent MIDI input threads
+
+**Statistics Tracking**:
+```cpp
+struct Statistics {
+    uint64_t realtimeMessagesSent;
+    uint64_t nonRealtimeMessagesSent;
+    uint64_t routingErrors;
+    uint64_t totalBytesSent;
+
+    // Detailed tracking (optional)
+    uint64_t noteMessages;
+    uint64_t controlChangeMessages;
+    uint64_t clockMessages;
+    uint64_t sysexMessages;
+    uint64_t otherMessages;
+};
+```
+
+**Callback Support**:
+```cpp
+bool routeMessageWithCallback(
+    const juce::MidiMessage& msg,
+    uint16_t deviceId,
+    const juce::Uuid& destNode,
+    const juce::String& destAddress,
+    int destPort,
+    std::function<void()> onDelivered,
+    std::function<void(const juce::String& reason)> onFailed
+);
+```
+
+- Real-time messages: Callback invoked immediately (async)
+- Non-real-time messages: Callback invoked on ACK/timeout
+
+**Error Handling**:
+```cpp
+std::function<void(const juce::String& error, const juce::MidiMessage& msg)> onRoutingError;
+```
+
+Dispatched asynchronously to avoid blocking real-time threads.
+
+#### Integration Example
+
+```cpp
+class MidiInputHandler : public juce::MidiInputCallback {
+    MidiMessageRouter& router;
+
+    void handleIncomingMidiMessage(juce::MidiInput* source,
+                                   const juce::MidiMessage& msg) override {
+        uint16_t deviceId = getDeviceIdForSource(source);
+
+        // Automatic classification and routing
+        bool success = router.routeMessage(
+            msg,
+            deviceId,
+            destNode,
+            destAddress,
+            destPort
+        );
+
+        if (!success) {
+            // Handle error
+        }
+    }
+};
+```
+
+---
+
+## Test Results
+
+### Classifier Tests (`MidiClassifierTest.cpp`)
+
+**Test Coverage**: 30 tests, 100% pass rate
+
+#### Test Categories
+
+1. **Channel Voice Messages** (Real-Time)
+   - ✅ Note On → RealTime
+   - ✅ Note Off → RealTime
+   - ✅ Control Change → RealTime
+   - ✅ Pitch Bend → RealTime
+   - ✅ Program Change → RealTime
+   - ✅ Aftertouch → RealTime
+   - ✅ Channel Pressure → RealTime
+
+2. **System Real-Time Messages** (Real-Time)
+   - ✅ MIDI Clock (0xF8) → RealTime
+   - ✅ MIDI Start (0xFA) → RealTime
+   - ✅ MIDI Stop (0xFC) → RealTime
+   - ✅ MIDI Continue (0xFB) → RealTime
+   - ✅ Active Sensing (0xFE) → RealTime
+   - ✅ System Reset (0xFF) → RealTime
+
+3. **System Exclusive Messages** (Non-Real-Time)
+   - ✅ Short SysEx (5 bytes) → NonRealTime
+   - ✅ Large SysEx (1KB) → NonRealTime
+   - ✅ Universal SysEx → NonRealTime
+
+4. **System Common Messages** (Non-Real-Time)
+   - ✅ MTC Quarter Frame (0xF1) → NonRealTime
+   - ✅ Song Position (0xF2) → NonRealTime
+   - ✅ Song Select (0xF3) → NonRealTime
+   - ✅ Tune Request (0xF6) → NonRealTime
+
+5. **Edge Cases**
+   - ✅ Empty message → NonRealTime (safety)
+   - ✅ All 16 MIDI channels work correctly
+   - ✅ All note numbers (0-127) classified correctly
+   - ✅ All controller numbers (0-127) classified correctly
+
+6. **Performance Tests**
+   - ✅ Classification speed: 45ns average (target: <100ns)
+   - ✅ Zero allocation verified
+   - ✅ Thread-safe (const function)
+
+### Router Tests (`MidiMessageRouterTest.cpp`)
+
+**Test Coverage**: 13 tests, 100% pass rate
+
+#### Test Categories
+
+1. **Basic Routing**
+   - ✅ Note On routed to UDP (real-time)
+   - ✅ SysEx routed to TCP (non-real-time)
+   - ✅ Control Change routed to UDP
+   - ✅ MIDI Clock routed to UDP
+
+2. **Statistics Tracking**
+   - ✅ Real-time counter increments correctly
+   - ✅ Non-real-time counter increments correctly
+   - ✅ Byte counter tracks total data sent
+   - ✅ Reset statistics works
+
+3. **Detailed Statistics**
+   - ✅ Note message counter works
+   - ✅ Control Change counter works
+   - ✅ Clock counter works
+   - ✅ SysEx counter works
+   - ✅ Enable/disable detailed tracking
+
+4. **Callback Support**
+   - ✅ Real-time callback invoked immediately
+   - ✅ Non-real-time callback passed to transport
+
+5. **Thread Safety**
+   - ✅ 10 threads × 100 messages = 1000 concurrent routes
+   - ✅ No data races (verified with thread sanitizer)
+   - ✅ All messages successfully routed
+
+6. **Performance Under Load**
+   - ✅ 1000 mixed message types routed correctly
+   - ✅ Statistics accurate under concurrent load
+
+7. **Performance Benchmark**
+   - ✅ Routing speed: 8.2μs average (target: <10μs)
+   - ✅ 10,000 messages processed in 82ms
+
+8. **Error Handling**
+   - ✅ Error callback invoked on transport failure
+   - ✅ Error counter increments
+
+---
+
+## Compliance with Requirements
+
+### Workplan Requirements
+
+| Requirement | Status | Evidence |
+|-------------|--------|----------|
+| classifyMidiMessage() implemented | ✅ | `MidiClassifier.h:50-73` |
+| Classification rules correct | ✅ | All tests pass |
+| Message routing works | ✅ | Router tests pass |
+| Unit tests for all MIDI types | ✅ | 30 classifier tests |
+| Thread-safe routing | ✅ | Concurrent routing test passes |
+| Performance <100ns classification | ✅ | 45ns measured |
+
+### Design Document Requirements
+
+| Requirement | Status | Evidence |
+|-------------|--------|----------|
+| Real-time messages → UDP | ✅ | Router routes Note On/CC/Clock to UDP |
+| Non-real-time messages → TCP | ✅ | Router routes SysEx to TCP |
+| Lock-free statistics | ✅ | All counters use `std::atomic` |
+| No allocation in hot path | ✅ | Inline functions, stack-only data |
+| Real-time safe | ✅ | No locks, no blocking calls |
+
+### CLAUDE.md Guidelines
+
+| Guideline | Status | Evidence |
+|-----------|--------|----------|
+| JUCE coding style | ✅ | camelCase, JUCE types used |
+| Comprehensive comments | ✅ | Doxygen-style documentation |
+| No class inheritance | ✅ | Composition-based design |
+| Files <500 lines | ✅ | Largest file: 400 lines |
+| Thread-safe design | ✅ | Atomics, no locks |
+
+---
+
+## Integration Points
+
+### How to Use the Classifier
+
+```cpp
+#include "network/transport/MidiClassifier.h"
+
+using namespace NetworkMidi;
+
+// Simple classification
+juce::MidiMessage msg = juce::MidiMessage::noteOn(1, 60, 0.8f);
+MidiMessageClass msgClass = classifyMidiMessage(msg);
+
+if (msgClass == MidiMessageClass::RealTime) {
+    // Send via UDP
+} else {
+    // Send via TCP
+}
+
+// Debugging
+juce::String explanation = explainClassification(msg);
+DBG(explanation);  // "Channel Voice (0x90) -> RealTime"
+```
+
+### How to Use the Router
+
+```cpp
+#include "network/transport/MidiMessageRouter.h"
+
+// Setup (once)
+UdpMidiTransport udpTransport(5004);
+ReliableTransport reliableTransport(udpTransport);
+MidiMessageRouter router(udpTransport, reliableTransport);
+
+// Enable detailed tracking
+router.setDetailedTracking(true);
+
+// Route messages (from MIDI input callback)
+void handleIncomingMidiMessage(juce::MidiInput* source,
+                               const juce::MidiMessage& msg) {
+    router.routeMessage(
+        msg,
+        deviceId,
+        destNode,
+        destAddress,
+        destPort
+    );
+}
+
+// Get statistics
+auto stats = router.getStatistics();
+DBG("Real-time messages: " << stats.realtimeMessagesSent);
+DBG("Non-real-time messages: " << stats.nonRealtimeMessagesSent);
+DBG("Note messages: " << stats.noteMessages);
+```
+
+### Full Integration Example
+
+See `network/transport/MidiClassifier_Example.cpp` for a complete working example including:
+- Transport setup
+- Router initialization
+- MIDI input callback integration
+- Statistics monitoring
+- Error handling
+
+---
+
+## Performance Analysis
+
+### Classification Performance
+
+**Test Setup**: 100,000 iterations of Note On message classification
+
+**Results**:
+```
+Average classification time: 45ns
+Peak classification time: 120ns
+Minimum classification time: 38ns
+
+Target: <100ns ✅
+```
+
+**Analysis**:
+- Well within target
+- Inline functions eliminate function call overhead
+- Single-threaded cache-friendly design
+- Status byte range checks are CPU-predictable branches
+
+### Routing Performance
+
+**Test Setup**: 10,000 Note On messages routed through full stack
+
+**Results**:
+```
+Average routing time: 8.2μs
+Peak routing time: 25μs
+Minimum routing time: 5μs
+
+Target: <10μs ✅
+```
+
+**Breakdown**:
+- Classification: ~45ns (<1%)
+- MidiPacket construction: ~2μs (25%)
+- UDP send: ~6μs (73%)
+- Statistics update: ~150ns (2%)
+
+**Bottleneck**: UDP socket send operation (expected - OS kernel call)
+
+### Concurrent Performance
+
+**Test Setup**: 10 threads × 100 messages = 1000 messages
+
+**Results**:
+```
+All messages routed successfully: 1000/1000 (100%)
+No data races detected
+No deadlocks
+Statistics accurate
+
+Thread safety: ✅
+```
+
+**Analysis**:
+- Atomic operations scale well
+- No lock contention
+- Real-time safe under concurrent load
+
+---
+
+## Next Steps (Phase C.5)
+
+The following items remain for complete dual-transport implementation:
+
+### Testing & Validation
+
+1. **Burst Handling Test**
+   - Verify 2000 msg/sec burst handling
+   - Measure drop rate (<1% target)
+   - Test RealtimeMidiBuffer overflow behavior
+
+2. **SysEx Reliability Test**
+   - Send 100 large SysEx messages
+   - Verify 100% delivery
+   - Test fragmentation/reassembly
+
+3. **Latency Measurement**
+   - Real-time path: <1ms target
+   - Non-real-time path: <100ms target
+   - Measure end-to-end latency
+
+4. **Metrics Endpoint**
+   - Implement `/metrics/midi` HTTP endpoint
+   - Export statistics as JSON
+   - Add latency histograms
+
+5. **Integration**
+   - Integrate with existing NetworkConnection
+   - Update MeshManager to use router
+   - Add configuration options
+
+---
+
+## Lessons Learned
+
+### What Went Well
+
+1. **Header-only classifier** - Zero overhead, easy to use
+2. **Atomic statistics** - Thread-safe without locks
+3. **Comprehensive tests** - High confidence in correctness
+4. **Performance targets** - All targets exceeded
+5. **Documentation** - Clear examples and integration guide
+
+### Challenges Encountered
+
+1. **MidiPacket API** - Had to use factory methods instead of direct field access
+2. **JUCE MessageManager** - runDispatchLoopUntil() not available, had to simplify tests
+3. **Pre-existing test failures** - NodeIdentity tests broken, but not our concern
+
+### Improvements for Next Phase
+
+1. **Add latency tracking** - Histogram of routing latencies
+2. **Add drop rate monitoring** - Alert when >1% drops
+3. **Metrics dashboard** - Web UI for statistics
+4. **Integration tests** - End-to-end tests with real MIDI devices
+5. **Benchmarking suite** - Automated performance regression tests
+
+---
+
+## References
+
+### Design Documents
+
+- [SEDA Architecture Design](/docs/1.0/seda/planning/design.md)
+- [Implementation Workplan](/docs/1.0/seda/implementation/workplan.md)
+
+### Relevant Code
+
+- **MidiPacket**: `/network/core/MidiPacket.h`
+- **UdpMidiTransport**: `/network/transport/UdpMidiTransport.h`
+- **ReliableTransport**: `/network/transport/ReliableTransport.h`
+
+### Standards
+
+- **MIDI 1.0 Specification**: Message format and status bytes
+- **RTP-MIDI (RFC 6295)**: Reference for real-time MIDI transport
+- **C++ Core Guidelines**: Modern C++ best practices
+
+---
+
+## Conclusion
+
+Phase C.4 is **complete and successful**. The message classification and routing system is:
+
+✅ **Correct**: All tests pass, all MIDI message types handled
+✅ **Fast**: Classification <100ns, routing <10μs
+✅ **Thread-safe**: Concurrent routing works flawlessly
+✅ **Real-time safe**: No allocation, no locks, no blocking
+✅ **Well-tested**: 43 tests, comprehensive coverage
+✅ **Well-documented**: Clear examples and integration guide
+
+The system is ready for integration into Phase C.5 (Testing & Validation) and subsequent phases.
+
+**Total Implementation Time**: ~2 hours (as estimated in workplan)
+
+---
+
+**Document Status**: Final
+**Next Review**: Phase C.5 completion
+**Author**: Claude Code (C++ Pro Agent)
+**Date**: 2025-10-06
diff --git a/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.cpp b/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.cpp
new file mode 100644
index 0000000..abceaed
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.cpp
@@ -0,0 +1,69 @@
+#include "RealtimeMidiBuffer.h"
+
+namespace NetworkMidi {
+
+bool RealtimeMidiBuffer::write(const MidiPacket& packet) {
+    int start1, size1, start2, size2;
+    fifo.prepareToWrite(1, start1, size1, start2, size2);
+
+    if (size1 == 0) {
+        // Buffer full - implement drop-oldest policy
+        droppedCount.fetch_add(1, std::memory_order_relaxed);
+
+        // Force-advance read pointer to make space
+        // This drops the oldest message
+        int readStart, readSize, dummy1, dummy2;
+        fifo.prepareToRead(1, readStart, readSize, dummy1, dummy2);
+        if (readSize > 0) {
+            fifo.finishedRead(1);  // Discard oldest
+        }
+
+        // Try again
+        fifo.prepareToWrite(1, start1, size1, start2, size2);
+        if (size1 == 0) {
+            return false;  // Still can't write (shouldn't happen)
+        }
+    }
+
+    buffer[start1] = packet;
+    fifo.finishedWrite(1);
+    totalWritten.fetch_add(1, std::memory_order_relaxed);
+    return true;
+}
+
+int RealtimeMidiBuffer::readBatch(MidiPacket* dest, int maxCount) {
+    int start1, size1, start2, size2;
+    fifo.prepareToRead(maxCount, start1, size1, start2, size2);
+
+    int totalReadCount = 0;
+
+    // Copy first contiguous block
+    for (int i = 0; i < size1; ++i) {
+        dest[totalReadCount++] = buffer[start1 + i];
+    }
+
+    // Copy second block if ring wraps around
+    for (int i = 0; i < size2; ++i) {
+        dest[totalReadCount++] = buffer[start2 + i];
+    }
+
+    if (totalReadCount > 0) {
+        fifo.finishedRead(totalReadCount);
+        totalRead.fetch_add(totalReadCount, std::memory_order_relaxed);
+    }
+
+    return totalReadCount;
+}
+
+RealtimeMidiBuffer::Stats RealtimeMidiBuffer::getStats() const {
+    Stats s;
+    s.numReady = fifo.getNumReady();
+    s.freeSpace = fifo.getFreeSpace();
+    s.dropped = droppedCount.load(std::memory_order_relaxed);
+    s.written = totalWritten.load(std::memory_order_relaxed);
+    s.read = totalRead.load(std::memory_order_relaxed);
+    s.dropRate = (s.written > 0) ? (100.0f * s.dropped / s.written) : 0.0f;
+    return s;
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.h b/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.h
new file mode 100644
index 0000000..a3740a5
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.h
@@ -0,0 +1,80 @@
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include <atomic>
+#include <cstdint>
+
+namespace NetworkMidi {
+
+/**
+ * Lock-free ring buffer for real-time MIDI messages.
+ *
+ * Features:
+ * - Single producer, single consumer (lock-free)
+ * - Fixed capacity with drop-oldest overflow policy
+ * - ~50ns write latency, ~200ns batch read latency
+ * - Thread-safe without mutexes
+ *
+ * Design rationale:
+ * Real-time MIDI can produce sustained 500 msg/sec with bursts to 2000+ msg/sec.
+ * This buffer uses juce::AbstractFifo for lock-free operation with a capacity
+ * of 2048 messages (~1 second buffering at peak burst rate).
+ *
+ * Overflow policy: Drop oldest messages to keep newest (latest performer intent).
+ */
+class RealtimeMidiBuffer {
+public:
+    static constexpr int CAPACITY = 2048;  // Power of 2 for efficient modulo
+
+    struct MidiPacket {
+        uint8_t data[4];     // Max 4 bytes for channel voice messages
+        uint8_t length;
+        uint16_t deviceId;
+        uint32_t timestamp;  // Microseconds since epoch
+    };
+
+    /**
+     * Write message to buffer (called from MIDI input thread).
+     *
+     * @param packet MIDI message to enqueue
+     * @return true if written, false if buffer full (message dropped)
+     *
+     * Performance: ~50ns on modern CPU (no cache misses)
+     */
+    bool write(const MidiPacket& packet);
+
+    /**
+     * Read batch of messages (called from UDP sender thread).
+     *
+     * @param dest Destination array (caller-owned)
+     * @param maxCount Maximum messages to read
+     * @return Number of messages actually read
+     *
+     * Performance: ~200ns for batch of 16 messages
+     */
+    int readBatch(MidiPacket* dest, int maxCount);
+
+    /**
+     * Get buffer statistics (lock-free).
+     */
+    struct Stats {
+        int numReady;        // Messages currently in buffer
+        int freeSpace;       // Available capacity
+        uint64_t dropped;    // Total messages dropped
+        uint64_t written;    // Total messages written
+        uint64_t read;       // Total messages read
+        float dropRate;      // Percentage of messages dropped
+    };
+
+    Stats getStats() const;
+
+private:
+    juce::AbstractFifo fifo{CAPACITY};
+    MidiPacket buffer[CAPACITY];
+
+    std::atomic<uint64_t> droppedCount{0};
+    std::atomic<uint64_t> totalWritten{0};
+    std::atomic<uint64_t> totalRead{0};
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/RealtimeMidiTransport.cpp b/modules/juce/midi-server/network/transport/RealtimeMidiTransport.cpp
new file mode 100644
index 0000000..1119ac0
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/RealtimeMidiTransport.cpp
@@ -0,0 +1,107 @@
+#include "RealtimeMidiTransport.h"
+#include <cstring>
+
+namespace NetworkMidi {
+
+RealtimeMidiTransport::RealtimeMidiTransport(RealtimeMidiBuffer& buf,
+                                              juce::String host, int port)
+    : juce::Thread("RealtimeMidiUDP"), buffer(buf),
+      remoteHost(host), remotePort(port)
+{
+    // Set real-time priority
+    setPriority(juce::Thread::Priority::highest);
+}
+
+RealtimeMidiTransport::~RealtimeMidiTransport() {
+    signalThreadShouldExit();
+    stopThread(2000);  // 2 second timeout
+}
+
+void RealtimeMidiTransport::run() {
+    // Bind socket to any available port (OS assigns)
+    if (!udpSocket.bindToPort(0)) {
+        juce::Logger::writeToLog("RealtimeMidiTransport: Failed to bind UDP socket");
+        return;
+    }
+
+    juce::Logger::writeToLog("RealtimeMidiTransport: Started on port " +
+                            juce::String(udpSocket.getBoundPort()));
+
+    RealtimeMidiBuffer::MidiPacket packets[32];  // Batch buffer
+
+    while (!threadShouldExit()) {
+        // Read batch from ring buffer (lock-free)
+        int count = buffer.readBatch(packets, 32);
+
+        if (count > 0) {
+            // Send each packet via UDP (non-blocking)
+            for (int i = 0; i < count; ++i) {
+                sendPacket(packets[i]);
+            }
+        } else {
+            // No messages - yield CPU briefly
+            // 1ms sleep is acceptable for real-time (still <1ms latency target)
+            juce::Thread::sleep(1);
+        }
+
+        // Also receive incoming UDP messages (non-blocking)
+        receivePackets();
+    }
+
+    juce::Logger::writeToLog("RealtimeMidiTransport: Stopped");
+}
+
+void RealtimeMidiTransport::sendPacket(const RealtimeMidiBuffer::MidiPacket& packet) {
+    // Serialize packet (fixed-size binary format)
+    uint8_t wireFormat[16];
+    wireFormat[0] = 'M';  // Magic byte
+    wireFormat[1] = 'R';  // Real-time marker
+    wireFormat[2] = packet.length;
+    wireFormat[3] = static_cast<uint8_t>((packet.deviceId >> 8) & 0xFF);
+    wireFormat[4] = static_cast<uint8_t>(packet.deviceId & 0xFF);
+    std::memcpy(&wireFormat[5], &packet.timestamp, 4);
+    std::memcpy(&wireFormat[9], packet.data, packet.length);
+
+    int totalSize = 9 + packet.length;
+
+    // Send UDP (best-effort, no retry)
+    int sent = udpSocket.write(remoteHost, remotePort, wireFormat, totalSize);
+    if (sent == totalSize) {
+        packetsSent.fetch_add(1, std::memory_order_relaxed);
+    } else {
+        sendFailures.fetch_add(1, std::memory_order_relaxed);
+    }
+}
+
+void RealtimeMidiTransport::receivePackets() {
+    uint8_t receiveBuffer[1024];
+    juce::String senderHost;
+    int senderPort;
+
+    // Non-blocking read (returns immediately if no data)
+    int received = udpSocket.read(receiveBuffer, sizeof(receiveBuffer), false,
+                                   senderHost, senderPort);
+
+    if (received > 0) {
+        // Verify magic bytes
+        if (received >= 9 && receiveBuffer[0] == 'M' && receiveBuffer[1] == 'R') {
+            packetsReceived.fetch_add(1, std::memory_order_relaxed);
+
+            // Parse packet (implementation-specific - could enqueue to input buffer)
+            // For now, just count received packets
+        } else {
+            receiveErrors.fetch_add(1, std::memory_order_relaxed);
+        }
+    }
+}
+
+RealtimeMidiTransport::Stats RealtimeMidiTransport::getStats() const {
+    Stats s;
+    s.packetsSent = packetsSent.load(std::memory_order_relaxed);
+    s.packetsReceived = packetsReceived.load(std::memory_order_relaxed);
+    s.sendFailures = sendFailures.load(std::memory_order_relaxed);
+    s.receiveErrors = receiveErrors.load(std::memory_order_relaxed);
+    return s;
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/RealtimeMidiTransport.h b/modules/juce/midi-server/network/transport/RealtimeMidiTransport.h
new file mode 100644
index 0000000..4354a4b
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/RealtimeMidiTransport.h
@@ -0,0 +1,64 @@
+#pragma once
+
+#include "RealtimeMidiBuffer.h"
+#include <juce_core/juce_core.h>
+#include <atomic>
+
+namespace NetworkMidi {
+
+/**
+ * Real-time MIDI UDP transport thread.
+ *
+ * Priority: realtimeAudio (highest user-space priority)
+ * Latency target: <1ms end-to-end
+ * Delivery: Best-effort (no retries)
+ *
+ * This transport uses non-blocking UDP I/O to send real-time MIDI messages
+ * with minimal latency. Messages are batched in groups of up to 32 for efficiency.
+ *
+ * Wire format:
+ * - 2 bytes magic: 'M' 'R' (MIDI Real-time)
+ * - 1 byte length
+ * - 2 bytes device ID (big-endian)
+ * - 4 bytes timestamp (microseconds)
+ * - N bytes MIDI data (up to 4)
+ */
+class RealtimeMidiTransport : public juce::Thread {
+public:
+    /**
+     * Create real-time MIDI transport.
+     *
+     * @param buf Reference to shared ring buffer
+     * @param host Remote host address
+     * @param port Remote UDP port
+     */
+    RealtimeMidiTransport(RealtimeMidiBuffer& buf, juce::String host, int port);
+    ~RealtimeMidiTransport() override;
+
+    void run() override;
+
+    struct Stats {
+        uint64_t packetsSent{0};
+        uint64_t packetsReceived{0};
+        uint64_t sendFailures{0};
+        uint64_t receiveErrors{0};
+    };
+
+    Stats getStats() const;
+
+private:
+    RealtimeMidiBuffer& buffer;
+    juce::DatagramSocket udpSocket;
+    juce::String remoteHost;
+    int remotePort;
+
+    std::atomic<uint64_t> packetsSent{0};
+    std::atomic<uint64_t> packetsReceived{0};
+    std::atomic<uint64_t> sendFailures{0};
+    std::atomic<uint64_t> receiveErrors{0};
+
+    void sendPacket(const RealtimeMidiBuffer::MidiPacket& packet);
+    void receivePackets();
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/transport/tests/DualTransportTest.cpp b/modules/juce/midi-server/network/transport/tests/DualTransportTest.cpp
new file mode 100644
index 0000000..5927dab
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/tests/DualTransportTest.cpp
@@ -0,0 +1,271 @@
+#include <gtest/gtest.h>
+#include "../RealtimeMidiBuffer.h"
+#include "../RealtimeMidiTransport.h"
+#include "../NonRealtimeMidiTransport.h"
+#include <juce_audio_basics/juce_audio_basics.h>
+#include <thread>
+#include <chrono>
+
+using namespace NetworkMidi;
+
+/**
+ * Integration tests for dual-transport MIDI architecture.
+ *
+ * Tests cover:
+ * - UDP send/receive loop (measure latency)
+ * - TCP send/receive with ACK
+ * - SysEx fragmentation/reassembly
+ * - Retry on failure
+ */
+
+class DualTransportTest : public ::testing::Test {
+protected:
+    void SetUp() override {
+        // Initialize JUCE message manager for thread operations
+        if (juce::MessageManager::getInstance() == nullptr) {
+            juce::MessageManager::getInstance();
+        }
+    }
+
+    void TearDown() override {
+        // Small delay to ensure threads finish
+        std::this_thread::sleep_for(std::chrono::milliseconds(100));
+    }
+};
+
+TEST_F(DualTransportTest, RealtimeBufferBasicOperations) {
+    RealtimeMidiBuffer buffer;
+
+    RealtimeMidiBuffer::MidiPacket packet;
+    packet.data[0] = 0x90;
+    packet.data[1] = 60;
+    packet.data[2] = 100;
+    packet.length = 3;
+    packet.deviceId = 0;
+    packet.timestamp = 12345;
+
+    EXPECT_TRUE(buffer.write(packet));
+
+    RealtimeMidiBuffer::MidiPacket readPackets[1];
+    int count = buffer.readBatch(readPackets, 1);
+    EXPECT_EQ(count, 1);
+    EXPECT_EQ(readPackets[0].data[0], 0x90);
+}
+
+TEST_F(DualTransportTest, RealtimeTransportStartStop) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+
+    transport.startThread();
+    EXPECT_TRUE(transport.isThreadRunning());
+
+    std::this_thread::sleep_for(std::chrono::milliseconds(100));
+
+    transport.stopThread(1000);
+    EXPECT_FALSE(transport.isThreadRunning());
+}
+
+TEST_F(DualTransportTest, RealtimeTransportSendMessages) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+
+    transport.startThread();
+
+    // Write messages to buffer
+    for (int i = 0; i < 100; ++i) {
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = 0x90;
+        packet.data[1] = static_cast<uint8_t>(60 + (i % 12));
+        packet.data[2] = 100;
+        packet.length = 3;
+        packet.deviceId = 0;
+        packet.timestamp = static_cast<uint32_t>(i);
+        buffer.write(packet);
+    }
+
+    // Wait for transmission
+    std::this_thread::sleep_for(std::chrono::milliseconds(200));
+
+    auto stats = transport.getStats();
+    // Should have sent most messages (UDP is best-effort, may drop some)
+    EXPECT_GT(stats.packetsSent, 80u);  // At least 80% sent
+
+    transport.stopThread(1000);
+}
+
+TEST_F(DualTransportTest, RealtimeTransportLatencyMeasurement) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+
+    transport.startThread();
+
+    auto start = std::chrono::high_resolution_clock::now();
+
+    // Write a single message
+    RealtimeMidiBuffer::MidiPacket packet;
+    packet.data[0] = 0x90;
+    packet.data[1] = 60;
+    packet.data[2] = 100;
+    packet.length = 3;
+    packet.deviceId = 0;
+    packet.timestamp = 0;
+    buffer.write(packet);
+
+    // Wait for it to be processed
+    std::this_thread::sleep_for(std::chrono::milliseconds(10));
+
+    auto elapsed = std::chrono::high_resolution_clock::now() - start;
+    auto elapsedMs = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();
+
+    // Should process within 10ms (well under 1s target, accounting for sleep)
+    EXPECT_LT(elapsedMs, 20);
+
+    transport.stopThread(1000);
+}
+
+TEST_F(DualTransportTest, NonRealtimeTransportStartStop) {
+    NonRealtimeMidiTransport transport("127.0.0.1", 5005);
+
+    transport.startThread();
+    EXPECT_TRUE(transport.isThreadRunning());
+
+    std::this_thread::sleep_for(std::chrono::milliseconds(100));
+
+    transport.stopThread(2000);
+    EXPECT_FALSE(transport.isThreadRunning());
+}
+
+TEST_F(DualTransportTest, NonRealtimeTransportSendMessage) {
+    NonRealtimeMidiTransport transport("127.0.0.1", 5005);
+
+    transport.startThread();
+
+    // Create a simple MIDI message (not a real connection, just testing queuing)
+    std::vector<uint8_t> midiData = {0x90, 0x3C, 0x64};  // Note On C4, velocity 100
+    juce::MidiMessage msg(midiData.data(), static_cast<int>(midiData.size()));
+
+    transport.sendMessage(msg, 0);
+
+    // Wait for processing
+    std::this_thread::sleep_for(std::chrono::milliseconds(100));
+
+    auto stats = transport.getStats();
+    // Message should be queued (may not be sent without real TCP connection)
+    EXPECT_GE(stats.messagesSent, 0u);
+
+    transport.stopThread(2000);
+}
+
+TEST_F(DualTransportTest, NonRealtimeTransportSysExFragmentation) {
+    NonRealtimeMidiTransport transport("127.0.0.1", 5005);
+
+    transport.startThread();
+
+    // Create a large SysEx message (2KB)
+    std::vector<uint8_t> sysex(2000);
+    sysex[0] = 0xF0;  // SysEx start
+    for (size_t i = 1; i < sysex.size() - 1; ++i) {
+        sysex[i] = static_cast<uint8_t>(i % 128);
+    }
+    sysex.back() = 0xF7;  // SysEx end
+
+    juce::MidiMessage msg(sysex.data(), static_cast<int>(sysex.size()));
+    transport.sendMessage(msg, 0);
+
+    // Wait for fragmentation processing
+    std::this_thread::sleep_for(std::chrono::milliseconds(200));
+
+    auto stats = transport.getStats();
+    // Should have attempted to fragment (may not succeed without real connection)
+    // At 1KB per fragment, 2KB should create 2 fragments
+    EXPECT_GE(stats.fragmentsSent, 0u);
+
+    transport.stopThread(2000);
+}
+
+TEST_F(DualTransportTest, BurstHandling2000MsgPerSec) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+
+    transport.startThread();
+
+    // Simulate 2000 msg/sec burst for 1 second
+    const int BURST_COUNT = 2000;
+    auto startTime = std::chrono::high_resolution_clock::now();
+
+    for (int i = 0; i < BURST_COUNT; ++i) {
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = 0x90;
+        packet.data[1] = static_cast<uint8_t>(60 + (i % 12));
+        packet.data[2] = 100;
+        packet.length = 3;
+        packet.deviceId = 0;
+        packet.timestamp = static_cast<uint32_t>(i);
+
+        buffer.write(packet);
+
+        // Sleep to maintain 2000 msg/sec rate (500µs between messages)
+        std::this_thread::sleep_for(std::chrono::microseconds(500));
+    }
+
+    auto elapsed = std::chrono::high_resolution_clock::now() - startTime;
+    auto elapsedMs = std::chrono::duration_cast<std::chrono::milliseconds>(elapsed).count();
+
+    // Should complete in approximately 1 second (2000 msgs * 500µs = 1000ms)
+    EXPECT_GT(elapsedMs, 900);   // At least 900ms
+    EXPECT_LT(elapsedMs, 1200);  // No more than 1200ms
+
+    // Wait for buffer to drain
+    std::this_thread::sleep_for(std::chrono::milliseconds(200));
+
+    auto bufferStats = buffer.getStats();
+    // Drop rate should be <1% for 2000 msg/sec burst
+    EXPECT_LT(bufferStats.dropRate, 1.0f);
+
+    transport.stopThread(1000);
+}
+
+TEST_F(DualTransportTest, ConcurrentRealtimeAndNonRealtime) {
+    // Test that both transports can operate simultaneously without interference
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport realtimeTransport(buffer, "127.0.0.1", 5004);
+    NonRealtimeMidiTransport nonRealtimeTransport("127.0.0.1", 5005);
+
+    realtimeTransport.startThread();
+    nonRealtimeTransport.startThread();
+
+    // Send real-time messages
+    for (int i = 0; i < 50; ++i) {
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = 0x90;
+        packet.data[1] = 60;
+        packet.data[2] = 100;
+        packet.length = 3;
+        packet.deviceId = 0;
+        packet.timestamp = static_cast<uint32_t>(i);
+        buffer.write(packet);
+    }
+
+    // Send non-real-time message
+    std::vector<uint8_t> sysex(500);
+    sysex[0] = 0xF0;
+    for (size_t i = 1; i < sysex.size() - 1; ++i) {
+        sysex[i] = static_cast<uint8_t>(i % 128);
+    }
+    sysex.back() = 0xF7;
+    juce::MidiMessage msg(sysex.data(), static_cast<int>(sysex.size()));
+    nonRealtimeTransport.sendMessage(msg, 0);
+
+    std::this_thread::sleep_for(std::chrono::milliseconds(200));
+
+    auto realtimeStats = realtimeTransport.getStats();
+    auto nonRealtimeStats = nonRealtimeTransport.getStats();
+
+    // Both should have processed messages
+    EXPECT_GT(realtimeStats.packetsSent, 0u);
+    // Non-realtime may not send without real connection, but should queue
+    EXPECT_GE(nonRealtimeStats.messagesSent, 0u);
+
+    realtimeTransport.stopThread(1000);
+    nonRealtimeTransport.stopThread(2000);
+}
diff --git a/modules/juce/midi-server/network/transport/tests/RealtimeMidiBufferTest.cpp b/modules/juce/midi-server/network/transport/tests/RealtimeMidiBufferTest.cpp
new file mode 100644
index 0000000..4d78d64
--- /dev/null
+++ b/modules/juce/midi-server/network/transport/tests/RealtimeMidiBufferTest.cpp
@@ -0,0 +1,194 @@
+#include <gtest/gtest.h>
+#include "../RealtimeMidiBuffer.h"
+#include <thread>
+#include <vector>
+
+using namespace NetworkMidi;
+
+/**
+ * Unit tests for RealtimeMidiBuffer.
+ *
+ * Tests cover:
+ * - Basic write/read operations
+ * - Burst handling (2000 msg/sec for 1 second)
+ * - Overflow behavior (drop oldest)
+ * - Statistics accuracy
+ * - Multi-threaded stress test
+ */
+
+class RealtimeMidiBufferTest : public ::testing::Test {
+protected:
+    RealtimeMidiBuffer buffer;
+
+    RealtimeMidiBuffer::MidiPacket createTestPacket(uint8_t note) {
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = 0x90;  // Note On
+        packet.data[1] = note;
+        packet.data[2] = 100;   // Velocity
+        packet.length = 3;
+        packet.deviceId = 0;
+        packet.timestamp = 12345;
+        return packet;
+    }
+};
+
+TEST_F(RealtimeMidiBufferTest, WriteAndReadSingleMessage) {
+    auto packet = createTestPacket(60);  // Middle C
+
+    EXPECT_TRUE(buffer.write(packet));
+
+    RealtimeMidiBuffer::MidiPacket readPackets[1];
+    int count = buffer.readBatch(readPackets, 1);
+
+    EXPECT_EQ(count, 1);
+    EXPECT_EQ(readPackets[0].data[0], 0x90);
+    EXPECT_EQ(readPackets[0].data[1], 60);
+    EXPECT_EQ(readPackets[0].data[2], 100);
+    EXPECT_EQ(readPackets[0].length, 3);
+}
+
+TEST_F(RealtimeMidiBufferTest, WriteMultipleReadBatch) {
+    // Write 10 messages
+    for (uint8_t i = 0; i < 10; ++i) {
+        auto packet = createTestPacket(60 + i);
+        EXPECT_TRUE(buffer.write(packet));
+    }
+
+    // Read in batch
+    RealtimeMidiBuffer::MidiPacket readPackets[10];
+    int count = buffer.readBatch(readPackets, 10);
+
+    EXPECT_EQ(count, 10);
+    for (int i = 0; i < 10; ++i) {
+        EXPECT_EQ(readPackets[i].data[1], 60 + i);
+    }
+}
+
+TEST_F(RealtimeMidiBufferTest, BurstHandling2000MessagesPerSecond) {
+    // Simulate 2000 msg/sec burst for 1 second
+    const int BURST_COUNT = 2000;
+
+    for (int i = 0; i < BURST_COUNT; ++i) {
+        auto packet = createTestPacket(static_cast<uint8_t>(60 + (i % 12)));
+        buffer.write(packet);
+    }
+
+    auto stats = buffer.getStats();
+
+    // Verify: drop rate should be <1% for 2000 msg burst with 2048 capacity
+    EXPECT_LT(stats.dropRate, 1.0f);
+    EXPECT_GE(stats.written, static_cast<uint64_t>(BURST_COUNT * 0.99));  // At least 99% written
+}
+
+TEST_F(RealtimeMidiBufferTest, OverflowBehaviorDropOldest) {
+    // Fill buffer to capacity
+    for (int i = 0; i < RealtimeMidiBuffer::CAPACITY; ++i) {
+        auto packet = createTestPacket(60);
+        EXPECT_TRUE(buffer.write(packet));
+    }
+
+    // Write one more message (should trigger drop-oldest)
+    auto newPacket = createTestPacket(72);  // Special note
+    EXPECT_TRUE(buffer.write(newPacket));
+
+    auto stats = buffer.getStats();
+    EXPECT_EQ(stats.dropped, 1u);
+    EXPECT_EQ(stats.numReady, RealtimeMidiBuffer::CAPACITY);
+
+    // Read all messages - last one should be our special note
+    RealtimeMidiBuffer::MidiPacket readPackets[RealtimeMidiBuffer::CAPACITY + 1];
+    int count = buffer.readBatch(readPackets, RealtimeMidiBuffer::CAPACITY + 1);
+
+    EXPECT_EQ(count, RealtimeMidiBuffer::CAPACITY);
+    // The special note should be in the buffer (oldest was dropped)
+    bool foundSpecialNote = false;
+    for (int i = 0; i < count; ++i) {
+        if (readPackets[i].data[1] == 72) {
+            foundSpecialNote = true;
+            break;
+        }
+    }
+    EXPECT_TRUE(foundSpecialNote);
+}
+
+TEST_F(RealtimeMidiBufferTest, StatisticsAccuracy) {
+    // Write 100 messages
+    for (int i = 0; i < 100; ++i) {
+        buffer.write(createTestPacket(60));
+    }
+
+    auto stats1 = buffer.getStats();
+    EXPECT_EQ(stats1.written, 100u);
+    EXPECT_EQ(stats1.dropped, 0u);
+    EXPECT_EQ(stats1.numReady, 100);
+
+    // Read 50 messages
+    RealtimeMidiBuffer::MidiPacket readPackets[50];
+    buffer.readBatch(readPackets, 50);
+
+    auto stats2 = buffer.getStats();
+    EXPECT_EQ(stats2.read, 50u);
+    EXPECT_EQ(stats2.numReady, 50);
+    EXPECT_EQ(stats2.freeSpace, RealtimeMidiBuffer::CAPACITY - 50);
+}
+
+TEST_F(RealtimeMidiBufferTest, MultiThreadedStressTest) {
+    std::atomic<int> totalWritten{0};
+    std::atomic<int> totalRead{0};
+    std::atomic<bool> stop{false};
+
+    // Writer thread (producer)
+    std::thread writer([&] {
+        while (!stop) {
+            auto packet = createTestPacket(60);
+            if (buffer.write(packet)) {
+                totalWritten++;
+            }
+            std::this_thread::sleep_for(std::chrono::microseconds(500));  // 2000 msg/sec
+        }
+    });
+
+    // Reader thread (consumer)
+    std::thread reader([&] {
+        while (!stop) {
+            RealtimeMidiBuffer::MidiPacket packets[32];
+            int count = buffer.readBatch(packets, 32);
+            totalRead += count;
+            if (count == 0) {
+                std::this_thread::sleep_for(std::chrono::milliseconds(1));
+            }
+        }
+    });
+
+    // Run for 1 second
+    std::this_thread::sleep_for(std::chrono::seconds(1));
+    stop = true;
+
+    writer.join();
+    reader.join();
+
+    // Verify: should have written ~2000 messages, read close to that
+    EXPECT_GT(totalWritten, 1500);  // At least 75% of target (allow for timing variance)
+    EXPECT_GT(totalRead, totalWritten * 0.95);  // At least 95% read (allow for small buffer lag)
+
+    auto stats = buffer.getStats();
+    EXPECT_LT(stats.dropRate, 5.0f);  // <5% drop rate under stress
+}
+
+TEST_F(RealtimeMidiBufferTest, EmptyBufferReadReturnsZero) {
+    RealtimeMidiBuffer::MidiPacket packets[10];
+    int count = buffer.readBatch(packets, 10);
+    EXPECT_EQ(count, 0);
+}
+
+TEST_F(RealtimeMidiBufferTest, PartialBatchRead) {
+    // Write 5 messages
+    for (int i = 0; i < 5; ++i) {
+        buffer.write(createTestPacket(60 + i));
+    }
+
+    // Try to read 10 (only 5 available)
+    RealtimeMidiBuffer::MidiPacket packets[10];
+    int count = buffer.readBatch(packets, 10);
+    EXPECT_EQ(count, 5);
+}
diff --git a/modules/juce/midi-server/tests/unit/MidiClassifierTest.cpp b/modules/juce/midi-server/tests/unit/MidiClassifierTest.cpp
new file mode 100644
index 0000000..be5f06f
--- /dev/null
+++ b/modules/juce/midi-server/tests/unit/MidiClassifierTest.cpp
@@ -0,0 +1,284 @@
+#include "../../network/transport/MidiClassifier.h"
+#include <gtest/gtest.h>
+#include <juce_audio_basics/juce_audio_basics.h>
+
+using namespace NetworkMidi;
+
+/**
+ * Unit tests for MIDI message classification.
+ *
+ * Tests verify that messages are correctly classified as either:
+ * - RealTime (UDP transport, low latency, best-effort)
+ * - NonRealTime (TCP transport, reliable delivery)
+ */
+class MidiClassifierTest : public ::testing::Test {
+protected:
+    void SetUp() override {
+        // Initialize JUCE if needed
+    }
+
+    void TearDown() override {
+    }
+};
+
+// ============================================================================
+// Channel Voice Messages (Real-Time)
+// ============================================================================
+
+TEST_F(MidiClassifierTest, ClassifyNoteOn)
+{
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+    EXPECT_EQ(classifyMidiMessage(noteOn), MidiMessageClass::RealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyNoteOff)
+{
+    juce::MidiMessage noteOff = juce::MidiMessage::noteOff(1, 60, 0.5f);
+    EXPECT_EQ(classifyMidiMessage(noteOff), MidiMessageClass::RealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyControlChange)
+{
+    juce::MidiMessage cc = juce::MidiMessage::controllerEvent(1, 7, 127);
+    EXPECT_EQ(classifyMidiMessage(cc), MidiMessageClass::RealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyPitchBend)
+{
+    juce::MidiMessage pitchBend = juce::MidiMessage::pitchWheel(1, 8192);
+    EXPECT_EQ(classifyMidiMessage(pitchBend), MidiMessageClass::RealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyProgramChange)
+{
+    juce::MidiMessage programChange = juce::MidiMessage::programChange(1, 42);
+    EXPECT_EQ(classifyMidiMessage(programChange), MidiMessageClass::RealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyAftertouch)
+{
+    juce::MidiMessage aftertouch = juce::MidiMessage::aftertouchChange(1, 60, 100);
+    EXPECT_EQ(classifyMidiMessage(aftertouch), MidiMessageClass::RealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyChannelPressure)
+{
+    juce::MidiMessage channelPressure = juce::MidiMessage::channelPressureChange(1, 80);
+    EXPECT_EQ(classifyMidiMessage(channelPressure), MidiMessageClass::RealTime);
+}
+
+// ============================================================================
+// System Real-Time Messages (Real-Time)
+// ============================================================================
+
+TEST_F(MidiClassifierTest, ClassifyMidiClock)
+{
+    juce::MidiMessage clock = juce::MidiMessage::midiClock();
+    EXPECT_EQ(classifyMidiMessage(clock), MidiMessageClass::RealTime);
+    EXPECT_EQ(clock.getRawData()[0], 0xF8);
+}
+
+TEST_F(MidiClassifierTest, ClassifyMidiStart)
+{
+    juce::MidiMessage start = juce::MidiMessage::midiStart();
+    EXPECT_EQ(classifyMidiMessage(start), MidiMessageClass::RealTime);
+    EXPECT_EQ(start.getRawData()[0], 0xFA);
+}
+
+TEST_F(MidiClassifierTest, ClassifyMidiStop)
+{
+    juce::MidiMessage stop = juce::MidiMessage::midiStop();
+    EXPECT_EQ(classifyMidiMessage(stop), MidiMessageClass::RealTime);
+    EXPECT_EQ(stop.getRawData()[0], 0xFC);
+}
+
+TEST_F(MidiClassifierTest, ClassifyMidiContinue)
+{
+    juce::MidiMessage cont = juce::MidiMessage::midiContinue();
+    EXPECT_EQ(classifyMidiMessage(cont), MidiMessageClass::RealTime);
+    EXPECT_EQ(cont.getRawData()[0], 0xFB);
+}
+
+TEST_F(MidiClassifierTest, ClassifyActiveSensing)
+{
+    // Active Sensing is 0xFE
+    uint8_t activeSensingData[] = {0xFE};
+    juce::MidiMessage activeSensing(activeSensingData, 1);
+    EXPECT_EQ(classifyMidiMessage(activeSensing), MidiMessageClass::RealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifySystemReset)
+{
+    // System Reset is 0xFF
+    uint8_t systemResetData[] = {0xFF};
+    juce::MidiMessage systemReset(systemResetData, 1);
+    EXPECT_EQ(classifyMidiMessage(systemReset), MidiMessageClass::RealTime);
+}
+
+// ============================================================================
+// System Exclusive Messages (Non-Real-Time)
+// ============================================================================
+
+TEST_F(MidiClassifierTest, ClassifyShortSysEx)
+{
+    uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+    juce::MidiMessage sysex(sysexData, 5);
+    EXPECT_EQ(classifyMidiMessage(sysex), MidiMessageClass::NonRealTime);
+    EXPECT_TRUE(sysex.isSysEx());
+}
+
+TEST_F(MidiClassifierTest, ClassifyLargeSysEx)
+{
+    // Create a large SysEx (1KB)
+    std::vector<uint8_t> sysexData(1024);
+    sysexData[0] = 0xF0;  // SysEx start
+    for (size_t i = 1; i < sysexData.size() - 1; ++i) {
+        sysexData[i] = static_cast<uint8_t>(i % 128);
+    }
+    sysexData.back() = 0xF7;  // SysEx end
+
+    juce::MidiMessage sysex(sysexData.data(), static_cast<int>(sysexData.size()));
+    EXPECT_EQ(classifyMidiMessage(sysex), MidiMessageClass::NonRealTime);
+    EXPECT_TRUE(sysex.isSysEx());
+}
+
+TEST_F(MidiClassifierTest, ClassifyUniversalSysEx)
+{
+    // Universal Real-Time SysEx (0xF0 0x7F ...)
+    uint8_t universalSysex[] = {0xF0, 0x7F, 0x7F, 0x04, 0x01, 0xF7};
+    juce::MidiMessage msg(universalSysex, 6);
+    EXPECT_EQ(classifyMidiMessage(msg), MidiMessageClass::NonRealTime);
+}
+
+// ============================================================================
+// System Common Messages (Non-Real-Time by default)
+// ============================================================================
+
+TEST_F(MidiClassifierTest, ClassifyMTCQuarterFrame)
+{
+    // MTC Quarter Frame is 0xF1
+    uint8_t mtcData[] = {0xF1, 0x20};
+    juce::MidiMessage mtc(mtcData, 2);
+    EXPECT_EQ(classifyMidiMessage(mtc), MidiMessageClass::NonRealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifySongPosition)
+{
+    // Song Position Pointer is 0xF2
+    uint8_t songPosData[] = {0xF2, 0x00, 0x00};
+    juce::MidiMessage songPos(songPosData, 3);
+    EXPECT_EQ(classifyMidiMessage(songPos), MidiMessageClass::NonRealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifySongSelect)
+{
+    // Song Select is 0xF3
+    uint8_t songSelectData[] = {0xF3, 0x05};
+    juce::MidiMessage songSelect(songSelectData, 2);
+    EXPECT_EQ(classifyMidiMessage(songSelect), MidiMessageClass::NonRealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyTuneRequest)
+{
+    // Tune Request is 0xF6
+    uint8_t tuneRequestData[] = {0xF6};
+    juce::MidiMessage tuneRequest(tuneRequestData, 1);
+    EXPECT_EQ(classifyMidiMessage(tuneRequest), MidiMessageClass::NonRealTime);
+}
+
+// ============================================================================
+// Edge Cases
+// ============================================================================
+
+TEST_F(MidiClassifierTest, ClassifyEmptyMessage)
+{
+    // Edge case: empty message should default to NonRealTime for safety
+    juce::MidiMessage empty;
+    EXPECT_EQ(classifyMidiMessage(empty), MidiMessageClass::NonRealTime);
+}
+
+TEST_F(MidiClassifierTest, ClassifyAllChannelNumbers)
+{
+    // Test that classification works for all 16 MIDI channels
+    for (int channel = 1; channel <= 16; ++channel) {
+        juce::MidiMessage noteOn = juce::MidiMessage::noteOn(channel, 60, 0.8f);
+        EXPECT_EQ(classifyMidiMessage(noteOn), MidiMessageClass::RealTime)
+            << "Failed for channel " << channel;
+    }
+}
+
+TEST_F(MidiClassifierTest, ClassifyAllNoteNumbers)
+{
+    // Test note range (0-127)
+    for (int note = 0; note <= 127; ++note) {
+        juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, note, 0.8f);
+        EXPECT_EQ(classifyMidiMessage(noteOn), MidiMessageClass::RealTime)
+            << "Failed for note " << note;
+    }
+}
+
+TEST_F(MidiClassifierTest, ClassifyAllControllerNumbers)
+{
+    // Test CC range (0-127)
+    for (int cc = 0; cc <= 127; ++cc) {
+        juce::MidiMessage controller = juce::MidiMessage::controllerEvent(1, cc, 64);
+        EXPECT_EQ(classifyMidiMessage(controller), MidiMessageClass::RealTime)
+            << "Failed for CC " << cc;
+    }
+}
+
+// ============================================================================
+// Helper Function Tests
+// ============================================================================
+
+TEST_F(MidiClassifierTest, GetMessageClassName)
+{
+    EXPECT_EQ(getMidiMessageClassName(MidiMessageClass::RealTime), "RealTime");
+    EXPECT_EQ(getMidiMessageClassName(MidiMessageClass::NonRealTime), "NonRealTime");
+}
+
+TEST_F(MidiClassifierTest, ExplainClassification)
+{
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+    juce::String explanation = explainClassification(noteOn);
+    EXPECT_TRUE(explanation.contains("Channel Voice"));
+    EXPECT_TRUE(explanation.contains("RealTime"));
+
+    uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+    juce::MidiMessage sysex(sysexData, 5);
+    explanation = explainClassification(sysex);
+    EXPECT_TRUE(explanation.contains("System Exclusive"));
+    EXPECT_TRUE(explanation.contains("NonRealTime"));
+
+    juce::MidiMessage clock = juce::MidiMessage::midiClock();
+    explanation = explainClassification(clock);
+    EXPECT_TRUE(explanation.contains("System Real-Time"));
+    EXPECT_TRUE(explanation.contains("RealTime"));
+}
+
+// ============================================================================
+// Performance Tests (Benchmark)
+// ============================================================================
+
+TEST_F(MidiClassifierTest, ClassificationPerformance)
+{
+    // Measure classification speed
+    const int iterations = 100000;
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+
+    auto startTime = juce::Time::getHighResolutionTicks();
+
+    for (int i = 0; i < iterations; ++i) {
+        volatile auto result = classifyMidiMessage(noteOn);
+        (void)result;  // Prevent optimization
+    }
+
+    auto endTime = juce::Time::getHighResolutionTicks();
+    auto elapsedSeconds = juce::Time::highResolutionTicksToSeconds(endTime - startTime);
+    auto avgTimeNs = (elapsedSeconds / iterations) * 1e9;
+
+    // Classification should take < 100ns per call
+    EXPECT_LT(avgTimeNs, 100.0) << "Classification too slow: " << avgTimeNs << "ns";
+
+    std::cout << "Average classification time: " << avgTimeNs << "ns" << std::endl;
+}
diff --git a/modules/juce/midi-server/tests/unit/MidiMessageRouterTest.cpp b/modules/juce/midi-server/tests/unit/MidiMessageRouterTest.cpp
new file mode 100644
index 0000000..78cff10
--- /dev/null
+++ b/modules/juce/midi-server/tests/unit/MidiMessageRouterTest.cpp
@@ -0,0 +1,461 @@
+#include "../../network/transport/MidiMessageRouter.h"
+#include "../../network/transport/UdpMidiTransport.h"
+#include "../../network/transport/ReliableTransport.h"
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+#include <juce_audio_basics/juce_audio_basics.h>
+#include <thread>
+#include <atomic>
+
+using namespace NetworkMidi;
+using ::testing::_;
+using ::testing::Return;
+using ::testing::Invoke;
+
+/**
+ * Unit tests for MidiMessageRouter.
+ *
+ * Tests verify that:
+ * - Real-time messages are routed to UDP transport
+ * - Non-real-time messages are routed to TCP transport
+ * - Statistics are updated correctly
+ * - Thread-safe routing works under load
+ */
+class MidiMessageRouterTest : public ::testing::Test {
+protected:
+    void SetUp() override {
+        // Create transports
+        udpTransport = std::make_unique<UdpMidiTransport>(0);  // Auto-assign port
+        udpTransport->setNodeId(juce::Uuid());
+
+        reliableTransport = std::make_unique<ReliableTransport>(*udpTransport);
+
+        // Create router
+        router = std::make_unique<MidiMessageRouter>(*udpTransport, *reliableTransport);
+
+        // Set up callbacks to track routing
+        udpSendCount = 0;
+        tcpSendCount = 0;
+
+        udpTransport->onPacketReceived = [this](const MidiPacket& packet,
+                                                 const juce::String& sourceAddress,
+                                                 int sourcePort) {
+            udpSendCount++;
+        };
+    }
+
+    void TearDown() override {
+        router.reset();
+        reliableTransport.reset();
+        udpTransport.reset();
+    }
+
+    std::unique_ptr<UdpMidiTransport> udpTransport;
+    std::unique_ptr<ReliableTransport> reliableTransport;
+    std::unique_ptr<MidiMessageRouter> router;
+
+    std::atomic<int> udpSendCount;
+    std::atomic<int> tcpSendCount;
+
+    // Test destination
+    const juce::String testAddress = "127.0.0.1";
+    const int testPort = 5004;
+    const juce::Uuid testDestNode = juce::Uuid();
+    const uint16_t testDeviceId = 0;
+};
+
+// ============================================================================
+// Basic Routing Tests
+// ============================================================================
+
+TEST_F(MidiMessageRouterTest, RouteNoteOnToRealtime)
+{
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+
+    bool success = router->routeMessage(
+        noteOn,
+        testDeviceId,
+        testDestNode,
+        testAddress,
+        testPort
+    );
+
+    EXPECT_TRUE(success);
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, 1);
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, 0);
+}
+
+TEST_F(MidiMessageRouterTest, RouteSysExToNonRealtime)
+{
+    uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+    juce::MidiMessage sysex(sysexData, 5);
+
+    bool success = router->routeMessage(
+        sysex,
+        testDeviceId,
+        testDestNode,
+        testAddress,
+        testPort
+    );
+
+    EXPECT_TRUE(success);
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, 0);
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, 1);
+}
+
+TEST_F(MidiMessageRouterTest, RouteControlChangeToRealtime)
+{
+    juce::MidiMessage cc = juce::MidiMessage::controllerEvent(1, 7, 127);
+
+    bool success = router->routeMessage(
+        cc,
+        testDeviceId,
+        testDestNode,
+        testAddress,
+        testPort
+    );
+
+    EXPECT_TRUE(success);
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, 1);
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, 0);
+}
+
+TEST_F(MidiMessageRouterTest, RouteMidiClockToRealtime)
+{
+    juce::MidiMessage clock = juce::MidiMessage::midiClock();
+
+    bool success = router->routeMessage(
+        clock,
+        testDeviceId,
+        testDestNode,
+        testAddress,
+        testPort
+    );
+
+    EXPECT_TRUE(success);
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, 1);
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, 0);
+}
+
+// ============================================================================
+// Statistics Tests
+// ============================================================================
+
+TEST_F(MidiMessageRouterTest, StatisticsCountCorrectly)
+{
+    // Send mixed messages
+    router->routeMessage(
+        juce::MidiMessage::noteOn(1, 60, 0.8f),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    router->routeMessage(
+        juce::MidiMessage::noteOff(1, 60, 0.5f),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    router->routeMessage(
+        juce::MidiMessage::controllerEvent(1, 7, 127),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+    juce::MidiMessage sysex(sysexData, 5);
+    router->routeMessage(
+        sysex,
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, 3);
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, 1);
+    EXPECT_GT(stats.totalBytesSent, 0);
+}
+
+TEST_F(MidiMessageRouterTest, ResetStatistics)
+{
+    // Send some messages
+    router->routeMessage(
+        juce::MidiMessage::noteOn(1, 60, 0.8f),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    router->routeMessage(
+        juce::MidiMessage::noteOff(1, 60, 0.5f),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    // Verify stats are non-zero
+    auto stats = router->getStatistics();
+    EXPECT_GT(stats.realtimeMessagesSent, 0);
+
+    // Reset
+    router->resetStatistics();
+
+    // Verify stats are zero
+    stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, 0);
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, 0);
+    EXPECT_EQ(stats.totalBytesSent, 0);
+}
+
+TEST_F(MidiMessageRouterTest, DetailedStatisticsTracking)
+{
+    // Enable detailed tracking
+    router->setDetailedTracking(true);
+    EXPECT_TRUE(router->isDetailedTrackingEnabled());
+
+    // Send various message types
+    router->routeMessage(
+        juce::MidiMessage::noteOn(1, 60, 0.8f),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    router->routeMessage(
+        juce::MidiMessage::controllerEvent(1, 7, 127),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    router->routeMessage(
+        juce::MidiMessage::midiClock(),
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+    juce::MidiMessage sysex(sysexData, 5);
+    router->routeMessage(
+        sysex,
+        testDeviceId, testDestNode, testAddress, testPort
+    );
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.noteMessages, 1);
+    EXPECT_EQ(stats.controlChangeMessages, 1);
+    EXPECT_EQ(stats.clockMessages, 1);
+    EXPECT_EQ(stats.sysexMessages, 1);
+}
+
+// ============================================================================
+// Callback Tests
+// ============================================================================
+
+TEST_F(MidiMessageRouterTest, RouteWithCallbackRealtime)
+{
+    std::atomic<bool> callbackInvoked{false};
+
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+
+    bool success = router->routeMessageWithCallback(
+        noteOn,
+        testDeviceId,
+        testDestNode,
+        testAddress,
+        testPort,
+        [&callbackInvoked]() {
+            callbackInvoked = true;
+        },
+        nullptr
+    );
+
+    EXPECT_TRUE(success);
+
+    // For real-time messages, callback is invoked immediately (async)
+    // Wait a bit for async callback
+    for (int i = 0; i < 10 && !callbackInvoked; ++i) {
+        std::this_thread::sleep_for(std::chrono::milliseconds(10));
+    }
+
+    EXPECT_TRUE(callbackInvoked);
+}
+
+TEST_F(MidiMessageRouterTest, RouteWithCallbackNonRealtime)
+{
+    std::atomic<bool> deliveredCallbackInvoked{false};
+    std::atomic<bool> failedCallbackInvoked{false};
+
+    uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+    juce::MidiMessage sysex(sysexData, 5);
+
+    bool success = router->routeMessageWithCallback(
+        sysex,
+        testDeviceId,
+        testDestNode,
+        testAddress,
+        testPort,
+        [&deliveredCallbackInvoked]() {
+            deliveredCallbackInvoked = true;
+        },
+        [&failedCallbackInvoked](const juce::String& reason) {
+            failedCallbackInvoked = true;
+        }
+    );
+
+    EXPECT_TRUE(success);
+
+    // Non-real-time messages use reliable transport
+    // Callbacks depend on ACK/timeout (tested in ReliableTransport tests)
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, 1);
+}
+
+// ============================================================================
+// Thread Safety Tests
+// ============================================================================
+
+TEST_F(MidiMessageRouterTest, ConcurrentRoutingFromMultipleThreads)
+{
+    const int numThreads = 10;
+    const int messagesPerThread = 100;
+    std::atomic<int> successCount{0};
+
+    std::vector<std::thread> threads;
+
+    for (int t = 0; t < numThreads; ++t) {
+        threads.emplace_back([this, &successCount, messagesPerThread]() {
+            for (int i = 0; i < messagesPerThread; ++i) {
+                juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60 + (i % 12), 0.8f);
+                bool success = router->routeMessage(
+                    noteOn,
+                    testDeviceId,
+                    testDestNode,
+                    testAddress,
+                    testPort
+                );
+                if (success) {
+                    successCount++;
+                }
+            }
+        });
+    }
+
+    for (auto& thread : threads) {
+        thread.join();
+    }
+
+    // All messages should be routed successfully
+    EXPECT_EQ(successCount.load(), numThreads * messagesPerThread);
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, numThreads * messagesPerThread);
+}
+
+TEST_F(MidiMessageRouterTest, MixedMessageTypesUnderLoad)
+{
+    const int numMessages = 1000;
+    std::atomic<int> realtimeCount{0};
+    std::atomic<int> nonRealtimeCount{0};
+
+    std::thread sender([this, &realtimeCount, &nonRealtimeCount, numMessages]() {
+        for (int i = 0; i < numMessages; ++i) {
+            if (i % 10 == 0) {
+                // Send SysEx (non-real-time)
+                uint8_t sysexData[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+                juce::MidiMessage sysex(sysexData, 5);
+                router->routeMessage(
+                    sysex,
+                    testDeviceId,
+                    testDestNode,
+                    testAddress,
+                    testPort
+                );
+                nonRealtimeCount++;
+            }
+            else {
+                // Send Note On (real-time)
+                juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60 + (i % 12), 0.8f);
+                router->routeMessage(
+                    noteOn,
+                    testDeviceId,
+                    testDestNode,
+                    testAddress,
+                    testPort
+                );
+                realtimeCount++;
+            }
+        }
+    });
+
+    sender.join();
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, realtimeCount.load());
+    EXPECT_EQ(stats.nonRealtimeMessagesSent, nonRealtimeCount.load());
+}
+
+// ============================================================================
+// Performance Tests
+// ============================================================================
+
+TEST_F(MidiMessageRouterTest, RoutingPerformance)
+{
+    const int iterations = 10000;
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+
+    auto startTime = juce::Time::getHighResolutionTicks();
+
+    for (int i = 0; i < iterations; ++i) {
+        router->routeMessage(
+            noteOn,
+            testDeviceId,
+            testDestNode,
+            testAddress,
+            testPort
+        );
+    }
+
+    auto endTime = juce::Time::getHighResolutionTicks();
+    auto elapsedSeconds = juce::Time::highResolutionTicksToSeconds(endTime - startTime);
+    auto avgTimeMicros = (elapsedSeconds / iterations) * 1e6;
+
+    // Routing should take < 10μs per message
+    EXPECT_LT(avgTimeMicros, 10.0) << "Routing too slow: " << avgTimeMicros << "μs";
+
+    std::cout << "Average routing time: " << avgTimeMicros << "μs" << std::endl;
+
+    auto stats = router->getStatistics();
+    EXPECT_EQ(stats.realtimeMessagesSent, iterations);
+}
+
+// ============================================================================
+// Error Handling Tests
+// ============================================================================
+
+TEST_F(MidiMessageRouterTest, ErrorCallbackOnFailure)
+{
+    std::atomic<bool> errorCallbackInvoked{false};
+    juce::String lastError;
+
+    router->onRoutingError = [&errorCallbackInvoked, &lastError](
+        const juce::String& error,
+        const juce::MidiMessage& msg
+    ) {
+        errorCallbackInvoked = true;
+        lastError = error;
+    };
+
+    // Stop UDP transport to force send failure
+    udpTransport->stop();
+
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 0.8f);
+    bool success = router->routeMessage(
+        noteOn,
+        testDeviceId,
+        testDestNode,
+        testAddress,
+        testPort
+    );
+
+    // Note: sendPacket will fail, but routeMessage returns success if queued
+    // Error handling depends on transport implementation
+
+    auto stats = router->getStatistics();
+    EXPECT_GT(stats.routingErrors, 0);
+}


---

_**Agent (claude-sonnet-4-5-20250929)**_

feat(midi-server): complete Phase B.2 SEDA command handlers and Phase C dual-transport MIDI architecture

