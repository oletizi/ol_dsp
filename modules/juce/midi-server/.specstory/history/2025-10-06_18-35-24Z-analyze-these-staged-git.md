<!-- Generated by SpecStory -->

# 2025-10-06 18:35:24Z

<!-- Claude Code Session 12a1d786-a387-4eb7-8bac-c5bbfe3cd7d8 (2025-10-06_18-35-24Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/CLAUDE.md b/CLAUDE.md
index 2d4f1a7..9360100 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -269,4 +269,5 @@ An AI agent has successfully completed work when:
 - don't mock/stub modules.
 - don't mock/stub modules; use dependency injection and a mock interface instead.
 - always document make targets in the Makefile itself to ensure it's self documenting
-- always use make targets instead of running ./scripts/* directly to ensure the make targets work properly. There should only be a single path to achieve a goal.
\ No newline at end of file
+- always use make targets instead of running ./scripts/* directly to ensure the make targets work properly. There should only be a single path to achieve a goal.
+- Don't mention "production-readiness" in documentation. It's almost certainly not true until proven by actual production testing.
\ No newline at end of file
diff --git a/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md b/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md
index d3c611e..6a5cdc2 100644
--- a/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md
+++ b/modules/juce/midi-server/docs/1.0/seda/implementation/workplan.md
@@ -1,6 +1,6 @@
 # SEDA Implementation Workplan
 
-**Document Version**: 1.0
+**Document Version**: 1.1
 **Date**: 2025-10-06
 **Status**: Ready for Execution
 **Related Design**: [design.md](../planning/design.md)
@@ -13,33 +13,40 @@
 2. [Strategic Decision](#strategic-decision)
 3. [Approach A: Mutex Fixes (Recommended Start)](#approach-a-mutex-fixes-recommended-start)
 4. [Approach B: Full SEDA Migration](#approach-b-full-seda-migration)
-5. [Decision Criteria](#decision-criteria)
-6. [Integration with Current Phase 6](#integration-with-current-phase-6)
-7. [Testing & Validation Strategy](#testing--validation-strategy)
-8. [Timeline & Resources](#timeline--resources)
-9. [Risk Assessment](#risk-assessment)
-10. [Rollback Procedures](#rollback-procedures)
+5. [Approach C: Dual-Transport MIDI (Independent)](#approach-c-dual-transport-midi-independent)
+6. [Decision Criteria](#decision-criteria)
+7. [Integration with Current Phase 6](#integration-with-current-phase-6)
+8. [Testing & Validation Strategy](#testing--validation-strategy)
+9. [Timeline & Resources](#timeline--resources)
+10. [Risk Assessment](#risk-assessment)
+11. [Rollback Procedures](#rollback-procedures)
 
 ---
 
 ## Executive Summary
 
-This workplan provides two parallel implementation strategies for resolving the mutex-based deadlock potential in `NetworkConnection`:
+This workplan provides **three implementation strategies** for improving the MIDI server architecture:
 
 - **Approach A (Mutex Fixes)**: Quick, low-risk fixes to eliminate callback-under-lock and race conditions - **2-4 hours**
 - **Approach B (Full SEDA)**: Complete architectural migration to event-driven stages - **8-14 hours**
+- **Approach C (Dual-Transport MIDI)**: Separate real-time and non-real-time MIDI into independent transports - **8-12 hours** (**NEW**)
 
-**Recommendation**: Start with Approach A to eliminate immediate deadlock risks, then collect production metrics to determine if full SEDA migration is warranted.
+**Recommendation**: Start with Approach A to eliminate immediate deadlock risks. **Implement Approach C independently** to address QoS requirements. Evaluate Approach B based on production metrics.
 
 ### Key Metrics
 
-| Metric | Current (Mutex) | After Fixes | Full SEDA | Target |
-|--------|----------------|-------------|-----------|--------|
-| Deadlock Risk | Medium | Low | Zero | Zero |
-| Query Latency | ~100ns-10ms | ~100ns | ~10ns (atomic) | <1ms |
-| Implementation Time | 0h | 2-4h | 8-14h | Minimize |
-| Code Complexity | Low | Low | Medium-High | Balance |
-| Maintainability | Good | Good | Medium | High |
+| Metric | Current (Mutex) | After Fixes (A) | Full SEDA (B) | Dual-Transport (C) | Target |
+|--------|----------------|----------------|---------------|-------------------|--------|
+| Deadlock Risk | Medium | Low | Zero | Low | Zero |
+| Query Latency | ~100ns-10ms | ~100ns | ~10ns (atomic) | ~100ns | <1ms |
+| MIDI RT Latency | N/A | N/A | N/A | <1ms (UDP) | <1ms |
+| MIDI Bulk Latency | N/A | N/A | N/A | <100ms (TCP) | <100ms |
+| Burst Handling | Poor | Poor | Poor | 2000 msg/sec | 500+ msg/sec |
+| Implementation Time | 0h | 2-4h | 8-14h | 8-12h | Minimize |
+| Code Complexity | Low | Low | Medium-High | Medium | Balance |
+| Maintainability | Good | Good | Medium | Good | High |
+
+**Key Insight:** **Approach C addresses different concerns than A/B** - it solves MIDI QoS requirements regardless of threading architecture.
 
 ---
 
@@ -48,25 +55,36 @@ This workplan provides two parallel implementation strategies for resolving the
 ### Decision Framework
 
 ```
-┌─────────────────────────────────────────────────────────┐
-│                  Decision Tree                           │
-├─────────────────────────────────────────────────────────┤
-│                                                           │
-│  Are deadlocks occurring in production?                 │
-│           │                                              │
-│           ├── NO ──> Start with Approach A (Mutex Fixes)│
-│           │          Monitor for 1-2 weeks               │
-│           │          Collect metrics                     │
-│           │                                              │
-│           └── YES ──> Skip to Approach B (Full SEDA)    │
-│                       High priority migration            │
-│                                                           │
-│  After Approach A:                                       │
-│  ├── Metrics show <1% contention ──> DONE              │
-│  ├── Metrics show >5% contention ──> Proceed to B      │
-│  └── Deadlocks still occur ──> Emergency B              │
-│                                                           │
-└─────────────────────────────────────────────────────────┘
+┌─────────────────────────────────────────────────────────────────────────────┐
+│                           Decision Tree                                      │
+├─────────────────────────────────────────────────────────────────────────────┤
+│                                                                               │
+│  Are deadlocks occurring in production?                                     │
+│           │                                                                   │
+│           ├── NO ──> Start with Approach A (Mutex Fixes)                    │
+│           │          Monitor for 1-2 weeks                                   │
+│           │          Collect metrics                                         │
+│           │                                                                   │
+│           └── YES ──> Skip to Approach B (Full SEDA)                        │
+│                       High priority migration                                │
+│                                                                               │
+│  After Approach A:                                                           │
+│  ├── Metrics show <1% contention ──> DONE (but consider C)                 │
+│  ├── Metrics show >5% contention ──> Proceed to B                           │
+│  └── Deadlocks still occur ──> Emergency B                                  │
+│                                                                               │
+│  Do you need real-time MIDI performance?                                    │
+│           │                                                                   │
+│           ├── YES ──> Implement Approach C (Dual-Transport)                 │
+│           │          - Burst handling (>500 msg/sec)                         │
+│           │          - SysEx reliability (100%)                              │
+│           │          - Latency requirements differ by message type           │
+│           │                                                                   │
+│           └── NO ──> Single transport sufficient                             │
+│                                                                               │
+│  Approach C is INDEPENDENT - can run alongside A or B                        │
+│                                                                               │
+└─────────────────────────────────────────────────────────────────────────────┘
 ```
 
 ### Current Status Assessment
@@ -77,8 +95,12 @@ Based on the design document analysis:
 - **Contention Evidence**: Not measured
 - **Scale Requirements**: Current mesh typically <10 connections
 - **Performance Requirements**: HTTP queries must complete <100ms
+- **MIDI Requirements**: Need to support burst traffic and reliable SysEx delivery (**NEW**)
 
-**Recommended Path**: **Approach A first**, with Approach B as planned follow-up if metrics justify it.
+**Recommended Path**:
+1. **Approach A first** (eliminate immediate risks)
+2. **Approach C in parallel** (address MIDI QoS requirements)
+3. **Approach B if needed** (based on production metrics)
 
 ---
 
@@ -984,8 +1006,8 @@ cmake --build build --target NetworkConnectionBenchmark
 
 | Operation | Current | Target | Actual | Pass/Fail |
 |-----------|---------|--------|--------|-----------|
-| getState() | 100ns | <20ns | ??? | ??? |
-| getRemoteDevices() | 100ns | <1ms | ??? | ??? |
+| getState() latency | 120ns | <20ns | ??? | ??? |
+| getRemoteDevices() latency| 150ns | <1ms | ??? | ??? |
 | 100 threads querying | 10ms | <1ms | ??? | ??? |
 
 #### Acceptance Criteria
@@ -1062,6 +1084,877 @@ TEST(NetworkConnectionSEDA, StressTest_100Threads_60Seconds) {
 
 ---
 
+## Approach C: Dual-Transport MIDI (Independent)
+
+### Overview
+
+**NEW APPROACH**: Separate real-time and non-real-time MIDI into independent transport paths with purpose-built QoS.
+
+**Key Insight**: This approach addresses **different requirements** than Approaches A and B:
+- Approaches A/B solve **threading/mutex issues**
+- Approach C solves **MIDI quality-of-service requirements**
+
+**Therefore: Approach C can be implemented INDEPENDENTLY** of whether you choose mutex fixes (A) or full SEDA (B).
+
+**Effort Estimate**: 8-12 hours
+**Risk Level**: Medium
+**Rollback Complexity**: Moderate (feature branch required)
+**Prerequisites**: None (can be done alongside A or B)
+
+---
+
+### When to Implement Approach C
+
+**Implement dual-transport if:**
+
+- ✅ Need to support burst MIDI traffic (>500 msg/sec)
+- ✅ Need reliable SysEx delivery (100% guaranteed)
+- ✅ Latency requirements differ by message type (real-time <1ms, bulk <100ms)
+- ✅ Planning for real-time performance scenarios (live music, controllers)
+- ✅ Network mesh will handle intensive MIDI traffic
+
+**Skip dual-transport if:**
+
+- ❌ Only sending low-frequency MIDI (<50 msg/sec)
+- ❌ No SysEx or bulk transfers needed
+- ❌ All MIDI can tolerate 100ms+ latency
+- ❌ Single-transport simplicity preferred
+
+---
+
+### Architecture Overview
+
+```
+┌─────────────────────────────────────────────────────────────────────────────┐
+│                          MIDI Message Router                                 │
+│                                                                               │
+│  Input: juce::MidiMessage                                                    │
+│  ┌───────────────────────────────────────────────────────────┐              │
+│  │  Message Classifier: classifyMidiMessage()                │              │
+│  │  - Route by message type (0x80-0xFF)                     │              │
+│  └───────────┬────────────────────────────────┬──────────────┘              │
+│              │                                 │                              │
+│              │ Real-Time                       │ Non-Real-Time                │
+│              │ (Note On/Off, CC, Clock)        │ (SysEx, Bulk Transfer)       │
+│              v                                 v                              │
+│   ┌──────────────────────┐         ┌──────────────────────┐                 │
+│   │  REAL-TIME STAGE     │         │ NON-REAL-TIME STAGE  │                 │
+│   │  (Lock-Free)         │         │ (Standard Queue)     │                 │
+│   ├──────────────────────┤         ├──────────────────────┤                 │
+│   │ juce::AbstractFifo   │         │ std::mutex +         │                 │
+│   │ Ring Buffer          │         │ std::deque           │                 │
+│   │                      │         │                      │                 │
+│   │ Capacity: 2048 msgs  │         │ Unbounded capacity   │                 │
+│   │ Policy: Drop oldest  │         │ Policy: Block/Retry  │                 │
+│   │                      │         │                      │                 │
+│   │ Thread Priority:     │         │ Thread Priority:     │                 │
+│   │ realtimeAudio (9)    │         │ normal (5)           │                 │
+│   └──────────┬───────────┘         └──────────┬───────────┘                 │
+│              │                                 │                              │
+│              │ UDP Packets                     │ TCP Stream                   │
+│              │ (Best-effort)                   │ (Reliable)                   │
+│              v                                 v                              │
+│   ┌──────────────────────┐         ┌──────────────────────┐                 │
+│   │  UDP I/O THREAD      │         │  TCP I/O THREAD      │                 │
+│   │  (Non-blocking)      │         │  (Blocking OK)       │                 │
+│   └──────────────────────┘         └──────────────────────┘                 │
+│              │                                 │                              │
+│              v                                 v                              │
+│        UDP Socket (port 5004)           TCP Socket (port 5005)               │
+└─────────────────────────────────────────────────────────────────────────────┘
+```
+
+---
+
+### Phase C.1: Implement Real-Time Ring Buffer
+
+**Objective**: Create lock-free ring buffer for real-time MIDI messages.
+
+**Duration**: 2-3 hours
+
+#### Tasks
+
+1. **Create RealtimeMidiBuffer class**
+   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/RealtimeMidiBuffer.h`
+
+```cpp
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include <atomic>
+
+namespace NetworkMidi {
+
+/**
+ * Lock-free ring buffer for real-time MIDI messages.
+ *
+ * Features:
+ * - Single producer, single consumer (lock-free)
+ * - Fixed capacity with drop-oldest overflow policy
+ * - ~50ns write latency, ~200ns batch read latency
+ * - Thread-safe without mutexes
+ */
+class RealtimeMidiBuffer {
+public:
+    static constexpr int CAPACITY = 2048;  // Power of 2
+
+    struct MidiPacket {
+        uint8_t data[4];     // Max 4 bytes for channel voice messages
+        uint8_t length;
+        uint16_t deviceId;
+        uint32_t timestamp;  // Microseconds since epoch
+    };
+
+    /**
+     * Write message to buffer (called from MIDI input thread).
+     *
+     * @param packet MIDI message to enqueue
+     * @return true if written, false if buffer full (message dropped)
+     */
+    bool write(const MidiPacket& packet);
+
+    /**
+     * Read batch of messages (called from UDP sender thread).
+     *
+     * @param dest Destination array (caller-owned)
+     * @param maxCount Maximum messages to read
+     * @return Number of messages actually read
+     */
+    int readBatch(MidiPacket* dest, int maxCount);
+
+    /**
+     * Get buffer statistics (lock-free).
+     */
+    struct Stats {
+        int numReady;        // Messages currently in buffer
+        int freeSpace;       // Available capacity
+        uint64_t dropped;    // Total messages dropped
+        uint64_t written;    // Total messages written
+        uint64_t read;       // Total messages read
+        float dropRate;      // Percentage of messages dropped
+    };
+
+    Stats getStats() const;
+
+private:
+    juce::AbstractFifo fifo{CAPACITY};
+    MidiPacket buffer[CAPACITY];
+
+    std::atomic<uint64_t> droppedCount{0};
+    std::atomic<uint64_t> totalWritten{0};
+    std::atomic<uint64_t> totalRead{0};
+};
+
+} // namespace NetworkMidi
+```
+
+2. **Implement write() with drop-oldest policy**
+   - File: `RealtimeMidiBuffer.cpp`
+
+```cpp
+bool RealtimeMidiBuffer::write(const MidiPacket& packet) {
+    int start1, size1, start2, size2;
+    fifo.prepareToWrite(1, start1, size1, start2, size2);
+
+    if (size1 == 0) {
+        // Buffer full - implement drop-oldest policy
+        droppedCount.fetch_add(1, std::memory_order_relaxed);
+
+        // Force-advance read pointer to make space
+        int readStart, readSize, dummy1, dummy2;
+        fifo.prepareToRead(1, readStart, readSize, dummy1, dummy2);
+        if (readSize > 0) {
+            fifo.finishedRead(1);  // Discard oldest
+        }
+
+        // Try again
+        fifo.prepareToWrite(1, start1, size1, start2, size2);
+        if (size1 == 0) {
+            return false;  // Still can't write (shouldn't happen)
+        }
+    }
+
+    buffer[start1] = packet;
+    fifo.finishedWrite(1);
+    totalWritten.fetch_add(1, std::memory_order_relaxed);
+    return true;
+}
+```
+
+3. **Implement readBatch() for efficient UDP batching**
+
+```cpp
+int RealtimeMidiBuffer::readBatch(MidiPacket* dest, int maxCount) {
+    int start1, size1, start2, size2;
+    fifo.prepareToRead(maxCount, start1, size1, start2, size2);
+
+    int totalRead = 0;
+
+    // Copy first contiguous block
+    for (int i = 0; i < size1; ++i) {
+        dest[totalRead++] = buffer[start1 + i];
+    }
+
+    // Copy second block if ring wraps around
+    for (int i = 0; i < size2; ++i) {
+        dest[totalRead++] = buffer[start2 + i];
+    }
+
+    if (totalRead > 0) {
+        fifo.finishedRead(totalRead);
+        this->totalRead.fetch_add(totalRead, std::memory_order_relaxed);
+    }
+
+    return totalRead;
+}
+```
+
+4. **Unit tests**
+
+```cpp
+TEST(RealtimeMidiBuffer, WriteAndRead) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiBuffer::MidiPacket packet;
+    packet.data[0] = 0x90;  // Note On
+    packet.data[1] = 60;    // Middle C
+    packet.data[2] = 100;   // Velocity
+    packet.length = 3;
+
+    EXPECT_TRUE(buffer.write(packet));
+
+    RealtimeMidiBuffer::MidiPacket readPackets[1];
+    int count = buffer.readBatch(readPackets, 1);
+    EXPECT_EQ(count, 1);
+    EXPECT_EQ(readPackets[0].data[0], 0x90);
+}
+
+TEST(RealtimeMidiBuffer, BurstHandling) {
+    RealtimeMidiBuffer buffer;
+
+    // Write 2000 messages (burst scenario)
+    for (int i = 0; i < 2000; ++i) {
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = 0x90;
+        packet.data[1] = 60 + (i % 12);
+        packet.data[2] = 100;
+        packet.length = 3;
+        buffer.write(packet);
+    }
+
+    auto stats = buffer.getStats();
+    // Should handle 2000 messages with <1% drops
+    EXPECT_LT(stats.dropRate, 1.0f);
+}
+```
+
+#### Acceptance Criteria
+
+- [ ] RealtimeMidiBuffer compiles successfully
+- [ ] write() handles overflow with drop-oldest policy
+- [ ] readBatch() efficiently reads multiple messages
+- [ ] Burst handling test passes (2000 msg/sec)
+- [ ] ThreadSanitizer clean
+
+---
+
+### Phase C.2: Create UDP Real-Time Transport
+
+**Objective**: Implement UDP transport thread for real-time MIDI.
+
+**Duration**: 2-3 hours
+
+#### Tasks
+
+1. **Create RealtimeMidiTransport class**
+   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/UdpMidiTransport.h`
+
+```cpp
+#pragma once
+
+#include "RealtimeMidiBuffer.h"
+#include <juce_core/juce_core.h>
+
+namespace NetworkMidi {
+
+/**
+ * Real-time MIDI UDP transport thread.
+ *
+ * Priority: realtimeAudio (highest user-space priority)
+ * Latency target: <1ms end-to-end
+ * Delivery: Best-effort (no retries)
+ */
+class RealtimeMidiTransport : public juce::Thread {
+public:
+    RealtimeMidiTransport(RealtimeMidiBuffer& buf, juce::String host, int port);
+    ~RealtimeMidiTransport() override;
+
+    void run() override;
+
+    struct Stats {
+        std::atomic<uint64_t> packetsSent{0};
+        std::atomic<uint64_t> packetsReceived{0};
+        std::atomic<uint64_t> sendFailures{0};
+    };
+
+    Stats getStats() const { return stats; }
+
+private:
+    RealtimeMidiBuffer& buffer;
+    juce::DatagramSocket udpSocket;
+    juce::String remoteHost;
+    int remotePort;
+    Stats stats;
+
+    void sendPacket(const RealtimeMidiBuffer::MidiPacket& packet);
+    void receivePackets();
+};
+
+} // namespace NetworkMidi
+```
+
+2. **Implement UDP send/receive loop**
+   - File: `UdpMidiTransport.cpp`
+
+```cpp
+RealtimeMidiTransport::RealtimeMidiTransport(RealtimeMidiBuffer& buf,
+                                              juce::String host, int port)
+    : juce::Thread("RealtimeMidiUDP"), buffer(buf),
+      remoteHost(host), remotePort(port)
+{
+    // Set real-time priority
+    setPriority(9);  // realtimeAudio priority
+}
+
+void RealtimeMidiTransport::run() {
+    // Bind socket (non-blocking)
+    if (!udpSocket.bindToPort(0)) {  // Let OS assign port
+        DBG("Failed to bind UDP socket");
+        return;
+    }
+
+    RealtimeMidiBuffer::MidiPacket packets[32];  // Batch buffer
+
+    while (!threadShouldExit()) {
+        // Read batch from ring buffer (lock-free)
+        int count = buffer.readBatch(packets, 32);
+
+        if (count > 0) {
+            // Send each packet via UDP (non-blocking)
+            for (int i = 0; i < count; ++i) {
+                sendPacket(packets[i]);
+            }
+        } else {
+            // No messages - yield CPU briefly
+            juce::Thread::sleep(1);  // 1ms sleep (acceptable latency)
+        }
+
+        // Also receive incoming UDP messages (non-blocking)
+        receivePackets();
+    }
+}
+
+void RealtimeMidiTransport::sendPacket(const RealtimeMidiBuffer::MidiPacket& packet) {
+    // Serialize packet (fixed-size binary format)
+    uint8_t wireFormat[16];
+    wireFormat[0] = 'M';  // Magic byte
+    wireFormat[1] = 'R';  // Real-time marker
+    wireFormat[2] = packet.length;
+    wireFormat[3] = (packet.deviceId >> 8) & 0xFF;
+    wireFormat[4] = packet.deviceId & 0xFF;
+    std::memcpy(&wireFormat[5], &packet.timestamp, 4);
+    std::memcpy(&wireFormat[9], packet.data, packet.length);
+
+    int totalSize = 9 + packet.length;
+
+    // Send UDP (best-effort, no retry)
+    int sent = udpSocket.write(remoteHost, remotePort, wireFormat, totalSize);
+    if (sent == totalSize) {
+        stats.packetsSent.fetch_add(1, std::memory_order_relaxed);
+    } else {
+        stats.sendFailures.fetch_add(1, std::memory_order_relaxed);
+    }
+}
+```
+
+3. **Unit tests**
+
+```cpp
+TEST(RealtimeMidiTransport, SendReceive) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+
+    transport.startThread();
+
+    // Write messages to buffer
+    for (int i = 0; i < 100; ++i) {
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = 0x90;
+        packet.data[1] = 60;
+        packet.data[2] = 100;
+        packet.length = 3;
+        buffer.write(packet);
+    }
+
+    // Wait for transmission
+    juce::Thread::sleep(100);
+
+    auto stats = transport.getStats();
+    EXPECT_GT(stats.packetsSent, 90);  // At least 90% sent
+}
+```
+
+#### Acceptance Criteria
+
+- [ ] UDP transport thread starts successfully
+- [ ] Real-time priority set (priority 9)
+- [ ] Non-blocking send/receive implemented
+- [ ] Latency <1ms (measure with timestamps)
+- [ ] Unit tests pass
+
+---
+
+### Phase C.3: Create TCP Non-Real-Time Transport
+
+**Objective**: Implement TCP transport for reliable SysEx delivery.
+
+**Duration**: 2-3 hours
+
+#### Tasks
+
+1. **Create NonRealtimeMidiTransport class**
+   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/TcpMidiTransport.h`
+
+```cpp
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include <deque>
+#include <mutex>
+#include <map>
+
+namespace NetworkMidi {
+
+/**
+ * Non-real-time MIDI transport using TCP for reliable delivery.
+ *
+ * Features:
+ * - Guaranteed delivery (ACK/retry)
+ * - SysEx fragmentation (1KB chunks)
+ * - Flow control
+ * - 100% reliability target
+ */
+class NonRealtimeMidiTransport : public juce::Thread {
+public:
+    struct MidiPacket {
+        std::vector<uint8_t> data;
+        uint16_t deviceId;
+        uint32_t sequenceNumber;
+        bool requiresAck;
+    };
+
+    NonRealtimeMidiTransport(juce::String host, int port);
+    ~NonRealtimeMidiTransport() override;
+
+    void sendMessage(const juce::MidiMessage& msg, uint16_t deviceId);
+    std::vector<MidiPacket> getReceivedMessages();
+
+    void run() override;
+
+private:
+    std::mutex queueMutex;
+    std::deque<MidiPacket> sendQueue;
+    std::deque<MidiPacket> receiveQueue;
+    juce::WaitableEvent dataAvailable;
+
+    juce::StreamingSocket tcpSocket;
+    juce::String remoteHost;
+    int remotePort;
+    bool connected{false};
+
+    uint32_t nextSequenceNumber{0};
+    std::map<uint32_t, MidiPacket> pendingAcks;
+
+    void attemptConnection();
+    void processSendQueue();
+    void sendTcpPacket(const MidiPacket& packet);
+    void receiveData();
+    void sendAck(uint32_t seqNum);
+    void retryUnacknowledged();
+};
+
+} // namespace NetworkMidi
+```
+
+2. **Implement SysEx fragmentation**
+   - File: `TcpMidiTransport.cpp`
+
+```cpp
+void NonRealtimeMidiTransport::sendTcpPacket(const MidiPacket& packet) {
+    // Fragment if SysEx is too large (>1KB chunks)
+    const size_t MAX_FRAGMENT = 1024;
+    size_t offset = 0;
+
+    while (offset < packet.data.size()) {
+        size_t fragmentSize = std::min(MAX_FRAGMENT, packet.data.size() - offset);
+
+        // Build TCP frame: [header][fragment]
+        std::vector<uint8_t> frame;
+        frame.push_back('M');  // Magic
+        frame.push_back('N');  // Non-real-time
+        frame.push_back((packet.sequenceNumber >> 24) & 0xFF);
+        frame.push_back((packet.sequenceNumber >> 16) & 0xFF);
+        frame.push_back((packet.sequenceNumber >> 8) & 0xFF);
+        frame.push_back(packet.sequenceNumber & 0xFF);
+        frame.push_back((fragmentSize >> 8) & 0xFF);
+        frame.push_back(fragmentSize & 0xFF);
+        frame.insert(frame.end(), packet.data.begin() + offset,
+                    packet.data.begin() + offset + fragmentSize);
+
+        int sent = tcpSocket.write(frame.data(), (int)frame.size());
+        if (sent != (int)frame.size()) {
+            connected = false;
+            return;
+        }
+
+        offset += fragmentSize;
+    }
+}
+```
+
+3. **Implement ACK/retry mechanism**
+
+```cpp
+void NonRealtimeMidiTransport::retryUnacknowledged() {
+    auto now = juce::Time::getCurrentTime();
+    std::vector<uint32_t> toRetry;
+
+    for (auto& [seqNum, pending] : pendingAcks) {
+        auto elapsed = now.toMilliseconds() - pending.sentTime.toMilliseconds();
+
+        if (elapsed > 1000 && pending.retryCount < 3) {  // 1s timeout, 3 retries
+            toRetry.push_back(seqNum);
+        } else if (pending.retryCount >= 3) {
+            // Give up - log error
+            DBG("Failed to deliver packet " << seqNum << " after 3 retries");
+            pendingAcks.erase(seqNum);
+        }
+    }
+
+    for (uint32_t seqNum : toRetry) {
+        auto& pending = pendingAcks[seqNum];
+        pending.retryCount++;
+        pending.sentTime = juce::Time::getCurrentTime();
+        sendTcpPacket(pending.packet);
+    }
+}
+```
+
+4. **Unit tests**
+
+```cpp
+TEST(NonRealtimeMidiTransport, SysExReliability) {
+    NonRealtimeMidiTransport transport("127.0.0.1", 5005);
+    transport.startThread();
+
+    // Send 100 large SysEx messages
+    for (int i = 0; i < 100; ++i) {
+        std::vector<uint8_t> sysex(5000);
+        sysex[0] = 0xF0;  // SysEx start
+        for (size_t j = 1; j < sysex.size() - 1; ++j) {
+            sysex[j] = rand() % 128;
+        }
+        sysex.back() = 0xF7;  // SysEx end
+
+        juce::MidiMessage msg(sysex.data(), (int)sysex.size());
+        transport.sendMessage(msg, 0);
+    }
+
+    // Wait for delivery
+    juce::Thread::sleep(10000);
+
+    // Verify 100% delivery
+    auto received = transport.getReceivedMessages();
+    EXPECT_EQ(received.size(), 100);
+}
+```
+
+#### Acceptance Criteria
+
+- [ ] TCP transport thread starts successfully
+- [ ] SysEx fragmentation works (1KB chunks)
+- [ ] ACK/retry mechanism implemented
+- [ ] 100% delivery in reliability test
+- [ ] Latency <100ms for large SysEx
+
+---
+
+### Phase C.4: Message Classification and Routing
+
+**Objective**: Route MIDI messages to appropriate transport based on type.
+
+**Duration**: 1-2 hours
+
+#### Tasks
+
+1. **Create message classifier**
+   - New file: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/transport/MidiClassifier.h`
+
+```cpp
+#pragma once
+
+#include <juce_audio_basics/juce_audio_basics.h>
+
+namespace NetworkMidi {
+
+enum class MidiMessageClass {
+    RealTime,      // Needs UDP transport
+    NonRealTime    // Needs TCP transport
+};
+
+/**
+ * Classify MIDI message by QoS requirements.
+ *
+ * Real-Time (UDP):
+ * - Note On/Off, CC, Pitch Bend (0x80-0xEF)
+ * - MIDI Clock, Start, Stop (0xF8-0xFF)
+ * - Active Sensing
+ *
+ * Non-Real-Time (TCP):
+ * - System Exclusive (0xF0...0xF7)
+ * - Bulk transfers
+ */
+inline MidiMessageClass classifyMidiMessage(const juce::MidiMessage& msg) {
+    // System Real-Time messages (0xF8 - 0xFF)
+    if (msg.getRawData()[0] >= 0xF8) {
+        return MidiMessageClass::RealTime;
+    }
+
+    // System Exclusive (0xF0 ... 0xF7)
+    if (msg.isSysEx()) {
+        return MidiMessageClass::NonRealTime;
+    }
+
+    // Channel Voice messages (0x80 - 0xEF)
+    if (msg.getRawData()[0] >= 0x80 && msg.getRawData()[0] < 0xF0) {
+        return MidiMessageClass::RealTime;
+    }
+
+    // Default to non-real-time for safety
+    return MidiMessageClass::NonRealTime;
+}
+
+} // namespace NetworkMidi
+```
+
+2. **Update MIDI input callback to route messages**
+
+```cpp
+void MidiInputCallback::handleIncomingMidiMessage(juce::MidiInput* source,
+                                                   const juce::MidiMessage& msg) {
+    auto messageClass = classifyMidiMessage(msg);
+
+    if (messageClass == MidiMessageClass::RealTime) {
+        // Route to real-time buffer (lock-free)
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = msg.getRawData()[0];
+        packet.data[1] = msg.getRawData()[1];
+        packet.data[2] = msg.getRawData()[2];
+        packet.length = std::min(msg.getRawDataSize(), 4);
+        packet.deviceId = 0;
+        packet.timestamp = juce::Time::getMillisecondCounterHiRes();
+
+        bool success = realtimeBuffer.write(packet);
+        if (!success) {
+            inputDrops.fetch_add(1, std::memory_order_relaxed);
+        }
+    } else {
+        // Route to non-real-time transport (TCP)
+        nonRealtimeTransport.sendMessage(msg, 0);
+    }
+}
+```
+
+3. **Unit tests**
+
+```cpp
+TEST(MidiClassifier, ClassifyNoteOn) {
+    juce::MidiMessage noteOn = juce::MidiMessage::noteOn(1, 60, 100.0f);
+    EXPECT_EQ(classifyMidiMessage(noteOn), MidiMessageClass::RealTime);
+}
+
+TEST(MidiClassifier, ClassifySysEx) {
+    uint8_t sysex[] = {0xF0, 0x43, 0x12, 0x00, 0xF7};
+    juce::MidiMessage msg(sysex, 5);
+    EXPECT_EQ(classifyMidiMessage(msg), MidiMessageClass::NonRealTime);
+}
+
+TEST(MidiClassifier, ClassifyMidiClock) {
+    juce::MidiMessage clock(0xF8);
+    EXPECT_EQ(classifyMidiMessage(clock), MidiMessageClass::RealTime);
+}
+```
+
+#### Acceptance Criteria
+
+- [ ] classifyMidiMessage() correctly identifies all message types
+- [ ] MIDI routing works (real-time to UDP, non-real-time to TCP)
+- [ ] Unit tests pass
+- [ ] No classification errors in manual testing
+
+---
+
+### Phase C.5: Testing and Validation
+
+**Objective**: Validate dual-transport performance and reliability.
+
+**Duration**: 2-3 hours
+
+#### Tasks
+
+1. **Burst handling test**
+
+```cpp
+TEST(DualTransport, BurstHandling_2000MsgPerSec) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+    transport.startThread();
+
+    // Simulate 2000 msg/sec burst for 1 second
+    for (int i = 0; i < 2000; ++i) {
+        RealtimeMidiBuffer::MidiPacket packet;
+        packet.data[0] = 0x90;
+        packet.data[1] = 60 + (i % 12);
+        packet.data[2] = 100;
+        packet.length = 3;
+        buffer.write(packet);
+
+        // 500µs between messages = 2000 msg/sec
+        std::this_thread::sleep_for(std::chrono::microseconds(500));
+    }
+
+    auto stats = buffer.getStats();
+    EXPECT_LT(stats.dropRate, 1.0f);  // <1% drops
+}
+```
+
+2. **SysEx reliability test**
+
+```cpp
+TEST(DualTransport, SysExReliability_100Percent) {
+    NonRealtimeMidiTransport transport("127.0.0.1", 5005);
+    transport.startThread();
+
+    // Send 100 SysEx messages
+    for (int i = 0; i < 100; ++i) {
+        std::vector<uint8_t> sysex(1000);
+        sysex[0] = 0xF0;
+        for (size_t j = 1; j < sysex.size() - 1; ++j) {
+            sysex[j] = (i * 10 + j) % 128;
+        }
+        sysex.back() = 0xF7;
+
+        juce::MidiMessage msg(sysex.data(), (int)sysex.size());
+        transport.sendMessage(msg, 0);
+    }
+
+    juce::Thread::sleep(5000);
+
+    auto received = transport.getReceivedMessages();
+    EXPECT_EQ(received.size(), 100);  // 100% delivery
+}
+```
+
+3. **Latency measurement test**
+
+```cpp
+TEST(DualTransport, LatencyMeasurement) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+    transport.startThread();
+
+    // Measure round-trip latency
+    auto start = juce::Time::getMillisecondCounterHiRes();
+
+    RealtimeMidiBuffer::MidiPacket packet;
+    packet.data[0] = 0x90;
+    packet.data[1] = 60;
+    packet.data[2] = 100;
+    packet.length = 3;
+    packet.timestamp = start;
+    buffer.write(packet);
+
+    // Wait for response (implementation-specific)
+    juce::Thread::sleep(10);
+
+    auto elapsed = juce::Time::getMillisecondCounterHiRes() - start;
+    EXPECT_LT(elapsed, 1.0);  // <1ms latency
+}
+```
+
+4. **Create metrics endpoint**
+
+```cpp
+// Add to HTTP server
+svr.Get("/metrics", [](const auto& req, auto& res) {
+    juce::DynamicObject::Ptr obj = new juce::DynamicObject();
+
+    auto rtStats = realtimeBuffer.getStats();
+    obj->setProperty("realtime_messages_sent", (int)rtStats.written);
+    obj->setProperty("realtime_messages_dropped", (int)rtStats.dropped);
+    obj->setProperty("realtime_drop_rate", (double)rtStats.dropRate);
+
+    auto nrtStats = nonRealtimeTransport.getStats();
+    obj->setProperty("nonrealtime_messages_sent", (int)nrtStats.sent);
+    obj->setProperty("nonrealtime_retries", (int)nrtStats.retries);
+
+    res.set_content(juce::JSON::toString(juce::var(obj)), "application/json");
+});
+```
+
+#### Acceptance Criteria
+
+- [ ] Burst handling: <1% drops at 2000 msg/sec
+- [ ] SysEx reliability: 100% delivery
+- [ ] Real-time latency: <1ms
+- [ ] Non-real-time latency: <100ms
+- [ ] Metrics endpoint functional
+
+---
+
+### Integration with Approaches A and B
+
+#### Integration with Approach A (Mutex Fixes)
+
+**Scenario**: Dual-transport + mutex fixes
+
+**Compatibility**: ✅ **Fully compatible**
+
+- Dual-transport uses its own lock-free buffer (real-time path)
+- TCP path can use mutexes safely (non-real-time)
+- No conflicts with mutex fixes in NetworkConnection
+
+**Implementation notes**:
+- Real-time buffer is lock-free (no mutex issues)
+- TCP queue uses mutex but only for low-frequency SysEx
+- Message routing layer sits above NetworkConnection
+
+#### Integration with Approach B (Full SEDA)
+
+**Scenario**: Dual-transport + SEDA architecture
+
+**Compatibility**: ✅ **Natural fit**
+
+- Real-time MIDI becomes Stage 3A (UDP worker)
+- Non-real-time MIDI becomes Stage 3B (TCP worker)
+- Both integrate cleanly with SEDA command queue pattern
+
+**Implementation notes**:
+- Real-time buffer can be part of SEDA Stage 3A
+- Non-real-time transport can be SEDA Stage 3B
+- Classification layer routes messages to appropriate stage
+
+---
+
 ## Decision Criteria
 
 ### When to Use Each Approach
@@ -1082,6 +1975,16 @@ TEST(NetworkConnectionSEDA, StressTest_100Threads_60Seconds) {
 - ✅ Query latency <100µs required
 - ✅ Long-term scalability critical
 
+#### Choose Approach C (Dual-Transport) if:
+
+- ✅ Need burst MIDI handling (>500 msg/sec)
+- ✅ Need reliable SysEx delivery (100%)
+- ✅ Latency requirements differ by message type
+- ✅ Planning for real-time performance scenarios
+- ✅ Network mesh will carry intensive MIDI traffic
+
+**Key Insight**: Approach C is **orthogonal** to A and B - you can implement dual-transport with either mutex fixes or SEDA.
+
 #### Metrics to Collect After Approach A
 
 ```cpp
@@ -1123,6 +2026,7 @@ According to the project workplan, Phase 6 focuses on:
 - Network mesh topology management
 - Heartbeat monitoring for connection health
 - HTTP endpoints for mesh queries
+- **UDP transport for MIDI messages** (partially implemented)
 
 ### Integration Points
 
@@ -1140,6 +2044,11 @@ According to the project workplan, Phase 6 focuses on:
 - Query performance improves significantly
 - May need to update tests for async behavior
 
+**Approach C Impact**:
+- MeshManager routes MIDI messages through classifier
+- Needs to track dual-transport statistics
+- May add `/metrics/midi` endpoint
+
 #### 2. HeartbeatMonitor Integration
 
 **Current State**: HeartbeatMonitor timer calls `getTimeSinceLastHeartbeat()` every 1 second.
@@ -1152,7 +2061,11 @@ According to the project workplan, Phase 6 focuses on:
 - Significant performance improvement (atomic read vs mutex)
 - Must post CheckHeartbeatCommand instead of direct setState()
 
-**Required Change**:
+**Approach C Impact**:
+- No direct impact (heartbeats can use existing mechanism)
+- Could optionally use UDP real-time path for heartbeat packets
+
+**Required Change for Approach B**:
 
 ```cpp
 // HeartbeatMonitor.cpp
@@ -1182,7 +2095,28 @@ void HeartbeatMonitor::checkTimeouts()
 - Complex queries (getRemoteDevices) may add <1ms latency
 - Simple queries (getState) become 100x faster
 
-**No changes needed** - public API remains identical.
+**Approach C Impact**:
+- Add `/metrics/midi` endpoint for transport statistics
+- Show real-time vs non-real-time message counts
+- Display drop rates and latency histograms
+
+**No changes needed for A/B** - public API remains identical.
+
+#### 4. UDP Transport Integration (Phase 6)
+
+**Current State**: UDP transport partially implemented for MIDI messages.
+
+**Approach C Integration**:
+- Existing UDP transport becomes **real-time MIDI path**
+- Add TCP transport as **non-real-time path**
+- Message classifier routes between the two
+- Minimal changes to existing UDP code
+
+**Migration path**:
+1. Wrap existing UDP code in `RealtimeMidiTransport`
+2. Add `RealtimeMidiBuffer` in front of UDP sender
+3. Create parallel `NonRealtimeMidiTransport` for TCP
+4. Add `classifyMidiMessage()` router
 
 ---
 
@@ -1190,14 +2124,14 @@ void HeartbeatMonitor::checkTimeouts()
 
 ### Test Matrix
 
-| Test Category | Approach A | Approach B | Purpose |
-|--------------|------------|------------|---------|
-| Unit Tests | Update callbacks | Update callbacks + async | Verify correctness |
-| Integration Tests | Minor updates | Moderate updates | Verify subsystem interaction |
-| Concurrency Tests | New: 100 threads | New: stress test | Verify no deadlocks |
-| Performance Tests | Baseline only | Full benchmarks | Verify improvements |
-| Regression Tests | Full suite | Full suite | Verify no breakage |
-| TSAN Tests | Required | Required | Verify no races |
+| Test Category | Approach A | Approach B | Approach C | Purpose |
+|--------------|------------|------------|------------|---------|
+| Unit Tests | Update callbacks | Update callbacks + async | MIDI routing | Verify correctness |
+| Integration Tests | Minor updates | Moderate updates | Dual-transport integration | Verify subsystem interaction |
+| Concurrency Tests | New: 100 threads | New: stress test | Burst handling | Verify no deadlocks / overflow |
+| Performance Tests | Baseline only | Full benchmarks | Latency measurement | Verify improvements |
+| Regression Tests | Full suite | Full suite | Full suite | Verify no breakage |
+| TSAN Tests | Required | Required | Required | Verify no races |
 
 ### Validation Plan
 
@@ -1355,6 +2289,33 @@ TEST(NetworkConnection, ChaosTest_RandomOperations) {
 }
 ```
 
+#### Scenario 4: MIDI Burst Testing (NEW - Approach C)
+
+```cpp
+TEST(DualTransport, MIDIBurstTest_2000MsgPerSec) {
+    RealtimeMidiBuffer buffer;
+    RealtimeMidiTransport transport(buffer, "127.0.0.1", 5004);
+    transport.startThread();
+
+    // Simulate intense performance (2000 msg/sec for 5 seconds)
+    for (int second = 0; second < 5; ++second) {
+        for (int i = 0; i < 2000; ++i) {
+            RealtimeMidiBuffer::MidiPacket packet;
+            packet.data[0] = 0x90;  // Note On
+            packet.data[1] = 60 + (i % 12);
+            packet.data[2] = 100;
+            packet.length = 3;
+            buffer.write(packet);
+
+            std::this_thread::sleep_for(std::chrono::microseconds(500));
+        }
+    }
+
+    auto stats = buffer.getStats();
+    EXPECT_LT(stats.dropRate, 1.0f);  // <1% drops over 5 seconds
+}
+```
+
 ---
 
 ## Timeline & Resources
@@ -1390,6 +2351,36 @@ TEST(NetworkConnection, ChaosTest_RandomOperations) {
 **Parallelization**: B.5 and B.6 can run in parallel
 **Calendar Time**: 2-3 days (with buffer for debugging)
 
+### Approach C: Dual-Transport Timeline (NEW)
+
+| Phase | Duration | Developer Hours | Dependencies |
+|-------|----------|----------------|--------------|
+| C.1: Real-time ring buffer | 2-3 hours | 2.5h | None |
+| C.2: UDP real-time transport | 2-3 hours | 2.5h | C.1 |
+| C.3: TCP non-real-time transport | 2-3 hours | 2.5h | None (parallel) |
+| C.4: Message classification | 1-2 hours | 1.5h | C.2, C.3 |
+| C.5: Testing & validation | 2-3 hours | 2.5h | All previous |
+| **Total** | **9-14 hours** | **11.5h** | - |
+
+**Critical Path**: C.1 → C.2 → C.4 → C.5 (C.3 can be parallel with C.1/C.2)
+**Parallelization**: C.3 independent of C.1/C.2
+**Calendar Time**: 2 days (with buffer for testing)
+
+### Combined Timeline: A + C (Recommended)
+
+| Phase | Duration | Developer Hours | Dependencies |
+|-------|----------|----------------|--------------|
+| **Week 1** | | | |
+| A.1-A.5: Mutex fixes | 3-4 hours | 4.25h | None |
+| **Week 2** | | | |
+| C.1-C.2: Real-time path | 4-6 hours | 5h | None |
+| C.3: Non-real-time path | 2-3 hours | 2.5h | Parallel |
+| **Week 3** | | | |
+| C.4-C.5: Integration & testing | 3-5 hours | 4h | C.1-C.3 |
+| **Total** | **12-18 hours** | **15.75h** | - |
+
+**Calendar Time**: 3 weeks (relaxed schedule with testing)
+
 ### Resource Requirements
 
 #### Approach A
@@ -1416,6 +2407,20 @@ TEST(NetworkConnection, ChaosTest_RandomOperations) {
   - Benchmarking environment (isolated CPU cores)
   - CI/CD with performance regression detection
 
+#### Approach C (NEW)
+
+- **Developers**: 1 senior C++ developer
+- **Skills Required**:
+  - Lock-free data structures (juce::AbstractFifo)
+  - Network programming (UDP/TCP)
+  - MIDI protocol knowledge
+  - Real-time systems experience
+- **Infrastructure**:
+  - Development machine with network access
+  - MIDI hardware for testing (optional)
+  - Packet capture tools (Wireshark)
+  - Latency measurement tools
+
 ### External Dependencies
 
 - **JUCE Framework**: Version 6.0+ (for modern threading primitives)
@@ -1454,12 +2459,26 @@ TEST(NetworkConnection, ChaosTest_RandomOperations) {
 
 **Overall Risk**: Medium
 
+### Approach C Risks (NEW)
+
+| Risk | Probability | Impact | Mitigation |
+|------|------------|--------|------------|
+| Ring buffer sizing inadequate for bursts | Low | Medium | Monitor drop rates, increase capacity if needed |
+| UDP packet loss in network | Medium | Low | Expected - monitor drop rates, acceptable for real-time |
+| TCP connection failures | Medium | Medium | Retry logic (3 retries, 1s timeout) |
+| Message classification errors | Low | High | Comprehensive unit tests, manual validation |
+| Real-time priority not available on platform | Low | Medium | Graceful fallback to normal priority |
+| Latency targets not met | Medium | High | Benchmark early, optimize UDP path |
+| SysEx fragmentation bugs | Medium | Medium | Test with large SysEx messages (10KB+) |
+
+**Overall Risk**: Medium
+
 ### Mitigation Strategies
 
-#### For Both Approaches
+#### For All Approaches
 
 1. **Feature Branch Development**
-   - Create `feature/mutex-fixes` or `feature/seda-migration` branch
+   - Create `feature/mutex-fixes`, `feature/seda-migration`, or `feature/dual-transport` branch
    - No direct commits to main
    - Require PR review before merge
 
@@ -1542,6 +2561,39 @@ git cherry-pick <working-commit>
 
 **Data Loss**: None (runtime state only)
 
+### Approach C Rollback (NEW)
+
+**Complexity**: Moderate (independent feature)
+
+#### Option 1: Feature Flag Disable
+
+```cpp
+// Add feature flag in configuration
+static constexpr bool ENABLE_DUAL_TRANSPORT = false;
+
+if (ENABLE_DUAL_TRANSPORT) {
+    // Use dual-transport
+    auto msgClass = classifyMidiMessage(msg);
+    // ...
+} else {
+    // Use original single transport
+    sendViaSingleTransport(msg);
+}
+```
+
+**Recovery Time**: <5 minutes (config change)
+
+#### Option 2: Git Revert
+
+```bash
+git revert <dual-transport-merge-commit>
+git push origin main
+```
+
+**Recovery Time**: 15-30 minutes
+
+**Data Loss**: None (transport layer only)
+
 ### Rollback Decision Criteria
 
 | Severity | Symptom | Action | Timeline |
@@ -1553,7 +2605,7 @@ git cherry-pick <working-commit>
 
 ### Rollback Testing
 
-Before deploying either approach, verify rollback procedure:
+Before deploying any approach, verify rollback procedure:
 
 ```bash
 # Simulate rollback in test environment
@@ -1600,6 +2652,9 @@ watch -n 1 "grep 'Queue depth' /var/log/midi-server.log"
 
 # Check contention percentage
 curl http://localhost:8080/debug/metrics | jq '.contention_percent'
+
+# Monitor MIDI transport metrics (Approach C)
+curl http://localhost:8080/metrics/midi | jq '.realtime_drop_rate'
 ```
 
 ---
@@ -1660,6 +2715,39 @@ curl http://localhost:8080/debug/metrics | jq '.contention_percent'
   - [ ] >1M queries/minute achieved
   - [ ] No memory leaks
 
+### Approach C Checklist (NEW)
+
+- [ ] Phase C.1: Real-time ring buffer
+  - [ ] RealtimeMidiBuffer.h created
+  - [ ] write() with drop-oldest policy implemented
+  - [ ] readBatch() for efficient reading
+  - [ ] getStats() for monitoring
+  - [ ] Unit tests pass
+  - [ ] Burst handling test passes (2000 msg/sec)
+- [ ] Phase C.2: UDP real-time transport
+  - [ ] RealtimeMidiTransport thread created
+  - [ ] Real-time priority set (9)
+  - [ ] Non-blocking UDP send/receive
+  - [ ] Packet serialization implemented
+  - [ ] Latency <1ms verified
+- [ ] Phase C.3: TCP non-real-time transport
+  - [ ] NonRealtimeMidiTransport thread created
+  - [ ] TCP connection management
+  - [ ] SysEx fragmentation (1KB chunks)
+  - [ ] SysEx reassembly with sequence numbers
+  - [ ] ACK/retry mechanism (1s timeout, 3 retries)
+  - [ ] 100% delivery verified
+- [ ] Phase C.4: Message classification
+  - [ ] classifyMidiMessage() implemented
+  - [ ] Message routing works correctly
+  - [ ] Unit tests for all MIDI message types
+- [ ] Phase C.5: Testing & validation
+  - [ ] Burst handling test passes (<1% drops)
+  - [ ] SysEx reliability test passes (100%)
+  - [ ] Latency tests pass (RT <1ms, NRT <100ms)
+  - [ ] /metrics/midi endpoint functional
+  - [ ] Integration with existing code complete
+
 ---
 
 ## Appendix C: Metrics Dashboard
@@ -1674,12 +2762,8 @@ struct ConnectionMetrics {
     std::atomic<uint64_t> callbacksDispatched{0};
     std::atomic<uint64_t> commandsProcessed{0};  // SEDA only
 
-    // Latency histogram (requires external library)
-    // histogram<int64_t> queryLatencyNs;
-
     void recordQuery(int64_t latencyNs) {
         totalQueries.fetch_add(1);
-        // queryLatencyNs.record(latencyNs);
     }
 
     nlohmann::json toJson() const {
@@ -1699,6 +2783,49 @@ struct ConnectionMetrics {
 };
 ```
 
+### MIDI Transport Metrics (Approach C - NEW)
+
+```cpp
+struct MidiTransportMetrics {
+    // Real-time path (UDP)
+    std::atomic<uint64_t> realtimeMessagesSent{0};
+    std::atomic<uint64_t> realtimeMessagesReceived{0};
+    std::atomic<uint64_t> realtimeMessagesDropped{0};
+    std::atomic<uint64_t> udpSendFailures{0};
+
+    // Non-real-time path (TCP)
+    std::atomic<uint64_t> nonRealtimeMessagesSent{0};
+    std::atomic<uint64_t> nonRealtimeMessagesReceived{0};
+    std::atomic<uint64_t> tcpRetries{0};
+    std::atomic<uint64_t> tcpFragmentsSent{0};
+
+    nlohmann::json toJson() const {
+        return {
+            {"realtime_sent", realtimeMessagesSent.load()},
+            {"realtime_received", realtimeMessagesReceived.load()},
+            {"realtime_dropped", realtimeMessagesDropped.load()},
+            {"realtime_drop_rate", calculateDropRate()},
+            {"nonrealtime_sent", nonRealtimeMessagesSent.load()},
+            {"nonrealtime_received", nonRealtimeMessagesReceived.load()},
+            {"tcp_retries", tcpRetries.load()},
+            {"tcp_retry_rate", calculateRetryRate()}
+        };
+    }
+
+    double calculateDropRate() const {
+        uint64_t sent = realtimeMessagesSent.load();
+        uint64_t dropped = realtimeMessagesDropped.load();
+        return sent > 0 ? (100.0 * dropped / sent) : 0.0;
+    }
+
+    double calculateRetryRate() const {
+        uint64_t sent = nonRealtimeMessagesSent.load();
+        uint64_t retries = tcpRetries.load();
+        return sent > 0 ? (100.0 * retries / sent) : 0.0;
+    }
+};
+```
+
 ### HTTP Debug Endpoint
 
 ```cpp
@@ -1714,11 +2841,20 @@ svr.Get("/debug/connection/:uuid/metrics", [](const auto& req, auto& res) {
 
     res.set_content(conn->getMetrics().toJson().dump(), "application/json");
 });
+
+// Approach C: Add MIDI transport metrics
+svr.Get("/metrics/midi", [](const auto& req, auto& res) {
+    auto metrics = midiTransportMetrics.toJson();
+    res.set_content(metrics.dump(), "application/json");
+});
 ```
 
 ---
 
 **Document Status**: Ready for Execution
-**Recommended Start**: Approach A (Mutex Fixes)
-**Decision Point**: Re-evaluate after 1 week of production monitoring
-**Next Steps**: Create feature branch and begin Phase A.1
+**Recommended Start**: Approach A (Mutex Fixes) + Approach C (Dual-Transport) in parallel or sequence
+**Decision Point**: Re-evaluate Approach B after 1 week of production monitoring
+**Next Steps**:
+1. Create feature branch for Approach A
+2. Create feature branch for Approach C (can be parallel)
+3. Begin Phase A.1 and/or Phase C.1


---

_**Agent (claude-sonnet-4-5-20250929)**_

docs(midi-server): add dual-transport architecture guidance to SEDA workplan

