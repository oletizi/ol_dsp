<!-- Generated by SpecStory -->

# 2025-10-07 03:53:58Z

<!-- Claude Code Session 6eed4be8-fc95-4f33-a751-e64e72683d39 (2025-10-07_03-53-58Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/CMakeLists.txt b/modules/juce/midi-server/CMakeLists.txt
index a88f85a..489bf0e 100644
--- a/modules/juce/midi-server/CMakeLists.txt
+++ b/modules/juce/midi-server/CMakeLists.txt
@@ -228,6 +228,7 @@ add_executable(network_midi_tests
     tests/unit/MidiPacketTest.cpp
     tests/unit/DeviceRegistryTest.cpp
     tests/unit/RoutingTableTest.cpp
+    tests/unit/RouteManagerTest.cpp
     tests/unit/MessageBufferTest.cpp
     tests/unit/UdpMidiTransportTest.cpp
     tests/unit/ConnectionPoolTest.cpp
diff --git a/modules/juce/midi-server/NetworkMidiServer.cpp b/modules/juce/midi-server/NetworkMidiServer.cpp
index 177b2c2..d0ea6c6 100644
--- a/modules/juce/midi-server/NetworkMidiServer.cpp
+++ b/modules/juce/midi-server/NetworkMidiServer.cpp
@@ -19,6 +19,7 @@
 #include "network/routing/MidiRouter.h"
 #include "network/routing/DeviceRegistry.h"
 #include "network/routing/RoutingTable.h"
+#include "network/routing/RouteManager.h"
 #include "network/transport/UdpMidiTransport.h"
 
 #include <iostream>
@@ -226,8 +227,14 @@ NetworkMidi::NodeInfo convertToMeshNodeInfo(const ::NodeInfo& discoveryNode) {
 class NetworkMidiServer : public juce::MidiInputCallback
 {
 public:
-    NetworkMidiServer(const NetworkMidi::NodeIdentity& nodeIdentity, int port = 0)
-        : identity(nodeIdentity), requestedPort(port), actualPort(0), udpPort(0) {}
+    NetworkMidiServer(const NetworkMidi::NodeIdentity& nodeIdentity,
+                     NetworkMidi::InstanceManager* instanceMgr,
+                     int port = 0)
+        : identity(nodeIdentity)
+        , instanceManager(instanceMgr)
+        , requestedPort(port)
+        , actualPort(0)
+        , udpPort(0) {}
 
     ~NetworkMidiServer() {
         stopServer();
@@ -253,6 +260,7 @@ public:
         // 2. Create routing infrastructure
         deviceRegistry = std::make_unique<NetworkMidi::DeviceRegistry>();
         routingTable = std::make_unique<NetworkMidi::RoutingTable>();
+        routeManager = std::make_unique<NetworkMidi::RouteManager>(*deviceRegistry);
 
         // 3. Create MIDI router BEFORE registering devices
         midiRouter = std::make_unique<NetworkMidi::MidiRouter>(*deviceRegistry, *routingTable);
@@ -262,6 +270,9 @@ public:
         // 4. Enumerate and register local MIDI devices (now that router exists)
         registerLocalMidiDevices();
 
+        // 5. Load persisted routes (after devices are registered)
+        loadRoutes();
+
         // Set up UDP packet reception callback
         udpTransport->onPacketReceived = [this](const NetworkMidi::MidiPacket& packet,
                                                 const juce::String& /*sourceAddr*/,
@@ -269,7 +280,7 @@ public:
             handleNetworkPacket(packet);
         };
 
-        // 5. Create HTTP server
+        // 6. Create HTTP server
         server = std::make_unique<httplib::Server>();
         setupRoutes();
 
@@ -296,7 +307,7 @@ public:
         // Wait for HTTP server to start
         std::this_thread::sleep_for(std::chrono::milliseconds(100));
 
-        // 6. Create service discovery (advertise this node)
+        // 7. Create service discovery (advertise this node)
         int deviceCount = deviceRegistry->getLocalDeviceCount();
         serviceDiscovery = std::make_unique<ServiceDiscovery>(
             identity.getNodeId(),
@@ -312,7 +323,7 @@ public:
         serviceDiscovery->advertise();
         std::cout << "Started mDNS advertising" << std::endl;
 
-        // 7. Create mesh manager (handle peer connections)
+        // 8. Create mesh manager (handle peer connections)
         meshManager = std::make_unique<NetworkMidi::MeshManager>(
             identity.getNodeId(),
             actualPort,
@@ -328,11 +339,14 @@ public:
         // Connect network adapter to mesh manager
         networkAdapter->setMeshManager(meshManager.get());
 
-        // 8. NOW start MIDI inputs (after everything is fully initialized)
+        // 9. NOW start MIDI inputs (after everything is fully initialized)
         startMidiInputs();
     }
 
     void stopServer() {
+        // Save routes before shutdown
+        saveRoutes();
+
         // Stop MIDI inputs first
         for (auto& input : midiInputs) {
             if (input) {
@@ -595,6 +609,40 @@ private:
         }
     }
 
+    void loadRoutes() {
+        if (!routeManager || !instanceManager) {
+            return;
+        }
+
+        auto routesFile = instanceManager->getStateFile("routes.json");
+        if (routesFile.existsAsFile()) {
+            std::cout << "Loading routes from " << routesFile.getFullPathName().toStdString() << std::endl;
+            if (routeManager->loadFromFile(routesFile)) {
+                int count = routeManager->getRuleCount();
+                std::cout << "Loaded " << count << " routing rule(s)" << std::endl;
+            } else {
+                std::cerr << "Warning: Failed to load routes from file" << std::endl;
+            }
+        } else {
+            std::cout << "No routes file found, starting with empty routing table" << std::endl;
+        }
+    }
+
+    void saveRoutes() {
+        if (!routeManager || !instanceManager) {
+            return;
+        }
+
+        auto routesFile = instanceManager->getStateFile("routes.json");
+        std::cout << "Saving routes to " << routesFile.getFullPathName().toStdString() << std::endl;
+        if (routeManager->saveToFile(routesFile)) {
+            int count = routeManager->getRuleCount();
+            std::cout << "Saved " << count << " routing rule(s)" << std::endl;
+        } else {
+            std::cerr << "Warning: Failed to save routes to file" << std::endl;
+        }
+    }
+
     void setupRoutes() {
         // Health check endpoint
         server->Get("/health", [](const httplib::Request&, httplib::Response& res) {
@@ -800,9 +848,387 @@ private:
                 res.status = 500;
             }
         });
+
+        //=================================================================================
+        // MIDI Routing Configuration API (Phase 2)
+        //=================================================================================
+
+        // Helper to parse node ID from string ("local" -> null UUID)
+        auto parseNodeId = [](const std::string& str) -> juce::Uuid {
+            if (str == "local" || str.empty()) {
+                return juce::Uuid();
+            }
+            return juce::Uuid(str);
+        };
+
+        // 1. GET /routing/routes - List all routing rules
+        server->Get("/routing/routes", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                auto rules = routeManager->getAllRules();
+                auto stats = routeManager->getStatistics();
+
+                JsonBuilder json;
+                json.startObject();
+
+                // Build routes array
+                json.key("routes").startArray();
+                for (const auto& rule : rules) {
+                    json.startObject()
+                        .key("route_id").value(rule.ruleId.toStdString())
+                        .key("enabled").value(rule.enabled)
+                        .key("priority").value(rule.priority);
+
+                    // Source device
+                    json.key("source").startObject()
+                        .key("node_id").value(rule.sourceNodeId().toString().toStdString())
+                        .key("device_id").value((int)rule.sourceDeviceId())
+                        .endObject();
+
+                    // Destination device
+                    json.key("destination").startObject()
+                        .key("node_id").value(rule.destinationNodeId().toString().toStdString())
+                        .key("device_id").value((int)rule.destinationDeviceId())
+                        .endObject();
+
+                    // Statistics
+                    json.key("messages_forwarded").value((int)rule.statistics.messagesForwarded)
+                        .key("messages_dropped").value((int)rule.statistics.messagesDropped)
+                        .endObject();
+                }
+                json.endArray();
+
+                // Summary statistics
+                json.key("total").value((int)stats.totalRules)
+                    .key("enabled").value((int)stats.enabledRules)
+                    .key("disabled").value((int)stats.disabledRules)
+                    .endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /routing/routes: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 2. POST /routing/routes - Create a new routing rule
+        server->Post("/routing/routes", [this, parseNodeId](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                // Parse JSON body (simple extraction)
+                auto body = req.body;
+                std::string srcNodeStr, dstNodeStr;
+                int srcDeviceId = 0, dstDeviceId = 0;
+                bool enabled = true;
+                int priority = 100;
+
+                // Extract fields
+                auto extractString = [&body](const std::string& key) -> std::string {
+                    std::string pattern = "\"" + key + "\":\"";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        size_t end = body.find("\"", start);
+                        if (end != std::string::npos) {
+                            return body.substr(start, end - start);
+                        }
+                    }
+                    return "";
+                };
+
+                auto extractInt = [&body](const std::string& key) -> int {
+                    std::string pattern = "\"" + key + "\":";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        size_t end = body.find_first_of(",}", start);
+                        if (end != std::string::npos) {
+                            return std::stoi(body.substr(start, end - start));
+                        }
+                    }
+                    return 0;
+                };
+
+                auto extractBool = [&body](const std::string& key) -> bool {
+                    std::string pattern = "\"" + key + "\":";
+                    size_t pos = body.find(pattern);
+                    if (pos != std::string::npos) {
+                        size_t start = pos + pattern.length();
+                        return body.substr(start, 4) == "true";
+                    }
+                    return true;
+                };
+
+                srcNodeStr = extractString("source_node_id");
+                srcDeviceId = extractInt("source_device_id");
+                dstNodeStr = extractString("destination_node_id");
+                dstDeviceId = extractInt("destination_device_id");
+
+                // Optional fields
+                if (body.find("\"enabled\"") != std::string::npos) {
+                    enabled = extractBool("enabled");
+                }
+                if (body.find("\"priority\"") != std::string::npos) {
+                    priority = extractInt("priority");
+                }
+
+                // Parse node IDs
+                auto srcNodeId = parseNodeId(srcNodeStr);
+                auto dstNodeId = parseNodeId(dstNodeStr);
+
+                // Create rule
+                NetworkMidi::ForwardingRule rule(srcNodeId, (uint16_t)srcDeviceId,
+                                                  dstNodeId, (uint16_t)dstDeviceId);
+                rule.enabled = enabled;
+                rule.priority = priority;
+
+                // Add rule to manager
+                std::string ruleId = routeManager->addRule(rule);
+
+                // Build response
+                JsonBuilder json;
+                json.startObject()
+                    .key("route_id").value(ruleId)
+                    .key("status").value(std::string("created"))
+                    .endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 201;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error creating route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 400;
+            }
+        });
+
+        // 3. GET /routing/routes/:route_id - Get specific route details
+        server->Get(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+                auto rule = routeManager->getRule(ruleId);
+
+                if (!rule.has_value()) {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                    return;
+                }
+
+                // Build detailed response
+                JsonBuilder json;
+                json.startObject()
+                    .key("route_id").value(rule->ruleId.toStdString())
+                    .key("enabled").value(rule->enabled)
+                    .key("priority").value(rule->priority);
+
+                // Source device
+                json.key("source").startObject()
+                    .key("node_id").value(rule->sourceNodeId().toString().toStdString())
+                    .key("device_id").value((int)rule->sourceDeviceId())
+                    .endObject();
+
+                // Destination device
+                json.key("destination").startObject()
+                    .key("node_id").value(rule->destinationNodeId().toString().toStdString())
+                    .key("device_id").value((int)rule->destinationDeviceId())
+                    .endObject();
+
+                // Statistics
+                json.key("statistics").startObject()
+                    .key("messages_forwarded").value((int)rule->statistics.messagesForwarded)
+                    .key("messages_dropped").value((int)rule->statistics.messagesDropped)
+                    .endObject();
+
+                json.endObject();
+
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error retrieving route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 4. PUT /routing/routes/:route_id - Update a route
+        server->Put(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+                auto existingRule = routeManager->getRule(ruleId);
+
+                if (!existingRule.has_value()) {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                    return;
+                }
+
+                // Parse JSON body for updates
+                auto body = req.body;
+                auto updatedRule = *existingRule;
+
+                // Check for enabled field
+                if (body.find("\"enabled\"") != std::string::npos) {
+                    size_t pos = body.find("\"enabled\":");
+                    if (pos != std::string::npos) {
+                        size_t start = pos + 10;
+                        updatedRule.enabled = (body.substr(start, 4) == "true");
+                    }
+                }
+
+                // Check for priority field
+                if (body.find("\"priority\"") != std::string::npos) {
+                    size_t pos = body.find("\"priority\":");
+                    if (pos != std::string::npos) {
+                        size_t start = pos + 11;
+                        size_t end = body.find_first_of(",}", start);
+                        if (end != std::string::npos) {
+                            updatedRule.priority = std::stoi(body.substr(start, end - start));
+                        }
+                    }
+                }
+
+                // Update the rule
+                if (routeManager->updateRule(ruleId, updatedRule)) {
+                    JsonBuilder json;
+                    json.startObject()
+                        .key("status").value(std::string("updated"))
+                        .key("route_id").value(ruleId)
+                        .endObject();
+
+                    res.set_content(json.toString(), "application/json");
+                    res.status = 200;
+                } else {
+                    res.set_content("{\"error\":\"Failed to update route\"}", "application/json");
+                    res.status = 500;
+                }
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error updating route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 400;
+            }
+        });
+
+        // 5. DELETE /routing/routes/:route_id - Delete a route
+        server->Delete(R"(/routing/routes/(.+))", [this](const httplib::Request& req, httplib::Response& res) {
+            try {
+                if (!routeManager) {
+                    res.set_content("{\"error\":\"Route manager not initialized\"}", "application/json");
+                    res.status = 500;
+                    return;
+                }
+
+                std::string ruleId = req.matches[1];
+
+                if (routeManager->removeRule(ruleId)) {
+                    JsonBuilder json;
+                    json.startObject()
+                        .key("status").value(std::string("deleted"))
+                        .key("route_id").value(ruleId)
+                        .endObject();
+
+                    res.set_content(json.toString(), "application/json");
+                    res.status = 200;
+                } else {
+                    res.set_content("{\"error\":\"Route not found\"}", "application/json");
+                    res.status = 404;
+                }
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error deleting route: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
+
+        // 6. GET /routing/table - Get complete routing state (debug endpoint)
+        server->Get("/routing/table", [this](const httplib::Request&, httplib::Response& res) {
+            try {
+                JsonBuilder json;
+                json.startObject();
+
+                if (routeManager) {
+                    auto rules = routeManager->getAllRules();
+                    auto stats = routeManager->getStatistics();
+
+                    json.key("total_rules").value((int)stats.totalRules)
+                        .key("enabled_rules").value((int)stats.enabledRules)
+                        .key("disabled_rules").value((int)stats.disabledRules)
+                        .key("total_messages_forwarded").value((int)stats.totalMessagesForwarded)
+                        .key("total_messages_dropped").value((int)stats.totalMessagesDropped);
+
+                    json.key("rules").startArray();
+                    for (const auto& rule : rules) {
+                        json.startObject()
+                            .key("route_id").value(rule.ruleId.toStdString())
+                            .key("enabled").value(rule.enabled)
+                            .key("priority").value(rule.priority)
+                            .key("source_node").value(rule.sourceNodeId().toString().toStdString())
+                            .key("source_device").value((int)rule.sourceDeviceId())
+                            .key("dest_node").value(rule.destinationNodeId().toString().toStdString())
+                            .key("dest_device").value((int)rule.destinationDeviceId())
+                            .key("messages_forwarded").value((int)rule.statistics.messagesForwarded)
+                            .key("messages_dropped").value((int)rule.statistics.messagesDropped)
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                if (deviceRegistry) {
+                    auto devices = deviceRegistry->getAllDevices();
+                    json.key("devices").startArray();
+                    for (const auto& device : devices) {
+                        json.startObject()
+                            .key("node_id").value(device.ownerNode().toString().toStdString())
+                            .key("device_id").value((int)device.id())
+                            .key("name").value(device.name.toStdString())
+                            .key("type").value(device.type.toStdString())
+                            .key("is_local").value(device.isLocal())
+                            .endObject();
+                    }
+                    json.endArray();
+                }
+
+                json.endObject();
+                res.set_content(json.toString(), "application/json");
+                res.status = 200;
+
+            } catch (const std::exception& e) {
+                std::cerr << "Error in /routing/table: " << e.what() << std::endl;
+                res.set_content(std::string("{\"error\":\"") + e.what() + "\"}", "application/json");
+                res.status = 500;
+            }
+        });
     }
 
     const NetworkMidi::NodeIdentity& identity;
+    NetworkMidi::InstanceManager* instanceManager;
     int requestedPort;
     int actualPort;
     int udpPort;
@@ -812,6 +1238,7 @@ private:
     std::unique_ptr<NetworkMidi::UdpMidiTransport> udpTransport;
     std::unique_ptr<NetworkMidi::DeviceRegistry> deviceRegistry;
     std::unique_ptr<NetworkMidi::RoutingTable> routingTable;
+    std::unique_ptr<NetworkMidi::RouteManager> routeManager;
     std::unique_ptr<NetworkMidi::MidiRouter> midiRouter;
     std::unique_ptr<NetworkMidi::MeshManager> meshManager;
     std::unique_ptr<NetworkTransportAdapter> networkAdapter;
@@ -861,7 +1288,7 @@ int main(int argc, char* argv[])
         std::cout << "  HTTP Port: " << port << std::endl;
     }
 
-    NetworkMidiServer server(identity, port);
+    NetworkMidiServer server(identity, instanceManager.get(), port);
     server.startServer();
 
     int actualPort = server.getActualPort();
@@ -876,11 +1303,17 @@ int main(int argc, char* argv[])
                                        .getFullPathName().toStdString() << std::endl;
 
     std::cout << "\nEndpoints:" << std::endl;
-    std::cout << "  GET  /health          - Health check" << std::endl;
-    std::cout << "  GET  /node/info       - Node information" << std::endl;
-    std::cout << "  GET  /midi/devices    - List all MIDI devices (local + remote)" << std::endl;
-    std::cout << "  GET  /network/mesh    - Network mesh status" << std::endl;
-    std::cout << "  GET  /network/stats   - Network statistics" << std::endl;
+    std::cout << "  GET    /health                - Health check" << std::endl;
+    std::cout << "  GET    /node/info             - Node information" << std::endl;
+    std::cout << "  GET    /midi/devices          - List all MIDI devices (local + remote)" << std::endl;
+    std::cout << "  GET    /network/mesh          - Network mesh status" << std::endl;
+    std::cout << "  GET    /network/stats         - Network statistics" << std::endl;
+    std::cout << "  GET    /routing/routes        - List all routing rules" << std::endl;
+    std::cout << "  POST   /routing/routes        - Create new routing rule" << std::endl;
+    std::cout << "  GET    /routing/routes/:id    - Get specific routing rule" << std::endl;
+    std::cout << "  PUT    /routing/routes/:id    - Update routing rule" << std::endl;
+    std::cout << "  DELETE /routing/routes/:id    - Delete routing rule" << std::endl;
+    std::cout << "  GET    /routing/table         - Get complete routing state (debug)" << std::endl;
 
     std::cout << "\nReady. Press Ctrl+C to stop..." << std::endl;
 
diff --git a/modules/juce/midi-server/ROUTE_MANAGER_TESTS.md b/modules/juce/midi-server/ROUTE_MANAGER_TESTS.md
new file mode 100644
index 0000000..b45394d
--- /dev/null
+++ b/modules/juce/midi-server/ROUTE_MANAGER_TESTS.md
@@ -0,0 +1,282 @@
+# RouteManager Test Coverage Summary
+
+## Overview
+Comprehensive test suite for the Routing Configuration API (Phase 2) with both unit tests and integration tests.
+
+## Test Files Created
+
+### 1. Unit Tests
+**File:** `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/unit/RouteManagerTest.cpp`
+
+**Test Coverage:** 80%+ (Target achieved)
+
+**Test Categories:**
+
+#### Rule Management (7 tests)
+- ✅ Add basic routing rule
+- ✅ Remove routing rule
+- ✅ Update existing rule
+- ✅ Get all rules
+- ✅ Clear all rules
+- ✅ Get specific rule
+- ✅ Handle non-existent rule operations
+
+#### Destination Lookup (3 tests)
+- ✅ Get destinations for source device
+- ✅ Return empty for no matching rules
+- ✅ Ignore disabled rules in lookup
+
+#### Priority Ordering (1 test)
+- ✅ Order destinations by priority (highest first)
+
+#### Rule Validation (5 tests)
+- ✅ Reject invalid source device ID
+- ✅ Reject invalid destination device ID
+- ✅ Reject non-existent source node
+- ✅ Reject non-existent destination node
+- ✅ Allow same source and destination (loopback)
+
+#### Enable/Disable (3 tests)
+- ✅ Enable rule
+- ✅ Disable rule
+- ✅ Reject enable on non-existent rule
+
+#### Filter Support (3 tests)
+- ✅ Add rule with channel filter
+- ✅ Add rule with message type filter
+- ✅ Add rule with both filters
+
+#### Statistics (3 tests)
+- ✅ Track message routing statistics
+- ✅ Return empty stats for non-existent rule
+- ✅ Reset rule statistics
+- ✅ Reset all statistics
+
+#### File Persistence (5 tests)
+- ✅ Save rules to file
+- ✅ Load rules from file
+- ✅ Preserve rule details in persistence
+- ✅ Handle load from non-existent file
+- ✅ Handle save to invalid path
+
+#### Thread Safety (3 tests)
+- ✅ Handle concurrent rule addition
+- ✅ Handle concurrent rule removal
+- ✅ Handle concurrent read/write operations
+
+#### Edge Cases (7 tests)
+- ✅ Handle remove non-existent rule
+- ✅ Handle update non-existent rule
+- ✅ Handle get non-existent rule
+- ✅ Handle empty channel filter
+- ✅ Handle empty message type filter
+- ✅ Handle duplicate rules
+- ✅ Handle zero priority
+- ✅ Handle maximum priority
+
+**Total Unit Tests:** 42 tests
+
+### 2. Integration Tests
+**File:** `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/tests/integration/routing_api_test.sh`
+
+**Test Scenarios:**
+
+#### API Endpoints (11 tests)
+- ✅ Health check endpoint
+- ✅ Create routing rule (POST /routing/routes)
+- ✅ List routing rules (GET /routing/routes)
+- ✅ Get specific route (GET /routing/routes/{id})
+- ✅ Update route (PUT /routing/routes/{id})
+- ✅ Create route with filters
+- ✅ Get route statistics (GET /routing/routes/{id}/stats)
+- ✅ Enable/disable route (PATCH /routing/routes/{id})
+- ✅ Delete route (DELETE /routing/routes/{id})
+- ✅ Verify route deletion (404 on GET)
+- ✅ Reject invalid route creation
+- ✅ Reject malformed JSON
+
+**Features:**
+- Automated server startup/shutdown
+- Colored output for pass/fail
+- JSON parsing with jq (optional)
+- Comprehensive error handling
+- Test result summary
+
+**Usage:**
+```bash
+chmod +x tests/integration/routing_api_test.sh
+./tests/integration/routing_api_test.sh [server_port]
+```
+
+## Build Configuration
+
+### CMakeLists.txt Updates
+Added `tests/unit/RouteManagerTest.cpp` to the `network_midi_tests` target at line 231:
+
+```cmake
+add_executable(network_midi_tests
+    # ... other tests ...
+    tests/unit/RouteManagerTest.cpp  # NEW
+    # ... rest of tests ...
+)
+```
+
+## Test Strategy
+
+### Unit Test Approach
+1. **Dependency Injection:** Uses real `DeviceRegistry` for realistic testing
+2. **Isolation:** Each test creates fresh instances
+3. **Thread Safety:** Validates concurrent access patterns
+4. **Error Handling:** Tests all error paths
+5. **Edge Cases:** Validates boundary conditions
+
+### Integration Test Approach
+1. **End-to-End:** Tests complete API workflow
+2. **HTTP Protocol:** Validates REST endpoints
+3. **State Management:** Verifies rule persistence
+4. **Error Responses:** Checks proper HTTP status codes
+5. **Automation:** Fully scripted with no manual steps
+
+## Expected Test Results
+
+### Unit Tests (via Google Test)
+```bash
+# Build and run unit tests
+cmake --build build
+./build/network_midi_tests --gtest_filter="RouteManagerTest.*"
+
+# Expected output:
+[==========] Running 42 tests from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 42 tests from RouteManagerTest
+...
+[----------] 42 tests from RouteManagerTest (XX ms total)
+[==========] 42 tests from 1 test suite ran. (XX ms total)
+[  PASSED  ] 42 tests.
+```
+
+### Integration Tests (via Shell Script)
+```bash
+# Run integration tests
+./tests/integration/routing_api_test.sh 8080
+
+# Expected output:
+[INFO] Starting Routing API Integration Tests
+[INFO] Server: http://localhost:8080
+...
+========================================
+Test Summary
+========================================
+Passed: 11
+Failed: 0
+Total:  11
+
+All tests passed!
+```
+
+### Code Coverage
+```bash
+# Enable coverage and run tests
+cmake -B build -DENABLE_COVERAGE=ON
+cmake --build build
+./build/network_midi_tests
+make -C build coverage
+
+# Coverage report: build/coverage/html/index.html
+# Target: 80%+ coverage for RouteManager
+```
+
+## Test Dependencies
+
+### Required for Unit Tests
+- Google Test (already configured)
+- Google Mock (already configured)
+- JUCE framework
+- C++17 compiler
+- DeviceRegistry implementation
+
+### Required for Integration Tests
+- curl (HTTP client)
+- jq (JSON parser, optional but recommended)
+- Bash shell
+- network_midi_server binary
+
+## Coverage Gaps and Future Tests
+
+### Potential Additional Tests (if needed)
+1. **Performance Tests**
+   - Large-scale rule sets (1000+ rules)
+   - Rapid rule updates
+   - High-frequency lookups
+
+2. **Stress Tests**
+   - Memory leak detection
+   - Long-running stability
+   - Resource exhaustion scenarios
+
+3. **API Security Tests**
+   - Malicious input handling
+   - SQL injection (if using DB)
+   - Buffer overflow protection
+
+4. **Network Tests**
+   - Connection timeout handling
+   - Partial JSON handling
+   - Large payload handling
+
+## Running the Tests
+
+### Quick Start
+```bash
+# 1. Build the project
+cmake -B build -S .
+cmake --build build
+
+# 2. Run unit tests
+./build/network_midi_tests --gtest_filter="RouteManagerTest.*"
+
+# 3. Run integration tests (after implementation)
+chmod +x tests/integration/routing_api_test.sh
+./tests/integration/routing_api_test.sh 8080
+```
+
+### With Coverage
+```bash
+# 1. Build with coverage
+cmake -B build -S . -DENABLE_COVERAGE=ON
+cmake --build build
+
+# 2. Run tests
+./build/network_midi_tests
+
+# 3. Generate coverage report
+make -C build coverage
+
+# 4. View report
+open build/coverage/html/index.html
+```
+
+## Test Maintenance
+
+### When to Update Tests
+- Adding new RouteManager features
+- Modifying rule validation logic
+- Changing API endpoints
+- Updating data structures
+- Adding new filter types
+
+### Test Review Checklist
+- [ ] All new features have corresponding tests
+- [ ] Error cases are covered
+- [ ] Thread safety is validated
+- [ ] Documentation is updated
+- [ ] Coverage remains above 80%
+- [ ] Integration tests pass
+- [ ] No test flakiness
+
+## Notes
+- Unit tests are designed to work with the RouteManager implementation once it's created
+- Integration tests require the HTTP server endpoints to be implemented
+- Both test suites follow the existing project patterns (RoutingTableTest, DeviceRegistryTest)
+- Tests are compatible with the JUCE-based architecture
+- All file paths are absolute as required by the project guidelines
diff --git a/modules/juce/midi-server/docs/1.0/routing/persistence.md b/modules/juce/midi-server/docs/1.0/routing/persistence.md
new file mode 100644
index 0000000..2f89422
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/routing/persistence.md
@@ -0,0 +1,279 @@
+# Route Persistence
+
+This document describes the persistence behavior for MIDI routing rules in the Network MIDI Server.
+
+## Overview
+
+Routing rules are automatically persisted to disk and reloaded on server startup, ensuring that routing configurations survive server restarts. This eliminates the need to manually reconfigure routes after every restart.
+
+## File Location
+
+Routes are stored in the instance-specific state directory:
+
+```
+/tmp/midi-network-{node-uuid}/routes.json
+```
+
+Where `{node-uuid}` is the unique identifier for this server instance.
+
+### Example Path
+
+```
+/tmp/midi-network-a1b2c3d4-e5f6-7890-abcd-ef1234567890/routes.json
+```
+
+## File Format
+
+Routes are stored as a JSON array of rule objects. Each rule contains:
+
+- **ruleId**: Unique identifier (UUID)
+- **enabled**: Boolean flag indicating if rule is active
+- **priority**: Integer priority (higher = higher priority, default: 100)
+- **source**: Source device specification
+  - **nodeId**: UUID of the node owning the source device
+  - **deviceId**: Integer device ID on that node
+- **destination**: Destination device specification
+  - **nodeId**: UUID of the node owning the destination device
+  - **deviceId**: Integer device ID on that node
+- **channelFilter**: (optional) MIDI channel filter (0 = all, 1-16 = specific channel)
+- **messageTypeFilter**: Integer bitmask for message type filtering
+- **statistics**: Usage statistics
+  - **messagesForwarded**: Count of forwarded messages
+  - **messagesDropped**: Count of dropped messages
+  - **lastForwardedTime**: Timestamp of last forwarded message (milliseconds)
+
+### Example File
+
+```json
+[
+  {
+    "ruleId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
+    "enabled": true,
+    "priority": 100,
+    "source": {
+      "nodeId": "00000000-0000-0000-0000-000000000000",
+      "deviceId": 2
+    },
+    "destination": {
+      "nodeId": "36222d7d-c84e-4dd5-b0f5-01159de9b5da",
+      "deviceId": 6
+    },
+    "messageTypeFilter": 255,
+    "statistics": {
+      "messagesForwarded": 1234,
+      "messagesDropped": 5,
+      "lastForwardedTime": 1728256000000
+    }
+  },
+  {
+    "ruleId": "b2c3d4e5-f6a7-8901-bcde-f12345678901",
+    "enabled": true,
+    "priority": 90,
+    "source": {
+      "nodeId": "36222d7d-c84e-4dd5-b0f5-01159de9b5da",
+      "deviceId": 3
+    },
+    "destination": {
+      "nodeId": "00000000-0000-0000-0000-000000000000",
+      "deviceId": 4
+    },
+    "channelFilter": 1,
+    "messageTypeFilter": 3,
+    "statistics": {
+      "messagesForwarded": 567,
+      "messagesDropped": 0,
+      "lastForwardedTime": 1728256100000
+    }
+  }
+]
+```
+
+## Auto-Load Behavior
+
+Routes are automatically loaded during server startup in the following sequence:
+
+1. **UDP transport** is started
+2. **Device registry** is initialized
+3. **Routing infrastructure** is created (DeviceRegistry, RoutingTable, RouteManager)
+4. **Local MIDI devices** are registered
+5. **Routes are loaded** from `routes.json` (if file exists)
+6. **Remote devices** are discovered via mesh network
+7. **MIDI inputs** are started
+
+This ensures that all devices are registered before attempting to load routes, preventing validation errors due to missing devices.
+
+### Startup Logging
+
+```
+Loading routes from /tmp/midi-network-{uuid}/routes.json
+Loaded 5 routing rule(s)
+```
+
+If no routes file exists:
+
+```
+No routes file found, starting with empty routing table
+```
+
+If loading fails:
+
+```
+Warning: Failed to load routes from file
+```
+
+## Auto-Save Behavior
+
+Routes are automatically saved during server shutdown:
+
+1. **Routes are saved** to `routes.json`
+2. **MIDI inputs** are stopped
+3. **Network components** are shut down
+4. **Instance cleanup** occurs
+
+### Shutdown Logging
+
+```
+Saving routes to /tmp/midi-network-{uuid}/routes.json
+Saved 5 routing rule(s)
+```
+
+If saving fails:
+
+```
+Warning: Failed to save routes to file
+```
+
+## Manual Save/Load via API
+
+Currently, routes are only saved automatically on shutdown. Future API endpoints may support:
+
+- **POST /routing/save** - Manually trigger route save
+- **POST /routing/load** - Manually trigger route reload
+- **POST /routing/export** - Export routes to custom file
+- **POST /routing/import** - Import routes from custom file
+
+These endpoints are not yet implemented.
+
+## Validation
+
+When loading routes from file:
+
+1. **JSON parsing** - File must be valid JSON array
+2. **Rule validation** - Each rule is validated:
+   - Rule ID must not be empty
+   - Source and destination must be different
+   - Channel filter must be valid (0-16)
+   - Source device must exist in DeviceRegistry
+   - Destination device must exist in DeviceRegistry
+   - Source must be type "input"
+   - Destination must be type "output"
+
+### Invalid Rules
+
+If a rule fails validation during load, it is silently skipped. Only valid rules are loaded.
+
+This can happen when:
+- Referenced devices no longer exist
+- Device IDs have changed
+- Remote nodes are not yet connected
+
+## Remote Device Routes
+
+Routes that reference remote devices (devices on other nodes) are loaded during startup, but may fail validation if:
+
+1. The remote node is not yet discovered
+2. The remote node's devices have not been registered
+3. The remote node is offline
+
+These routes remain in the file and will be validated again on next startup when the remote node may be available.
+
+## Statistics Persistence
+
+Route statistics (message counts, last forwarded time) are persisted along with the route configuration. This allows tracking long-term routing behavior across server restarts.
+
+To reset statistics, use the API endpoint:
+- **POST /routing/statistics/reset** (not yet implemented)
+
+## Instance Isolation
+
+Each server instance has its own routes file, ensuring that:
+- Multiple instances can run simultaneously with different routing configurations
+- Routes are isolated per instance (identified by node UUID)
+- Stopping one instance does not affect another instance's routes
+
+## Cleanup Behavior
+
+Route files are **NOT** automatically deleted when the server shuts down. They persist in the instance directory until:
+
+1. The instance directory is manually deleted
+2. The operating system cleans up `/tmp` (varies by OS)
+3. The server is restarted with a different node UUID
+
+This ensures routes survive unexpected crashes and restarts.
+
+## Best Practices
+
+1. **Backup routes** - Periodically export routes to a persistent location
+2. **Monitor logs** - Check startup/shutdown logs for load/save errors
+3. **Test after restart** - Verify routes are active after server restart
+4. **Document routes** - Keep external documentation of critical routes
+5. **Use descriptive priorities** - Assign meaningful priority values for rule ordering
+
+## Troubleshooting
+
+### Routes not loading on startup
+
+Check:
+1. File exists at `/tmp/midi-network-{uuid}/routes.json`
+2. File is valid JSON
+3. Referenced devices exist and are registered
+4. Log messages for validation errors
+
+### Routes not saving on shutdown
+
+Check:
+1. Write permissions to instance directory
+2. Disk space available
+3. Log messages for save errors
+
+### Routes disappear after restart
+
+Check:
+1. Server is using the same node UUID (check identity persistence)
+2. Instance directory was not cleaned up
+3. File path is correct in logs
+
+## Implementation Details
+
+### RouteManager Methods
+
+- `loadFromFile(const juce::File& file)` - Load routes from JSON file
+- `saveToFile(const juce::File& file)` - Save routes to JSON file
+
+### NetworkMidiServer Integration
+
+- `loadRoutes()` - Called during `startServer()` after device registration
+- `saveRoutes()` - Called during `stopServer()` before cleanup
+
+### File I/O
+
+- Uses JUCE `File` class for cross-platform file operations
+- Uses JUCE `JSON` parser for serialization/deserialization
+- Thread-safe (RouteManager uses mutex for all operations)
+
+## Future Enhancements
+
+Potential improvements to route persistence:
+
+1. **Auto-save on modification** - Save immediately when routes change (not just on shutdown)
+2. **Configurable location** - Allow custom route file path
+3. **Backup/versioning** - Keep multiple versions of route files
+4. **Export/import** - API endpoints for manual export/import
+5. **Hot reload** - Reload routes without server restart
+6. **Merge strategy** - Options for merging loaded routes with existing routes
+
+## Related Documentation
+
+- [ForwardingRule.h](../../../network/routing/ForwardingRule.h) - Rule data structure
+- [RouteManager.h](../../../network/routing/RouteManager.h) - Route management API
+- [InstanceManager.h](../../../network/core/InstanceManager.h) - Instance isolation
diff --git a/modules/juce/midi-server/network/routing/ForwardingRule.h b/modules/juce/midi-server/network/routing/ForwardingRule.h
new file mode 100644
index 0000000..5827420
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/ForwardingRule.h
@@ -0,0 +1,285 @@
+/**
+ * ForwardingRule.h
+ *
+ * Defines MIDI routing rules for cross-node message forwarding.
+ * Each rule specifies a source device, destination device, and optional filters.
+ */
+
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include "DeviceRegistry.h"
+#include <cstdint>
+#include <optional>
+
+namespace NetworkMidi {
+
+/**
+ * MIDI message type filter flags
+ * Used to selectively filter which MIDI messages are forwarded
+ */
+enum class MidiMessageType : uint8_t {
+    None = 0,
+    NoteOff = 1 << 0,          // 0x80-0x8F
+    NoteOn = 1 << 1,           // 0x90-0x9F
+    PolyAftertouch = 1 << 2,   // 0xA0-0xAF
+    ControlChange = 1 << 3,    // 0xB0-0xBF
+    ProgramChange = 1 << 4,    // 0xC0-0xCF
+    ChannelAftertouch = 1 << 5,// 0xD0-0xDF
+    PitchBend = 1 << 6,        // 0xE0-0xEF
+    SystemMessage = 1 << 7,    // 0xF0-0xFF (SysEx, Clock, etc)
+    All = 0xFF
+};
+
+// Bitwise operators for MidiMessageType
+inline MidiMessageType operator|(MidiMessageType a, MidiMessageType b) {
+    return static_cast<MidiMessageType>(static_cast<uint8_t>(a) | static_cast<uint8_t>(b));
+}
+
+inline MidiMessageType operator&(MidiMessageType a, MidiMessageType b) {
+    return static_cast<MidiMessageType>(static_cast<uint8_t>(a) & static_cast<uint8_t>(b));
+}
+
+inline bool hasMessageType(MidiMessageType flags, MidiMessageType type) {
+    return (static_cast<uint8_t>(flags) & static_cast<uint8_t>(type)) != 0;
+}
+
+/**
+ * MIDI channel filter (1-16, or 0 for "all channels")
+ * Supports filtering on a specific MIDI channel
+ */
+struct ChannelFilter {
+    uint8_t channel;  // 0 = all channels, 1-16 = specific channel
+
+    ChannelFilter() : channel(0) {}
+    explicit ChannelFilter(uint8_t ch) : channel(ch) {}
+
+    bool matchesAll() const { return channel == 0; }
+    bool isValid() const { return channel <= 16; }
+
+    bool matches(uint8_t midiChannel) const {
+        if (matchesAll()) return true;
+        return channel == midiChannel;
+    }
+
+    juce::var toVar() const {
+        return juce::var(static_cast<int>(channel));
+    }
+
+    static ChannelFilter fromVar(const juce::var& v) {
+        return ChannelFilter(static_cast<uint8_t>(static_cast<int>(v)));
+    }
+};
+
+/**
+ * Forwarding rule statistics
+ * Tracks usage and performance metrics for a routing rule
+ */
+struct ForwardingStatistics {
+    uint64_t messagesForwarded = 0;
+    uint64_t messagesDropped = 0;
+    juce::Time lastForwardedTime;
+
+    ForwardingStatistics() = default;
+
+    void incrementForwarded() {
+        messagesForwarded++;
+        lastForwardedTime = juce::Time::getCurrentTime();
+    }
+
+    void incrementDropped() {
+        messagesDropped++;
+    }
+
+    void reset() {
+        messagesForwarded = 0;
+        messagesDropped = 0;
+        lastForwardedTime = juce::Time();
+    }
+
+    juce::var toVar() const {
+        auto obj = new juce::DynamicObject();
+        obj->setProperty("messagesForwarded", static_cast<juce::int64>(messagesForwarded));
+        obj->setProperty("messagesDropped", static_cast<juce::int64>(messagesDropped));
+        obj->setProperty("lastForwardedTime", lastForwardedTime.toMilliseconds());
+        return juce::var(obj);
+    }
+
+    static ForwardingStatistics fromVar(const juce::var& v) {
+        ForwardingStatistics stats;
+        if (auto* obj = v.getDynamicObject()) {
+            stats.messagesForwarded = static_cast<uint64_t>(static_cast<juce::int64>(obj->getProperty("messagesForwarded")));
+            stats.messagesDropped = static_cast<uint64_t>(static_cast<juce::int64>(obj->getProperty("messagesDropped")));
+            stats.lastForwardedTime = juce::Time(static_cast<juce::int64>(obj->getProperty("lastForwardedTime")));
+        }
+        return stats;
+    }
+};
+
+/**
+ * Forwarding rule for MIDI message routing
+ *
+ * Design (Phase 2: Routing Configuration):
+ * - Maps source device (nodeId, deviceId) to destination device (nodeId, deviceId)
+ * - Supports optional filters (channel, message type)
+ * - Tracks statistics (messages forwarded, dropped, last forwarded time)
+ * - Rule priority for conflict resolution (higher = higher priority)
+ * - Enable/disable flag for temporary rule deactivation
+ * - UUID-based rule ID for stable references
+ */
+struct ForwardingRule {
+    // Rule identity
+    juce::String ruleId;                 // UUID-based unique identifier
+    bool enabled = true;                 // Rule active/inactive
+    int priority = 100;                  // Higher = higher priority (default: 100)
+
+    // Source device (where MIDI comes from)
+    DeviceKey sourceDevice;
+
+    // Destination device (where MIDI goes to)
+    DeviceKey destinationDevice;
+
+    // Optional filters
+    std::optional<ChannelFilter> channelFilter;           // Filter by MIDI channel
+    MidiMessageType messageTypeFilter = MidiMessageType::All;  // Filter by message type
+
+    // Statistics
+    ForwardingStatistics statistics;
+
+    // Constructors
+    ForwardingRule() = default;
+
+    ForwardingRule(const juce::Uuid& srcNode, uint16_t srcDeviceId,
+                   const juce::Uuid& dstNode, uint16_t dstDeviceId)
+        : sourceDevice(srcNode, srcDeviceId)
+        , destinationDevice(dstNode, dstDeviceId)
+    {
+        ruleId = juce::Uuid().toString();
+    }
+
+    // Convenience accessors
+    const juce::Uuid& sourceNodeId() const { return sourceDevice.ownerNode; }
+    uint16_t sourceDeviceId() const { return sourceDevice.deviceId; }
+    const juce::Uuid& destinationNodeId() const { return destinationDevice.ownerNode; }
+    uint16_t destinationDeviceId() const { return destinationDevice.deviceId; }
+
+    // Validation
+    bool isValid() const {
+        // Rule ID must not be empty
+        if (ruleId.isEmpty()) return false;
+
+        // Source and destination must be different
+        if (sourceDevice == destinationDevice) return false;
+
+        // Channel filter must be valid if present
+        if (channelFilter.has_value() && !channelFilter->isValid()) return false;
+
+        return true;
+    }
+
+    // Filter matching
+    bool matchesChannel(uint8_t midiChannel) const {
+        if (!channelFilter.has_value()) return true;
+        return channelFilter->matches(midiChannel);
+    }
+
+    bool matchesMessageType(MidiMessageType msgType) const {
+        return hasMessageType(messageTypeFilter, msgType);
+    }
+
+    bool shouldForward(uint8_t midiChannel, MidiMessageType msgType) const {
+        if (!enabled) return false;
+        if (!matchesChannel(midiChannel)) return false;
+        if (!matchesMessageType(msgType)) return false;
+        return true;
+    }
+
+    // Comparison operators (for sorting by priority)
+    bool operator<(const ForwardingRule& other) const {
+        return priority < other.priority;  // Lower priority value = lower priority
+    }
+
+    bool operator==(const ForwardingRule& other) const {
+        return ruleId == other.ruleId;
+    }
+
+    // JSON serialization
+    juce::var toVar() const {
+        auto obj = new juce::DynamicObject();
+
+        obj->setProperty("ruleId", ruleId);
+        obj->setProperty("enabled", enabled);
+        obj->setProperty("priority", priority);
+
+        // Source device
+        auto srcObj = new juce::DynamicObject();
+        srcObj->setProperty("nodeId", sourceDevice.ownerNode.toString());
+        srcObj->setProperty("deviceId", static_cast<int>(sourceDevice.deviceId));
+        obj->setProperty("source", juce::var(srcObj));
+
+        // Destination device
+        auto dstObj = new juce::DynamicObject();
+        dstObj->setProperty("nodeId", destinationDevice.ownerNode.toString());
+        dstObj->setProperty("deviceId", static_cast<int>(destinationDevice.deviceId));
+        obj->setProperty("destination", juce::var(dstObj));
+
+        // Filters
+        if (channelFilter.has_value()) {
+            obj->setProperty("channelFilter", channelFilter->toVar());
+        }
+        obj->setProperty("messageTypeFilter", static_cast<int>(messageTypeFilter));
+
+        // Statistics
+        obj->setProperty("statistics", statistics.toVar());
+
+        return juce::var(obj);
+    }
+
+    static ForwardingRule fromVar(const juce::var& v) {
+        ForwardingRule rule;
+
+        if (auto* obj = v.getDynamicObject()) {
+            rule.ruleId = obj->getProperty("ruleId").toString();
+            rule.enabled = static_cast<bool>(obj->getProperty("enabled"));
+            rule.priority = static_cast<int>(obj->getProperty("priority"));
+
+            // Source device
+            if (auto* srcObj = obj->getProperty("source").getDynamicObject()) {
+                juce::Uuid srcNodeId(srcObj->getProperty("nodeId").toString());
+                uint16_t srcDevId = static_cast<uint16_t>(static_cast<int>(srcObj->getProperty("deviceId")));
+                rule.sourceDevice = DeviceKey(srcNodeId, srcDevId);
+            }
+
+            // Destination device
+            if (auto* dstObj = obj->getProperty("destination").getDynamicObject()) {
+                juce::Uuid dstNodeId(dstObj->getProperty("nodeId").toString());
+                uint16_t dstDevId = static_cast<uint16_t>(static_cast<int>(dstObj->getProperty("deviceId")));
+                rule.destinationDevice = DeviceKey(dstNodeId, dstDevId);
+            }
+
+            // Filters
+            if (obj->hasProperty("channelFilter")) {
+                rule.channelFilter = ChannelFilter::fromVar(obj->getProperty("channelFilter"));
+            }
+            rule.messageTypeFilter = static_cast<MidiMessageType>(static_cast<int>(obj->getProperty("messageTypeFilter")));
+
+            // Statistics
+            if (obj->hasProperty("statistics")) {
+                rule.statistics = ForwardingStatistics::fromVar(obj->getProperty("statistics"));
+            }
+        }
+
+        return rule;
+    }
+
+    juce::String toJsonString() const {
+        return juce::JSON::toString(toVar(), true);
+    }
+
+    static ForwardingRule fromJsonString(const juce::String& json) {
+        auto parsed = juce::JSON::parse(json);
+        return fromVar(parsed);
+    }
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/PHASE2_IMPLEMENTATION.md b/modules/juce/midi-server/network/routing/PHASE2_IMPLEMENTATION.md
new file mode 100644
index 0000000..0528d11
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/PHASE2_IMPLEMENTATION.md
@@ -0,0 +1,270 @@
+# Phase 2: Routing Configuration API - Implementation Summary
+
+## Overview
+This document describes the core data structures implemented for Phase 2 of the cross-node MIDI routing system. These structures enable configuration and management of MIDI forwarding rules between devices across the mesh network.
+
+## Files Created
+
+### 1. ForwardingRule.h
+**Location**: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/ForwardingRule.h`
+**Size**: 285 lines
+**Purpose**: Complete header-only implementation of MIDI forwarding rules
+
+#### Key Components:
+
+**MidiMessageType Enum**
+- Bitfield enum for filtering MIDI message types
+- Supports: NoteOff, NoteOn, PolyAftertouch, ControlChange, ProgramChange, ChannelAftertouch, PitchBend, SystemMessage
+- Bitwise operators for combining flags
+- Default: All messages (0xFF)
+
+**ChannelFilter Structure**
+- Filters MIDI by channel (1-16, or 0 for all channels)
+- JSON serialization support
+- Validation for channel range
+
+**ForwardingStatistics Structure**
+- Tracks messages forwarded and dropped
+- Records last forwarded timestamp
+- JSON serialization support
+- Reset functionality
+
+**ForwardingRule Structure**
+- Core routing rule with source and destination devices
+- Uses DeviceKey for composite (nodeId, deviceId) addressing
+- Priority system (higher = higher priority, default 100)
+- Enable/disable flag
+- Optional channel and message type filters
+- Statistics tracking
+- Full JSON serialization/deserialization
+- Validation logic
+- Filter matching for routing decisions
+
+#### Design Decisions:
+
+1. **Header-only implementation**: All code in .h file for simplicity and template-like usage
+2. **Composite device keys**: Uses existing DeviceKey structure from Phase 1
+3. **Priority-based routing**: Supports multiple rules per source with conflict resolution
+4. **Optional filters**: Channel and message type filters can be omitted for "forward everything"
+5. **Statistics tracking**: Built-in metrics for monitoring and debugging
+6. **JSON serialization**: Uses JUCE's DynamicObject for clean JSON handling
+
+### 2. RouteManager.h
+**Location**: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/RouteManager.h`
+**Size**: 232 lines
+**Purpose**: Thread-safe manager for forwarding rules
+
+#### API Surface:
+
+**Rule Management (CRUD)**
+- `addRule(rule)` - Add new rule, auto-generate ID if needed
+- `removeRule(ruleId)` - Remove by ID
+- `updateRule(ruleId, rule)` - Update existing rule
+- `getRule(ruleId)` - Get single rule
+- `getAllRules()` - Get all rules
+- `clearAllRules()` - Remove all rules
+
+**Query Operations**
+- `getDestinations(sourceNodeId, sourceDeviceId)` - Get destinations for a source (sorted by priority)
+- `getSourceRules(nodeId, deviceId)` - Get rules with device as source
+- `getDestinationRules(nodeId, deviceId)` - Get rules with device as destination
+- `getEnabledRules()` - Get active rules only
+- `getDisabledRules()` - Get inactive rules only
+- `hasRule(ruleId)` - Check rule existence
+- `getRuleCount()` - Get total rule count
+
+**Validation**
+- `validateRule(rule, errorMsg)` - Validate rule structure and device existence
+
+**Persistence**
+- `loadFromFile(file)` - Load rules from JSON file
+- `saveToFile(file)` - Save rules to JSON file
+
+**Statistics**
+- `getStatistics()` - Aggregate statistics across all rules
+- `resetStatistics()` - Clear all statistics
+- `updateRuleStatistics(ruleId, forwarded)` - Update during message forwarding
+
+#### Design Decisions:
+
+1. **Thread-safe**: All operations protected by std::mutex
+2. **Reference to DeviceRegistry**: Validates rules against actual devices
+3. **Priority sorting**: getDestinations() returns rules sorted by priority for fast routing
+4. **Preserves statistics**: updateRule() keeps existing statistics
+5. **Error handling**: Throws std::runtime_error for invalid rules with descriptive messages
+6. **UUID-based IDs**: Auto-generates UUIDs for stable rule references
+7. **Type checking**: Validates source is "input" and destination is "output"
+
+### 3. RouteManager.cpp
+**Location**: `/Users/orion/work/ol_dsp-midi-server/modules/juce/midi-server/network/routing/RouteManager.cpp`
+**Size**: 415 lines
+**Purpose**: Implementation of RouteManager
+
+#### Implementation Highlights:
+
+**Validation**
+- Checks rule structure (non-empty ID, source != destination)
+- Verifies source device exists in DeviceRegistry
+- Verifies destination device exists in DeviceRegistry
+- Validates source is type "input" (receives MIDI)
+- Validates destination is type "output" (sends MIDI)
+- Validates channel filter if present (0-16)
+
+**Persistence**
+- JSON array format for rules
+- Replaces all rules on load (not merge)
+- Pretty-printed JSON with indentation
+- Error handling for file I/O failures
+
+**Query Optimization**
+- getDestinations() sorts by priority (highest first) for fast routing decisions
+- Thread-safe iteration with lock guards
+- Reserve capacity where possible to reduce allocations
+
+**Statistics Management**
+- Aggregates across all rules
+- updateRuleStatistics() called from message forwarding path
+- Thread-safe updates with mutex
+
+## Integration Points
+
+### Dependencies
+- **DeviceRegistry**: Validates device existence
+- **DeviceKey**: Uses existing composite key structure
+- **JUCE**: Core, Time, JSON, File, Uuid
+
+### Used By (Future)
+- **HTTP Routing API**: Will expose CRUD endpoints
+- **MidiRouter**: Will use getDestinations() for forwarding decisions
+- **Rule UI**: Will use for configuration interface
+
+## Testing Strategy
+
+### Unit Tests (Recommended)
+1. **ForwardingRule Tests**
+   - JSON serialization round-trip
+   - Filter matching (channel, message type)
+   - Validation (source != destination, channel range)
+   - Statistics tracking
+
+2. **RouteManager Tests**
+   - CRUD operations
+   - Thread safety (concurrent access)
+   - Validation against DeviceRegistry
+   - Query operations (getDestinations priority sorting)
+   - Persistence (save/load)
+   - Statistics aggregation
+
+### Integration Tests (Recommended)
+1. **With DeviceRegistry**
+   - Validate rules against actual devices
+   - Handle device removal (orphaned rules)
+
+2. **With MidiRouter**
+   - Routing decisions based on rules
+   - Statistics updates during forwarding
+
+## Usage Example
+
+```cpp
+// Create device registry and route manager
+DeviceRegistry registry;
+RouteManager routeManager(registry);
+
+// Add some devices
+registry.addLocalDevice(1, "MIDI In", "input");
+registry.addLocalDevice(2, "MIDI Out", "output");
+registry.addRemoteDevice(remoteNodeId, 1, "Remote MIDI Out", "output");
+
+// Create a forwarding rule
+ForwardingRule rule(
+    juce::Uuid::null(), 1,  // Local MIDI In (source)
+    remoteNodeId, 1          // Remote MIDI Out (destination)
+);
+rule.priority = 100;
+rule.channelFilter = ChannelFilter(1);  // Only channel 1
+rule.messageTypeFilter = MidiMessageType::NoteOn | MidiMessageType::NoteOff;
+
+// Add the rule
+std::string ruleId = routeManager.addRule(rule);
+
+// Query destinations for routing
+auto destinations = routeManager.getDestinations(juce::Uuid::null(), 1);
+for (const auto& dest : destinations) {
+    if (dest.shouldForward(1, MidiMessageType::NoteOn)) {
+        // Forward message to dest.destinationDevice
+        routeManager.updateRuleStatistics(dest.ruleId.toStdString(), true);
+    }
+}
+
+// Save rules to file
+routeManager.saveToFile(juce::File("rules.json"));
+
+// Get statistics
+auto stats = routeManager.getStatistics();
+std::cout << "Total rules: " << stats.totalRules << std::endl;
+std::cout << "Messages forwarded: " << stats.totalMessagesForwarded << std::endl;
+```
+
+## Next Steps
+
+1. **Unit Tests**: Create RouteManagerTest.cpp
+2. **HTTP API**: Implement REST endpoints for CRUD operations
+3. **Integration**: Hook into MidiRouter for actual message forwarding
+4. **Persistence**: Decide on default rules file location
+5. **Documentation**: Add API docs for HTTP endpoints
+
+## Design Rationale
+
+### Why Header-only ForwardingRule?
+- Small, self-contained structure
+- Inline JSON serialization for efficiency
+- No need for separate compilation unit
+- Similar to DeviceKey pattern in codebase
+
+### Why Reference to DeviceRegistry?
+- Validates rules against actual devices
+- Prevents orphaned rules pointing to non-existent devices
+- Enforces type constraints (input->output)
+- Single source of truth for device state
+
+### Why Priority System?
+- Allows multiple rules per source
+- Conflict resolution (which destination wins)
+- Future: Load balancing, failover, multi-destination
+
+### Why Statistics Tracking?
+- Debugging: Which rules are actually used?
+- Monitoring: Message throughput per rule
+- Performance: Identify bottlenecks
+- User feedback: Show active/inactive rules
+
+### Why UUID-based Rule IDs?
+- Stable references across saves/loads
+- No ID collision issues
+- URL-safe for HTTP API
+- Easy to generate, no ID allocation needed
+
+## Compliance Checklist
+
+- [x] Files under 500 lines (285, 232, 415)
+- [x] Modern C++17 patterns
+- [x] Thread-safe with std::mutex
+- [x] JUCE conventions (camelCase, types)
+- [x] Matches existing codebase style
+- [x] No memory leaks (JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR)
+- [x] Descriptive error messages
+- [x] No fallbacks/mock data (throws errors instead)
+- [x] Const correctness
+- [x] RAII for resources
+- [x] Smart pointer usage where appropriate
+- [x] Comprehensive documentation
+
+## Known Limitations
+
+1. **No rule duplicate detection**: Can create identical rules with different IDs
+2. **No rule naming**: Rules only identified by UUID (could add human-readable name)
+3. **No rule groups**: Can't organize rules into logical groups
+4. **No rule templates**: Can't create rule templates for reuse
+5. **No automatic cleanup**: Orphaned rules when devices removed (future enhancement)
+6. **No rule scheduling**: Can't enable/disable rules on schedule (future enhancement)
diff --git a/modules/juce/midi-server/network/routing/RouteManager.cpp b/modules/juce/midi-server/network/routing/RouteManager.cpp
new file mode 100644
index 0000000..cccf612
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/RouteManager.cpp
@@ -0,0 +1,415 @@
+/**
+ * RouteManager.cpp
+ *
+ * Implementation of thread-safe MIDI forwarding rule manager
+ */
+
+#include "RouteManager.h"
+#include <algorithm>
+
+namespace NetworkMidi {
+
+RouteManager::RouteManager(DeviceRegistry& registry)
+    : deviceRegistry(registry)
+{
+}
+
+RouteManager::~RouteManager()
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+    rules.clear();
+}
+
+//==============================================================================
+// Rule management (CRUD operations)
+
+std::string RouteManager::addRule(const ForwardingRule& rule)
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    // Create a copy to potentially modify
+    ForwardingRule newRule = rule;
+
+    // Generate rule ID if not provided
+    if (newRule.ruleId.isEmpty()) {
+        newRule.ruleId = generateRuleId();
+    }
+
+    // Validate the rule
+    std::string errorMsg;
+    if (!validateRuleInternal(newRule, errorMsg)) {
+        throw std::runtime_error("Invalid forwarding rule: " + errorMsg);
+    }
+
+    // Check for duplicate rule ID
+    if (rules.find(newRule.ruleId.toStdString()) != rules.end()) {
+        throw std::runtime_error("Rule with ID '" + newRule.ruleId.toStdString() + "' already exists");
+    }
+
+    // Add the rule
+    rules[newRule.ruleId.toStdString()] = newRule;
+
+    return newRule.ruleId.toStdString();
+}
+
+bool RouteManager::removeRule(const std::string& ruleId)
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    auto it = rules.find(ruleId);
+    if (it == rules.end()) {
+        return false;
+    }
+
+    rules.erase(it);
+    return true;
+}
+
+bool RouteManager::updateRule(const std::string& ruleId, const ForwardingRule& rule)
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    // Check if rule exists
+    auto it = rules.find(ruleId);
+    if (it == rules.end()) {
+        return false;
+    }
+
+    // Create updated rule with correct ID
+    ForwardingRule updatedRule = rule;
+    updatedRule.ruleId = juce::String(ruleId);
+
+    // Validate the updated rule
+    std::string errorMsg;
+    if (!validateRuleInternal(updatedRule, errorMsg)) {
+        throw std::runtime_error("Invalid forwarding rule update: " + errorMsg);
+    }
+
+    // Preserve statistics from old rule
+    updatedRule.statistics = it->second.statistics;
+
+    // Update the rule
+    it->second = updatedRule;
+
+    return true;
+}
+
+std::optional<ForwardingRule> RouteManager::getRule(const std::string& ruleId) const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    auto it = rules.find(ruleId);
+    if (it != rules.end()) {
+        return it->second;
+    }
+
+    return std::nullopt;
+}
+
+std::vector<ForwardingRule> RouteManager::getAllRules() const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    std::vector<ForwardingRule> result;
+    result.reserve(rules.size());
+
+    for (const auto& pair : rules) {
+        result.push_back(pair.second);
+    }
+
+    return result;
+}
+
+void RouteManager::clearAllRules()
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+    rules.clear();
+}
+
+//==============================================================================
+// Query operations
+
+std::vector<ForwardingRule> RouteManager::getDestinations(const juce::Uuid& sourceNodeId,
+                                                           uint16_t sourceDeviceId) const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    std::vector<ForwardingRule> result;
+    DeviceKey sourceKey(sourceNodeId, sourceDeviceId);
+
+    // Find all rules with matching source
+    for (const auto& pair : rules) {
+        if (pair.second.sourceDevice == sourceKey && pair.second.enabled) {
+            result.push_back(pair.second);
+        }
+    }
+
+    // Sort by priority (highest first)
+    std::sort(result.begin(), result.end(),
+              [](const ForwardingRule& a, const ForwardingRule& b) {
+                  return a.priority > b.priority;  // Higher priority first
+              });
+
+    return result;
+}
+
+std::vector<ForwardingRule> RouteManager::getSourceRules(const juce::Uuid& nodeId,
+                                                          uint16_t deviceId) const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    std::vector<ForwardingRule> result;
+    DeviceKey sourceKey(nodeId, deviceId);
+
+    for (const auto& pair : rules) {
+        if (pair.second.sourceDevice == sourceKey) {
+            result.push_back(pair.second);
+        }
+    }
+
+    return result;
+}
+
+std::vector<ForwardingRule> RouteManager::getDestinationRules(const juce::Uuid& nodeId,
+                                                               uint16_t deviceId) const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    std::vector<ForwardingRule> result;
+    DeviceKey destKey(nodeId, deviceId);
+
+    for (const auto& pair : rules) {
+        if (pair.second.destinationDevice == destKey) {
+            result.push_back(pair.second);
+        }
+    }
+
+    return result;
+}
+
+std::vector<ForwardingRule> RouteManager::getEnabledRules() const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    std::vector<ForwardingRule> result;
+
+    for (const auto& pair : rules) {
+        if (pair.second.enabled) {
+            result.push_back(pair.second);
+        }
+    }
+
+    return result;
+}
+
+std::vector<ForwardingRule> RouteManager::getDisabledRules() const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    std::vector<ForwardingRule> result;
+
+    for (const auto& pair : rules) {
+        if (!pair.second.enabled) {
+            result.push_back(pair.second);
+        }
+    }
+
+    return result;
+}
+
+bool RouteManager::hasRule(const std::string& ruleId) const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+    return rules.find(ruleId) != rules.end();
+}
+
+int RouteManager::getRuleCount() const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+    return static_cast<int>(rules.size());
+}
+
+//==============================================================================
+// Validation
+
+bool RouteManager::validateRule(const ForwardingRule& rule, std::string& errorMsg) const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+    return validateRuleInternal(rule, errorMsg);
+}
+
+bool RouteManager::validateRuleInternal(const ForwardingRule& rule, std::string& errorMsg) const
+{
+    // Check basic rule validity
+    if (!rule.isValid()) {
+        if (rule.ruleId.isEmpty()) {
+            errorMsg = "Rule ID cannot be empty";
+        } else if (rule.sourceDevice == rule.destinationDevice) {
+            errorMsg = "Source and destination devices must be different";
+        } else if (rule.channelFilter.has_value() && !rule.channelFilter->isValid()) {
+            errorMsg = "Channel filter is invalid (must be 0-16)";
+        } else {
+            errorMsg = "Rule failed basic validation";
+        }
+        return false;
+    }
+
+    // Validate source device exists
+    if (!deviceRegistry.hasDevice(rule.sourceDevice.ownerNode, rule.sourceDevice.deviceId)) {
+        errorMsg = "Source device (" + rule.sourceDevice.ownerNode.toString().toStdString() +
+                   ", " + std::to_string(rule.sourceDevice.deviceId) + ") does not exist";
+        return false;
+    }
+
+    // Validate destination device exists
+    if (!deviceRegistry.hasDevice(rule.destinationDevice.ownerNode, rule.destinationDevice.deviceId)) {
+        errorMsg = "Destination device (" + rule.destinationDevice.ownerNode.toString().toStdString() +
+                   ", " + std::to_string(rule.destinationDevice.deviceId) + ") does not exist";
+        return false;
+    }
+
+    // Validate source and destination types are compatible
+    auto sourceDevice = deviceRegistry.getDevice(rule.sourceDevice.ownerNode, rule.sourceDevice.deviceId);
+    auto destDevice = deviceRegistry.getDevice(rule.destinationDevice.ownerNode, rule.destinationDevice.deviceId);
+
+    if (sourceDevice.has_value() && destDevice.has_value()) {
+        // Source must be an input (receives MIDI from hardware)
+        // Destination must be an output (sends MIDI to hardware)
+        if (sourceDevice->type != "input") {
+            errorMsg = "Source device must be of type 'input', found '" + sourceDevice->type.toStdString() + "'";
+            return false;
+        }
+
+        if (destDevice->type != "output") {
+            errorMsg = "Destination device must be of type 'output', found '" + destDevice->type.toStdString() + "'";
+            return false;
+        }
+    }
+
+    errorMsg.clear();
+    return true;
+}
+
+//==============================================================================
+// Persistence
+
+bool RouteManager::loadFromFile(const juce::File& file)
+{
+    if (!file.existsAsFile()) {
+        return false;
+    }
+
+    try {
+        // Read file contents
+        juce::String jsonContent = file.loadFileAsString();
+        auto parsed = juce::JSON::parse(jsonContent);
+
+        if (!parsed.isArray()) {
+            return false;
+        }
+
+        // Parse rules array
+        std::vector<ForwardingRule> loadedRules;
+        auto* rulesArray = parsed.getArray();
+
+        for (const auto& ruleVar : *rulesArray) {
+            ForwardingRule rule = ForwardingRule::fromVar(ruleVar);
+            loadedRules.push_back(rule);
+        }
+
+        // Replace current rules with loaded rules
+        std::lock_guard<std::mutex> lock(rulesMutex);
+        rules.clear();
+
+        for (const auto& rule : loadedRules) {
+            rules[rule.ruleId.toStdString()] = rule;
+        }
+
+        return true;
+    } catch (...) {
+        return false;
+    }
+}
+
+bool RouteManager::saveToFile(const juce::File& file) const
+{
+    try {
+        std::lock_guard<std::mutex> lock(rulesMutex);
+
+        // Create JSON array of rules
+        juce::Array<juce::var> rulesArray;
+
+        for (const auto& pair : rules) {
+            rulesArray.add(pair.second.toVar());
+        }
+
+        // Convert to JSON string
+        juce::String jsonContent = juce::JSON::toString(juce::var(rulesArray), true);
+
+        // Write to file
+        file.replaceWithText(jsonContent);
+
+        return true;
+    } catch (...) {
+        return false;
+    }
+}
+
+//==============================================================================
+// Statistics
+
+RouteManager::Statistics RouteManager::getStatistics() const
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    Statistics stats;
+    stats.totalRules = rules.size();
+
+    for (const auto& pair : rules) {
+        const auto& rule = pair.second;
+
+        if (rule.enabled) {
+            stats.enabledRules++;
+        } else {
+            stats.disabledRules++;
+        }
+
+        stats.totalMessagesForwarded += rule.statistics.messagesForwarded;
+        stats.totalMessagesDropped += rule.statistics.messagesDropped;
+    }
+
+    return stats;
+}
+
+void RouteManager::resetStatistics()
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    for (auto& pair : rules) {
+        pair.second.statistics.reset();
+    }
+}
+
+void RouteManager::updateRuleStatistics(const std::string& ruleId, bool forwarded)
+{
+    std::lock_guard<std::mutex> lock(rulesMutex);
+
+    auto it = rules.find(ruleId);
+    if (it != rules.end()) {
+        if (forwarded) {
+            it->second.statistics.incrementForwarded();
+        } else {
+            it->second.statistics.incrementDropped();
+        }
+    }
+}
+
+//==============================================================================
+// Private helper methods
+
+std::string RouteManager::generateRuleId() const
+{
+    return juce::Uuid().toString().toStdString();
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/RouteManager.h b/modules/juce/midi-server/network/routing/RouteManager.h
new file mode 100644
index 0000000..62b4450
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/RouteManager.h
@@ -0,0 +1,232 @@
+/**
+ * RouteManager.h
+ *
+ * Thread-safe manager for MIDI forwarding rules.
+ * Provides CRUD operations, validation, persistence, and statistics.
+ */
+
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include "ForwardingRule.h"
+#include "DeviceRegistry.h"
+#include <map>
+#include <vector>
+#include <mutex>
+#include <optional>
+#include <string>
+
+namespace NetworkMidi {
+
+/**
+ * Thread-safe manager for MIDI forwarding rules
+ *
+ * Design (Phase 2: Routing Configuration):
+ * - Manages collection of ForwardingRule objects
+ * - Thread-safe CRUD operations (add, remove, update, query)
+ * - Rule validation against DeviceRegistry
+ * - File persistence (load/save JSON)
+ * - Statistics aggregation
+ * - Fast lookup by source device for routing decisions
+ */
+class RouteManager {
+public:
+    /**
+     * Aggregate statistics for all routing rules
+     */
+    struct Statistics {
+        uint64_t totalRules = 0;
+        uint64_t enabledRules = 0;
+        uint64_t disabledRules = 0;
+        uint64_t totalMessagesForwarded = 0;
+        uint64_t totalMessagesDropped = 0;
+
+        juce::var toVar() const {
+            auto obj = new juce::DynamicObject();
+            obj->setProperty("totalRules", static_cast<juce::int64>(totalRules));
+            obj->setProperty("enabledRules", static_cast<juce::int64>(enabledRules));
+            obj->setProperty("disabledRules", static_cast<juce::int64>(disabledRules));
+            obj->setProperty("totalMessagesForwarded", static_cast<juce::int64>(totalMessagesForwarded));
+            obj->setProperty("totalMessagesDropped", static_cast<juce::int64>(totalMessagesDropped));
+            return juce::var(obj);
+        }
+    };
+
+    // Constructor
+    explicit RouteManager(DeviceRegistry& registry);
+    ~RouteManager();
+
+    //==============================================================================
+    // Rule management (CRUD operations)
+
+    /**
+     * Add a new forwarding rule
+     * @param rule The rule to add (ruleId will be generated if empty)
+     * @return Rule ID of the added rule
+     * @throws std::runtime_error if rule is invalid
+     */
+    std::string addRule(const ForwardingRule& rule);
+
+    /**
+     * Remove a forwarding rule by ID
+     * @param ruleId The ID of the rule to remove
+     * @return true if rule was removed, false if not found
+     */
+    bool removeRule(const std::string& ruleId);
+
+    /**
+     * Update an existing forwarding rule
+     * @param ruleId The ID of the rule to update
+     * @param rule The new rule data
+     * @return true if rule was updated, false if not found
+     * @throws std::runtime_error if rule is invalid
+     */
+    bool updateRule(const std::string& ruleId, const ForwardingRule& rule);
+
+    /**
+     * Get a specific forwarding rule by ID
+     * @param ruleId The ID of the rule to retrieve
+     * @return The rule if found, std::nullopt otherwise
+     */
+    std::optional<ForwardingRule> getRule(const std::string& ruleId) const;
+
+    /**
+     * Get all forwarding rules
+     * @return Vector of all rules
+     */
+    std::vector<ForwardingRule> getAllRules() const;
+
+    /**
+     * Clear all forwarding rules
+     */
+    void clearAllRules();
+
+    //==============================================================================
+    // Query operations
+
+    /**
+     * Get all destination rules for a source device
+     * Used for fast routing lookups during message forwarding
+     * @param sourceNodeId Source device's node ID
+     * @param sourceDeviceId Source device's device ID
+     * @return Vector of rules sorted by priority (highest first)
+     */
+    std::vector<ForwardingRule> getDestinations(const juce::Uuid& sourceNodeId,
+                                                 uint16_t sourceDeviceId) const;
+
+    /**
+     * Get all rules where a device is the source
+     * @param nodeId Node ID of the source device
+     * @param deviceId Device ID of the source device
+     * @return Vector of rules using this device as source
+     */
+    std::vector<ForwardingRule> getSourceRules(const juce::Uuid& nodeId,
+                                                uint16_t deviceId) const;
+
+    /**
+     * Get all rules where a device is the destination
+     * @param nodeId Node ID of the destination device
+     * @param deviceId Device ID of the destination device
+     * @return Vector of rules using this device as destination
+     */
+    std::vector<ForwardingRule> getDestinationRules(const juce::Uuid& nodeId,
+                                                     uint16_t deviceId) const;
+
+    /**
+     * Get all enabled rules
+     * @return Vector of enabled rules
+     */
+    std::vector<ForwardingRule> getEnabledRules() const;
+
+    /**
+     * Get all disabled rules
+     * @return Vector of disabled rules
+     */
+    std::vector<ForwardingRule> getDisabledRules() const;
+
+    /**
+     * Check if a rule exists
+     * @param ruleId The rule ID to check
+     * @return true if rule exists, false otherwise
+     */
+    bool hasRule(const std::string& ruleId) const;
+
+    /**
+     * Get number of rules
+     * @return Total number of rules
+     */
+    int getRuleCount() const;
+
+    //==============================================================================
+    // Validation
+
+    /**
+     * Validate a forwarding rule
+     * Checks:
+     * - Rule structure is valid (ruleId, source != destination)
+     * - Source device exists in DeviceRegistry
+     * - Destination device exists in DeviceRegistry
+     * - Channel filter is valid if present
+     *
+     * @param rule The rule to validate
+     * @param errorMsg Output parameter for error message
+     * @return true if valid, false otherwise
+     */
+    bool validateRule(const ForwardingRule& rule, std::string& errorMsg) const;
+
+    //==============================================================================
+    // Persistence
+
+    /**
+     * Load rules from a JSON file
+     * Replaces all current rules with loaded rules
+     * @param file The file to load from
+     * @return true if successful, false on error
+     */
+    bool loadFromFile(const juce::File& file);
+
+    /**
+     * Save rules to a JSON file
+     * @param file The file to save to
+     * @return true if successful, false on error
+     */
+    bool saveToFile(const juce::File& file) const;
+
+    //==============================================================================
+    // Statistics
+
+    /**
+     * Get aggregate statistics for all rules
+     * @return Statistics structure with aggregated data
+     */
+    Statistics getStatistics() const;
+
+    /**
+     * Reset all rule statistics
+     * Clears message counts and last forwarded timestamps
+     */
+    void resetStatistics();
+
+    /**
+     * Update statistics for a rule (called during message forwarding)
+     * @param ruleId The rule ID to update
+     * @param forwarded true if message was forwarded, false if dropped
+     */
+    void updateRuleStatistics(const std::string& ruleId, bool forwarded);
+
+private:
+    // Reference to device registry for validation
+    DeviceRegistry& deviceRegistry;
+
+    // Thread-safe rule storage (keyed by ruleId)
+    mutable std::mutex rulesMutex;
+    std::map<std::string, ForwardingRule> rules;
+
+    // Helper methods
+    bool validateRuleInternal(const ForwardingRule& rule, std::string& errorMsg) const;
+    std::string generateRuleId() const;
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(RouteManager)
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/tests/integration/routing_api_test.sh b/modules/juce/midi-server/tests/integration/routing_api_test.sh
new file mode 100644
index 0000000..8ddbd0f
--- /dev/null
+++ b/modules/juce/midi-server/tests/integration/routing_api_test.sh
@@ -0,0 +1,462 @@
+#!/bin/bash
+# routing_api_test.sh
+#
+# Integration test for Routing Configuration API (Phase 2)
+# Tests the HTTP REST API endpoints for managing routing rules
+#
+# Usage: ./routing_api_test.sh [server_port]
+#
+# Prerequisites:
+# - network_midi_server must be built
+# - curl must be installed
+# - jq must be installed (for JSON parsing)
+
+set -e  # Exit on error
+
+# Configuration
+SERVER_PORT=${1:-8080}
+SERVER_HOST="localhost"
+BASE_URL="http://${SERVER_HOST}:${SERVER_PORT}"
+SERVER_BIN="./build/network_midi_server"
+SERVER_PID=""
+TEST_RESULTS=()
+FAILED_TESTS=0
+PASSED_TESTS=0
+
+# Colors for output
+RED='\033[0;31m'
+GREEN='\033[0;32m'
+YELLOW='\033[1;33m'
+NC='\033[0m' # No Color
+
+# Utility functions
+log_info() {
+    echo -e "${GREEN}[INFO]${NC} $1"
+}
+
+log_error() {
+    echo -e "${RED}[ERROR]${NC} $1"
+}
+
+log_warn() {
+    echo -e "${YELLOW}[WARN]${NC} $1"
+}
+
+test_pass() {
+    echo -e "${GREEN}✓${NC} $1"
+    TEST_RESULTS+=("PASS: $1")
+    ((PASSED_TESTS++))
+}
+
+test_fail() {
+    echo -e "${RED}✗${NC} $1"
+    TEST_RESULTS+=("FAIL: $1")
+    ((FAILED_TESTS++))
+}
+
+# Check prerequisites
+check_prerequisites() {
+    log_info "Checking prerequisites..."
+
+    if ! command -v curl &> /dev/null; then
+        log_error "curl is not installed. Please install curl."
+        exit 1
+    fi
+
+    if ! command -v jq &> /dev/null; then
+        log_warn "jq is not installed. JSON parsing will be limited."
+    fi
+
+    if [ ! -f "$SERVER_BIN" ]; then
+        log_error "Server binary not found at $SERVER_BIN"
+        log_error "Please build the project first: cmake --build build"
+        exit 1
+    fi
+}
+
+# Start the server
+start_server() {
+    log_info "Starting network_midi_server on port $SERVER_PORT..."
+
+    # Kill any existing server on the port
+    lsof -ti:$SERVER_PORT | xargs kill -9 2>/dev/null || true
+    sleep 1
+
+    # Start server in background
+    $SERVER_BIN --port $SERVER_PORT > /tmp/routing_test_server.log 2>&1 &
+    SERVER_PID=$!
+
+    log_info "Server started with PID $SERVER_PID"
+
+    # Wait for server to be ready
+    log_info "Waiting for server to be ready..."
+    for i in {1..30}; do
+        if curl -s "$BASE_URL/health" > /dev/null 2>&1; then
+            log_info "Server is ready"
+            return 0
+        fi
+        sleep 1
+    done
+
+    log_error "Server failed to start within 30 seconds"
+    cat /tmp/routing_test_server.log
+    return 1
+}
+
+# Stop the server
+stop_server() {
+    if [ -n "$SERVER_PID" ]; then
+        log_info "Stopping server (PID $SERVER_PID)..."
+        kill $SERVER_PID 2>/dev/null || true
+        wait $SERVER_PID 2>/dev/null || true
+        SERVER_PID=""
+    fi
+}
+
+# Cleanup on exit
+cleanup() {
+    stop_server
+    log_info "Cleanup complete"
+}
+
+trap cleanup EXIT
+
+# Test: Health check
+test_health_check() {
+    log_info "Test: Health check endpoint"
+
+    response=$(curl -s -w "\n%{http_code}" "$BASE_URL/health")
+    http_code=$(echo "$response" | tail -n1)
+    body=$(echo "$response" | head -n-1)
+
+    if [ "$http_code" = "200" ]; then
+        test_pass "Health check returned 200 OK"
+    else
+        test_fail "Health check returned $http_code (expected 200)"
+    fi
+}
+
+# Test: Create a route
+test_create_route() {
+    log_info "Test: Create routing rule via POST /routing/routes"
+
+    # Create a simple route
+    response=$(curl -s -w "\n%{http_code}" -X POST "$BASE_URL/routing/routes" \
+        -H "Content-Type: application/json" \
+        -d '{
+            "sourceNode": "00000000-0000-0000-0000-000000000000",
+            "sourceDeviceId": 1,
+            "destNode": "12345678-1234-5678-1234-567812345678",
+            "destDeviceId": 10,
+            "priority": 100,
+            "enabled": true
+        }')
+
+    http_code=$(echo "$response" | tail -n1)
+    body=$(echo "$response" | head -n-1)
+
+    if [ "$http_code" = "201" ] || [ "$http_code" = "200" ]; then
+        # Extract rule ID from response
+        if command -v jq &> /dev/null; then
+            CREATED_RULE_ID=$(echo "$body" | jq -r '.ruleId')
+            test_pass "Route created successfully (ID: $CREATED_RULE_ID)"
+        else
+            test_pass "Route created successfully (HTTP $http_code)"
+        fi
+    else
+        test_fail "Failed to create route (HTTP $http_code): $body"
+    fi
+}
+
+# Test: List routes
+test_list_routes() {
+    log_info "Test: List routing rules via GET /routing/routes"
+
+    response=$(curl -s -w "\n%{http_code}" "$BASE_URL/routing/routes")
+    http_code=$(echo "$response" | tail -n1)
+    body=$(echo "$response" | head -n-1)
+
+    if [ "$http_code" = "200" ]; then
+        if command -v jq &> /dev/null; then
+            rule_count=$(echo "$body" | jq '.rules | length')
+            test_pass "Listed $rule_count routing rules"
+        else
+            test_pass "Successfully retrieved routing rules"
+        fi
+    else
+        test_fail "Failed to list routes (HTTP $http_code): $body"
+    fi
+}
+
+# Test: Get specific route
+test_get_route() {
+    log_info "Test: Get specific route via GET /routing/routes/{id}"
+
+    if [ -z "$CREATED_RULE_ID" ]; then
+        log_warn "No rule ID available, skipping get route test"
+        return
+    fi
+
+    response=$(curl -s -w "\n%{http_code}" "$BASE_URL/routing/routes/$CREATED_RULE_ID")
+    http_code=$(echo "$response" | tail -n1)
+    body=$(echo "$response" | head -n-1)
+
+    if [ "$http_code" = "200" ]; then
+        test_pass "Retrieved specific route successfully"
+    else
+        test_fail "Failed to get route (HTTP $http_code): $body"
+    fi
+}
+
+# Test: Update route
+test_update_route() {
+    log_info "Test: Update route via PUT /routing/routes/{id}"
+
+    if [ -z "$CREATED_RULE_ID" ]; then
+        log_warn "No rule ID available, skipping update test"
+        return
+    fi
+
+    response=$(curl -s -w "\n%{http_code}" -X PUT "$BASE_URL/routing/routes/$CREATED_RULE_ID" \
+        -H "Content-Type: application/json" \
+        -d '{
+            "sourceNode": "00000000-0000-0000-0000-000000000000",
+            "sourceDeviceId": 1,
+            "destNode": "87654321-4321-8765-4321-876543218765",
+            "destDeviceId": 20,
+            "priority": 200,
+            "enabled": false
+        }')
+
+    http_code=$(echo "$response" | tail -n1)
+    body=$(echo "$response" | head -n-1)
+
+    if [ "$http_code" = "200" ]; then
+        test_pass "Route updated successfully"
+    else
+        test_fail "Failed to update route (HTTP $http_code): $body"
+    fi
+}
+
+# Test: Create route with filters
+test_create_route_with_filters() {
+    log_info "Test: Create route with channel and message type filters"
+
+    response=$(curl -s -w "\n%{http_code}" -X POST "$BASE_URL/routing/routes" \
+        -H "Content-Type: application/json" \
+        -d '{
+            "sourceNode": "00000000-0000-0000-0000-000000000000",
+            "sourceDeviceId": 2,
+            "destNode": "12345678-1234-5678-1234-567812345678",
+            "destDeviceId": 15,
+            "priority": 150,
+            "enabled": true,
+            "channelFilter": [1, 2, 3],
+            "messageTypeFilter": [144, 128]
+        }')
+
+    http_code=$(echo "$response" | tail -n1)
+    body=$(echo "$response" | head -n-1)
+
+    if [ "$http_code" = "201" ] || [ "$http_code" = "200" ]; then
+        if command -v jq &> /dev/null; then
+            FILTERED_RULE_ID=$(echo "$body" | jq -r '.ruleId')
+            test_pass "Route with filters created successfully (ID: $FILTERED_RULE_ID)"
+        else
+            test_pass "Route with filters created successfully"
+        fi
+    else
+        test_fail "Failed to create route with filters (HTTP $http_code): $body"
+    fi
+}
+
+# Test: Get route statistics
+test_route_statistics() {
+    log_info "Test: Get route statistics via GET /routing/routes/{id}/stats"
+
+    if [ -z "$CREATED_RULE_ID" ]; then
+        log_warn "No rule ID available, skipping statistics test"
+        return
+    fi
+
+    response=$(curl -s -w "\n%{http_code}" "$BASE_URL/routing/routes/$CREATED_RULE_ID/stats")
+    http_code=$(echo "$response" | tail -n1)
+    body=$(echo "$response" | head -n-1)
+
+    if [ "$http_code" = "200" ]; then
+        if command -v jq &> /dev/null; then
+            messages_routed=$(echo "$body" | jq -r '.messagesRouted')
+            test_pass "Retrieved route statistics (messages: $messages_routed)"
+        else
+            test_pass "Retrieved route statistics"
+        fi
+    else
+        test_fail "Failed to get statistics (HTTP $http_code): $body"
+    fi
+}
+
+# Test: Enable/disable route
+test_enable_disable_route() {
+    log_info "Test: Enable/disable route via PATCH /routing/routes/{id}"
+
+    if [ -z "$CREATED_RULE_ID" ]; then
+        log_warn "No rule ID available, skipping enable/disable test"
+        return
+    fi
+
+    # Disable
+    response=$(curl -s -w "\n%{http_code}" -X PATCH "$BASE_URL/routing/routes/$CREATED_RULE_ID" \
+        -H "Content-Type: application/json" \
+        -d '{"enabled": false}')
+
+    http_code=$(echo "$response" | tail -n1)
+
+    if [ "$http_code" = "200" ]; then
+        test_pass "Route disabled successfully"
+    else
+        test_fail "Failed to disable route (HTTP $http_code)"
+    fi
+
+    # Enable
+    response=$(curl -s -w "\n%{http_code}" -X PATCH "$BASE_URL/routing/routes/$CREATED_RULE_ID" \
+        -H "Content-Type: application/json" \
+        -d '{"enabled": true}')
+
+    http_code=$(echo "$response" | tail -n1)
+
+    if [ "$http_code" = "200" ]; then
+        test_pass "Route enabled successfully"
+    else
+        test_fail "Failed to enable route (HTTP $http_code)"
+    fi
+}
+
+# Test: Delete route
+test_delete_route() {
+    log_info "Test: Delete route via DELETE /routing/routes/{id}"
+
+    if [ -z "$CREATED_RULE_ID" ]; then
+        log_warn "No rule ID available, skipping delete test"
+        return
+    fi
+
+    response=$(curl -s -w "\n%{http_code}" -X DELETE "$BASE_URL/routing/routes/$CREATED_RULE_ID")
+    http_code=$(echo "$response" | tail -n1)
+
+    if [ "$http_code" = "204" ] || [ "$http_code" = "200" ]; then
+        test_pass "Route deleted successfully"
+    else
+        test_fail "Failed to delete route (HTTP $http_code)"
+    fi
+
+    # Verify deletion
+    response=$(curl -s -w "\n%{http_code}" "$BASE_URL/routing/routes/$CREATED_RULE_ID")
+    http_code=$(echo "$response" | tail -n1)
+
+    if [ "$http_code" = "404" ]; then
+        test_pass "Verified route was deleted (404 on GET)"
+    else
+        test_fail "Route still exists after deletion (HTTP $http_code)"
+    fi
+}
+
+# Test: Invalid route creation
+test_invalid_route_creation() {
+    log_info "Test: Reject invalid route (non-existent device)"
+
+    response=$(curl -s -w "\n%{http_code}" -X POST "$BASE_URL/routing/routes" \
+        -H "Content-Type: application/json" \
+        -d '{
+            "sourceNode": "00000000-0000-0000-0000-000000000000",
+            "sourceDeviceId": 9999,
+            "destNode": "12345678-1234-5678-1234-567812345678",
+            "destDeviceId": 10,
+            "priority": 100,
+            "enabled": true
+        }')
+
+    http_code=$(echo "$response" | tail -n1)
+
+    if [ "$http_code" = "400" ] || [ "$http_code" = "404" ]; then
+        test_pass "Invalid route rejected with appropriate error code ($http_code)"
+    else
+        test_fail "Invalid route should be rejected (got HTTP $http_code)"
+    fi
+}
+
+# Test: Malformed JSON
+test_malformed_json() {
+    log_info "Test: Reject malformed JSON"
+
+    response=$(curl -s -w "\n%{http_code}" -X POST "$BASE_URL/routing/routes" \
+        -H "Content-Type: application/json" \
+        -d '{"invalid json": }')
+
+    http_code=$(echo "$response" | tail -n1)
+
+    if [ "$http_code" = "400" ]; then
+        test_pass "Malformed JSON rejected with 400 Bad Request"
+    else
+        test_fail "Malformed JSON should return 400 (got HTTP $http_code)"
+    fi
+}
+
+# Print test summary
+print_summary() {
+    echo ""
+    echo "========================================"
+    echo "Test Summary"
+    echo "========================================"
+    echo -e "${GREEN}Passed:${NC} $PASSED_TESTS"
+    echo -e "${RED}Failed:${NC} $FAILED_TESTS"
+    echo "Total:  $((PASSED_TESTS + FAILED_TESTS))"
+    echo ""
+
+    if [ $FAILED_TESTS -eq 0 ]; then
+        echo -e "${GREEN}All tests passed!${NC}"
+        exit 0
+    else
+        echo -e "${RED}Some tests failed!${NC}"
+        echo ""
+        echo "Failed tests:"
+        for result in "${TEST_RESULTS[@]}"; do
+            if [[ $result == FAIL:* ]]; then
+                echo -e "  ${RED}✗${NC} ${result#FAIL: }"
+            fi
+        done
+        exit 1
+    fi
+}
+
+# Main test execution
+main() {
+    log_info "Starting Routing API Integration Tests"
+    log_info "Server: $BASE_URL"
+    echo ""
+
+    check_prerequisites
+    start_server
+
+    echo ""
+    log_info "Running tests..."
+    echo ""
+
+    # Run all tests
+    test_health_check
+    test_create_route
+    test_list_routes
+    test_get_route
+    test_update_route
+    test_create_route_with_filters
+    test_route_statistics
+    test_enable_disable_route
+    test_delete_route
+    test_invalid_route_creation
+    test_malformed_json
+
+    echo ""
+    print_summary
+}
+
+# Run main
+main "$@"
diff --git a/modules/juce/midi-server/tests/unit/RouteManagerTest.cpp b/modules/juce/midi-server/tests/unit/RouteManagerTest.cpp
new file mode 100644
index 0000000..48fa4a7
--- /dev/null
+++ b/modules/juce/midi-server/tests/unit/RouteManagerTest.cpp
@@ -0,0 +1,716 @@
+/**
+ * RouteManagerTest.cpp
+ *
+ * Unit tests for RouteManager (Phase 2: Routing Configuration API)
+ * Tests: rule add/remove/update, priority ordering, validation, filters,
+ *        statistics, persistence, thread safety
+ *
+ * Coverage Target: 80%+
+ */
+
+#include "network/routing/RouteManager.h"
+#include "network/routing/DeviceRegistry.h"
+#include <gtest/gtest.h>
+#include <gmock/gmock.h>
+#include <thread>
+#include <filesystem>
+
+using namespace NetworkMidi;
+using namespace testing;
+
+class RouteManagerTest : public ::testing::Test {
+protected:
+    void SetUp() override {
+        // Create a real DeviceRegistry for testing
+        deviceRegistry = std::make_unique<DeviceRegistry>();
+
+        // Create RouteManager with the registry
+        routeManager = std::make_unique<RouteManager>(*deviceRegistry);
+
+        // Setup test node IDs
+        localNode = juce::Uuid::null();
+        remoteNode1 = juce::Uuid();
+        remoteNode2 = juce::Uuid();
+
+        // Add test devices to registry
+        deviceRegistry->addLocalDevice(1, "Local Input 1", "input", "TestVendor");
+        deviceRegistry->addLocalDevice(2, "Local Output 1", "output", "TestVendor");
+        deviceRegistry->addRemoteDevice(remoteNode1, 10, "Remote Output 1", "output", "RemoteVendor");
+        deviceRegistry->addRemoteDevice(remoteNode2, 20, "Remote Output 2", "output", "RemoteVendor");
+
+        // Create temporary file for persistence tests
+        tempConfigFile = std::filesystem::temp_directory_path() / "route_manager_test.json";
+    }
+
+    void TearDown() override {
+        // Clean up temporary file
+        if (std::filesystem::exists(tempConfigFile)) {
+            std::filesystem::remove(tempConfigFile);
+        }
+    }
+
+    std::unique_ptr<DeviceRegistry> deviceRegistry;
+    std::unique_ptr<RouteManager> routeManager;
+    juce::Uuid localNode;
+    juce::Uuid remoteNode1;
+    juce::Uuid remoteNode2;
+    std::filesystem::path tempConfigFile;
+};
+
+//==============================================================================
+// Rule Management Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, AddsBasicRule) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto rule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(rule.has_value());
+    EXPECT_EQ(localNode, rule->sourceNodeId());
+    EXPECT_EQ(1, rule->sourceDeviceId());
+    EXPECT_EQ(remoteNode1, rule->destinationNodeId());
+    EXPECT_EQ(10, rule->destinationDeviceId());
+    EXPECT_EQ(100, rule->priority);
+    EXPECT_TRUE(rule->enabled);
+}
+
+TEST_F(RouteManagerTest, RemovesRule) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    bool removed = routeManager->removeRule(ruleId);
+
+    EXPECT_TRUE(removed);
+    EXPECT_FALSE(routeManager->getRule(ruleId).has_value());
+}
+
+TEST_F(RouteManagerTest, UpdatesRule) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    // Update to different destination and priority
+    NetworkMidi::ForwardingRule updatedRule(localNode, 1, remoteNode2, 20);
+    updatedRule.priority = 200;
+    updatedRule.enabled = false;
+    updatedRule.ruleId = ruleId;  // Preserve the rule ID
+
+    bool updated = routeManager->updateRule(ruleId, updatedRule);
+
+    EXPECT_TRUE(updated);
+
+    auto rule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(rule.has_value());
+    EXPECT_EQ(remoteNode2, rule->destinationNodeId());
+    EXPECT_EQ(20, rule->destinationDeviceId());
+    EXPECT_EQ(200, rule->priority);
+    EXPECT_FALSE(rule->enabled);
+}
+
+TEST_F(RouteManagerTest, GetsAllRules) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId1 = routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 200;
+    rule2.enabled = true;
+    auto ruleId2 = routeManager->addRule(rule2);
+
+    auto rules = routeManager->getAllRules();
+
+    EXPECT_EQ(2u, rules.size());
+}
+
+TEST_F(RouteManagerTest, ClearsAllRules) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 200;
+    rule2.enabled = true;
+    routeManager->addRule(rule2);
+
+    routeManager->clearAllRules();
+
+    auto rules = routeManager->getAllRules();
+    EXPECT_TRUE(rules.empty());
+}
+
+//==============================================================================
+// Destination Lookup Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, GetsDestinationsForSource) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 200;
+    rule2.enabled = true;
+    routeManager->addRule(rule2);
+
+    auto destinations = routeManager->getDestinations(localNode, 1);
+
+    EXPECT_EQ(2u, destinations.size());
+}
+
+TEST_F(RouteManagerTest, ReturnsEmptyForNoMatchingRules) {
+    auto destinations = routeManager->getDestinations(localNode, 999);
+
+    EXPECT_TRUE(destinations.empty());
+}
+
+TEST_F(RouteManagerTest, IgnoresDisabledRules) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 200;
+    rule2.enabled = false;
+    routeManager->addRule(rule2);
+
+    auto destinations = routeManager->getDestinations(localNode, 1);
+
+    EXPECT_EQ(1u, destinations.size());
+    EXPECT_EQ(remoteNode1, destinations[0].destinationNodeId());
+    EXPECT_EQ(10, destinations[0].destinationDeviceId());
+}
+
+//==============================================================================
+// Priority Ordering Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, OrdersDestinationsByPriority) {
+    // Add rules in random order
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 50;
+    rule1.enabled = true;
+    routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 100;
+    rule2.enabled = true;
+    routeManager->addRule(rule2);
+
+    NetworkMidi::ForwardingRule rule3(localNode, 1, localNode, 2);
+    rule3.priority = 25;
+    rule3.enabled = true;
+    auto ruleId3 = routeManager->addRule(rule3);
+
+    auto destinations = routeManager->getDestinations(localNode, 1);
+
+    // Should be ordered by priority (highest first)
+    ASSERT_EQ(3u, destinations.size());
+    EXPECT_EQ(remoteNode2, destinations[0].destinationNodeId());  // Priority 100
+    EXPECT_EQ(20, destinations[0].destinationDeviceId());
+    EXPECT_EQ(remoteNode1, destinations[1].destinationNodeId());  // Priority 50
+    EXPECT_EQ(10, destinations[1].destinationDeviceId());
+    EXPECT_EQ(localNode, destinations[2].destinationNodeId());    // Priority 25
+    EXPECT_EQ(2, destinations[2].destinationDeviceId());
+}
+
+//==============================================================================
+// Rule Validation Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, RejectsInvalidSourceDevice) {
+    NetworkMidi::ForwardingRule rule1(localNode, 999, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+
+    EXPECT_THROW(routeManager->addRule(rule1), std::runtime_error);
+}
+
+TEST_F(RouteManagerTest, RejectsInvalidDestinationDevice) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 999);
+    rule1.priority = 100;
+    rule1.enabled = true;
+
+    EXPECT_THROW(routeManager->addRule(rule1), std::runtime_error);
+}
+
+TEST_F(RouteManagerTest, RejectsNonExistentSourceNode) {
+    juce::Uuid nonExistentNode;
+    NetworkMidi::ForwardingRule rule1(nonExistentNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+
+    EXPECT_THROW(routeManager->addRule(rule1), std::runtime_error);
+}
+
+TEST_F(RouteManagerTest, RejectsNonExistentDestinationNode) {
+    juce::Uuid nonExistentNode;
+    NetworkMidi::ForwardingRule rule1(localNode, 1, nonExistentNode, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+
+    EXPECT_THROW(routeManager->addRule(rule1), std::runtime_error);
+}
+
+TEST_F(RouteManagerTest, AllowsSameSourceAndDestination) {
+    // Local routing (loopback) should be allowed
+    NetworkMidi::ForwardingRule rule1(localNode, 1, localNode, 2);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    EXPECT_FALSE(ruleId.empty());
+}
+
+//==============================================================================
+// Enable/Disable Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, EnablesRule) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = false;
+    auto ruleId = routeManager->addRule(rule1);
+
+    // To enable a rule, update it with enabled=true
+    auto rule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(rule.has_value());
+    rule->enabled = true;
+    bool enabled = routeManager->updateRule(ruleId, *rule);
+
+    EXPECT_TRUE(enabled);
+
+    auto updatedRule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(updatedRule.has_value());
+    EXPECT_TRUE(updatedRule->enabled);
+}
+
+TEST_F(RouteManagerTest, DisablesRule) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    // To disable a rule, update it with enabled=false
+    auto rule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(rule.has_value());
+    rule->enabled = false;
+    bool disabled = routeManager->updateRule(ruleId, *rule);
+
+    EXPECT_TRUE(disabled);
+
+    auto updatedRule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(updatedRule.has_value());
+    EXPECT_FALSE(updatedRule->enabled);
+}
+
+TEST_F(RouteManagerTest, RejectsEnableNonExistentRule) {
+    std::string fakeId = "non-existent-id";
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    bool result = routeManager->updateRule(fakeId, rule1);
+
+    EXPECT_FALSE(result);
+}
+
+//==============================================================================
+// Filter Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, AddsRuleWithChannelFilter) {
+    NetworkMidi::ForwardingRule rule(localNode, 1, remoteNode1, 10);
+    rule.priority = 100;
+    rule.enabled = true;
+    rule.channelFilter = NetworkMidi::ChannelFilter{1};  // Channel 1
+
+    auto ruleId = routeManager->addRule(rule);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto retrievedRule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(retrievedRule.has_value());
+    ASSERT_TRUE(retrievedRule->channelFilter.has_value());
+    EXPECT_EQ(1, retrievedRule->channelFilter->channel);
+}
+
+TEST_F(RouteManagerTest, AddsRuleWithMessageTypeFilter) {
+    NetworkMidi::ForwardingRule rule(localNode, 1, remoteNode1, 10);
+    rule.priority = 100;
+    rule.enabled = true;
+    rule.messageTypeFilter = NetworkMidi::MidiMessageType::NoteOn | NetworkMidi::MidiMessageType::NoteOff;
+
+    auto ruleId = routeManager->addRule(rule);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto retrievedRule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(retrievedRule.has_value());
+    auto expectedFilter = NetworkMidi::MidiMessageType::NoteOn | NetworkMidi::MidiMessageType::NoteOff;
+    EXPECT_EQ(expectedFilter, retrievedRule->messageTypeFilter);
+}
+
+TEST_F(RouteManagerTest, AddsRuleWithBothFilters) {
+    NetworkMidi::ForwardingRule rule(localNode, 1, remoteNode1, 10);
+    rule.priority = 100;
+    rule.enabled = true;
+    rule.channelFilter = NetworkMidi::ChannelFilter{1};  // Channel 1
+    rule.messageTypeFilter = NetworkMidi::MidiMessageType::NoteOn | NetworkMidi::MidiMessageType::NoteOff;
+
+    auto ruleId = routeManager->addRule(rule);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto retrievedRule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(retrievedRule.has_value());
+    ASSERT_TRUE(retrievedRule->channelFilter.has_value());
+    EXPECT_EQ(1, retrievedRule->channelFilter->channel);
+    auto expectedFilter = NetworkMidi::MidiMessageType::NoteOn | NetworkMidi::MidiMessageType::NoteOff;
+    EXPECT_EQ(expectedFilter, retrievedRule->messageTypeFilter);
+}
+
+//==============================================================================
+// Statistics Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, TracksRuleStatistics) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    // Simulate messages being routed
+    routeManager->updateRuleStatistics(ruleId, true);
+    routeManager->updateRuleStatistics(ruleId, true);
+    routeManager->updateRuleStatistics(ruleId, true);
+
+    auto rule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(rule.has_value());
+    EXPECT_EQ(3u, rule->statistics.messagesForwarded);
+}
+
+TEST_F(RouteManagerTest, ReturnsEmptyStatsForNonExistentRule) {
+    std::string fakeId = "non-existent-id";
+    auto rule = routeManager->getRule(fakeId);
+
+    EXPECT_FALSE(rule.has_value());
+}
+
+TEST_F(RouteManagerTest, ResetsAllStatistics) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId1 = routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 200;
+    rule2.enabled = true;
+    auto ruleId2 = routeManager->addRule(rule2);
+
+    routeManager->updateRuleStatistics(ruleId1, true);
+    routeManager->updateRuleStatistics(ruleId2, true);
+
+    routeManager->resetStatistics();
+
+    auto rule1Updated = routeManager->getRule(ruleId1);
+    auto rule2Updated = routeManager->getRule(ruleId2);
+
+    ASSERT_TRUE(rule1Updated.has_value());
+    ASSERT_TRUE(rule2Updated.has_value());
+    EXPECT_EQ(0u, rule1Updated->statistics.messagesForwarded);
+    EXPECT_EQ(0u, rule2Updated->statistics.messagesForwarded);
+}
+
+//==============================================================================
+// File Persistence Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, SavesRulesToFile) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 200;
+    rule2.enabled = false;
+    routeManager->addRule(rule2);
+
+    bool saved = routeManager->saveToFile(juce::File(tempConfigFile.string()));
+
+    EXPECT_TRUE(saved);
+    EXPECT_TRUE(std::filesystem::exists(tempConfigFile));
+}
+
+TEST_F(RouteManagerTest, LoadsRulesFromFile) {
+    // First, save some rules
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId1 = routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode2, 20);
+    rule2.priority = 200;
+    rule2.enabled = false;
+    auto ruleId2 = routeManager->addRule(rule2);
+    routeManager->saveToFile(juce::File(tempConfigFile.string()));
+
+    // Clear current rules
+    routeManager->clearAllRules();
+    EXPECT_TRUE(routeManager->getAllRules().empty());
+
+    // Load from file
+    bool loaded = routeManager->loadFromFile(juce::File(tempConfigFile.string()));
+
+    EXPECT_TRUE(loaded);
+    auto rules = routeManager->getAllRules();
+    EXPECT_EQ(2u, rules.size());
+}
+
+TEST_F(RouteManagerTest, PreservesRuleDetailsInPersistence) {
+    NetworkMidi::ForwardingRule rule(localNode, 1, remoteNode1, 10);
+    rule.priority = 150;
+    rule.enabled = true;
+    rule.channelFilter = NetworkMidi::ChannelFilter{1};  // Channel 1
+    rule.messageTypeFilter = NetworkMidi::MidiMessageType::NoteOn | NetworkMidi::MidiMessageType::NoteOff;
+
+    auto ruleId = routeManager->addRule(rule);
+
+    routeManager->saveToFile(juce::File(tempConfigFile.string()));
+    routeManager->clearAllRules();
+    routeManager->loadFromFile(juce::File(tempConfigFile.string()));
+
+    auto rules = routeManager->getAllRules();
+    ASSERT_EQ(1u, rules.size());
+
+    const auto& loadedRule = rules[0];
+    EXPECT_EQ(localNode, loadedRule.sourceNodeId());
+    EXPECT_EQ(1, loadedRule.sourceDeviceId());
+    EXPECT_EQ(remoteNode1, loadedRule.destinationNodeId());
+    EXPECT_EQ(10, loadedRule.destinationDeviceId());
+    EXPECT_EQ(150, loadedRule.priority);
+    EXPECT_TRUE(loadedRule.enabled);
+    ASSERT_TRUE(loadedRule.channelFilter.has_value());
+    EXPECT_EQ(1, loadedRule.channelFilter->channel);
+    auto expectedFilter = NetworkMidi::MidiMessageType::NoteOn | NetworkMidi::MidiMessageType::NoteOff;
+    EXPECT_EQ(expectedFilter, loadedRule.messageTypeFilter);
+}
+
+TEST_F(RouteManagerTest, HandlesLoadFromNonExistentFile) {
+    bool loaded = routeManager->loadFromFile(juce::File("/nonexistent/path/file.json"));
+
+    EXPECT_FALSE(loaded);
+}
+
+// NOTE: Removed HandlesSaveToInvalidPath test - it's platform-specific and JUCE
+// file handling may create parent directories or handle paths differently than expected
+
+//==============================================================================
+// Thread Safety Tests
+//==============================================================================
+
+TEST_F(RouteManagerTest, HandlesConcurrentRuleAddition) {
+    std::vector<std::thread> threads;
+    std::vector<std::string> ruleIds(10);
+
+    for (int i = 0; i < 10; ++i) {
+        threads.emplace_back([this, i, &ruleIds]() {
+            // Add rules with different priorities (same destination is fine for thread safety test)
+            NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+            rule1.priority = 100 + i;
+            rule1.enabled = true;
+            ruleIds[i] = routeManager->addRule(rule1);
+        });
+    }
+
+    for (auto& thread : threads) {
+        thread.join();
+    }
+
+    auto rules = routeManager->getAllRules();
+    EXPECT_EQ(10u, rules.size());
+}
+
+TEST_F(RouteManagerTest, HandlesConcurrentRuleRemoval) {
+    // Add rules (all using same destination device for simplicity)
+    std::vector<std::string> ruleIds;
+    for (int i = 0; i < 10; ++i) {
+        NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+        rule1.priority = 100 + i;
+        rule1.enabled = true;
+        auto ruleId = routeManager->addRule(rule1);
+        ruleIds.push_back(ruleId);
+    }
+
+    // Remove concurrently
+    std::vector<std::thread> threads;
+    for (int i = 0; i < 10; ++i) {
+        threads.emplace_back([this, &ruleIds, i]() {
+            routeManager->removeRule(ruleIds[i]);
+        });
+    }
+
+    for (auto& thread : threads) {
+        thread.join();
+    }
+
+    auto rules = routeManager->getAllRules();
+    EXPECT_TRUE(rules.empty());
+}
+
+TEST_F(RouteManagerTest, HandlesConcurrentReadWrite) {
+    std::atomic<bool> running{true};
+    std::vector<std::thread> threads;
+
+    // Writer thread
+    threads.emplace_back([this, &running]() {
+        int count = 0;
+        while (running && count < 50) {
+            deviceRegistry->addRemoteDevice(remoteNode1, 100 + count,
+                "Dynamic Device " + juce::String(count), "output");
+            NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 100 + count);
+            rule1.priority = 100;
+            rule1.enabled = true;
+            routeManager->addRule(rule1);
+            count++;
+            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        }
+    });
+
+    // Reader threads
+    for (int i = 0; i < 3; ++i) {
+        threads.emplace_back([this, &running]() {
+            while (running) {
+                auto rules = routeManager->getAllRules();
+                auto destinations = routeManager->getDestinations(localNode, 1);
+                (void)rules;
+                (void)destinations;
+            }
+        });
+    }
+
+    std::this_thread::sleep_for(std::chrono::milliseconds(100));
+    running = false;
+
+    for (auto& thread : threads) {
+        thread.join();
+    }
+}
+
+//==============================================================================
+// Edge Cases and Error Handling
+//==============================================================================
+
+TEST_F(RouteManagerTest, HandlesRemoveNonExistentRule) {
+    std::string fakeId = "non-existent-id";
+    bool removed = routeManager->removeRule(fakeId);
+
+    EXPECT_FALSE(removed);
+}
+
+TEST_F(RouteManagerTest, HandlesUpdateNonExistentRule) {
+    std::string fakeId = "non-existent-id";
+    NetworkMidi::ForwardingRule rule(localNode, 1, remoteNode1, 10);
+    rule.priority = 100;
+    rule.enabled = true;
+    bool updated = routeManager->updateRule(fakeId, rule);
+
+    EXPECT_FALSE(updated);
+}
+
+TEST_F(RouteManagerTest, HandlesGetNonExistentRule) {
+    std::string fakeId = "non-existent-id";
+    auto rule = routeManager->getRule(fakeId);
+
+    EXPECT_FALSE(rule.has_value());
+}
+
+TEST_F(RouteManagerTest, HandlesEmptyChannelFilter) {
+    NetworkMidi::ForwardingRule rule(localNode, 1, remoteNode1, 10);
+    rule.priority = 100;
+    rule.enabled = true;
+    // Don't set channelFilter - it remains std::nullopt
+
+    auto ruleId = routeManager->addRule(rule);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto retrievedRule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(retrievedRule.has_value());
+    EXPECT_FALSE(retrievedRule->channelFilter.has_value());
+}
+
+TEST_F(RouteManagerTest, HandlesAllChannelsFilter) {
+    NetworkMidi::ForwardingRule rule(localNode, 1, remoteNode1, 10);
+    rule.priority = 100;
+    rule.enabled = true;
+    rule.channelFilter = NetworkMidi::ChannelFilter{0};  // All channels (0 = all)
+
+    auto ruleId = routeManager->addRule(rule);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto retrievedRule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(retrievedRule.has_value());
+    ASSERT_TRUE(retrievedRule->channelFilter.has_value());
+    EXPECT_EQ(0, retrievedRule->channelFilter->channel);
+    EXPECT_TRUE(retrievedRule->channelFilter->matchesAll());
+}
+
+TEST_F(RouteManagerTest, HandlesDuplicateRules) {
+    // Add the same rule twice
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 100;
+    rule1.enabled = true;
+    auto ruleId1 = routeManager->addRule(rule1);
+
+    NetworkMidi::ForwardingRule rule2(localNode, 1, remoteNode1, 10);
+    rule2.priority = 100;
+    rule2.enabled = true;
+    auto ruleId2 = routeManager->addRule(rule2);
+
+    // Both should succeed with different IDs
+    EXPECT_FALSE(ruleId1.empty());
+    EXPECT_FALSE(ruleId2.empty());
+    EXPECT_NE(ruleId1, ruleId2);
+
+    auto rules = routeManager->getAllRules();
+    EXPECT_EQ(2u, rules.size());
+}
+
+TEST_F(RouteManagerTest, HandlesZeroPriority) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = 0;
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto rule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(rule.has_value());
+    EXPECT_EQ(0, rule->priority);
+}
+
+TEST_F(RouteManagerTest, HandlesMaximumPriority) {
+    NetworkMidi::ForwardingRule rule1(localNode, 1, remoteNode1, 10);
+    rule1.priority = std::numeric_limits<int>::max();
+    rule1.enabled = true;
+    auto ruleId = routeManager->addRule(rule1);
+
+    EXPECT_FALSE(ruleId.empty());
+
+    auto rule = routeManager->getRule(ruleId);
+    ASSERT_TRUE(rule.has_value());
+    EXPECT_EQ(std::numeric_limits<int>::max(), rule->priority);
+}


---

_**Agent (claude-sonnet-4-5-20250929)**_

feat(midi-server): implement Phase 2 routing configuration API with persistence and HTTP endpoints

