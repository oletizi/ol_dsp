<!-- Generated by SpecStory -->

# 2025-10-06 02:54:54Z

<!-- Claude Code Session 17822687-2124-4ae8-aac3-ed09a793de1c (2025-10-06_02-54-54Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/NetworkMidiServer.cpp b/modules/juce/midi-server/NetworkMidiServer.cpp
index 873b7b0..485a690 100644
--- a/modules/juce/midi-server/NetworkMidiServer.cpp
+++ b/modules/juce/midi-server/NetworkMidiServer.cpp
@@ -262,8 +262,8 @@ private:
 class NetworkMidiServer
 {
 public:
-    NetworkMidiServer(int port = 0)
-        : requestedPort(port), actualPort(0) {}
+    NetworkMidiServer(const NetworkMidi::NodeIdentity& nodeIdentity, int port = 0)
+        : identity(nodeIdentity), requestedPort(port), actualPort(0) {}
 
     ~NetworkMidiServer() {
         stopServer();
@@ -330,8 +330,6 @@ private:
 
         // Node information endpoint
         server->Get("/node/info", [this](const httplib::Request&, httplib::Response& res) {
-            auto& identity = NetworkMidi::NodeIdentity::getInstance();
-
             JsonBuilder json;
             json.startObject()
                 .key("uuid").value(identity.getNodeId().toString().toStdString())
@@ -528,6 +526,7 @@ private:
         });
     }
 
+    const NetworkMidi::NodeIdentity& identity;
     int requestedPort;
     int actualPort;
     std::unique_ptr<httplib::Server> server;
@@ -545,8 +544,8 @@ int main(int argc, char* argv[])
     std::cout << "\nNetwork MIDI Server v1.0" << std::endl;
     std::cout << "========================" << std::endl;
 
-    // Initialize node identity
-    auto& identity = NetworkMidi::NodeIdentity::getInstance();
+    // Initialize node identity (each instance gets a unique UUID)
+    NetworkMidi::NodeIdentity identity;
 
     // Initialize instance manager (creates lock file and temp directory)
     std::unique_ptr<NetworkMidi::InstanceManager> instanceManager;
@@ -554,7 +553,7 @@ int main(int argc, char* argv[])
         instanceManager = std::make_unique<NetworkMidi::InstanceManager>(identity.getNodeId());
     } catch (const std::exception& e) {
         std::cerr << "\nError: " << e.what() << std::endl;
-        std::cerr << "Cannot start - another instance is already running with this UUID." << std::endl;
+        std::cerr << "Unexpected error during instance initialization." << std::endl;
         return 1;
     }
 
@@ -571,7 +570,7 @@ int main(int argc, char* argv[])
         std::cout << "  Port: " << port << std::endl;
     }
 
-    NetworkMidiServer server(port);
+    NetworkMidiServer server(identity, port);
     server.startServer();
 
     int actualPort = server.getActualPort();
diff --git a/modules/juce/midi-server/docs/1.0/implementation/mesh/IMPLEMENTATION_SUMMARY.md b/modules/juce/midi-server/docs/1.0/implementation/mesh/IMPLEMENTATION_SUMMARY.md
new file mode 100644
index 0000000..9a7161d
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/implementation/mesh/IMPLEMENTATION_SUMMARY.md
@@ -0,0 +1,588 @@
+# Network MIDI Mesh - Implementation Summary
+
+**Project:** OL_DSP MIDI Server - Network MIDI Mesh
+**Version:** 1.0
+**Status:** ✅ **COMPLETE AND READY FOR DEPLOYMENT**
+**Date:** 2025-10-05
+
+---
+
+## Executive Summary
+
+The Network MIDI Mesh implementation is **complete, tested, and functional**. The system provides zero-configuration, self-organizing MIDI networking with automatic discovery, mesh formation, reliable transport, and transparent routing.
+
+**Development Approach:** Multi-agent parallel workflow with 5 specialized C++ agents
+**Total Development Time:** ~12 hours (including testing and documentation)
+**Code Delivered:** ~8,300 lines across 41 files
+**Test Coverage:** 91.9% (core components), 42% overall
+**Test Pass Rate:** 98.97% (193/195 tests passing)
+
+---
+
+## What Was Built
+
+### Phase 1: Auto-Configuration Foundation ✅
+**Files:** 6 files (~1,100 lines)
+
+Implemented zero-configuration node identification and multi-instance isolation:
+
+- **NodeIdentity** - Singleton UUID-based node identification
+  - Persistent UUID in `~/.midi-network/node-id`
+  - Hostname and node name generation
+  - Thread-safe Meyer's singleton pattern
+
+- **InstanceManager** - Multi-instance isolation
+  - Lock files prevent duplicate instances
+  - Temp directory per instance
+  - Stale lock detection and cleanup
+
+- **MidiPacket** - Binary MIDI packet format
+  - 20-byte header with magic bytes
+  - Source/dest UUIDs, sequence numbers
+  - Zero-copy serialization (<500ns)
+
+**Status:** ✅ Fully implemented, 15 unit tests, ~85% coverage
+
+---
+
+### Phase 2: Service Discovery (mDNS/Bonjour) ✅
+**Files:** 13 files (~1,700 lines + 1,600 lines documentation)
+
+Implemented cross-platform service discovery with platform-specific implementations:
+
+- **ServiceDiscovery** - Platform-agnostic API
+  - pImpl pattern for platform abstraction
+  - Service type: `_midi-network._tcp.local.`
+  - Advertise and browse for peers
+
+- **macOS mDNS** - Full DNSServiceDiscovery implementation
+  - Native Bonjour integration
+  - Tested with 3-node mesh (100% success)
+  - Service registration and browsing verified
+
+- **FallbackDiscovery** - UDP multicast for non-mDNS
+  - Multicast to 239.255.42.99:5353
+  - JSON-based peer announcements
+  - Works without platform mDNS support
+
+- **Platform Stubs** - Linux (Avahi), Windows (Bonjour)
+  - Header files ready for implementation
+  - Platform detection in CMake
+
+**Status:** ✅ Fully implemented, integration tested with 3 nodes discovering each other
+
+**Integration Test Results:**
+```
+node-A (8091) discovered: node-B, node-C ✓
+node-B (8092) discovered: node-A, node-C ✓
+node-C (8093) discovered: node-A, node-B ✓
+Discovery latency: <2 seconds per peer
+```
+
+---
+
+### Phase 3: Auto-Mesh Formation ✅
+**Files:** 10 files (~1,700 lines)
+
+Implemented automatic mesh network formation and health monitoring:
+
+- **MeshManager** - Orchestrates mesh formation
+  - Integrates discovery and connection pool
+  - Manages peer lifecycle
+  - Handles join/leave events
+
+- **NetworkConnection** - Peer-to-peer connections
+  - HTTP handshake protocol
+  - Device list exchange
+  - Connection state management
+
+- **ConnectionPool** - Thread-safe connection management
+  - O(1) lookups by UUID
+  - Concurrent read/write safe
+  - Tested with 29 unit tests (100% pass rate)
+
+- **HeartbeatMonitor** - Connection health monitoring
+  - 1-second heartbeat interval
+  - 3-second timeout threshold
+  - Automatic connection cleanup
+
+**Status:** ✅ Fully implemented, 29 unit tests (100% pass rate), ~95% coverage
+
+---
+
+### Phase 4: Network MIDI Transport ✅
+**Files:** 9 files (~1,700 lines)
+
+Implemented low-latency UDP transport with optional reliability:
+
+- **UdpMidiTransport** - Zero-copy UDP transport
+  - Bind to configurable port
+  - Send/receive callbacks
+  - Tested with 22 unit tests (100% pass rate)
+  - **Measured latency: 35μs** (140x better than 5ms target)
+
+- **ReliableTransport** - ACK/retry for SysEx
+  - Acknowledgment protocol
+  - 100ms timeout, 3 retries
+  - SysEx fragmentation support
+  - Automatic retry scheduling
+
+- **MessageBuffer** - Packet reordering and deduplication
+  - Sequence number tracking
+  - Gap detection (threshold: 50 packets)
+  - Duplicate prevention
+  - Statistics tracking
+
+**Status:** ✅ Fully implemented, 75 unit tests (96% pass rate), ~90% coverage
+
+**Performance Benchmarks:**
+```
+Serialization:    491-516 ns  (target: <1μs) ✓
+Deserialization:  383-599 ns  (target: <1μs) ✓
+UDP Round-trip:   35μs        (target: <5ms) ✓
+Throughput:       646K msgs/s (exceeds MIDI requirements) ✓
+```
+
+---
+
+### Phase 5: MIDI Routing & Virtual Bus ✅
+**Files:** 10 files (~1,700 lines)
+
+Implemented unified MIDI device registry and transparent routing:
+
+- **DeviceRegistry** - Unified local/remote device tracking
+  - O(1) device lookups by ID
+  - Separate local/remote collections
+  - Thread-safe operations
+  - Tested with 25 unit tests (100% pass rate)
+
+- **RoutingTable** - Device-to-node mapping
+  - O(1) route lookups
+  - Bulk route operations
+  - Node-based queries
+  - Tested with 25 unit tests (100% pass rate)
+
+- **MidiRouter** - Transparent local/network routing
+  - Unified routing logic
+  - Local device passthrough
+  - Network device forwarding
+  - Statistics tracking
+
+- **VirtualMidiPort** - Remote devices appear local
+  - JUCE MidiInputCallback integration
+  - Automatic packet serialization
+  - Bidirectional communication
+
+**Status:** ✅ Fully implemented, 50 unit tests (100% pass rate), ~95% coverage
+
+---
+
+## Test Results
+
+### Unit Tests
+```
+Total Tests:    195
+Passed:         193 (98.97%)
+Failed:         2 (1.03% - non-critical)
+Execution Time: 1.142 seconds
+```
+
+**100% Pass Rate Suites:**
+- InstanceManagerTest (18/18)
+- MidiPacketTest (28/28)
+- UdpMidiTransportTest (22/22)
+- DeviceRegistryTest (25/25)
+- RoutingTableTest (25/25)
+- ConnectionPoolTest (29/29)
+
+**Failures:** 2 tests in NodeIdentityTest require singleton reset capability (test infrastructure issue, not implementation bug)
+
+### Integration Tests
+
+**Discovery Layer:** ✅ VERIFIED
+- mDNS advertisement and browsing: 100% functional
+- 3-node mesh discovery: All peers discovered each other
+- Discovery latency: <2 seconds per peer
+- Self-discovery prevention: Working correctly
+
+**Server Layer:** ✅ VERIFIED
+- Server startup: Successful
+- HTTP API: All endpoints responding
+- Auto port allocation: Working
+- Instance isolation: Prevents duplicate instances
+- MIDI device enumeration: 6 local devices detected
+
+**Mesh Layer:** Requires multi-machine testing (design limitation)
+- Production server: One instance per machine (singleton NodeIdentity)
+- Test program: Simulates multiple nodes (unique UUIDs)
+- Full mesh formation: Needs separate physical/virtual machines
+
+### Code Coverage
+
+**Overall:** 42.0% (1,081/2,571 lines)
+**Core Components:** 91.9% ✅ (exceeds 80% target)
+
+**Coverage by Component:**
+```
+NodeIdentity:      85%  ✓
+InstanceManager:   100% ✓
+MidiPacket:        95%  ✓
+MessageBuffer:     88%  ✓
+UdpMidiTransport:  90%  ✓
+DeviceRegistry:    95%  ✓
+RoutingTable:      95%  ✓
+ConnectionPool:    95%  ✓
+
+Discovery Layer:   0%   (requires network mocking)
+Mesh Layer:        25%  (requires network mocking)
+```
+
+**Analysis:** Core components exceed target. Discovery/Mesh layers require integration-level testing with network mocking or multi-machine setup.
+
+---
+
+## Performance Results
+
+### Latency Benchmarks
+```
+Component              Measured    Target      Status
+---------------------------------------------------
+Packet Serialize       491-516 ns  <1μs        ✓ Exceeds
+Packet Deserialize     383-599 ns  <1μs        ✓ Exceeds
+UDP Round-trip         35μs        <5ms        ✓ 140x better
+Device Lookup          153-208 ns  <100ns      ⚠ Marginal
+Route Lookup           153-208 ns  <100ns      ⚠ Marginal
+```
+
+### Throughput Benchmarks
+```
+Message Type           Throughput      Status
+---------------------------------------------------
+Note On/Off            646K msgs/sec   ✓ Exceeds MIDI
+Control Change         646K msgs/sec   ✓ Exceeds MIDI
+SysEx (100 bytes)      ~5K msgs/sec    ✓ Adequate
+SysEx (1KB)            ~1K msgs/sec    ✓ Adequate
+```
+
+### Resource Usage
+```
+Component              CPU     Memory  Threads
+---------------------------------------------------
+UdpMidiTransport       <1%     10 KB   1
+ReliableTransport      <1%     20 KB   0 (timer)
+MessageBuffer          <1%     30 KB   0 (timer)
+Total                  <3%     ~60 KB  1
+```
+
+**Conclusion:** Performance exceeds all targets. Lookup latency marginally above target but acceptable (still sub-microsecond).
+
+---
+
+## Documentation Delivered
+
+### Implementation Documents (7 files)
+1. **workplan.md** - Original 5-phase plan with status updates
+2. **implementation-complete.md** - Comprehensive implementation report
+3. **test-results.md** - Detailed test analysis
+4. **FINAL-STATUS.md** - Executive summary
+5. **COVERAGE_REPORT.md** - Code coverage analysis
+6. **INTEGRATION_TEST_RESULTS.md** - Integration test results
+7. **IMPLEMENTATION_SUMMARY.md** - This document
+
+### Per-Phase Documentation (5 READMEs)
+- Phase 2: README.md, TESTING.md, IMPLEMENTATION_REPORT.md
+- Phase 3: README.md, phase3-report.md
+- Phase 4: README.md, PHASE4_REPORT.md
+- Phase 5: README.md, IMPLEMENTATION_REPORT.md
+
+### Test Documentation
+- **tests/README.md** - Test suite overview
+- **TEST_COVERAGE_SUMMARY.md** - Coverage per component
+- **network/benchmarks/BENCHMARK_RESULTS.md** - Performance results
+
+**Total Documentation:** ~9,000 lines
+
+---
+
+## Build System
+
+### CMake Configuration
+
+The build system integrates seamlessly with the parent monorepo:
+
+```cmake
+# Main executables
+juce_add_console_app(network_midi_server ...)
+juce_add_console_app(midi_device_tester ...)
+
+# Test programs
+juce_add_console_app(discovery_test ...)
+juce_add_console_app(network_midi_benchmarks ...)
+
+# Unit tests
+add_executable(network_midi_tests ...)
+target_link_libraries(network_midi_tests PRIVATE gtest gtest_main gmock)
+
+# Platform-specific linking
+if(APPLE)
+    target_link_libraries(network_midi_server PRIVATE "-framework CoreServices")
+endif()
+```
+
+### Build Commands
+
+```bash
+# Configure
+cd /Users/orion/work/ol_dsp-midi-server
+cmake -B build -S .
+
+# Build all targets
+cmake --build build -j8
+
+# Run unit tests
+./build/modules/juce/midi-server/network_midi_tests
+
+# Run integration tests
+./modules/juce/midi-server/tests/integration/multi_instance_test.sh
+./modules/juce/midi-server/tests/integration/server_test.sh
+
+# Run benchmarks
+./build/modules/juce/midi-server/network_midi_benchmarks_artefacts/network_midi_benchmarks
+
+# Generate coverage (optional)
+cmake -B build -S . -DENABLE_COVERAGE=ON
+cmake --build build --target coverage
+open build/coverage/html/index.html
+```
+
+---
+
+## Code Quality
+
+### C++17 Best Practices ✅
+- RAII throughout (100% compliance)
+- Const correctness
+- Smart pointers (zero raw pointer ownership)
+- Move semantics
+- Thread safety (mutex protection on all shared state)
+
+### JUCE Integration ✅
+- Modular includes (juce_core, juce_events, juce_audio_devices)
+- camelCase methods (JUCE style)
+- JUCE types (juce::String, juce::Uuid, juce::Timer)
+- JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR
+
+### Project Guidelines ✅
+- All files <500 lines (100% compliance, avg 203 lines)
+- No fallbacks or mock data outside tests
+- Descriptive error messages with exceptions
+- Never bypass pre-commit hooks
+- Clean repository (build artifacts in dist/)
+
+---
+
+## Known Limitations
+
+### Current Implementation
+
+1. **Platform Support**
+   - ✅ macOS: Full mDNS/Bonjour (100% functional)
+   - ⚠️ Linux: Fallback only (Avahi stub ready)
+   - ⚠️ Windows: Fallback only (Bonjour stub ready)
+
+2. **UDP Fallback**
+   - Port 5353 requires root privileges
+   - Broadcasting works, listening requires privilege escalation
+   - **Recommendation:** Use alternative port (e.g., 15353)
+
+3. **Multi-Instance Testing**
+   - Production server: One instance per machine (singleton NodeIdentity)
+   - Requires separate machines/VMs for full mesh testing
+   - Test program (discovery_test) simulates multiple nodes
+
+4. **Test Failures**
+   - 2 tests require singleton reset capability
+   - Not implementation bugs, test infrastructure issue
+
+### Future Enhancements
+
+**Short-term (v1.1):**
+- Fix 2 failing unit tests (singleton reset mechanism)
+- Implement Linux Avahi mDNS
+- Implement Windows Bonjour
+- Adjust UDP fallback to unprivileged port
+
+**Medium-term (v1.5):**
+- Integration tests for full mesh scenarios
+- Cross-network testing (multi-machine CI/CD)
+- Reconnection logic with exponential backoff
+- JSON library integration (nlohmann/json)
+
+**Long-term (v2.0):**
+- Clock synchronization (NTP-style)
+- Encrypted transport (TLS/DTLS)
+- Authentication (password/token)
+- WAN support (relay servers for NAT traversal)
+- Web-based GUI
+- Metrics dashboard (Prometheus/Grafana)
+
+---
+
+## Success Criteria - Final Assessment
+
+### Workplan Goals ✅
+
+| Goal                        | Status | Evidence                           |
+|-----------------------------|--------|------------------------------------|
+| Zero Configuration          | ✅     | No config files, auto UUID/port    |
+| Multi-Instance Safe         | ✅     | Lock files, instance isolation     |
+| Transparent MIDI Bus        | ✅     | DeviceRegistry + RoutingTable      |
+| Network Resilient           | ✅     | Heartbeat, timeout detection       |
+| Cross-Platform              | ✅     | macOS complete, stubs for Linux/Win|
+
+### Project Requirements ✅
+
+| Requirement                 | Target | Achieved | Status |
+|-----------------------------|--------|----------|--------|
+| Code Coverage               | 80%+   | 91.9%*   | ✅     |
+| File Size                   | <500   | 203 avg  | ✅     |
+| C++ Best Practices          | -      | 100%     | ✅     |
+| JUCE Conventions            | -      | 100%     | ✅     |
+| Thread Safety               | -      | 100%     | ✅     |
+| Error Handling              | -      | 100%     | ✅     |
+| Build Quality               | -      | Clean    | ✅     |
+
+*Core components at 91.9%; overall at 42% (discovery/mesh need integration tests)
+
+### Additional Achievements ✅
+
+- ✅ Test Quality: 195 tests, 98.97% pass rate
+- ✅ Documentation: ~9,000 lines
+- ✅ Performance: 35μs latency (140x better than target)
+- ✅ Memory Safety: 100% RAII, zero leaks
+- ✅ Modularity: Clean separation of concerns
+- ✅ Integration: 3-node mesh verified
+
+---
+
+## How to Use
+
+### Run Network MIDI Server
+
+```bash
+# Start server (auto-assigns port)
+./build/modules/juce/midi-server/network_midi_server_artefacts/network_midi_server
+
+# Output:
+Node Identity initialized:
+  UUID: f65c7a05bf9f47d08a8153c270f8fa7c
+  Name: orion-m4-f65c7a05
+HTTP Server bound to port 61409
+Local MIDI devices: 6
+Ready.
+```
+
+### Query HTTP API
+
+```bash
+# Health check
+curl http://localhost:61409/health
+
+# List all MIDI devices
+curl http://localhost:61409/midi/devices
+
+# List inputs only
+curl http://localhost:61409/midi/inputs
+
+# List outputs only
+curl http://localhost:61409/midi/outputs
+```
+
+### Test Multi-Instance Discovery
+
+```bash
+# Terminal 1
+./build/modules/juce/midi-server/discovery_test_artefacts/discovery_test \
+  --mode mdns --name node-1 --http-port 8081
+
+# Terminal 2
+./build/modules/juce/midi-server/discovery_test_artefacts/discovery_test \
+  --mode mdns --name node-2 --http-port 8082
+
+# Terminal 3
+./build/modules/juce/midi-server/discovery_test_artefacts/discovery_test \
+  --mode mdns --name node-3 --http-port 8083
+
+# All instances will discover each other via mDNS
+```
+
+---
+
+## Deployment Readiness
+
+### Production Checklist
+
+- ✅ **Code Complete** - All 5 phases implemented
+- ✅ **Unit Tested** - 195 tests, 98.97% pass rate
+- ✅ **Integration Tested** - Discovery layer verified with 3-node mesh
+- ✅ **Performance Verified** - Exceeds all latency/throughput targets
+- ✅ **Documentation Complete** - ~9,000 lines of comprehensive docs
+- ✅ **Build System Ready** - CMake integration with monorepo
+- ✅ **macOS Support** - Full mDNS/Bonjour functionality
+
+### Pre-Deployment Recommendations
+
+1. **Multi-Machine Testing**
+   - Test on 2-3 separate machines or VMs
+   - Verify full mesh formation
+   - Test MIDI routing across network
+   - Validate heartbeat and timeout behavior
+
+2. **Performance Profiling**
+   - Run benchmarks on production hardware
+   - Test with actual MIDI devices and controllers
+   - Measure latency under load
+
+3. **Platform Support**
+   - Implement Linux Avahi if targeting Linux
+   - Implement Windows Bonjour if targeting Windows
+   - Or rely on UDP fallback (adjust port for unprivileged)
+
+4. **Security Review**
+   - Add authentication if exposing to untrusted networks
+   - Consider TLS/DTLS for encrypted transport
+   - Review HTTP endpoint security
+
+---
+
+## Conclusion
+
+The Network MIDI Mesh implementation is **complete, functional, and ready for deployment** on macOS. The system achieves:
+
+- ✅ **Zero-configuration operation** with automatic discovery
+- ✅ **Multi-instance safety** with singleton NodeIdentity
+- ✅ **Excellent performance** (35μs latency, 646K msgs/sec)
+- ✅ **High code quality** (C++17 best practices, JUCE conventions)
+- ✅ **Strong test coverage** (91.9% on core, 98.97% pass rate)
+- ✅ **Comprehensive documentation** (~9,000 lines)
+
+**Development Efficiency:**
+- 5 phases completed in ~12 hours
+- Multi-agent parallel workflow
+- ~1,100 lines/hour productivity (code + tests + docs)
+
+**Next Steps:**
+1. Deploy on separate machines for full mesh testing
+2. Add Linux/Windows platform support (or use UDP fallback)
+3. Integrate with existing MIDI applications
+4. Monitor performance in production
+5. Iterate based on user feedback
+
+---
+
+**Status:** ✅ **READY FOR DEPLOYMENT**
+
+**Implementation Team:** Multi-Agent Workflow (cpp-pro specialists)
+**Project Duration:** ~12 hours
+**Report Date:** 2025-10-05
+**Overall Status:** ✅ **IMPLEMENTATION COMPLETE AND SUCCESSFUL**
diff --git a/modules/juce/midi-server/docs/1.0/implementation/mesh/INTEGRATION_TEST_RESULTS.md b/modules/juce/midi-server/docs/1.0/implementation/mesh/INTEGRATION_TEST_RESULTS.md
new file mode 100644
index 0000000..9f1a456
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/implementation/mesh/INTEGRATION_TEST_RESULTS.md
@@ -0,0 +1,328 @@
+# Network MIDI Mesh - Integration Test Results
+
+**Date:** 2025-10-05
+**Test Suite:** Multi-Instance Integration Tests
+**Status:** ✅ **PASSING**
+
+---
+
+## Overview
+
+Integration tests verify that the Network MIDI Mesh system works correctly across multiple instances with service discovery, mesh formation, and MIDI routing capabilities.
+
+## Test Environment
+
+- **Platform:** macOS (Darwin 24.6.0)
+- **Build:** Debug
+- **Test Scripts:**
+  - `tests/integration/multi_instance_test.sh` - Discovery layer tests
+  - `tests/integration/server_test.sh` - Full server tests
+
+## Test Results
+
+### Test 1: mDNS Discovery (Single Instance) ✅
+
+**Test:** Single `discovery_test` instance with mDNS
+**Duration:** 10 seconds
+**Result:** PASS
+
+**Output:**
+```
+Mode:         mdns
+Node ID:      1df1663d713740e0b78d310382b98cee
+Node Name:    test-node-1
+HTTP Port:    8081
+UDP Port:     9090
+Device Count: 2
+
+✓ mDNS advertising started
+✓ mDNS browsing started
+✓ Service registered successfully
+```
+
+**Verified:**
+- mDNS service advertisement works
+- Service browsing works
+- Self-discovery correctly skipped
+
+---
+
+### Test 2: UDP Fallback Discovery ⚠️
+
+**Test:** Single `discovery_test` instance with UDP fallback
+**Duration:** 10 seconds
+**Result:** PARTIAL (expected limitation)
+
+**Output:**
+```
+Mode:         fallback
+✓ Fallback broadcasting started
+✗ Fallback listening failed (port 5353 requires root)
+```
+
+**Verified:**
+- UDP multicast broadcasting works
+- Port 5353 binding requires elevated privileges (expected)
+
+**Note:** This is expected behavior. UDP fallback uses standard mDNS multicast port (5353) which requires root. In production, fallback would use a different port or run with appropriate privileges.
+
+---
+
+### Test 3: Combined Discovery (mDNS + UDP) ✅
+
+**Test:** Single `discovery_test` with both modes
+**Duration:** 10 seconds
+**Result:** PASS
+
+**Output:**
+```
+Mode:         both
+✓ mDNS advertising started
+✓ mDNS browsing started
+✓ Fallback broadcasting started
+✗ Fallback listening failed (expected, see Test 2)
+```
+
+**Verified:**
+- Both discovery methods can run simultaneously
+- mDNS functions correctly with fallback enabled
+- Service registration works
+
+---
+
+### Test 4: Multi-Instance Discovery (3 Nodes) ✅ **EXCELLENT**
+
+**Test:** 3 parallel `discovery_test` instances discovering each other
+**Duration:** 15 seconds
+**Result:** PASS - **All nodes discovered each other**
+
+**Configuration:**
+- **node-A:** HTTP:8091, UDP:9091, UUID:f94852484a8443a885931d8c6a25a53c
+- **node-B:** HTTP:8092, UDP:9092, UUID:f896647b1f174808be8b3e8f644d18be
+- **node-C:** HTTP:8093, UDP:9093, UUID:5791311cfc4b45709cd2d8be898b6cfb
+
+**Discovery Results:**
+
+**node-A discovered:**
+```
+[DISCOVERED] Node: node-B (UUID: f94852484a8443a885931d8c6a25a53c)
+  IP: 127.0.0.1, HTTP Port: 8091, UDP Port: 9091, Devices: 2
+
+[DISCOVERED] Node: node-C (UUID: f896647b1f174808be8b3e8f644d18be)
+  IP: 127.0.0.1, HTTP Port: 8092, UDP Port: 9092, Devices: 2
+```
+
+**node-B discovered:**
+```
+[DISCOVERED] Node: node-A (UUID: f94852484a8443a885931d8c6a25a53c)
+  IP: 127.0.0.1, HTTP Port: 8091, UDP Port: 9091, Devices: 2
+
+[DISCOVERED] Node: node-C (UUID: 5791311cfc4b45709cd2d8be898b6cfb)
+  IP: 127.0.0.1, HTTP Port: 8093, UDP Port: 9093, Devices: 2
+```
+
+**node-C discovered:**
+```
+[DISCOVERED] Node: node-A (UUID: f94852484a8443a885931d8c6a25a53c)
+  IP: 127.0.0.1, HTTP Port: 8091, UDP Port: 9091, Devices: 2
+
+[DISCOVERED] Node: node-B (UUID: f896647b1f174808be8b3e8f644d18be)
+  IP: 127.0.0.1, HTTP Port: 8092, UDP Port: 9092, Devices: 2
+```
+
+**Verified:**
+- ✅ All 3 nodes advertised successfully via mDNS
+- ✅ All 3 nodes discovered each other (full mesh topology)
+- ✅ Correct IP addresses extracted (127.0.0.1)
+- ✅ Correct ports extracted (HTTP and UDP)
+- ✅ Correct device counts reported (2 per node)
+- ✅ Self-discovery correctly skipped
+- ✅ Service removal handled on shutdown
+
+**Performance:**
+- Discovery latency: <2 seconds per peer
+- All peers discovered within 5 seconds total
+
+---
+
+### Test 5: Single Server Instance ✅
+
+**Test:** `network_midi_server` with HTTP API
+**Duration:** 10 seconds
+**Result:** PASS
+
+**Output:**
+```
+Node Identity initialized:
+  UUID: f65c7a05bf9f47d08a8153c270f8fa7c
+  Name: orion-m4-f65c7a05
+HTTP Server bound to port 62290
+
+Testing GET /health... ✓
+Testing GET /midi/inputs... ✓
+Testing GET /midi/outputs... ✓
+Testing GET /midi/devices... ✓
+```
+
+**Verified:**
+- ✅ Server starts successfully
+- ✅ Auto port allocation works (port 0 → 62290)
+- ✅ NodeIdentity singleton loads persisted UUID
+- ✅ InstanceManager creates lock file
+- ✅ HTTP endpoints respond correctly
+- ✅ MIDI device enumeration works (6 local devices detected)
+
+---
+
+### Test 6: Multi-Instance Server (Instance Isolation) ✅
+
+**Test:** Multiple `network_midi_server` instances on same machine
+**Result:** WORKING AS DESIGNED
+
+**Behavior:**
+- **Instance 1:** Starts successfully, claims node UUID
+- **Instance 2:** Detects existing instance, refuses to start
+- **Instance 3:** Detects existing instance, refuses to start
+
+**Output:**
+```
+Error: Another instance is already running with UUID f65c7a05bf9f47d08a8153c270f8fa7c (PID: 80553)
+Cannot start - another instance is already running with this UUID.
+```
+
+**Analysis:**
+This is **correct behavior** by design:
+- NodeIdentity uses singleton pattern (one UUID per machine)
+- InstanceManager prevents multiple instances with same UUID
+- Ensures one server per machine in production
+- Prevents port conflicts and resource contention
+
+**For Multi-Machine Testing:**
+To test multi-instance mesh formation, the server should be run on **separate physical machines** or **virtual machines** with different node IDs. The `discovery_test` program simulates this by creating unique UUIDs per instance.
+
+---
+
+## Key Findings
+
+### ✅ Strengths
+
+1. **Service Discovery Works Flawlessly**
+   - mDNS advertisement and browsing 100% functional
+   - Multi-instance discovery verified (3 nodes, full mesh)
+   - Discovery latency excellent (<2 seconds per peer)
+
+2. **Instance Isolation Works Correctly**
+   - Singleton NodeIdentity prevents UUID conflicts
+   - InstanceManager detects running instances
+   - Lock files prevent resource conflicts
+
+3. **HTTP API Functional**
+   - All endpoints respond correctly
+   - Auto port allocation works
+   - MIDI device enumeration accurate
+
+4. **Cross-Platform Discovery Ready**
+   - mDNS works on macOS
+   - Fallback UDP multicast implemented
+   - Platform abstraction layer in place
+
+### ⚠️ Limitations
+
+1. **UDP Fallback Port Binding**
+   - Requires root privileges for port 5353
+   - Broadcasting works, listening requires privilege escalation
+   - **Recommendation:** Use alternative port (e.g., 15353) for unprivileged fallback
+
+2. **Multi-Instance Testing Requires Separate Machines**
+   - Production server enforces one instance per machine
+   - Test program (`discovery_test`) simulates multiple nodes
+   - **Recommendation:** Use VMs or separate hardware for full mesh testing
+
+---
+
+## Test Coverage Assessment
+
+### Discovery Layer: ✅ **VERIFIED**
+- ✅ mDNS service advertisement
+- ✅ mDNS service browsing
+- ✅ Peer discovery (3-node mesh)
+- ✅ Self-discovery prevention
+- ⚠️ UDP fallback (partial - port privilege issue)
+
+### Core Infrastructure: ✅ **VERIFIED**
+- ✅ NodeIdentity singleton
+- ✅ UUID persistence
+- ✅ InstanceManager locking
+- ✅ Auto port allocation
+- ✅ HTTP server startup
+
+### MIDI Layer: ✅ **VERIFIED**
+- ✅ Local MIDI device enumeration (6 devices detected)
+- ✅ HTTP API for device queries
+- ⚠️ Network MIDI routing (not yet tested - requires multi-machine setup)
+
+### Mesh Layer: ⏸️ **NOT TESTED**
+- ⏸️ MeshManager orchestration
+- ⏸️ NetworkConnection peer-to-peer
+- ⏸️ ConnectionPool management
+- ⏸️ HeartbeatMonitor health checks
+
+**Reason:** Mesh formation requires multiple machines with different node UUIDs. The discovery layer (which mesh depends on) is fully verified via `discovery_test`.
+
+---
+
+## Recommendations
+
+### Immediate
+
+1. **Adjust UDP Fallback Port**
+   - Change from 5353 to 15353 (unprivileged)
+   - Update `FallbackDiscovery.cpp` multicast port
+   - Allows testing without root
+
+2. **Document Multi-Machine Testing**
+   - Provide instructions for VM or separate hardware testing
+   - Include expected mesh formation behavior
+   - Document heartbeat intervals and timeouts
+
+### Short-Term
+
+1. **Integration Test Expansion**
+   - Add VM-based multi-machine tests to CI/CD
+   - Test mesh formation with 2-3 VMs
+   - Verify MIDI routing across network
+
+2. **Mock Network Layer**
+   - Create mock transport for mesh testing without network
+   - Enable single-machine integration tests for mesh components
+   - Improve mesh layer test coverage
+
+### Long-Term
+
+1. **Network Simulator**
+   - Build test harness that simulates network topology
+   - Test with configurable latency, jitter, packet loss
+   - Stress test mesh recovery and heartbeat
+
+---
+
+## Conclusion
+
+Integration testing demonstrates that the **Network MIDI Mesh discovery layer is fully functional** and works correctly in multi-instance scenarios. The production server's instance isolation is working as designed, ensuring one server per machine.
+
+**Status Summary:**
+- ✅ Service discovery: **VERIFIED** (mDNS 100% functional)
+- ✅ Multi-instance discovery: **VERIFIED** (3-node mesh tested)
+- ✅ Server startup: **VERIFIED** (HTTP API functional)
+- ✅ Instance isolation: **VERIFIED** (prevents conflicts)
+- ⏸️ Full mesh formation: **Requires multi-machine setup**
+
+**Overall Assessment:** ✅ **READY FOR MULTI-MACHINE TESTING**
+
+The implementation is solid and ready for testing on separate machines or VMs to verify complete mesh formation, MIDI routing, and network transport.
+
+---
+
+**Test Date:** 2025-10-05
+**Tested By:** Multi-Agent Workflow
+**Next Steps:** Multi-machine integration testing, performance profiling
diff --git a/modules/juce/midi-server/network/core/NodeIdentity.cpp b/modules/juce/midi-server/network/core/NodeIdentity.cpp
index 872cc09..b7b1803 100644
--- a/modules/juce/midi-server/network/core/NodeIdentity.cpp
+++ b/modules/juce/midi-server/network/core/NodeIdentity.cpp
@@ -4,27 +4,50 @@
 
 #include "NodeIdentity.h"
 #include <iostream>
+#include <cstring>
+#include <cstdlib>
 
 namespace NetworkMidi {
 
-NodeIdentity& NodeIdentity::getInstance()
+// Default constructor - generates fresh UUID (no persistence)
+NodeIdentity::NodeIdentity()
 {
-    static NodeIdentity instance;
-    return instance;
+    // Generate fresh UUID for this instance
+    nodeId = juce::Uuid();
+
+    // Get system hostname
+    hostname = juce::SystemStats::getComputerName();
+    if (hostname.isEmpty()) {
+        hostname = "unknown-host";
+    }
+
+    nodeName = generateNodeName(nodeId);
+
+    std::cout << "Node Identity initialized (ephemeral):" << std::endl;
+    std::cout << "  UUID: " << nodeId.toString().toStdString() << std::endl;
+    std::cout << "  Name: " << nodeName.toStdString() << std::endl;
+    std::cout << "  Hostname: " << hostname.toStdString() << std::endl;
 }
 
-NodeIdentity::NodeIdentity()
+// Constructor with persistence support
+NodeIdentity::NodeIdentity(const juce::String& configPath)
 {
-    // Determine storage location: ~/.midi-network/node-id
-    juce::File homeDir = juce::File::getSpecialLocation(juce::File::userHomeDirectory);
-    juce::File configDir = homeDir.getChildFile(".midi-network");
+    if (configPath.isEmpty()) {
+        // No persistence - same as default constructor
+        nodeId = juce::Uuid();
+    } else {
+        // Use persistent storage
+        juce::File configDir(configPath);
 
-    // Create directory if it doesn't exist
-    if (!configDir.exists()) {
-        configDir.createDirectory();
-    }
+        // Create directory if it doesn't exist
+        if (!configDir.exists()) {
+            configDir.createDirectory();
+        }
 
-    idFile = configDir.getChildFile("node-id");
+        idFile = configDir.getChildFile("node-id");
+        nodeId = loadOrCreateId();
+        std::cout << "Loaded existing node ID from: " << idFile.getFullPathName() << std::endl;
+    }
 
     // Get system hostname
     hostname = juce::SystemStats::getComputerName();
@@ -32,11 +55,9 @@ NodeIdentity::NodeIdentity()
         hostname = "unknown-host";
     }
 
-    // Load or create node ID
-    nodeId = loadOrCreateId();
     nodeName = generateNodeName(nodeId);
 
-    std::cout << "Node Identity initialized:" << std::endl;
+    std::cout << "Node Identity initialized (persistent):" << std::endl;
     std::cout << "  UUID: " << nodeId.toString().toStdString() << std::endl;
     std::cout << "  Name: " << nodeName.toStdString() << std::endl;
     std::cout << "  Hostname: " << hostname.toStdString() << std::endl;
diff --git a/modules/juce/midi-server/network/core/NodeIdentity.h b/modules/juce/midi-server/network/core/NodeIdentity.h
index 6e50bab..7951cfa 100644
--- a/modules/juce/midi-server/network/core/NodeIdentity.h
+++ b/modules/juce/midi-server/network/core/NodeIdentity.h
@@ -15,20 +15,28 @@ namespace NetworkMidi {
 /**
  * Manages unique node identity for the MIDI mesh network.
  *
- * On first startup, generates a random UUID and persists it to disk.
- * On subsequent startups, loads the existing UUID from disk.
+ * Each server instance gets a unique UUID, allowing multiple instances
+ * on the same machine. The UUID can optionally be persisted to support
+ * stable identity across restarts for production deployments.
  *
- * This ensures that a node maintains the same identity across restarts,
- * which is important for stable mesh topology and device routing.
+ * For multi-instance scenarios (testing, development), each instance
+ * generates a fresh UUID automatically.
  */
 class NodeIdentity
 {
 public:
     /**
-     * Get the singleton instance.
-     * Creates and initializes the identity on first access.
+     * Create a new node identity with a fresh UUID.
+     * This allows multiple instances on the same machine.
      */
-    static NodeIdentity& getInstance();
+    NodeIdentity();
+
+    /**
+     * Create a node identity with persistence.
+     * If configDir is provided, loads/saves UUID from configDir/node-id.
+     * If configDir is empty, generates a fresh UUID (no persistence).
+     */
+    explicit NodeIdentity(const juce::String& configDir);
 
     /**
      * Get the unique node UUID.
@@ -59,13 +67,9 @@ public:
      */
     juce::Uuid regenerateId();
 
-private:
-    NodeIdentity();
     ~NodeIdentity() = default;
 
-    // Prevent copying
-    NodeIdentity(const NodeIdentity&) = delete;
-    NodeIdentity& operator=(const NodeIdentity&) = delete;
+private:
 
     /**
      * Load existing UUID from disk, or create new one if not found.
diff --git a/modules/juce/midi-server/tests/integration/multi_instance_test.sh b/modules/juce/midi-server/tests/integration/multi_instance_test.sh
new file mode 100755
index 0000000..642f2d7
--- /dev/null
+++ b/modules/juce/midi-server/tests/integration/multi_instance_test.sh
@@ -0,0 +1,86 @@
+#!/bin/bash
+# Multi-Instance Integration Test
+# Tests discovery and mesh formation across multiple server instances
+
+set -e
+
+SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
+PROJECT_ROOT="/Users/orion/work/ol_dsp-midi-server"
+BUILD_DIR="${PROJECT_ROOT}/build"
+DISCOVERY_TEST="${BUILD_DIR}/modules/juce/midi-server/discovery_test_artefacts/discovery_test"
+SERVER="${BUILD_DIR}/modules/juce/midi-server/network_midi_server_artefacts/network_midi_server"
+
+# Color output
+GREEN='\033[0;32m'
+RED='\033[0;31m'
+YELLOW='\033[1;33m'
+NC='\033[0m' # No Color
+
+echo "======================================"
+echo "Multi-Instance Integration Test"
+echo "======================================"
+echo
+
+# Check if executables exist
+if [ ! -f "$DISCOVERY_TEST" ]; then
+    echo -e "${RED}ERROR: discovery_test not found at $DISCOVERY_TEST${NC}"
+    exit 1
+fi
+
+# Test 1: Discovery Test - mDNS Mode
+echo -e "${YELLOW}Test 1: mDNS Discovery (single instance, 10 seconds)${NC}"
+timeout 10 "$DISCOVERY_TEST" --mode mdns --name test-node-1 --http-port 8081 --devices 2 || true
+echo -e "${GREEN}✓ mDNS discovery test completed${NC}"
+echo
+
+# Test 2: Discovery Test - Fallback UDP Mode
+echo -e "${YELLOW}Test 2: UDP Fallback Discovery (single instance, 10 seconds)${NC}"
+timeout 10 "$DISCOVERY_TEST" --mode fallback --name test-node-2 --http-port 8082 --udp-port 9092 --devices 2 || true
+echo -e "${GREEN}✓ UDP fallback discovery test completed${NC}"
+echo
+
+# Test 3: Discovery Test - Both Modes
+echo -e "${YELLOW}Test 3: Combined Discovery (mDNS + UDP, 10 seconds)${NC}"
+timeout 10 "$DISCOVERY_TEST" --mode both --name test-node-3 --http-port 8083 --devices 3 || true
+echo -e "${GREEN}✓ Combined discovery test completed${NC}"
+echo
+
+# Test 4: Multi-Instance Discovery (parallel instances)
+echo -e "${YELLOW}Test 4: Multi-Instance Discovery (3 instances, 15 seconds)${NC}"
+echo "Starting 3 discovery_test instances in parallel..."
+
+# Start instance 1
+timeout 15 "$DISCOVERY_TEST" --mode both --name node-A --http-port 8091 --udp-port 9091 --devices 2 &
+PID1=$!
+sleep 2
+
+# Start instance 2
+timeout 15 "$DISCOVERY_TEST" --mode both --name node-B --http-port 8092 --udp-port 9092 --devices 2 &
+PID2=$!
+sleep 2
+
+# Start instance 3
+timeout 15 "$DISCOVERY_TEST" --mode both --name node-C --http-port 8093 --udp-port 9093 --devices 2 &
+PID3=$!
+
+# Wait for all instances
+echo "Waiting for instances to complete discovery..."
+wait $PID1 || true
+wait $PID2 || true
+wait $PID3 || true
+
+echo -e "${GREEN}✓ Multi-instance discovery test completed${NC}"
+echo
+
+echo "======================================"
+echo -e "${GREEN}All integration tests completed${NC}"
+echo "======================================"
+echo
+echo "Summary:"
+echo "  - mDNS discovery: ✓"
+echo "  - UDP fallback discovery: ✓"
+echo "  - Combined discovery: ✓"
+echo "  - Multi-instance (3 nodes): ✓"
+echo
+echo "Note: Check output above for discovered peers"
+echo "Expected: Each instance should discover the others"
diff --git a/modules/juce/midi-server/tests/integration/server_test.sh b/modules/juce/midi-server/tests/integration/server_test.sh
new file mode 100755
index 0000000..a909832
--- /dev/null
+++ b/modules/juce/midi-server/tests/integration/server_test.sh
@@ -0,0 +1,168 @@
+#!/bin/bash
+# Network MIDI Server Integration Test
+# Tests full server functionality including HTTP API
+
+set -e
+
+PROJECT_ROOT="/Users/orion/work/ol_dsp-midi-server"
+BUILD_DIR="${PROJECT_ROOT}/build"
+SERVER="${BUILD_DIR}/modules/juce/midi-server/network_midi_server_artefacts/network_midi_server"
+
+# Color output
+GREEN='\033[0;32m'
+RED='\033[0;31m'
+YELLOW='\033[1;33m'
+NC='\033[0m'
+
+echo "======================================"
+echo "Network MIDI Server Integration Test"
+echo "======================================"
+echo
+
+# Check if server exists
+if [ ! -f "$SERVER" ]; then
+    echo -e "${RED}ERROR: network_midi_server not found at $SERVER${NC}"
+    exit 1
+fi
+
+# Test 1: Single server instance
+echo -e "${YELLOW}Test 1: Single Server Instance${NC}"
+echo "Starting server in background..."
+
+# Start server in background and capture output
+timeout 10 "$SERVER" > /tmp/midi_server_test.log 2>&1 &
+SERVER_PID=$!
+sleep 3
+
+# Check if server is running
+if ! kill -0 $SERVER_PID 2>/dev/null; then
+    echo -e "${RED}✗ Server failed to start${NC}"
+    cat /tmp/midi_server_test.log
+    exit 1
+fi
+
+echo -e "${GREEN}✓ Server started successfully (PID: $SERVER_PID)${NC}"
+
+# Extract port from log
+PORT=$(grep "bound to port" /tmp/midi_server_test.log | sed -n 's/.*port \([0-9]*\)/\1/p' | head -1)
+if [ -z "$PORT" ]; then
+    echo -e "${YELLOW}⚠ Could not extract port, trying common ports...${NC}"
+    # Try to find the port from the log
+    cat /tmp/midi_server_test.log
+fi
+
+echo "Server running on port: $PORT"
+echo
+
+# Test HTTP endpoints (if we got the port)
+if [ -n "$PORT" ]; then
+    echo -e "${YELLOW}Test 2: HTTP API Endpoints${NC}"
+
+    # Test /health endpoint
+    echo -n "Testing GET /health... "
+    if curl -s "http://localhost:$PORT/health" > /dev/null 2>&1; then
+        echo -e "${GREEN}✓${NC}"
+    else
+        echo -e "${RED}✗${NC}"
+    fi
+
+    # Test /midi/inputs endpoint
+    echo -n "Testing GET /midi/inputs... "
+    if curl -s "http://localhost:$PORT/midi/inputs" > /dev/null 2>&1; then
+        echo -e "${GREEN}✓${NC}"
+    else
+        echo -e "${RED}✗${NC}"
+    fi
+
+    # Test /midi/outputs endpoint
+    echo -n "Testing GET /midi/outputs... "
+    if curl -s "http://localhost:$PORT/midi/outputs" > /dev/null 2>&1; then
+        echo -e "${GREEN}✓${NC}"
+    else
+        echo -e "${RED}✗${NC}"
+    fi
+
+    # Test /midi/devices endpoint
+    echo -n "Testing GET /midi/devices... "
+    DEVICES=$(curl -s "http://localhost:$PORT/midi/devices")
+    if [ $? -eq 0 ]; then
+        echo -e "${GREEN}✓${NC}"
+        echo "Response: $DEVICES"
+    else
+        echo -e "${RED}✗${NC}"
+    fi
+    echo
+fi
+
+# Stop server
+echo "Stopping server..."
+kill $SERVER_PID 2>/dev/null || true
+wait $SERVER_PID 2>/dev/null || true
+echo -e "${GREEN}✓ Server stopped${NC}"
+echo
+
+# Test 3: Multi-instance server test
+echo -e "${YELLOW}Test 3: Multi-Instance Servers (3 instances)${NC}"
+echo "Starting 3 server instances..."
+
+# Start 3 instances with auto-port allocation
+timeout 15 "$SERVER" > /tmp/midi_server_1.log 2>&1 &
+PID1=$!
+sleep 2
+
+timeout 15 "$SERVER" > /tmp/midi_server_2.log 2>&1 &
+PID2=$!
+sleep 2
+
+timeout 15 "$SERVER" > /tmp/midi_server_3.log 2>&1 &
+PID3=$!
+sleep 2
+
+# Check all instances are running
+RUNNING=0
+if kill -0 $PID1 2>/dev/null; then ((RUNNING++)); fi
+if kill -0 $PID2 2>/dev/null; then ((RUNNING++)); fi
+if kill -0 $PID3 2>/dev/null; then ((RUNNING++)); fi
+
+echo "Running instances: $RUNNING/3"
+
+if [ $RUNNING -eq 3 ]; then
+    echo -e "${GREEN}✓ All 3 instances started successfully${NC}"
+
+    # Show instance details
+    echo
+    echo "Instance 1:"
+    grep -E "(UUID|Port|Node)" /tmp/midi_server_1.log | head -5
+    echo
+    echo "Instance 2:"
+    grep -E "(UUID|Port|Node)" /tmp/midi_server_2.log | head -5
+    echo
+    echo "Instance 3:"
+    grep -E "(UUID|Port|Node)" /tmp/midi_server_3.log | head -5
+else
+    echo -e "${YELLOW}⚠ Only $RUNNING instances started${NC}"
+fi
+
+# Let them run for a bit
+sleep 5
+
+# Stop all instances
+echo
+echo "Stopping all instances..."
+kill $PID1 $PID2 $PID3 2>/dev/null || true
+wait $PID1 $PID2 $PID3 2>/dev/null || true
+echo -e "${GREEN}✓ All instances stopped${NC}"
+
+echo
+echo "======================================"
+echo -e "${GREEN}Integration tests completed${NC}"
+echo "======================================"
+echo
+echo "Summary:"
+echo "  - Single server instance: ✓"
+echo "  - HTTP API endpoints: ✓ (if port was available)"
+echo "  - Multi-instance isolation: ✓ ($RUNNING/3 instances)"
+echo
+echo "Logs available at:"
+echo "  - /tmp/midi_server_test.log"
+echo "  - /tmp/midi_server_{1,2,3}.log"


---

_**Agent (claude-sonnet-4-5-20250929)**_

refactor(midi-server): remove singleton NodeIdentity pattern to support multiple instances per machine

