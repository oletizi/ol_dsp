<!-- Generated by SpecStory -->

# 2025-10-07 19:48:40Z

<!-- Claude Code Session cd6f3ac3-5cbe-4eae-a75a-03f635eea90d (2025-10-07_19-48-40Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/docs/1.0/routing/MIDIROUTER_SEDA_REFACTORING.md b/modules/juce/midi-server/docs/1.0/routing/MIDIROUTER_SEDA_REFACTORING.md
new file mode 100644
index 0000000..e57e50c
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/routing/MIDIROUTER_SEDA_REFACTORING.md
@@ -0,0 +1,432 @@
+# MidiRouter SEDA Refactoring Plan
+
+**Status**: PLANNED
+**Priority**: HIGH - Architectural consistency required
+**Estimated Effort**: 8-12 hours
+**Created**: 2025-10-06
+
+---
+
+## Problem Statement
+
+### Current Architecture Inconsistency
+
+**MidiRouter** (Phase 3) uses traditional mutex-based concurrency:
+- 3 mutexes with complex ordering rules (`portMutex` → `messageMutex` → `statsMutex`)
+- Risk of deadlocks if ordering violated
+- Potential contention on hot paths (statistics updates)
+- Does not match system architecture
+
+**NetworkConnection** (Phase B) uses SEDA (Staged Event-Driven Architecture):
+- `NetworkConnectionQueue` with command pattern
+- Lock-free message passing
+- Worker thread processes commands sequentially
+- Zero deadlock risk
+
+### Why This Matters
+
+1. **Safety**: Mutex ordering is fragile - one mistake = deadlock
+2. **Performance**: Lock-free queues outperform mutexes
+3. **Consistency**: System should use one concurrency model
+4. **Maintainability**: SEDA is simpler to reason about
+
+### Decision
+
+**Refactor MidiRouter to use SEDA** matching the NetworkConnection pattern.
+
+---
+
+## Current State Analysis
+
+### MidiRouter Mutex Usage
+
+```cpp
+class MidiRouter {
+private:
+    // 3 mutexes with ordering rules
+    mutable std::mutex portMutex;        // 1. Protects localPorts
+    mutable std::mutex messageMutex;     // 2. Protects messageQueues
+    mutable std::mutex statsMutex;       // 3. Protects statistics
+
+    std::map<uint16_t, std::unique_ptr<MidiPortInterface>> localPorts;
+    std::map<uint16_t, std::queue<std::vector<uint8_t>>> messageQueues;
+    Statistics stats;
+};
+```
+
+### Critical Methods (Require Locking)
+
+1. **forwardMessage()** - Hot path, needs RouteManager lookup + forwarding
+2. **registerLocalPort()** - Infrequent, modifies localPorts
+3. **unregisterLocalPort()** - Infrequent, modifies localPorts
+4. **queueReceivedMessage()** - Receive path, modifies messageQueues
+5. **getStatistics()** - Read-only, needs consistent snapshot
+6. **resetStatistics()** - Infrequent, modifies stats
+
+### Performance Hotspots
+
+- `forwardMessage()`: Called for every MIDI message (high frequency)
+- `updateRuleStatistics()`: Acquires `statsMutex` inside forwarding loop
+- String conversion: `rule.ruleId.toStdString()` allocates on hot path
+
+---
+
+## Target State (SEDA Architecture)
+
+### Command Queue Pattern
+
+```cpp
+class MidiRouter {
+private:
+    NetworkConnectionQueue commandQueue;
+    juce::Thread workerThread;
+    std::atomic<bool> shouldStop{false};
+
+    // No mutexes needed - all state accessed from worker thread only
+    std::map<uint16_t, std::unique_ptr<MidiPortInterface>> localPorts;
+    std::map<uint16_t, std::queue<std::vector<uint8_t>>> messageQueues;
+    Statistics stats;
+
+    void workerThreadRun();
+};
+```
+
+### Command Definitions
+
+```cpp
+namespace MidiRouterCommands {
+
+// 1. Hot path - message forwarding (async, no response)
+struct ForwardMessageCommand : public NetworkConnectionQueue::Command {
+    juce::Uuid sourceNode;
+    uint16_t sourceDevice;
+    std::vector<uint8_t> midiData;
+
+    void execute(MidiRouter* router) override;
+};
+
+// 2. Port management (async, no response)
+struct RegisterPortCommand : public NetworkConnectionQueue::Command {
+    uint16_t deviceId;
+    std::unique_ptr<MidiPortInterface> port;
+
+    void execute(MidiRouter* router) override;
+};
+
+struct UnregisterPortCommand : public NetworkConnectionQueue::Command {
+    uint16_t deviceId;
+
+    void execute(MidiRouter* router) override;
+};
+
+// 3. Message queueing (async, no response)
+struct QueueMessageCommand : public NetworkConnectionQueue::Command {
+    uint16_t deviceId;
+    std::vector<uint8_t> midiData;
+
+    void execute(MidiRouter* router) override;
+};
+
+// 4. Statistics (sync, with response via callback)
+struct GetStatisticsCommand : public NetworkConnectionQueue::QueryCommand<Statistics> {
+    void execute(MidiRouter* router) override {
+        setResponse(router->getStatisticsInternal());
+    }
+};
+
+struct ResetStatisticsCommand : public NetworkConnectionQueue::Command {
+    void execute(MidiRouter* router) override;
+};
+
+// 5. Configuration (async, no response)
+struct SetRouteManagerCommand : public NetworkConnectionQueue::Command {
+    RouteManager* manager;
+
+    void execute(MidiRouter* router) override;
+};
+
+struct SetNetworkTransportCommand : public NetworkConnectionQueue::Command {
+    NetworkTransport* transport;
+
+    void execute(MidiRouter* router) override;
+};
+
+} // namespace MidiRouterCommands
+```
+
+---
+
+## Implementation Plan
+
+### Phase 3.5: SEDA Refactoring (8-12 hours)
+
+#### Step 1: Command Infrastructure (2 hours)
+
+**Task 1.1**: Create command classes
+- File: `network/routing/MidiRouterCommands.h` (new)
+- Implement all 8 command types
+- Inherit from `NetworkConnectionQueue::Command` or `QueryCommand<T>`
+
+**Task 1.2**: Add worker thread to MidiRouter
+- Add `NetworkConnectionQueue commandQueue`
+- Add worker thread start/stop in constructor/destructor
+- Implement `workerThreadRun()` loop
+
+#### Step 2: Public API Refactoring (3 hours)
+
+**Task 2.1**: Convert public methods to command dispatch
+
+**Before** (mutex-based):
+```cpp
+void MidiRouter::forwardMessage(const juce::Uuid& sourceNode,
+                                uint16_t sourceDevice,
+                                const std::vector<uint8_t>& midiData)
+{
+    std::lock_guard<std::mutex> lock(messageMutex);
+    // ... forwarding logic
+}
+```
+
+**After** (SEDA):
+```cpp
+void MidiRouter::forwardMessage(const juce::Uuid& sourceNode,
+                                uint16_t sourceDevice,
+                                const std::vector<uint8_t>& midiData)
+{
+    auto cmd = std::make_unique<ForwardMessageCommand>();
+    cmd->sourceNode = sourceNode;
+    cmd->sourceDevice = sourceDevice;
+    cmd->midiData = midiData;
+
+    commandQueue.push(std::move(cmd));
+}
+```
+
+**Task 2.2**: Handle synchronous methods with QueryCommand
+
+```cpp
+Statistics MidiRouter::getStatistics() const
+{
+    auto cmd = std::make_unique<GetStatisticsCommand>();
+    auto future = cmd->getResponseFuture();
+
+    commandQueue.push(std::move(cmd));
+
+    return future.get(); // Block until worker processes command
+}
+```
+
+#### Step 3: Remove Mutexes (1 hour)
+
+**Task 3.1**: Delete mutex declarations
+- Remove `portMutex`, `messageMutex`, `statsMutex`
+- Remove all `std::lock_guard` usage
+- Remove mutex ordering documentation (no longer needed!)
+
+**Task 3.2**: Make methods private/internal
+- Rename `forwardMessageInternal()` to just internal methods
+- Only worker thread calls internal methods
+- Public methods just dispatch commands
+
+#### Step 4: Testing (2-3 hours)
+
+**Task 4.1**: Update existing tests
+- Tests should still work (same public API)
+- May need to add short delays for async commands to process
+
+**Task 4.2**: Add SEDA-specific tests
+- Test command queue overflow handling
+- Test worker thread shutdown
+- Test query command timeout
+
+**Task 4.3**: Verify all 37 tests still pass
+
+#### Step 5: Performance Optimization (2 hours)
+
+**Task 5.1**: Eliminate hot-path allocations
+- Pre-allocate command objects (object pool)
+- Remove `toStdString()` calls (use juce::String directly)
+
+**Task 5.2**: Tune queue size
+- Set appropriate max queue size (1000? 10000?)
+- Add queue overflow statistics
+
+#### Step 6: Documentation (1 hour)
+
+**Task 6.1**: Update MidiRouter.h documentation
+- Replace mutex ordering docs with SEDA explanation
+- Update usage examples to note async behavior
+- Document command queue semantics
+
+**Task 6.2**: Update architectural docs
+- Note consistency with NetworkConnection
+- Explain SEDA benefits
+
+---
+
+## Migration Strategy
+
+### Backward Compatibility
+
+**Public API remains unchanged**:
+- All public methods have same signatures
+- Callers don't need to change
+- Async execution is transparent
+
+**Behavioral changes**:
+- Methods return immediately (async execution)
+- `getStatistics()` blocks until response (same as before, but via future)
+- Small latency increase (~microseconds for queue operation)
+
+### Testing Strategy
+
+1. **Existing tests must pass**: All 37 MidiMessageForwardingTest tests
+2. **Add async delay helpers**: `waitForCommandProcessing()` in tests if needed
+3. **Stress test**: High message rate forwarding
+4. **Regression test**: Ensure no deadlocks (run with TSan)
+
+### Rollout Plan
+
+1. **Development**: Implement on feature branch
+2. **Testing**: Verify all tests pass, run stress tests
+3. **Integration**: Merge after Phase 3 quality improvements
+4. **Monitoring**: Track queue depths, processing latency
+
+---
+
+## Benefits
+
+### Safety
+- ✅ **Zero deadlock risk** - no mutexes
+- ✅ **Sequential execution** - no race conditions
+- ✅ **Simple reasoning** - one thread owns all state
+
+### Performance
+- ✅ **Lock-free queues** - better throughput than mutexes
+- ✅ **No contention** - single worker thread
+- ✅ **Async execution** - callers don't block
+- ✅ **Object pooling** - can pre-allocate commands
+
+### Architecture
+- ✅ **Consistency** - matches NetworkConnection pattern
+- ✅ **Scalability** - easy to add commands
+- ✅ **Testability** - commands are independently testable
+- ✅ **Maintainability** - simpler concurrency model
+
+---
+
+## Risks & Mitigations
+
+### Risk 1: Async Latency
+**Risk**: Command queue adds latency (enqueue + dequeue + execution)
+**Mitigation**:
+- Lock-free queue is very fast (<1μs)
+- Still faster than mutex contention
+- MIDI has ~1ms tolerance
+
+### Risk 2: Queue Overflow
+**Risk**: High message rate could overflow queue
+**Mitigation**:
+- Set appropriate queue size (10000 messages)
+- Track overflow in statistics
+- Apply backpressure if needed
+
+### Risk 3: Query Command Blocking
+**Risk**: `getStatistics()` blocks caller until worker processes
+**Mitigation**:
+- Worker thread is fast (no I/O, no locks)
+- Typical latency <10μs
+- Same behavior as mutex-based version
+
+### Risk 4: Test Flakiness
+**Risk**: Async execution could cause test timing issues
+**Mitigation**:
+- Add `processAllPendingCommands()` test helper
+- Use command completion callbacks in tests
+- Increase timeouts if needed
+
+---
+
+## Success Criteria
+
+1. ✅ All 37 MidiMessageForwardingTest tests pass
+2. ✅ Zero mutexes in MidiRouter
+3. ✅ All public methods dispatch to command queue
+4. ✅ Worker thread processes commands sequentially
+5. ✅ No performance regression (measure with benchmarks)
+6. ✅ ThreadSanitizer (TSan) reports no issues
+7. ✅ Code review approval
+8. ✅ Documentation updated
+
+---
+
+## Implementation Checklist
+
+- [ ] Create `network/routing/MidiRouterCommands.h`
+- [ ] Implement 8 command classes
+- [ ] Add `NetworkConnectionQueue` to MidiRouter
+- [ ] Add worker thread start/stop
+- [ ] Implement `workerThreadRun()` loop
+- [ ] Convert `forwardMessage()` to command dispatch
+- [ ] Convert `registerLocalPort()` to command dispatch
+- [ ] Convert `unregisterLocalPort()` to command dispatch
+- [ ] Convert `queueReceivedMessage()` to command dispatch
+- [ ] Convert `getStatistics()` to query command
+- [ ] Convert `resetStatistics()` to command dispatch
+- [ ] Convert `setRouteManager()` to command dispatch
+- [ ] Convert `setNetworkTransport()` to command dispatch
+- [ ] Remove all 3 mutexes
+- [ ] Remove all `std::lock_guard` usage
+- [ ] Update MidiRouter.h documentation
+- [ ] Add test helpers for async commands
+- [ ] Run all 37 tests - verify pass
+- [ ] Run stress test (10k messages/sec)
+- [ ] Run ThreadSanitizer - verify no issues
+- [ ] Measure performance (latency, throughput)
+- [ ] Update architectural documentation
+- [ ] Code review
+- [ ] Merge to main branch
+
+---
+
+## Timeline
+
+**Estimated**: 8-12 hours
+- Step 1 (Infrastructure): 2 hours
+- Step 2 (API Refactoring): 3 hours
+- Step 3 (Remove Mutexes): 1 hour
+- Step 4 (Testing): 2-3 hours
+- Step 5 (Optimization): 2 hours
+- Step 6 (Documentation): 1 hour
+
+**Target Completion**: Before Phase 4 implementation
+
+---
+
+## References
+
+**Existing SEDA Implementation**:
+- `network/mesh/NetworkConnectionQueue.h` - Command queue infrastructure
+- `network/mesh/NetworkConnectionQueue.cpp` - Implementation
+- `network/mesh/tests/NetworkConnectionQueueTest.cpp` - Test patterns
+
+**Related Documentation**:
+- Phase B.1 SEDA infrastructure workplan
+- NetworkConnection SEDA integration docs
+
+---
+
+## Next Steps
+
+1. **Review this plan** with architecture team
+2. **Assign implementation** to backend engineer
+3. **Create feature branch**: `feat/midirouter-seda-refactoring`
+4. **Implement** following checklist above
+5. **Test** thoroughly
+6. **Merge** before Phase 4
+
+---
+
+**Author**: Claude Code
+**Reviewers**: [To be assigned]
+**Status**: PLANNED - Ready for implementation
diff --git a/modules/juce/midi-server/network/routing/MidiRouter.cpp b/modules/juce/midi-server/network/routing/MidiRouter.cpp
index 9bb9bb9..9fddfdd 100644
--- a/modules/juce/midi-server/network/routing/MidiRouter.cpp
+++ b/modules/juce/midi-server/network/routing/MidiRouter.cpp
@@ -1,76 +1,189 @@
 /**
  * MidiRouter.cpp
  *
- * Implementation of transparent MIDI message router
+ * Implementation of transparent MIDI message router with SEDA architecture
  */
 
 #include "MidiRouter.h"
 #include "RouteManager.h"
 #include "ForwardingRule.h"
+#include "MidiRouterCommands.h"
 #include <algorithm>
 
 namespace NetworkMidi {
 
+//==============================================================================
+// WorkerThread Implementation
+
+MidiRouter::WorkerThread::WorkerThread(MidiRouter& r)
+    : juce::Thread("MidiRouter")
+    , router(r)
+{
+}
+
+void MidiRouter::WorkerThread::run()
+{
+    while (!router.shouldStop.load()) {
+        // Wait for command with 100ms timeout
+        auto cmd = router.commandQueue.waitAndPop(100);
+
+        if (cmd) {
+            router.processCommand(std::move(cmd));
+        }
+    }
+}
+
+//==============================================================================
+// Constructor / Destructor
+
 MidiRouter::MidiRouter(DeviceRegistry& registry, RoutingTable& routes)
     : deviceRegistry(registry)
     , routingTable(routes)
     , networkTransport(nullptr)
     , routeManager(nullptr)
 {
+    // Start worker thread
+    workerThread = std::make_unique<WorkerThread>(*this);
+    workerThread->startThread();
 }
 
 MidiRouter::~MidiRouter()
 {
-    clearLocalPorts();
+    // Signal worker thread to stop
+    shouldStop.store(true);
+    commandQueue.shutdown();
+
+    // Wait for worker thread to finish (max 2 seconds)
+    if (workerThread) {
+        workerThread->stopThread(2000);
+    }
+
+    // Clear local ports (done on main thread after worker stopped)
+    localPorts.clear();
+}
+
+//==============================================================================
+// Command Processing
+
+void MidiRouter::processCommand(std::unique_ptr<MidiRouterCommands::Command> cmd)
+{
+    using namespace MidiRouterCommands;
+
+    switch (cmd->type) {
+        case Command::ForwardMessage: {
+            auto* fwdCmd = static_cast<ForwardMessageCommand*>(cmd.get());
+            ForwardingContext context;
+            forwardMessageInternal(fwdCmd->sourceNode, fwdCmd->sourceDevice,
+                                   fwdCmd->midiData, context);
+            break;
+        }
+
+        case Command::DirectSend: {
+            auto* sendCmd = static_cast<DirectSendCommand*>(cmd.get());
+            forwardToDestination(sendCmd->destNode, sendCmd->destDevice,
+                                 sendCmd->midiData);
+            break;
+        }
+
+        case Command::RegisterPort: {
+            auto* regCmd = static_cast<RegisterPortCommand*>(cmd.get());
+            registerLocalPortInternal(regCmd->deviceId, std::unique_ptr<MidiPortInterface>(regCmd->port));
+            break;
+        }
+
+        case Command::UnregisterPort: {
+            auto* unregCmd = static_cast<UnregisterPortCommand*>(cmd.get());
+            unregisterLocalPortInternal(unregCmd->deviceId);
+            break;
+        }
+
+        case Command::QueueMessage: {
+            auto* queueCmd = static_cast<QueueMessageCommand*>(cmd.get());
+            queueReceivedMessageInternal(queueCmd->deviceId, queueCmd->midiData);
+            break;
+        }
+
+        case Command::GetStatistics: {
+            auto* statsCmd = static_cast<GetStatisticsQuery*>(cmd.get());
+            auto routerStats = getStatisticsInternal();
+            statsCmd->result.localMessagesSent = routerStats.localMessagesSent;
+            statsCmd->result.localMessagesReceived = routerStats.localMessagesReceived;
+            statsCmd->result.networkMessagesSent = routerStats.networkMessagesSent;
+            statsCmd->result.networkMessagesReceived = routerStats.networkMessagesReceived;
+            statsCmd->result.routingErrors = routerStats.routingErrors;
+            statsCmd->result.messagesForwarded = routerStats.messagesForwarded;
+            statsCmd->result.messagesDropped = routerStats.messagesDropped;
+            statsCmd->result.loopsDetected = routerStats.loopsDetected;
+            statsCmd->signal();
+            // Release ownership - caller manages lifetime via shared_ptr
+            cmd.release();
+            break;
+        }
+
+        case Command::ResetStatistics: {
+            resetStatisticsInternal();
+            break;
+        }
+
+        case Command::SetRouteManager: {
+            auto* rmCmd = static_cast<SetRouteManagerCommand*>(cmd.get());
+            setRouteManagerInternal(rmCmd->manager);
+            break;
+        }
+
+        case Command::SetNetworkTransport: {
+            auto* ntCmd = static_cast<SetNetworkTransportCommand*>(cmd.get());
+            setNetworkTransportInternal(ntCmd->transport);
+            break;
+        }
+    }
 }
 
 //==============================================================================
-// Network transport integration
+// Public API - Network transport integration
 
 void MidiRouter::setNetworkTransport(NetworkTransport* transport)
 {
-    networkTransport = transport;
+    auto cmd = std::make_unique<MidiRouterCommands::SetNetworkTransportCommand>(transport);
+    commandQueue.push(std::move(cmd));
 }
 
 //==============================================================================
-// RouteManager integration (Phase 3.1)
+// Public API - RouteManager integration
 
 void MidiRouter::setRouteManager(RouteManager* manager)
 {
-    routeManager = manager;
+    auto cmd = std::make_unique<MidiRouterCommands::SetRouteManagerCommand>(manager);
+    commandQueue.push(std::move(cmd));
 }
 
 //==============================================================================
-// Local port management
+// Public API - Local port management
 
 void MidiRouter::registerLocalPort(uint16_t deviceId,
                                    std::unique_ptr<MidiPortInterface> port)
 {
-    std::lock_guard<std::mutex> lock(portMutex);
-
-    if (!port) {
-        reportError("Cannot register null MIDI port for device " +
-                    juce::String(deviceId));
-        return;
-    }
-
-    localPorts[deviceId] = std::move(port);
+    auto cmd = std::make_unique<MidiRouterCommands::RegisterPortCommand>(
+        deviceId, port.release());
+    commandQueue.push(std::move(cmd));
 }
 
 void MidiRouter::unregisterLocalPort(uint16_t deviceId)
 {
-    std::lock_guard<std::mutex> lock(portMutex);
-    localPorts.erase(deviceId);
+    auto cmd = std::make_unique<MidiRouterCommands::UnregisterPortCommand>(deviceId);
+    commandQueue.push(std::move(cmd));
 }
 
 void MidiRouter::clearLocalPorts()
 {
-    std::lock_guard<std::mutex> lock(portMutex);
-    localPorts.clear();
+    // Send unregister commands for all current ports
+    // Note: This is a simplified version - in practice we'd need to query
+    // current ports first, but that would require synchronization
+    // For now, rely on destructor cleanup
 }
 
 //==============================================================================
-// Message transmission
+// Public API - Message transmission
 
 void MidiRouter::sendMessage(uint16_t deviceId,
                              const std::vector<uint8_t>& midiData)
@@ -85,13 +198,15 @@ void MidiRouter::sendMessage(uint16_t deviceId,
     auto route = routingTable.getLocalRoute(deviceId);
     if (!route.has_value()) {
         reportError("No local route found for device " + juce::String(deviceId));
-        std::lock_guard<std::mutex> lock(statsMutex);
-        stats.routingErrors++;
+        // Note: Can't update stats here since we're not on worker thread
         return;
     }
 
-    // Route to local device
-    routeLocalMessage(deviceId, midiData);
+    // Create command to route to local device
+    // We'll use ForwardMessage with null UUID to indicate local routing
+    auto cmd = std::make_unique<MidiRouterCommands::ForwardMessageCommand>(
+        juce::Uuid(), deviceId, midiData);
+    commandQueue.push(std::move(cmd));
 }
 
 void MidiRouter::sendMessageToNode(const juce::Uuid& nodeId,
@@ -103,58 +218,40 @@ void MidiRouter::sendMessageToNode(const juce::Uuid& nodeId,
         return;
     }
 
-    routeNetworkMessage(nodeId, deviceId, midiData);
+    auto cmd = std::make_unique<MidiRouterCommands::DirectSendCommand>(
+        nodeId, deviceId, midiData);
+    commandQueue.push(std::move(cmd));
 }
 
 //==============================================================================
-// Message reception
+// Public API - Message reception (NOTE: These remain synchronous for now)
 
 std::vector<std::vector<uint8_t>> MidiRouter::getMessages(uint16_t deviceId)
 {
-    std::lock_guard<std::mutex> lock(messageMutex);
-
+    // TODO: Convert to SEDA query command
+    // For now, this is a potential race condition but acceptable for Phase 1
     std::vector<std::vector<uint8_t>> result;
 
-    auto it = messageQueues.find(deviceId);
-    if (it != messageQueues.end()) {
-        auto& queue = it->second;
-
-        result.reserve(queue.size());
-
-        while (!queue.empty()) {
-            result.push_back(std::move(queue.front()));
-            queue.pop();
-        }
-    }
+    // This accesses messageQueues which is also accessed by worker thread
+    // In practice, this is safe because std::map/std::queue operations are
+    // atomic at the container level, but ideally this should be a query command
 
     return result;
 }
 
 int MidiRouter::getMessageCount(uint16_t deviceId) const
 {
-    std::lock_guard<std::mutex> lock(messageMutex);
-
-    auto it = messageQueues.find(deviceId);
-    if (it != messageQueues.end()) {
-        return static_cast<int>(it->second.size());
-    }
-
+    // TODO: Convert to SEDA query command
     return 0;
 }
 
 void MidiRouter::clearMessages(uint16_t deviceId)
 {
-    std::lock_guard<std::mutex> lock(messageMutex);
-
-    auto it = messageQueues.find(deviceId);
-    if (it != messageQueues.end()) {
-        std::queue<std::vector<uint8_t>> empty;
-        std::swap(it->second, empty);
-    }
+    // TODO: Convert to SEDA command
 }
 
 //==============================================================================
-// Network packet handling
+// Public API - Network packet handling
 
 void MidiRouter::onNetworkPacketReceived(const juce::Uuid& sourceNode,
                                          uint16_t deviceId,
@@ -171,38 +268,75 @@ void MidiRouter::onNetworkPacketReceived(const juce::Uuid& sourceNode,
     if (!route.has_value()) {
         reportError("Received network message for unknown device " +
                     juce::String(deviceId) + " from node " + sourceNode.toString());
-        std::lock_guard<std::mutex> lock(statsMutex);
-        stats.routingErrors++;
         return;
     }
 
     // Queue for consumption by local applications
-    queueReceivedMessage(deviceId, midiData);
+    auto cmd = std::make_unique<MidiRouterCommands::QueueMessageCommand>(deviceId, midiData);
+    commandQueue.push(std::move(cmd));
+}
 
-    // Update statistics
-    {
-        std::lock_guard<std::mutex> lock(statsMutex);
-        stats.networkMessagesReceived++;
+//==============================================================================
+// Public API - Message forwarding
+
+void MidiRouter::forwardMessage(const juce::Uuid& sourceNode,
+                                uint16_t sourceDevice,
+                                const std::vector<uint8_t>& midiData)
+{
+    if (midiData.empty()) {
+        reportError("Cannot forward empty MIDI message");
+        return;
     }
+
+    auto cmd = std::make_unique<MidiRouterCommands::ForwardMessageCommand>(
+        sourceNode, sourceDevice, midiData);
+    commandQueue.push(std::move(cmd));
 }
 
 //==============================================================================
-// Statistics
+// Public API - Statistics
 
 MidiRouter::Statistics MidiRouter::getStatistics() const
 {
-    std::lock_guard<std::mutex> lock(statsMutex);
-    return stats;
+    // Allocate command (will be released in processCommand, not deleted)
+    auto cmd = std::make_unique<MidiRouterCommands::GetStatisticsQuery>();
+    auto* cmdPtr = cmd.get();
+
+    // Push command to queue
+    const_cast<MidiRouter*>(this)->commandQueue.push(std::move(cmd));
+
+    // Wait for response (max 1000ms)
+    if (cmdPtr->wait(1000)) {
+        // Convert from MidiRouterCommands::Statistics to MidiRouter::Statistics
+        Statistics result;
+        result.localMessagesSent = cmdPtr->result.localMessagesSent;
+        result.localMessagesReceived = cmdPtr->result.localMessagesReceived;
+        result.networkMessagesSent = cmdPtr->result.networkMessagesSent;
+        result.networkMessagesReceived = cmdPtr->result.networkMessagesReceived;
+        result.routingErrors = cmdPtr->result.routingErrors;
+        result.messagesForwarded = cmdPtr->result.messagesForwarded;
+        result.messagesDropped = cmdPtr->result.messagesDropped;
+        result.loopsDetected = cmdPtr->result.loopsDetected;
+
+        // Manual cleanup since we released ownership in processCommand
+        delete cmdPtr;
+
+        return result;
+    }
+
+    // Timeout - return empty statistics
+    reportError("Timeout waiting for statistics query");
+    return Statistics();
 }
 
 void MidiRouter::resetStatistics()
 {
-    std::lock_guard<std::mutex> lock(statsMutex);
-    stats = Statistics();
+    auto cmd = std::make_unique<MidiRouterCommands::ResetStatisticsCommand>();
+    commandQueue.push(std::move(cmd));
 }
 
 //==============================================================================
-// Error callback
+// Public API - Error callback
 
 void MidiRouter::setErrorCallback(ErrorCallback callback)
 {
@@ -210,33 +344,46 @@ void MidiRouter::setErrorCallback(ErrorCallback callback)
 }
 
 //==============================================================================
-// Private helper methods
+// Internal Methods - Port management
+
+void MidiRouter::registerLocalPortInternal(uint16_t deviceId,
+                                           std::unique_ptr<MidiPortInterface> port)
+{
+    if (!port) {
+        reportError("Cannot register null MIDI port for device " +
+                    juce::String(deviceId));
+        return;
+    }
+
+    localPorts[deviceId] = std::move(port);
+}
+
+void MidiRouter::unregisterLocalPortInternal(uint16_t deviceId)
+{
+    localPorts.erase(deviceId);
+}
+
+//==============================================================================
+// Internal Methods - Message routing
 
 void MidiRouter::routeLocalMessage(uint16_t deviceId,
                                    const std::vector<uint8_t>& midiData)
 {
-    std::lock_guard<std::mutex> lock(portMutex);
-
     auto it = localPorts.find(deviceId);
     if (it == localPorts.end()) {
         reportError("Local port not found for device " +
                     juce::String(deviceId));
-        std::lock_guard<std::mutex> statsLock(statsMutex);
         stats.routingErrors++;
         return;
     }
 
     try {
         it->second->sendMessage(midiData);
-
-        // Update statistics
-        std::lock_guard<std::mutex> statsLock(statsMutex);
         stats.localMessagesSent++;
     }
     catch (const std::exception& e) {
         reportError("Error sending local MIDI message: " +
                     juce::String(e.what()));
-        std::lock_guard<std::mutex> statsLock(statsMutex);
         stats.routingErrors++;
     }
 }
@@ -247,31 +394,24 @@ void MidiRouter::routeNetworkMessage(const juce::Uuid& destNode,
 {
     if (!networkTransport) {
         reportError("Network transport not configured - cannot route message");
-        std::lock_guard<std::mutex> lock(statsMutex);
         stats.routingErrors++;
         return;
     }
 
     try {
         networkTransport->sendMidiMessage(destNode, deviceId, midiData);
-
-        // Update statistics
-        std::lock_guard<std::mutex> lock(statsMutex);
         stats.networkMessagesSent++;
     }
     catch (const std::exception& e) {
         reportError("Error sending network MIDI message: " +
                     juce::String(e.what()));
-        std::lock_guard<std::mutex> lock(statsMutex);
         stats.routingErrors++;
     }
 }
 
-void MidiRouter::queueReceivedMessage(uint16_t deviceId,
-                                      const std::vector<uint8_t>& midiData)
+void MidiRouter::queueReceivedMessageInternal(uint16_t deviceId,
+                                              const std::vector<uint8_t>& midiData)
 {
-    std::lock_guard<std::mutex> lock(messageMutex);
-
     // Create queue if it doesn't exist
     auto& queue = messageQueues[deviceId];
 
@@ -285,9 +425,10 @@ void MidiRouter::queueReceivedMessage(uint16_t deviceId,
     }
 
     queue.push(midiData);
+    stats.networkMessagesReceived++;
 }
 
-void MidiRouter::reportError(const juce::String& error)
+void MidiRouter::reportError(const juce::String& error) const
 {
     if (errorCallback) {
         errorCallback(error);
@@ -297,41 +438,24 @@ void MidiRouter::reportError(const juce::String& error)
 }
 
 //==============================================================================
-// Message forwarding (Phase 3.1)
+// Internal Methods - Message forwarding
 
-void MidiRouter::forwardMessage(const juce::Uuid& sourceNode,
-                                uint16_t sourceDevice,
-                                const std::vector<uint8_t>& midiData)
+void MidiRouter::forwardMessageInternal(const juce::Uuid& sourceNode,
+                                        uint16_t sourceDevice,
+                                        const std::vector<uint8_t>& midiData,
+                                        ForwardingContext& context)
 {
-    if (midiData.empty()) {
-        reportError("Cannot forward empty MIDI message");
-        return;
-    }
-
     if (!routeManager) {
         // No route manager configured - skip forwarding
         return;
     }
 
-    // Create fresh forwarding context for this message
-    ForwardingContext context;
-
-    // Delegate to internal implementation with loop prevention
-    forwardMessageInternal(sourceNode, sourceDevice, midiData, context);
-}
-
-void MidiRouter::forwardMessageInternal(const juce::Uuid& sourceNode,
-                                        uint16_t sourceDevice,
-                                        const std::vector<uint8_t>& midiData,
-                                        ForwardingContext& context)
-{
     // Create device key for source
     DeviceKey sourceKey(sourceNode, sourceDevice);
 
     // Check if we should forward from this source (loop prevention)
     if (!context.shouldForward(sourceKey)) {
         // Loop detected - either hop count exceeded or device already visited
-        std::lock_guard<std::mutex> lock(statsMutex);
         stats.loopsDetected++;
 
         if (context.hopCount >= ForwardingContext::MAX_HOPS) {
@@ -363,8 +487,6 @@ void MidiRouter::forwardMessageInternal(const juce::Uuid& sourceNode,
         if (!matchesFilters(rule, midiData)) {
             // Message doesn't match filters - update statistics
             routeManager->updateRuleStatistics(rule.ruleId.toStdString(), false);
-
-            std::lock_guard<std::mutex> lock(statsMutex);
             stats.messagesDropped++;
             continue;
         }
@@ -376,11 +498,7 @@ void MidiRouter::forwardMessageInternal(const juce::Uuid& sourceNode,
 
         // Update statistics
         routeManager->updateRuleStatistics(rule.ruleId.toStdString(), true);
-
-        {
-            std::lock_guard<std::mutex> lock(statsMutex);
-            stats.messagesForwarded++;
-        }
+        stats.messagesForwarded++;
     }
 }
 
@@ -481,4 +599,30 @@ NetworkMidi::MidiMessageType MidiRouter::getMidiMessageType(const std::vector<ui
     }
 }
 
+//==============================================================================
+// Internal Methods - Statistics
+
+MidiRouter::Statistics MidiRouter::getStatisticsInternal() const
+{
+    return stats;
+}
+
+void MidiRouter::resetStatisticsInternal()
+{
+    stats = Statistics();
+}
+
+//==============================================================================
+// Internal Methods - Configuration
+
+void MidiRouter::setRouteManagerInternal(RouteManager* manager)
+{
+    routeManager = manager;
+}
+
+void MidiRouter::setNetworkTransportInternal(NetworkTransport* transport)
+{
+    networkTransport = transport;
+}
+
 } // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/MidiRouter.h b/modules/juce/midi-server/network/routing/MidiRouter.h
index c34b3eb..b2ad036 100644
--- a/modules/juce/midi-server/network/routing/MidiRouter.h
+++ b/modules/juce/midi-server/network/routing/MidiRouter.h
@@ -11,13 +11,13 @@
 #include "DeviceRegistry.h"
 #include "RoutingTable.h"
 #include "ForwardingRule.h"
+#include "MidiRouterQueue.h"
 #include <juce_core/juce_core.h>
 #include <juce_audio_devices/juce_audio_devices.h>
 #include <vector>
 #include <map>
 #include <set>
 #include <queue>
-#include <mutex>
 #include <functional>
 #include <memory>
 
@@ -100,11 +100,12 @@ public:
  *   {
  *       router.forwardMessage(sourceNode, sourceDevice, midiData);
  *       // MidiRouter will:
- *       //   1. Query RouteManager for destination rules
- *       //   2. Apply channel and message type filters
- *       //   3. Route to local ports or network nodes
- *       //   4. Update statistics
- *       //   5. Prevent loops (hop count & visited devices)
+ *       //   1. Queue command to worker thread
+ *       //   2. Worker queries RouteManager for destination rules
+ *       //   3. Apply channel and message type filters
+ *       //   4. Route to local ports or network nodes
+ *       //   5. Update statistics
+ *       //   6. Prevent loops (hop count & visited devices)
  *   }
  *
  * USAGE EXAMPLE 3: Monitoring Statistics
@@ -151,9 +152,25 @@ public:
  * - Destination lookup: O(log N) where N = number of rules (indexed)
  * - Filter matching: O(1) per rule
  * - Loop prevention: O(log H) where H = hop count (std::set lookup)
- * - Thread contention: Minimal (short critical sections)
+ * - Command dispatch: Lock-free queue push (async, non-blocking)
  * - Memory: ~50 bytes overhead per forwarded message (transient)
  *
+ * CONCURRENCY MODEL (SEDA):
+ * ─────────────────────────
+ * - Command queue: All operations dispatched as commands
+ * - Worker thread: Single thread processes commands sequentially
+ * - Lock-free: No deadlocks possible (no mutexes in router logic)
+ * - Async execution: Public methods return immediately after queueing command
+ * - Query commands: Block caller until worker responds (via atomic flag + polling)
+ *
+ * SEDA ARCHITECTURE:
+ * ──────────────────
+ * - Matches NetworkConnection pattern (architectural consistency)
+ * - Commands inherit from MidiRouterCommands::Command
+ * - Worker thread processes commands from MidiRouterQueue
+ * - State accessed only by worker thread (no synchronization needed)
+ * - Benefits: Zero deadlock risk, simpler reasoning, better scalability
+ *
  * LOOP PREVENTION:
  * ────────────────
  * - Max hops: 8 (prevents infinite chains)
@@ -225,9 +242,9 @@ public:
         uint64_t networkMessagesSent = 0;
         uint64_t networkMessagesReceived = 0;
         uint64_t routingErrors = 0;
-        uint64_t messagesForwarded = 0;      // Phase 3.1
-        uint64_t messagesDropped = 0;        // Phase 3.1
-        uint64_t loopsDetected = 0;          // Loop prevention
+        uint64_t messagesForwarded = 0;
+        uint64_t messagesDropped = 0;
+        uint64_t loopsDetected = 0;
     };
 
     Statistics getStatistics() const;
@@ -239,32 +256,19 @@ public:
 
 private:
     //==========================================================================
-    // Thread Safety & Mutex Ordering Convention
-    //
-    // This class uses three mutexes for thread safety. To prevent deadlocks,
-    // always acquire mutexes in this order:
-    //
-    //   1. portMutex (highest priority - protects local MIDI ports)
-    //   2. messageMutex (medium priority - protects message queues)
-    //   3. statsMutex (lowest priority - protects statistics)
+    // SEDA Architecture - Command Queue & Worker Thread
     //
-    // RULE: Never acquire a higher-numbered mutex while holding a
-    //       lower-numbered one.
+    // All public methods dispatch commands to a queue processed by a single
+    // worker thread. This eliminates all mutex-based synchronization and
+    // provides:
     //
-    // Example (CORRECT):
-    //   std::lock_guard<std::mutex> portLock(portMutex);      // Lock 1
-    //   doSomething();
-    //   std::lock_guard<std::mutex> statsLock(statsMutex);    // Lock 3
-    //                                                          // (OK: 1→3)
+    // - Zero deadlock risk (no mutexes in router logic)
+    // - Sequential execution (commands processed one at a time)
+    // - Async operation (callers don't block)
+    // - Architectural consistency (matches NetworkConnection pattern)
     //
-    // Example (INCORRECT - DEADLOCK RISK):
-    //   std::lock_guard<std::mutex> statsLock(statsMutex);    // Lock 3
-    //   doSomething();
-    //   std::lock_guard<std::mutex> portLock(portMutex);      // Lock 1
-    //                                                          // (BAD: 3→1)
-    //
-    // If you need multiple locks simultaneously, use std::scoped_lock:
-    //   std::scoped_lock lock(portMutex, messageMutex, statsMutex);
+    // Query commands (e.g., getStatistics) block the caller until the worker
+    // thread processes the command and sets the result via atomic flag.
     //
     //==========================================================================
 
@@ -300,6 +304,34 @@ private:
         }
     };
 
+    //==========================================================================
+    // Worker Thread
+    //==========================================================================
+
+    class WorkerThread : public juce::Thread {
+    public:
+        explicit WorkerThread(MidiRouter& r);
+        void run() override;
+
+    private:
+        MidiRouter& router;
+    };
+
+    std::unique_ptr<WorkerThread> workerThread;
+    std::atomic<bool> shouldStop{false};
+
+    //==========================================================================
+    // Command Processing
+    //==========================================================================
+
+    MidiRouterQueue commandQueue;
+
+    void processCommand(std::unique_ptr<MidiRouterCommands::Command> cmd);
+
+    //==========================================================================
+    // Internal State (accessed only by worker thread)
+    //==========================================================================
+
     // References to routing infrastructure
     DeviceRegistry& deviceRegistry;
     RoutingTable& routingTable;
@@ -310,11 +342,6 @@ private:
     // Route manager (Phase 3.1)
     RouteManager* routeManager;
 
-    // Thread synchronization (acquire in this order to prevent deadlocks)
-    mutable std::mutex portMutex;        // 1. Protects localPorts map
-    mutable std::mutex messageMutex;     // 2. Protects messageQueues map
-    mutable std::mutex statsMutex;       // 3. Protects stats structure
-
     // Local MIDI ports
     std::map<uint16_t, std::unique_ptr<MidiPortInterface>> localPorts;
 
@@ -327,7 +354,16 @@ private:
     // Error handling
     ErrorCallback errorCallback;
 
-    // Helper methods
+    //==========================================================================
+    // Internal Methods (called only by worker thread)
+    //==========================================================================
+
+    // Port management
+    void registerLocalPortInternal(uint16_t deviceId,
+                                    std::unique_ptr<MidiPortInterface> port);
+    void unregisterLocalPortInternal(uint16_t deviceId);
+
+    // Message routing
     void routeLocalMessage(uint16_t deviceId,
                            const std::vector<uint8_t>& midiData);
 
@@ -335,10 +371,10 @@ private:
                              uint16_t deviceId,
                              const std::vector<uint8_t>& midiData);
 
-    void queueReceivedMessage(uint16_t deviceId,
-                              const std::vector<uint8_t>& midiData);
+    void queueReceivedMessageInternal(uint16_t deviceId,
+                                      const std::vector<uint8_t>& midiData);
 
-    void reportError(const juce::String& error);
+    void reportError(const juce::String& error) const;
 
     // Phase 3.1 forwarding helpers
     void forwardMessageInternal(const juce::Uuid& sourceNode,
@@ -356,6 +392,14 @@ private:
     uint8_t extractMidiChannel(const std::vector<uint8_t>& midiData) const;
     MidiMessageType getMidiMessageType(const std::vector<uint8_t>& midiData) const;
 
+    // Statistics (internal)
+    Statistics getStatisticsInternal() const;
+    void resetStatisticsInternal();
+
+    // Configuration (internal)
+    void setRouteManagerInternal(RouteManager* manager);
+    void setNetworkTransportInternal(NetworkTransport* transport);
+
     JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MidiRouter)
 };
 
diff --git a/modules/juce/midi-server/network/routing/MidiRouterCommands.h b/modules/juce/midi-server/network/routing/MidiRouterCommands.h
new file mode 100644
index 0000000..ea5e8ac
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/MidiRouterCommands.h
@@ -0,0 +1,218 @@
+/**
+ * MidiRouterCommands.h
+ *
+ * SEDA command classes for MidiRouter operations.
+ * Provides type-safe commands for the router worker thread.
+ */
+
+#pragma once
+
+#include <juce_core/juce_core.h>
+#include <vector>
+#include <memory>
+#include <atomic>
+#include <chrono>
+#include <cstdint>
+
+namespace NetworkMidi {
+
+// Forward declarations
+class MidiRouter;
+class MidiPortInterface;
+class RouteManager;
+class NetworkTransport;
+
+namespace MidiRouterCommands {
+
+//==============================================================================
+// Statistics structure (must match MidiRouter::Statistics)
+struct Statistics {
+    uint64_t localMessagesSent = 0;
+    uint64_t localMessagesReceived = 0;
+    uint64_t networkMessagesSent = 0;
+    uint64_t networkMessagesReceived = 0;
+    uint64_t routingErrors = 0;
+    uint64_t messagesForwarded = 0;
+    uint64_t messagesDropped = 0;
+    uint64_t loopsDetected = 0;
+};
+
+//==============================================================================
+/**
+ * Base command class for all MidiRouter commands.
+ * Uses polymorphism for type-safe command dispatch.
+ */
+struct Command {
+    enum Type {
+        ForwardMessage,
+        DirectSend,
+        RegisterPort,
+        UnregisterPort,
+        QueueMessage,
+        GetStatistics,
+        ResetStatistics,
+        SetRouteManager,
+        SetNetworkTransport
+    };
+
+    Type type;
+    virtual ~Command() = default;
+
+protected:
+    explicit Command(Type t) : type(t) {}
+};
+
+//==============================================================================
+// HOT PATH COMMAND - Message forwarding (async, no response)
+
+/**
+ * Forward MIDI message according to routing rules.
+ * This is the hot path - called for every MIDI message.
+ */
+struct ForwardMessageCommand : Command {
+    juce::Uuid sourceNode;
+    uint16_t sourceDevice;
+    std::vector<uint8_t> midiData;
+
+    ForwardMessageCommand(const juce::Uuid& node, uint16_t dev,
+                          const std::vector<uint8_t>& data)
+        : Command(ForwardMessage)
+        , sourceNode(node)
+        , sourceDevice(dev)
+        , midiData(data)
+    {}
+};
+
+/**
+ * Send MIDI message directly to a destination node/device.
+ * Bypasses rule lookup and routes directly to the destination.
+ */
+struct DirectSendCommand : Command {
+    juce::Uuid destNode;
+    uint16_t destDevice;
+    std::vector<uint8_t> midiData;
+
+    DirectSendCommand(const juce::Uuid& node, uint16_t dev,
+                      const std::vector<uint8_t>& data)
+        : Command(DirectSend)
+        , destNode(node)
+        , destDevice(dev)
+        , midiData(data)
+    {}
+};
+
+//==============================================================================
+// PORT MANAGEMENT COMMANDS (async, no response)
+
+/**
+ * Register local MIDI port for a device.
+ * NOTE: Takes ownership of the port (raw pointer ownership transfer).
+ */
+struct RegisterPortCommand : Command {
+    uint16_t deviceId;
+    MidiPortInterface* port;  // Ownership transferred
+
+    RegisterPortCommand(uint16_t id, MidiPortInterface* p)
+        : Command(RegisterPort)
+        , deviceId(id)
+        , port(p)
+    {}
+};
+
+/**
+ * Unregister local MIDI port for a device.
+ */
+struct UnregisterPortCommand : Command {
+    uint16_t deviceId;
+
+    explicit UnregisterPortCommand(uint16_t id)
+        : Command(UnregisterPort)
+        , deviceId(id)
+    {}
+};
+
+//==============================================================================
+// MESSAGE QUEUEING COMMAND (async, no response)
+
+/**
+ * Queue received message for local device consumption.
+ */
+struct QueueMessageCommand : Command {
+    uint16_t deviceId;
+    std::vector<uint8_t> midiData;
+
+    QueueMessageCommand(uint16_t id, const std::vector<uint8_t>& data)
+        : Command(QueueMessage)
+        , deviceId(id)
+        , midiData(data)
+    {}
+};
+
+//==============================================================================
+// STATISTICS COMMANDS
+
+/**
+ * Query command for retrieving statistics (sync with response).
+ * Uses atomic flag for synchronization with worker thread.
+ */
+struct GetStatisticsQuery : Command {
+    std::atomic<bool> ready{false};
+    Statistics result;
+
+    GetStatisticsQuery() : Command(GetStatistics) {}
+
+    void signal() {
+        ready.store(true);
+    }
+
+    bool wait(int timeoutMs) {
+        // WORKAROUND: Use polling instead of condition_variable to avoid macOS libc++ bug
+        auto startTime = std::chrono::steady_clock::now();
+        auto timeout = std::chrono::milliseconds(timeoutMs);
+
+        while (std::chrono::steady_clock::now() - startTime < timeout) {
+            if (ready.load()) {
+                return true;
+            }
+            std::this_thread::sleep_for(std::chrono::milliseconds(1));
+        }
+        return false;
+    }
+};
+
+/**
+ * Reset statistics counters (async, no response).
+ */
+struct ResetStatisticsCommand : Command {
+    ResetStatisticsCommand() : Command(ResetStatistics) {}
+};
+
+//==============================================================================
+// CONFIGURATION COMMANDS (async, no response)
+
+/**
+ * Set RouteManager pointer for forwarding rules.
+ */
+struct SetRouteManagerCommand : Command {
+    RouteManager* manager;
+
+    explicit SetRouteManagerCommand(RouteManager* mgr)
+        : Command(SetRouteManager)
+        , manager(mgr)
+    {}
+};
+
+/**
+ * Set NetworkTransport pointer for network message transmission.
+ */
+struct SetNetworkTransportCommand : Command {
+    NetworkTransport* transport;
+
+    explicit SetNetworkTransportCommand(NetworkTransport* t)
+        : Command(SetNetworkTransport)
+        , transport(t)
+    {}
+};
+
+} // namespace MidiRouterCommands
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/MidiRouterQueue.cpp b/modules/juce/midi-server/network/routing/MidiRouterQueue.cpp
new file mode 100644
index 0000000..78f2ef6
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/MidiRouterQueue.cpp
@@ -0,0 +1,61 @@
+/**
+ * MidiRouterQueue.cpp
+ *
+ * Implementation of thread-safe command queue for MidiRouter SEDA architecture.
+ */
+
+#include "MidiRouterQueue.h"
+#include <chrono>
+#include <thread>
+
+namespace NetworkMidi {
+
+void MidiRouterQueue::push(std::unique_ptr<MidiRouterCommands::Command> cmd)
+{
+    std::lock_guard<std::mutex> lock(queueMutex);
+    commandQueue.push_back(std::move(cmd));
+}
+
+std::unique_ptr<MidiRouterCommands::Command> MidiRouterQueue::waitAndPop(int timeoutMs)
+{
+    // WORKAROUND: Use polling instead of condition_variable to avoid macOS libc++ bug
+    // macOS libc++ has a bug where condition_variable::wait_for throws
+    // "Invalid argument" exception on repeated calls
+
+    auto startTime = std::chrono::steady_clock::now();
+    auto timeout = std::chrono::milliseconds(timeoutMs);
+
+    while (std::chrono::steady_clock::now() - startTime < timeout) {
+        // Check shutdown flag first
+        if (isShutdown.load()) {
+            return nullptr;
+        }
+
+        {
+            std::lock_guard<std::mutex> lock(queueMutex);
+            if (!commandQueue.empty()) {
+                auto cmd = std::move(commandQueue.front());
+                commandQueue.pop_front();
+                return cmd;
+            }
+        }
+
+        // Sleep for 1ms to avoid busy-waiting
+        std::this_thread::sleep_for(std::chrono::milliseconds(1));
+    }
+
+    return nullptr;  // Timeout
+}
+
+size_t MidiRouterQueue::size() const
+{
+    std::lock_guard<std::mutex> lock(queueMutex);
+    return commandQueue.size();
+}
+
+void MidiRouterQueue::shutdown()
+{
+    isShutdown.store(true);
+}
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/MidiRouterQueue.h b/modules/juce/midi-server/network/routing/MidiRouterQueue.h
new file mode 100644
index 0000000..129fce8
--- /dev/null
+++ b/modules/juce/midi-server/network/routing/MidiRouterQueue.h
@@ -0,0 +1,78 @@
+/**
+ * MidiRouterQueue.h
+ *
+ * Thread-safe command queue for MidiRouter SEDA architecture.
+ * Provides multi-producer, single-consumer command queuing.
+ */
+
+#pragma once
+
+#include "MidiRouterCommands.h"
+#include <juce_core/juce_core.h>
+#include <deque>
+#include <memory>
+#include <mutex>
+#include <atomic>
+
+namespace NetworkMidi {
+
+//==============================================================================
+/**
+ * Thread-safe command queue for MidiRouter.
+ *
+ * Design:
+ * - Multi-producer safe: Any thread can push commands
+ * - Single consumer: Only worker thread should pop
+ * - Blocking wait with timeout: Consumer blocks until command available
+ * - Unbounded capacity: Uses std::deque (grows as needed)
+ *
+ * Thread Safety:
+ * - push() can be called from any thread
+ * - waitAndPop() should only be called from worker thread
+ * - size() can be called from any thread
+ * - shutdown() can be called to wake up waiting consumer
+ */
+class MidiRouterQueue {
+public:
+    MidiRouterQueue() = default;
+    ~MidiRouterQueue() = default;
+
+    /**
+     * Push command to queue (thread-safe, non-blocking).
+     * Called by any thread that needs to send a command to the worker.
+     *
+     * @param cmd Command to enqueue (ownership transferred)
+     */
+    void push(std::unique_ptr<MidiRouterCommands::Command> cmd);
+
+    /**
+     * Wait for and pop command from queue (blocking with timeout).
+     * Should only be called by worker thread.
+     *
+     * @param timeoutMs Maximum time to wait for command (milliseconds)
+     * @return Command or nullptr if timeout occurred or shutdown signaled
+     */
+    std::unique_ptr<MidiRouterCommands::Command> waitAndPop(int timeoutMs);
+
+    /**
+     * Get current queue size (thread-safe).
+     *
+     * @return Number of commands in queue
+     */
+    size_t size() const;
+
+    /**
+     * Signal shutdown to wake up waiting consumer.
+     * After shutdown, waitAndPop() will return nullptr immediately.
+     */
+    void shutdown();
+
+private:
+    mutable std::mutex queueMutex;
+    std::deque<std::unique_ptr<MidiRouterCommands::Command>> commandQueue;
+    std::atomic<bool> isShutdown{false};
+
+    JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(MidiRouterQueue)
+};
+
+} // namespace NetworkMidi
diff --git a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
index aba5875..73364d1 100644
--- a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
+++ b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
@@ -224,6 +224,9 @@ protected:
         mockPort3 = port3.get();
         midiRouter->registerLocalPort(2, std::move(port2));
         midiRouter->registerLocalPort(3, std::move(port3));
+
+        // SEDA: Wait for port registration commands to be processed
+        waitForCommands();
     }
 
     void TearDown() override {
@@ -250,6 +253,15 @@ protected:
         // Use MidiRouter's built-in forwarding logic which properly handles
         // local vs remote routing, filters, and statistics
         midiRouter->forwardMessage(srcNode, srcDev, midiData);
+
+        // SEDA: Wait for command to be processed (async execution)
+        waitForCommands();
+    }
+
+    // Helper to wait for pending SEDA commands to be processed
+    void waitForCommands(int timeoutMs = 50) {
+        // Give worker thread time to process queued commands
+        std::this_thread::sleep_for(std::chrono::milliseconds(timeoutMs));
     }
 
     // Helper to create additional remote nodes for loop prevention testing
@@ -660,12 +672,14 @@ TEST_F(MidiMessageForwardingTest, InvalidMidiDataHandling) {
 TEST_F(MidiMessageForwardingTest, NullNetworkTransportHandling) {
     // Remove network transport
     midiRouter->setNetworkTransport(nullptr);
+    waitForCommands();  // SEDA: Wait for command to be processed
 
     addRule(localNode, 1, remoteNode1, 10);
 
     // Try to forward (should fail gracefully)
     auto noteOn = createNoteOn(1, 60, 100);
     midiRouter->sendMessageToNode(remoteNode1, 10, noteOn);
+    waitForCommands();  // SEDA: Wait for forward attempt to be processed
 
     // Check router statistics show error
     auto stats = midiRouter->getStatistics();


---

_**Agent (claude-sonnet-4-5-20250929)**_

refactor(midi-server): convert MidiRouter to SEDA architecture with command queue pattern

