<!-- Generated by SpecStory -->

# 2025-10-08 04:36:47Z

<!-- Claude Code Session 107e705b-3fe1-496d-af6b-43b6bf4f24ab (2025-10-08_04-36-47Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/NetworkMidiServer.cpp b/modules/juce/midi-server/NetworkMidiServer.cpp
index 4b9534b..7f29221 100644
--- a/modules/juce/midi-server/NetworkMidiServer.cpp
+++ b/modules/juce/midi-server/NetworkMidiServer.cpp
@@ -287,10 +287,13 @@ public:
         networkAdapter = std::make_unique<NetworkTransportAdapter>(*udpTransport);
         midiRouter->setNetworkTransport(networkAdapter.get());
 
-        // 4. Enumerate and register local MIDI devices (now that router exists)
+        // 4. Create virtual MIDI ports (Phase 1: Virtual MIDI Ports)
+        createVirtualMidiPorts();
+
+        // 5. Enumerate and register local MIDI devices (now that router exists)
         registerLocalMidiDevices();
 
-        // 5. Load persisted routes (after devices are registered)
+        // 6. Load persisted routes (after devices are registered)
         loadRoutes();
 
         // Set up UDP packet reception callback
@@ -300,7 +303,7 @@ public:
             handleNetworkPacket(packet);
         };
 
-        // 6. Create HTTP server
+        // 7. Create HTTP server
         server = std::make_unique<httplib::Server>();
         setupRoutes();
 
@@ -327,7 +330,7 @@ public:
         // Wait for HTTP server to start
         std::this_thread::sleep_for(std::chrono::milliseconds(100));
 
-        // 7. Create service discovery (advertise this node)
+        // 8. Create service discovery (advertise this node)
         int deviceCount = deviceRegistry->getLocalDeviceCount();
         serviceDiscovery = std::make_unique<ServiceDiscovery>(
             identity.getNodeId(),
@@ -343,7 +346,7 @@ public:
         serviceDiscovery->advertise();
         std::cout << "Started mDNS advertising" << std::endl;
 
-        // 8. Create mesh manager (handle peer connections)
+        // 9. Create mesh manager (handle peer connections)
         meshManager = std::make_unique<NetworkMidi::MeshManager>(
             identity.getNodeId(),
             actualPort,
@@ -365,7 +368,7 @@ public:
             midiRouter->setUuidRegistry(&meshManager->getUuidRegistry());
         }
 
-        // 9. NOW start MIDI inputs (after everything is fully initialized)
+        // 10. NOW start MIDI inputs (after everything is fully initialized)
         startMidiInputs();
     }
 
@@ -380,6 +383,15 @@ public:
             }
         }
 
+        // Stop virtual MIDI ports
+        if (virtualInput) {
+            virtualInput->stop();
+            virtualInput.reset();
+        }
+        if (virtualOutput) {
+            virtualOutput.reset();
+        }
+
         // Stop mesh and discovery
         if (meshManager) {
             meshManager->stop();
@@ -437,6 +449,35 @@ public:
     }
 
 private:
+    //==============================================================================
+    // Phase 1: Virtual MIDI Port Creation
+    void createVirtualMidiPorts() {
+        std::cout << "DEBUG: createVirtualMidiPorts() called" << std::endl;
+
+        // Get short UUID for naming (first 8 chars)
+        auto shortUuid = identity.getNodeId().toString().substring(0, 8);
+        std::cout << "DEBUG: Short UUID = " << shortUuid.toStdString() << std::endl;
+
+        // Create virtual input (receive from other apps)
+        auto inputName = juce::String("Network MIDI Node ") + shortUuid + " In";
+        virtualInput = juce::MidiInput::createNewDevice(inputName, this);
+        if (virtualInput) {
+            virtualInput->start();
+            std::cout << "Created virtual MIDI input: " << inputName.toStdString() << std::endl;
+        } else {
+            std::cerr << "Warning: Failed to create virtual MIDI input" << std::endl;
+        }
+
+        // Create virtual output (send to other apps)
+        auto outputName = juce::String("Network MIDI Node ") + shortUuid + " Out";
+        virtualOutput = juce::MidiOutput::createNewDevice(outputName);
+        if (virtualOutput) {
+            std::cout << "Created virtual MIDI output: " << outputName.toStdString() << std::endl;
+        } else {
+            std::cerr << "Warning: Failed to create virtual MIDI output" << std::endl;
+        }
+    }
+
     void registerLocalMidiDevices() {
         uint16_t deviceId = 1;  // Start at 1 (0 reserved)
 
@@ -1313,6 +1354,10 @@ private:
     std::vector<std::unique_ptr<juce::MidiInput>> midiInputs;
     std::vector<std::unique_ptr<juce::MidiOutput>> midiOutputs;
     std::map<juce::String, uint16_t> inputDeviceMap;
+
+    // Phase 1: Virtual MIDI ports
+    std::unique_ptr<juce::MidiInput> virtualInput;
+    std::unique_ptr<juce::MidiOutput> virtualOutput;
 };
 
 //==============================================================================
diff --git a/modules/juce/midi-server/docs/1.0/virtual-midi-ports/implementation/workplan.md b/modules/juce/midi-server/docs/1.0/virtual-midi-ports/implementation/workplan.md
new file mode 100644
index 0000000..b8c9840
--- /dev/null
+++ b/modules/juce/midi-server/docs/1.0/virtual-midi-ports/implementation/workplan.md
@@ -0,0 +1,331 @@
+# Virtual MIDI Ports Implementation Workplan
+
+## Overview
+
+**Goal**: Replace system MIDI device enumeration with virtual MIDI port creation, allowing the server to create its own MIDI endpoints that other applications can connect to.
+
+**Status**: Planning ‚Üí Implementation
+
+**Date Started**: 2025-10-07
+
+---
+
+## Current Architecture (Problem)
+
+The server currently opens **existing system MIDI devices**:
+```
+registerLocalMidiDevices() {
+    auto inputs = MidiInput::getAvailableDevices();  // Opens: IAC Driver, virtual1, etc.
+    for (device : inputs) {
+        openDevice(device.identifier);  // Opens existing devices
+    }
+}
+```
+
+**Issues**:
+- ‚ùå Depends on IAC Driver configuration
+- ‚ùå Ambiguous device names ("virtual1", "virtual2")
+- ‚ùå Conflicts when multiple server instances run
+- ‚ùå No clear separation between server's own ports and system devices
+- ‚ùå Loopback doesn't work reliably across applications
+
+---
+
+## Proposed Architecture (Solution)
+
+The server creates **virtual MIDI ports** using JUCE's `createNewDevice()` API:
+```
+createVirtualMidiPorts() {
+    // Create virtual input (apps send TO server)
+    auto input = MidiInput::createNewDevice("Network MIDI Node 1 In", this);
+
+    // Create virtual output (server sends TO apps)
+    auto output = MidiOutput::createNewDevice("Network MIDI Node 1 Out");
+}
+```
+
+**Benefits**:
+- ‚úÖ No IAC Driver dependency
+- ‚úÖ Clear naming: "Network MIDI Node {UUID} In/Out"
+- ‚úÖ Each server instance has unique ports
+- ‚úÖ Self-contained and isolated
+- ‚úÖ Direct app-to-server communication
+- ‚úÖ Professional architecture (like Ableton Link, Logic Pro Virtual ports)
+
+---
+
+## Implementation Plan
+
+### Phase 1: Virtual Port Creation ‚úÖ COMPLETE / üîÑ IN PROGRESS / ‚è≥ PENDING
+
+**Status**: ‚úÖ COMPLETE (2025-10-07 21:20)
+
+**Tasks**:
+1. Add `createVirtualMidiPorts()` method to NetworkMidiServer
+2. Create virtual input port: "Network MIDI Node {shortUUID} In"
+3. Create virtual output port: "Network MIDI Node {shortUUID} Out"
+4. Store virtual ports in member variables
+5. Start virtual input port immediately after creation
+
+**Implementation Details**:
+```cpp
+class NetworkMidiServer {
+private:
+    std::unique_ptr<juce::MidiInput> virtualInput;
+    std::unique_ptr<juce::MidiOutput> virtualOutput;
+
+    void createVirtualMidiPorts() {
+        // Get short UUID for naming (first 8 chars)
+        auto shortUuid = identity.getNodeId().toString().substring(0, 8);
+
+        // Create virtual input (receive from other apps)
+        auto inputName = juce::String("Network MIDI Node ") + shortUuid + " In";
+        virtualInput = juce::MidiInput::createNewDevice(inputName, this);
+        if (virtualInput) {
+            virtualInput->start();
+            std::cout << "Created virtual MIDI input: " << inputName << std::endl;
+        }
+
+        // Create virtual output (send to other apps)
+        auto outputName = juce::String("Network MIDI Node ") + shortUuid + " Out";
+        virtualOutput = juce::MidiOutput::createNewDevice(outputName);
+        if (virtualOutput) {
+            std::cout << "Created virtual MIDI output: " << outputName << std::endl;
+        }
+    }
+};
+```
+
+**Success Criteria**:
+- ‚úÖ Virtual ports appear in system MIDI device list
+- ‚è≥ Virtual input receives MIDI from test applications (needs Phase 2)
+- ‚è≥ Virtual output can send MIDI to test applications (needs Phase 2)
+
+**Test Results**:
+- Virtual ports successfully created with correct naming: "Network MIDI Node {UUID} In/Out"
+- Ports visible in system MIDI device list (verified with midi_mesh_test)
+- Node 1 ports: "Network MIDI Node 11111111 In" and "Network MIDI Node 11111111 Out"
+- Node 2 ports: "Network MIDI Node 22222222 In" and "Network MIDI Node 22222222 Out"
+- Virtual input port started successfully
+- Clean startup with no errors
+
+---
+
+### Phase 2: Device Registration Refactoring ‚è≥ PENDING
+
+**Status**: ‚è≥ PENDING
+
+**Tasks**:
+1. Modify `registerLocalMidiDevices()` to register virtual ports instead of system devices
+2. Assign device ID 1 to virtual input, device ID 2 to virtual output
+3. Create `JuceMidiPort` wrappers for virtual ports
+4. Register virtual ports with `deviceRegistry` and `routingTable`
+5. Register virtual ports with `midiRouter`
+
+**Implementation Details**:
+```cpp
+void registerVirtualMidiPorts() {
+    // Register virtual input (device ID 1)
+    if (virtualInput) {
+        deviceRegistry->addLocalDevice(1, virtualInput->getName(), "input",
+                                      virtualInput->getIdentifier());
+        routingTable->addRoute(juce::Uuid(), 1, virtualInput->getName(), "input");
+
+        auto port = std::make_unique<JuceMidiPort>(virtualInput->getName(), true);
+        port->setMidiInput(std::move(virtualInput));
+        midiRouter->registerLocalPort(1, std::move(port));
+    }
+
+    // Register virtual output (device ID 2)
+    if (virtualOutput) {
+        deviceRegistry->addLocalDevice(2, virtualOutput->getName(), "output",
+                                      juce::String());  // Virtual outputs don't have identifiers
+        routingTable->addRoute(juce::Uuid(), 2, virtualOutput->getName(), "output");
+
+        auto port = std::make_unique<JuceMidiPort>(virtualOutput->getName(), false);
+        port->setMidiOutput(std::move(virtualOutput));
+        midiRouter->registerLocalPort(2, std::move(port));
+    }
+}
+```
+
+**Success Criteria**:
+- Virtual ports registered with correct device IDs
+- Virtual ports appear in `/midi/devices` API endpoint
+- Virtual ports integrated with routing system
+
+---
+
+### Phase 3: System Device Enumeration (Optional) ‚è≥ PENDING
+
+**Status**: ‚è≥ PENDING
+
+**Decision**: Do we still want to enumerate and open system MIDI devices?
+
+**Option A: Virtual Ports Only (Recommended)**
+- Server creates only its own virtual ports
+- Other apps connect to server's virtual ports
+- Clean, isolated architecture
+- Simpler codebase
+
+**Option B: Hybrid (Virtual + System)**
+- Server creates virtual ports (IDs 1-2)
+- Server also opens system devices (IDs 3+)
+- More flexibility but more complexity
+- May be useful for debugging or monitoring
+
+**Current Recommendation**: Option A (Virtual Ports Only)
+
+---
+
+### Phase 4: Testing & Validation ‚è≥ PENDING
+
+**Status**: ‚è≥ PENDING
+
+**Test Cases**:
+
+1. **Port Creation Test**
+   - Start server
+   - Verify virtual ports appear in system MIDI device list
+   - Verify ports have correct names with UUID
+
+2. **MIDI Input Test**
+   - Use `midi_mesh_test send` or MIDI keyboard
+   - Send MIDI to "Network MIDI Node {UUID} In"
+   - Verify server receives MIDI via `handleIncomingMidiMessage`
+
+3. **MIDI Output Test**
+   - Create routing rule: local input ‚Üí local output
+   - Send MIDI to virtual input
+   - Verify MIDI appears at virtual output (use MIDI Monitor app)
+
+4. **Multi-Instance Test**
+   - Start two server instances with different UUIDs
+   - Verify each has unique virtual port names
+   - Verify no port conflicts
+
+5. **Network Routing Test**
+   - Start Node 1 and Node 2
+   - Create route: Node 1 virtual input ‚Üí Node 2 virtual output
+   - Send MIDI to Node 1 virtual input
+   - Verify MIDI forwarded to Node 2 and appears at Node 2 virtual output
+
+**Success Criteria**:
+- All tests pass
+- No crashes or errors
+- Clean shutdown (ports removed from system)
+
+---
+
+### Phase 5: Cleanup & Documentation ‚è≥ PENDING
+
+**Status**: ‚è≥ PENDING
+
+**Tasks**:
+1. Remove old `registerLocalMidiDevices()` code (or refactor for Option B)
+2. Remove `startMidiInputs()` (no longer needed)
+3. Remove IAC Driver dependencies from documentation
+4. Update API documentation for `/midi/devices`
+5. Add examples showing how to connect external apps
+6. Update integration tests
+
+**Documentation Updates**:
+- README: Add virtual MIDI ports section
+- API docs: Update device IDs (1=input, 2=output)
+- Examples: Show connecting from Logic Pro, Ableton, etc.
+
+---
+
+## Implementation Progress
+
+### 2025-10-07 20:50 - Workplan Created
+- Created implementation workplan
+- Set up todo tracking
+- Ready to begin Phase 1
+
+### 2025-10-07 21:00 - Phase 1 Implementation
+- Added `virtualInput` and `virtualOutput` member variables (lines 1318-1319)
+- Implemented `createVirtualMidiPorts()` method (lines 454-476)
+- Added call to `createVirtualMidiPorts()` in `startServer()` (line 291)
+- Added cleanup in `stopServer()` (lines 384-390)
+- Added debug logging for troubleshooting
+
+### 2025-10-07 21:20 - Phase 1 Complete ‚úÖ
+- Virtual ports successfully created and visible in system
+- Verified with `midi_mesh_test` showing ports in available outputs
+- Node 1: "Network MIDI Node 11111111 In/Out"
+- Node 2: "Network MIDI Node 22222222 In/Out"
+- Ports appear in system MIDI device list
+- Virtual inputs started successfully
+- Ready for Phase 2: Device Registration
+
+---
+
+## Code Changes Summary
+
+### Files to Modify
+
+1. **NetworkMidiServer.cpp** (main changes)
+   - Add `createVirtualMidiPorts()` method
+   - Add `registerVirtualMidiPorts()` method
+   - Modify `startServer()` to call virtual port methods
+   - Remove or refactor `registerLocalMidiDevices()`
+   - Remove or refactor `startMidiInputs()`
+   - Update member variables
+
+2. **NetworkMidiServer.h** (if exists, or declarations in .cpp)
+   - Add virtual port member variables
+   - Add virtual port method declarations
+
+### Estimated Changes
+- **Lines Added**: ~100
+- **Lines Removed**: ~150 (if removing system device enumeration)
+- **Net Change**: -50 lines (simpler code!)
+
+---
+
+## Risk Assessment
+
+### Low Risk
+- ‚úÖ JUCE API is well-documented and stable
+- ‚úÖ Virtual ports are standard on macOS, Linux (ALSA), Windows (loopMIDI)
+- ‚úÖ No breaking changes to network protocol
+- ‚úÖ Can implement incrementally
+
+### Medium Risk
+- ‚ö†Ô∏è Need to ensure proper cleanup on shutdown
+- ‚ö†Ô∏è Need to handle port creation failures gracefully
+
+### Mitigation
+- Add error handling for `createNewDevice()` failures
+- Test on multiple platforms (macOS, Linux, Windows)
+- Add logging for port creation/destruction
+
+---
+
+## Success Metrics
+
+- [ ] Virtual ports visible in system MIDI device list
+- [ ] Server receives MIDI from external apps via virtual input
+- [ ] Server sends MIDI to external apps via virtual output
+- [ ] Multi-hop routing works: App ‚Üí Node 1 ‚Üí Node 2 ‚Üí App
+- [ ] Multiple server instances run without conflicts
+- [ ] Clean shutdown removes virtual ports
+
+---
+
+## Next Steps
+
+1. Implement Phase 1: Virtual Port Creation
+2. Test port creation and visibility
+3. Update this workplan with progress
+4. Proceed to Phase 2
+
+---
+
+## References
+
+- JUCE MidiInput API: https://docs.juce.com/master/classMidiInput.html
+- JUCE MidiOutput API: https://docs.juce.com/master/classMidiOutput.html
+- CoreMIDI Virtual Endpoints: Apple Developer Documentation
+- Phase 4 Multi-Hop Implementation: `../../../network/routing/IMPLEMENTATION_REPORT.md`


---

_**Agent (claude-sonnet-4-5-20250929)**_

```
feat(midi-server): add Phase 1 virtual MIDI port creation with UUID-based naming
```

