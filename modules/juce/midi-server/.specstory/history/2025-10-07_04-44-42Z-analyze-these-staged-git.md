<!-- Generated by SpecStory -->

# 2025-10-07 04:44:42Z

<!-- Claude Code Session a51474c3-491f-4876-935a-28f810d0b2ac (2025-10-07_04-44-42Z) -->

_**User**_

Analyze these staged git changes and output ONLY a single-line conventional commit message (type(scope): description). No explanations.
diff --git a/modules/juce/midi-server/network/routing/MidiRouter.cpp b/modules/juce/midi-server/network/routing/MidiRouter.cpp
index 71e6425..9bb9bb9 100644
--- a/modules/juce/midi-server/network/routing/MidiRouter.cpp
+++ b/modules/juce/midi-server/network/routing/MidiRouter.cpp
@@ -313,6 +313,42 @@ void MidiRouter::forwardMessage(const juce::Uuid& sourceNode,
         return;
     }
 
+    // Create fresh forwarding context for this message
+    ForwardingContext context;
+
+    // Delegate to internal implementation with loop prevention
+    forwardMessageInternal(sourceNode, sourceDevice, midiData, context);
+}
+
+void MidiRouter::forwardMessageInternal(const juce::Uuid& sourceNode,
+                                        uint16_t sourceDevice,
+                                        const std::vector<uint8_t>& midiData,
+                                        ForwardingContext& context)
+{
+    // Create device key for source
+    DeviceKey sourceKey(sourceNode, sourceDevice);
+
+    // Check if we should forward from this source (loop prevention)
+    if (!context.shouldForward(sourceKey)) {
+        // Loop detected - either hop count exceeded or device already visited
+        std::lock_guard<std::mutex> lock(statsMutex);
+        stats.loopsDetected++;
+
+        if (context.hopCount >= ForwardingContext::MAX_HOPS) {
+            reportError("Maximum hop count exceeded for message from node " +
+                        sourceNode.toString() + " device " + juce::String(sourceDevice));
+        } else {
+            reportError("Forwarding loop detected for message from node " +
+                        sourceNode.toString() + " device " + juce::String(sourceDevice));
+        }
+
+        return;
+    }
+
+    // Mark this device as visited in the forwarding path
+    context.recordVisit(sourceKey);
+    context.hopCount++;
+
     // Query RouteManager for destination rules (already sorted by priority, filtered to enabled only)
     auto rules = routeManager->getDestinations(sourceNode, sourceDevice);
 
diff --git a/modules/juce/midi-server/network/routing/MidiRouter.h b/modules/juce/midi-server/network/routing/MidiRouter.h
index 4b88603..27e1424 100644
--- a/modules/juce/midi-server/network/routing/MidiRouter.h
+++ b/modules/juce/midi-server/network/routing/MidiRouter.h
@@ -15,6 +15,7 @@
 #include <juce_audio_devices/juce_audio_devices.h>
 #include <vector>
 #include <map>
+#include <set>
 #include <queue>
 #include <mutex>
 #include <functional>
@@ -118,6 +119,7 @@ public:
         uint64_t routingErrors = 0;
         uint64_t messagesForwarded = 0;      // Phase 3.1
         uint64_t messagesDropped = 0;        // Phase 3.1
+        uint64_t loopsDetected = 0;          // Loop prevention
     };
 
     Statistics getStatistics() const;
@@ -128,6 +130,38 @@ public:
     void setErrorCallback(ErrorCallback callback);
 
 private:
+    /**
+     * Context for tracking message forwarding to prevent loops
+     *
+     * Prevents infinite forwarding loops via:
+     * - Hop count limiting (max 8 hops)
+     * - Visited device tracking (prevents A → B → A cycles)
+     */
+    struct ForwardingContext {
+        std::set<DeviceKey> visitedDevices;
+        uint8_t hopCount = 0;
+        static constexpr uint8_t MAX_HOPS = 8;
+
+        /**
+         * Check if we should forward from this device
+         * Returns false if:
+         * - Hop count exceeds MAX_HOPS
+         * - Device has already been visited (loop detected)
+         */
+        bool shouldForward(const DeviceKey& device) const {
+            if (hopCount >= MAX_HOPS) return false;
+            if (visitedDevices.count(device) > 0) return false;
+            return true;
+        }
+
+        /**
+         * Mark device as visited in the forwarding path
+         */
+        void recordVisit(const DeviceKey& device) {
+            visitedDevices.insert(device);
+        }
+    };
+
     // References to routing infrastructure
     DeviceRegistry& deviceRegistry;
     RoutingTable& routingTable;
@@ -167,6 +201,11 @@ private:
     void reportError(const juce::String& error);
 
     // Phase 3.1 forwarding helpers
+    void forwardMessageInternal(const juce::Uuid& sourceNode,
+                                uint16_t sourceDevice,
+                                const std::vector<uint8_t>& midiData,
+                                ForwardingContext& context);
+
     bool matchesFilters(const ForwardingRule& rule,
                         const std::vector<uint8_t>& midiData) const;
 
diff --git a/modules/juce/midi-server/network/routing/RouteManager.cpp b/modules/juce/midi-server/network/routing/RouteManager.cpp
index cccf612..bcce36c 100644
--- a/modules/juce/midi-server/network/routing/RouteManager.cpp
+++ b/modules/juce/midi-server/network/routing/RouteManager.cpp
@@ -49,6 +49,9 @@ std::string RouteManager::addRule(const ForwardingRule& rule)
     // Add the rule
     rules[newRule.ruleId.toStdString()] = newRule;
 
+    // Rebuild index for optimized lookups
+    rebuildSourceIndex();
+
     return newRule.ruleId.toStdString();
 }
 
@@ -62,6 +65,10 @@ bool RouteManager::removeRule(const std::string& ruleId)
     }
 
     rules.erase(it);
+
+    // Rebuild index for optimized lookups
+    rebuildSourceIndex();
+
     return true;
 }
 
@@ -91,6 +98,9 @@ bool RouteManager::updateRule(const std::string& ruleId, const ForwardingRule& r
     // Update the rule
     it->second = updatedRule;
 
+    // Rebuild index for optimized lookups
+    rebuildSourceIndex();
+
     return true;
 }
 
@@ -124,6 +134,7 @@ void RouteManager::clearAllRules()
 {
     std::lock_guard<std::mutex> lock(rulesMutex);
     rules.clear();
+    sourceIndex.clear();
 }
 
 //==============================================================================
@@ -134,23 +145,17 @@ std::vector<ForwardingRule> RouteManager::getDestinations(const juce::Uuid& sour
 {
     std::lock_guard<std::mutex> lock(rulesMutex);
 
-    std::vector<ForwardingRule> result;
     DeviceKey sourceKey(sourceNodeId, sourceDeviceId);
 
-    // Find all rules with matching source
-    for (const auto& pair : rules) {
-        if (pair.second.sourceDevice == sourceKey && pair.second.enabled) {
-            result.push_back(pair.second);
-        }
+    // Use indexed lookup for O(log N) performance instead of O(N) scan
+    auto it = sourceIndex.find(sourceKey);
+    if (it != sourceIndex.end()) {
+        // Index already contains enabled rules sorted by priority
+        return it->second;
     }
 
-    // Sort by priority (highest first)
-    std::sort(result.begin(), result.end(),
-              [](const ForwardingRule& a, const ForwardingRule& b) {
-                  return a.priority > b.priority;  // Higher priority first
-              });
-
-    return result;
+    // No rules found for this source device
+    return {};
 }
 
 std::vector<ForwardingRule> RouteManager::getSourceRules(const juce::Uuid& nodeId,
@@ -325,6 +330,9 @@ bool RouteManager::loadFromFile(const juce::File& file)
             rules[rule.ruleId.toStdString()] = rule;
         }
 
+        // Rebuild index for optimized lookups
+        rebuildSourceIndex();
+
         return true;
     } catch (...) {
         return false;
@@ -412,4 +420,25 @@ std::string RouteManager::generateRuleId() const
     return juce::Uuid().toString().toStdString();
 }
 
+void RouteManager::rebuildSourceIndex()
+{
+    // Clear existing index
+    sourceIndex.clear();
+
+    // Build index: group enabled rules by source device
+    for (const auto& [ruleId, rule] : rules) {
+        if (rule.enabled) {
+            sourceIndex[rule.sourceDevice].push_back(rule);
+        }
+    }
+
+    // Sort each source device's rules by priority (highest first)
+    for (auto& [sourceKey, ruleList] : sourceIndex) {
+        std::sort(ruleList.begin(), ruleList.end(),
+                  [](const ForwardingRule& a, const ForwardingRule& b) {
+                      return a.priority > b.priority;  // Higher priority first
+                  });
+    }
+}
+
 } // namespace NetworkMidi
diff --git a/modules/juce/midi-server/network/routing/RouteManager.h b/modules/juce/midi-server/network/routing/RouteManager.h
index 62b4450..9e0bc7b 100644
--- a/modules/juce/midi-server/network/routing/RouteManager.h
+++ b/modules/juce/midi-server/network/routing/RouteManager.h
@@ -222,10 +222,23 @@ private:
     mutable std::mutex rulesMutex;
     std::map<std::string, ForwardingRule> rules;
 
+    // Performance optimization: Indexed lookup cache for fast destination queries
+    // Maps source DeviceKey to vector of enabled rules, pre-sorted by priority
+    // Rebuilt whenever rules are added/removed/updated
+    // Trade-off: More memory, slower writes, much faster reads (O(log N) vs O(N))
+    std::map<DeviceKey, std::vector<ForwardingRule>> sourceIndex;
+
     // Helper methods
     bool validateRuleInternal(const ForwardingRule& rule, std::string& errorMsg) const;
     std::string generateRuleId() const;
 
+    /**
+     * Rebuild the source device index for fast lookups
+     * Called after any rule modification (add/remove/update)
+     * Time complexity: O(N log N) where N = number of rules
+     */
+    void rebuildSourceIndex();
+
     JUCE_DECLARE_NON_COPYABLE_WITH_LEAK_DETECTOR(RouteManager)
 };
 
diff --git a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
index 9de5c5d..23d5a26 100644
--- a/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
+++ b/modules/juce/midi-server/tests/unit/MidiMessageForwardingTest.cpp
@@ -186,6 +186,7 @@ protected:
         // Create mock network transport
         mockTransport = std::make_unique<MockNetworkTransport>();
         midiRouter->setNetworkTransport(mockTransport.get());
+        midiRouter->setRouteManager(routeManager.get());
 
         // Setup test node IDs
         localNode = juce::Uuid::null();
@@ -197,6 +198,8 @@ protected:
         deviceRegistry->addLocalDevice(1, "Local Input 1", "input", "TestVendor");
         deviceRegistry->addLocalDevice(2, "Local Output 1", "output", "TestVendor");
         deviceRegistry->addLocalDevice(3, "Local Output 2", "output", "TestVendor");
+        deviceRegistry->addLocalDevice(4, "Local Input 2", "input", "TestVendor");
+        deviceRegistry->addLocalDevice(5, "Local Input 3", "input", "TestVendor");
 
         deviceRegistry->addRemoteDevice(remoteNode1, 10, "Remote Output 1", "output", "RemoteVendor");
         deviceRegistry->addRemoteDevice(remoteNode1, 11, "Remote Input 1", "input", "RemoteVendor");
@@ -207,6 +210,8 @@ protected:
         routingTable->addRoute(localNode, 1, "Local Input 1", "input");
         routingTable->addRoute(localNode, 2, "Local Output 1", "output");
         routingTable->addRoute(localNode, 3, "Local Output 2", "output");
+        routingTable->addRoute(localNode, 4, "Local Input 2", "input");
+        routingTable->addRoute(localNode, 5, "Local Input 3", "input");
         routingTable->addRoute(remoteNode1, 10, "Remote Output 1", "output");
         routingTable->addRoute(remoteNode1, 11, "Remote Output 2", "output");
         routingTable->addRoute(remoteNode2, 20, "Remote Output 3", "output");
@@ -239,33 +244,12 @@ protected:
         return routeManager->addRule(rule);
     }
 
-    // Helper to forward a message using RouteManager rules
+    // Helper to forward a message using MidiRouter's forwardMessage method
     void forwardMessage(const juce::Uuid& srcNode, uint16_t srcDev,
                        const std::vector<uint8_t>& midiData) {
-        // Get destinations from RouteManager
-        auto destinations = routeManager->getDestinations(srcNode, srcDev);
-
-        // Forward to each destination
-        for (const auto& rule : destinations) {
-            if (!rule.enabled) continue;
-
-            // Apply filters
-            uint8_t channel = getMidiChannel(midiData);
-            MidiMessageType msgType = getMidiMessageType(midiData);
-
-            if (!rule.shouldForward(channel, msgType)) {
-                routeManager->updateRuleStatistics(rule.ruleId.toStdString(), false);
-                continue;
-            }
-
-            // Forward the message
-            midiRouter->sendMessageToNode(rule.destinationNodeId(),
-                                         rule.destinationDeviceId(),
-                                         midiData);
-
-            // Update statistics
-            routeManager->updateRuleStatistics(rule.ruleId.toStdString(), true);
-        }
+        // Use MidiRouter's built-in forwarding logic which properly handles
+        // local vs remote routing, filters, and statistics
+        midiRouter->forwardMessage(srcNode, srcDev, midiData);
     }
 
     // Test infrastructure
@@ -564,9 +548,10 @@ TEST_F(MidiMessageForwardingTest, AggregateStatistics) {
 //==============================================================================
 
 TEST_F(MidiMessageForwardingTest, MultiHopForwarding) {
-    // Setup chain: Local Input 1 → Remote Output 1 → Remote Output 2
+    // Setup chain: Local Input 1 → Remote Output 1 (on node1)
+    //              Remote Input 1 (on node1) → Remote Output 2 (on node2)
     addRule(localNode, 1, remoteNode1, 10);
-    addRule(remoteNode1, 10, remoteNode2, 20);
+    addRule(remoteNode1, 11, remoteNode2, 20);  // Use input device 11 as source
 
     // Send message from local node
     auto noteOn = createNoteOn(1, 60, 100);
@@ -575,9 +560,9 @@ TEST_F(MidiMessageForwardingTest, MultiHopForwarding) {
     // First hop: Local → Remote1
     EXPECT_EQ(1, mockTransport->getSentMessageCount());
 
-    // Simulate Remote1 receiving and forwarding
+    // Simulate Remote1 receiving on its input and forwarding
     mockTransport->clearSentMessages();
-    forwardMessage(remoteNode1, 10, noteOn);
+    forwardMessage(remoteNode1, 11, noteOn);  // Message comes in on input device 11
 
     // Second hop: Remote1 → Remote2
     EXPECT_EQ(1, mockTransport->getSentMessageCount());
@@ -733,15 +718,15 @@ TEST_F(MidiMessageForwardingTest, HandlesHighMessageThroughput) {
 }
 
 TEST_F(MidiMessageForwardingTest, HandlesMultipleConcurrentSources) {
-    // Add rules from multiple sources
+    // Add rules from multiple sources (all input devices)
     addRule(localNode, 1, remoteNode1, 10);
-    addRule(localNode, 2, remoteNode1, 10);
-    addRule(localNode, 3, remoteNode1, 10);
+    addRule(localNode, 4, remoteNode1, 10);
+    addRule(localNode, 5, remoteNode1, 10);
 
     // Send from multiple sources
     forwardMessage(localNode, 1, createNoteOn(1, 60, 100));
-    forwardMessage(localNode, 2, createNoteOn(2, 64, 100));
-    forwardMessage(localNode, 3, createNoteOn(3, 67, 100));
+    forwardMessage(localNode, 4, createNoteOn(2, 64, 100));
+    forwardMessage(localNode, 5, createNoteOn(3, 67, 100));
 
     // All messages should be forwarded
     EXPECT_EQ(3, mockTransport->getSentMessageCount());


---

_**Agent (claude-sonnet-4-5-20250929)**_

refactor(midi-server): optimize routing with indexed lookups and loop prevention

