#include "MidiPacket.h"
#include <cstring>
#include <stdexcept>
#include <chrono>

namespace NetworkMidi {

MidiPacket::MidiPacket()
    : magic(MAGIC)
    , version(VERSION)
    , flags(0)
    , sequence(0)
    , timestampMicros(0)
    , deviceId(0)
    , packetType(Data)
{
}

MidiPacket MidiPacket::createDataPacket(
    const juce::Uuid& sourceNode,
    const juce::Uuid& destNode,
    uint16_t deviceId,
    const std::vector<uint8_t>& midiData,
    uint16_t sequence)
{
    MidiPacket packet;
    packet.setSourceNode(sourceNode);
    packet.setDestNode(destNode);
    packet.setDeviceId(deviceId);
    packet.setMidiData(midiData);
    packet.setSequence(sequence);
    packet.updateTimestamp();
    packet.setPacketType(Data);

    // Auto-detect SysEx and set flags
    if (!midiData.empty() && midiData[0] == 0xF0) {
        packet.addFlag(SysEx);
        packet.addFlag(Reliable);  // SysEx requires reliable delivery
    }

    return packet;
}

MidiPacket MidiPacket::createHeartbeatPacket(
    const juce::Uuid& sourceNode,
    const juce::Uuid& destNode,
    uint16_t sequence)
{
    MidiPacket packet;
    packet.setSourceNode(sourceNode);
    packet.setDestNode(destNode);
    packet.setSequence(sequence);
    packet.updateTimestamp();
    packet.setPacketType(Heartbeat);
    return packet;
}

MidiPacket MidiPacket::createAckPacket(
    const juce::Uuid& sourceNode,
    const juce::Uuid& destNode,
    uint16_t ackSequence)
{
    MidiPacket packet;
    packet.setSourceNode(sourceNode);
    packet.setDestNode(destNode);
    packet.setSequence(ackSequence);
    packet.updateTimestamp();
    packet.setPacketType(Ack);
    return packet;
}

MidiPacket MidiPacket::createNackPacket(
    const juce::Uuid& sourceNode,
    const juce::Uuid& destNode,
    uint16_t nackSequence)
{
    MidiPacket packet;
    packet.setSourceNode(sourceNode);
    packet.setDestNode(destNode);
    packet.setSequence(nackSequence);
    packet.updateTimestamp();
    packet.setPacketType(Nack);
    return packet;
}

std::vector<uint8_t> MidiPacket::serialize() const {
    std::vector<uint8_t> buffer;
    buffer.reserve(HEADER_SIZE + midiData.size());

    // Magic (2 bytes, big-endian)
    buffer.push_back((magic >> 8) & 0xFF);
    buffer.push_back(magic & 0xFF);

    // Version (1 byte)
    buffer.push_back(version);

    // Flags (1 byte)
    buffer.push_back(flags);

    // Source Node UUID hash (4 bytes, big-endian)
    uint32_t sourceHash = hashUuid(sourceNode);
    buffer.push_back((sourceHash >> 24) & 0xFF);
    buffer.push_back((sourceHash >> 16) & 0xFF);
    buffer.push_back((sourceHash >> 8) & 0xFF);
    buffer.push_back(sourceHash & 0xFF);

    // Dest Node UUID hash (4 bytes, big-endian)
    uint32_t destHash = hashUuid(destNode);
    buffer.push_back((destHash >> 24) & 0xFF);
    buffer.push_back((destHash >> 16) & 0xFF);
    buffer.push_back((destHash >> 8) & 0xFF);
    buffer.push_back(destHash & 0xFF);

    // Sequence (2 bytes, big-endian)
    buffer.push_back((sequence >> 8) & 0xFF);
    buffer.push_back(sequence & 0xFF);

    // Timestamp (4 bytes, big-endian)
    buffer.push_back((timestampMicros >> 24) & 0xFF);
    buffer.push_back((timestampMicros >> 16) & 0xFF);
    buffer.push_back((timestampMicros >> 8) & 0xFF);
    buffer.push_back(timestampMicros & 0xFF);

    // Device ID (2 bytes, big-endian)
    buffer.push_back((deviceId >> 8) & 0xFF);
    buffer.push_back(deviceId & 0xFF);

    // MIDI data payload
    buffer.insert(buffer.end(), midiData.begin(), midiData.end());

    return buffer;
}

bool MidiPacket::serializeInto(uint8_t* buffer, size_t bufferSize, size_t& bytesWritten) const {
    size_t requiredSize = HEADER_SIZE + midiData.size();
    if (bufferSize < requiredSize) {
        bytesWritten = 0;
        return false;
    }

    size_t offset = 0;

    // Magic (2 bytes, big-endian)
    buffer[offset++] = (magic >> 8) & 0xFF;
    buffer[offset++] = magic & 0xFF;

    // Version (1 byte)
    buffer[offset++] = version;

    // Flags (1 byte)
    buffer[offset++] = flags;

    // Source Node UUID hash (4 bytes, big-endian)
    uint32_t sourceHash = hashUuid(sourceNode);
    buffer[offset++] = (sourceHash >> 24) & 0xFF;
    buffer[offset++] = (sourceHash >> 16) & 0xFF;
    buffer[offset++] = (sourceHash >> 8) & 0xFF;
    buffer[offset++] = sourceHash & 0xFF;

    // Dest Node UUID hash (4 bytes, big-endian)
    uint32_t destHash = hashUuid(destNode);
    buffer[offset++] = (destHash >> 24) & 0xFF;
    buffer[offset++] = (destHash >> 16) & 0xFF;
    buffer[offset++] = (destHash >> 8) & 0xFF;
    buffer[offset++] = destHash & 0xFF;

    // Sequence (2 bytes, big-endian)
    buffer[offset++] = (sequence >> 8) & 0xFF;
    buffer[offset++] = sequence & 0xFF;

    // Timestamp (4 bytes, big-endian)
    buffer[offset++] = (timestampMicros >> 24) & 0xFF;
    buffer[offset++] = (timestampMicros >> 16) & 0xFF;
    buffer[offset++] = (timestampMicros >> 8) & 0xFF;
    buffer[offset++] = timestampMicros & 0xFF;

    // Device ID (2 bytes, big-endian)
    buffer[offset++] = (deviceId >> 8) & 0xFF;
    buffer[offset++] = deviceId & 0xFF;

    // MIDI data payload
    if (!midiData.empty()) {
        std::memcpy(buffer + offset, midiData.data(), midiData.size());
        offset += midiData.size();
    }

    bytesWritten = offset;
    return true;
}

MidiPacket MidiPacket::deserialize(const uint8_t* data, size_t length) {
    MidiPacket packet;
    if (!tryDeserialize(data, length, packet)) {
        throw std::runtime_error("Failed to deserialize MIDI packet: invalid format");
    }
    return packet;
}

bool MidiPacket::tryDeserialize(const uint8_t* data, size_t length, MidiPacket& outPacket) {
    if (length < HEADER_SIZE) {
        return false;
    }

    size_t offset = 0;

    // Magic (2 bytes, big-endian)
    uint16_t magic = (static_cast<uint16_t>(data[offset]) << 8) | data[offset + 1];
    offset += 2;
    if (magic != MAGIC) {
        return false;
    }

    // Version (1 byte)
    uint8_t version = data[offset++];
    if (version != VERSION) {
        return false;  // Incompatible version
    }

    // Flags (1 byte)
    uint8_t flags = data[offset++];

    // Source Node UUID hash (4 bytes, big-endian)
    uint32_t sourceHash = (static_cast<uint32_t>(data[offset]) << 24) |
                          (static_cast<uint32_t>(data[offset + 1]) << 16) |
                          (static_cast<uint32_t>(data[offset + 2]) << 8) |
                          static_cast<uint32_t>(data[offset + 3]);
    offset += 4;

    // Dest Node UUID hash (4 bytes, big-endian)
    uint32_t destHash = (static_cast<uint32_t>(data[offset]) << 24) |
                        (static_cast<uint32_t>(data[offset + 1]) << 16) |
                        (static_cast<uint32_t>(data[offset + 2]) << 8) |
                        static_cast<uint32_t>(data[offset + 3]);
    offset += 4;

    // Sequence (2 bytes, big-endian)
    uint16_t sequence = (static_cast<uint16_t>(data[offset]) << 8) | data[offset + 1];
    offset += 2;

    // Timestamp (4 bytes, big-endian)
    uint32_t timestamp = (static_cast<uint32_t>(data[offset]) << 24) |
                         (static_cast<uint32_t>(data[offset + 1]) << 16) |
                         (static_cast<uint32_t>(data[offset + 2]) << 8) |
                         static_cast<uint32_t>(data[offset + 3]);
    offset += 4;

    // Device ID (2 bytes, big-endian)
    uint16_t deviceId = (static_cast<uint16_t>(data[offset]) << 8) | data[offset + 1];
    offset += 2;

    // MIDI data payload
    std::vector<uint8_t> midiData;
    if (length > HEADER_SIZE) {
        size_t payloadSize = length - HEADER_SIZE;
        midiData.resize(payloadSize);
        std::memcpy(midiData.data(), data + offset, payloadSize);
    }

    // Populate output packet
    outPacket.magic = magic;
    outPacket.version = version;
    outPacket.flags = flags;
    // Note: We only have hash values, not full UUIDs
    // The caller must maintain UUID mappings
    outPacket.sequence = sequence;
    outPacket.timestampMicros = timestamp;
    outPacket.deviceId = deviceId;
    outPacket.midiData = std::move(midiData);

    return true;
}

bool MidiPacket::isValid() const {
    return magic == MAGIC && version == VERSION;
}

bool MidiPacket::verifyChecksum() const {
    // Simple checksum verification placeholder
    // Could be enhanced with CRC32 or similar
    return isValid();
}

void MidiPacket::setSourceNode(const juce::Uuid& uuid) {
    sourceNode = uuid;
}

void MidiPacket::setDestNode(const juce::Uuid& uuid) {
    destNode = uuid;
}

void MidiPacket::setMidiData(const std::vector<uint8_t>& data) {
    midiData = data;

    // Auto-detect SysEx
    if (!data.empty() && data[0] == 0xF0) {
        addFlag(SysEx);
        addFlag(Reliable);
    }
}

void MidiPacket::updateTimestamp() {
    timestampMicros = static_cast<uint32_t>(getCurrentTimeMicros());
}

uint32_t MidiPacket::hashUuid(const juce::Uuid& uuid) {
    // Simple hash: XOR the 4 32-bit words of the UUID
    const uint64_t* data = reinterpret_cast<const uint64_t*>(uuid.getRawData());
    uint32_t hash = static_cast<uint32_t>(data[0] ^ (data[0] >> 32));
    hash ^= static_cast<uint32_t>(data[1] ^ (data[1] >> 32));
    return hash;
}

juce::Uuid MidiPacket::unhashUuid(uint32_t hash, const juce::Uuid& original) {
    // Hash is lossy, so we can't reverse it
    // This function is a placeholder for when we have UUID lookup tables
    return original;
}

uint64_t MidiPacket::getCurrentTimeMicros() {
    auto now = std::chrono::high_resolution_clock::now();
    auto micros = std::chrono::duration_cast<std::chrono::microseconds>(
        now.time_since_epoch()
    );
    return micros.count();
}

} // namespace NetworkMidi
